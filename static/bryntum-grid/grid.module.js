/*!
 *
 * Bryntum Grid 5.6.11
 *
 * Copyright(c) 2024 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// ../Core/lib/Core/helper/BrowserHelper.js
var _a;
var BrowserHelper = class {
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;
    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));
    me._isMobile = Boolean(userAgent.match(/Mobile|Opera Mini|Opera Mobi|Puffin/) || typeof globalThis.orientation === "number");
    me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./);
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._safariVersion = me.getVersion(userAgent, /Version\/(.*).Safari/);
    me._isAndroid = Boolean(userAgent.match(/Android/g));
  }
  //endregion
  //region Device
  /**
   * Yields `true` if the current browser supports CSS style `overflow:clip`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsOverflowClip() {
    if (this._supportsOverflowClip == null) {
      const div = document.createElement("div");
      div.style.overflow = "clip";
      div.style.display = "none";
      document.documentElement.appendChild(div);
      this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue("overflow") === "clip";
      div.remove();
    }
    return this._supportsOverflowClip;
  }
  /**
   * Yields `true` if the current browser supports CSS style `position:sticky`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsSticky() {
    return true;
  }
  /**
   * Returns matched version for userAgent.
   * @param {String} versionRe version match regular expression
   * @returns {Number} matched version
   * @readonly
   * @internal
   */
  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseFloat(match[1]) : 0;
  }
  /**
   * Determines if the user is using a touch device.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get isTouchDevice() {
    if (this._isTouchDevice === void 0) {
      this._isTouchDevice = globalThis.matchMedia("(any-pointer:coarse)").matches;
    }
    return this._isTouchDevice;
  }
  // Reports true by default for our tests
  static get isHoverableDevice() {
    if (this._isHoverableDevice === void 0) {
      this._isHoverableDevice = globalThis.matchMedia("(any-hover: hover)").matches;
    }
    return this._isHoverableDevice;
  }
  //endregion
  //region Platform
  static get isBrowserEnv() {
    return typeof window !== "undefined";
  }
  /**
   * Checks if platform is Mac.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isMac() {
    return this._isMac;
  }
  /**
   * Checks if platform is Windows.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isWindows() {
    return this._isWindows;
  }
  /**
   * Checks if platform is Linux.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isLinux() {
    return this._isLinux;
  }
  /**
   * Checks if platform is Android.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isAndroid() {
    return this._isAndroid;
  }
  //endregion
  //region Browser
  /**
   * Checks if browser is Webkit.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isWebkit() {
    return this._isWebkit;
  }
  /**
   * Checks if browser is Chrome or Chromium based browser.
   * Returns truthy value for Edge Chromium.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isChrome() {
    return this._isChrome;
  }
  /**
   * Returns the major Chrome version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get chromeVersion() {
    return this._chromeVersion;
  }
  /**
   * Checks if browser is Firefox.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isFirefox() {
    return this._isFirefox;
  }
  /**
   * Returns the major Firefox version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get firefoxVersion() {
    return this._firefoxVersion;
  }
  /**
   * Checks if browser is Safari.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isSafari() {
    return this._isSafari;
  }
  static get safariVersion() {
    return this._safariVersion;
  }
  /**
   * Checks if browser is mobile Safari
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobileSafari() {
    return this._isMobileSafari;
  }
  /**
   * Checks if the active device is a mobile device
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobile() {
    return this._isMobile;
  }
  static get platform() {
    const me = this;
    return me._isLinux ? "linux" : me._isMac ? "mac" : me._isWindows ? "windows" : me._isAndroid ? "android" : me._isMobileSafari ? "ios" : null;
  }
  /**
   * Returns `true` if the browser supports passive event listeners.
   * @property {Boolean}
   * @internal
   * @deprecated Since 5.0. All modern browsers now support passive event listeners.
   * @category Browser
   */
  static get supportsPassive() {
    return true;
  }
  // Only works in secure contexts
  static get supportsRandomUUID() {
    var _a4, _b;
    if (this._supportsRandomUUID === void 0) {
      try {
        this._supportsRandomUUID = Boolean(((_b = (_a4 = globalThis.crypto).randomUUID) == null ? void 0 : _b.call(_a4).length) > 0);
      } catch (e) {
        this._supportsRandomUUID = false;
      }
    }
    return this._supportsRandomUUID;
  }
  //endregion
  //region Storage
  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  static get storageAvailable() {
    let storage, x;
    try {
      storage = localStorage;
      x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && // everything except Firefox
      (e.code === 22 || // Firefox
      e.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e.name === "QuotaExceededError" || // Firefox
      e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  }
  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }
  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }
  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
  //endregion
  //region Helpers
  /**
   * Returns parameter value from search string by parameter name.
   * @param {String} paramName search parameter name
   * @param {String} [defaultValue] default value if parameter not found
   * @param {String} [search] search string. Defaults to `document.location.search`
   * @returns {String} search parameter string value
   * @category Helper
   */
  static searchParam(paramName, defaultValue2 = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=?([^&]*)`), match = search.match(re);
    return match && match[1] || defaultValue2;
  }
  /**
   * Returns cookie by name.
   * @param {String} name cookie name
   * @returns {String} cookie string value
   * @category Helper
   */
  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + "=", cookieItems = document.cookie.split(";");
    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }
    return "";
  }
  /**
   * Triggers a download of a file with the specified name / URL.
   * @param {String} filename The filename of the file to be downloaded
   * @param {String} [url] The URL where the file is to be downloaded from
   * @internal
   * @category Download
   */
  static download(filename, url) {
    const a = document.createElement("a");
    a.download = filename;
    a.href = url || filename;
    a.style.cssText = "display:none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  /**
   * Triggers a download of a Blob with the specified name.
   * @param {Blob} blob The Blob to be downloaded
   * @param {String} filename The filename of the file to be downloaded
   * @internal
   * @category Download
   */
  static downloadBlob(blob, filename) {
    const url = globalThis.URL.createObjectURL(blob);
    this.download(filename, url);
    globalThis.URL.revokeObjectURL(url);
  }
  static get queryString() {
    var _a4;
    const params = new URL(globalThis.location.href).searchParams;
    return (_a4 = Object.fromEntries) == null ? void 0 : _a4.call(Object, params.entries());
  }
  // Used by docs fiddle
  static copyToClipboard(code) {
    let success2 = true;
    const textArea = document.createElement("textarea");
    textArea.value = code;
    textArea.style.height = textArea.style.width = 0;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      success2 = false;
    }
    textArea.remove();
    return success2;
  }
  static isBryntumOnline(searchStrings) {
    searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];
    return Boolean(/^(www\.)?bryntum\.com/.test(globalThis.location.host) || (searchStrings == null ? void 0 : searchStrings.some((str) => this.queryString[str] != null)));
  }
  /**
   * Returns truthy value if page contains Content Security Policy meta tag or globalThis.bryntum.CSP is truthy value
   * @returns {Boolean}
   * @internal
   **/
  static get isCSP() {
    const { bryntum: bryntum2, document: document2 } = globalThis;
    if (bryntum2.CSP == null) {
      bryntum2.CSP = Boolean(document2.querySelector('meta[http-equiv="Content-Security-Policy"]'));
    }
    return bryntum2.CSP;
  }
  //endregion
};
__publicField(BrowserHelper, "supportsPointerEvents", Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent));
// Locker Service does not allow to instantiate PointerEvents. LWS apparently does, however.
// https://github.com/bryntum/support/issues/5578
__publicField(BrowserHelper, "supportsPointerEventConstructor", typeof PointerEvent !== "undefined");
__publicField(BrowserHelper, "PointerEventConstructor", globalThis.PointerEvent || globalThis.CustomEvent);
//region Init
/**
 * Yields `true` if the platform running is a phone (screen width or height <= 414 CSS pixels)
 * @property {Boolean}
 * @readonly
 * @static
 * @category Platform
 */
__publicField(BrowserHelper, "isPhone", (_a = globalThis.matchMedia) == null ? void 0 : _a.call(globalThis, "(max-height:414px) or (max-width:414px)").matches);
if (BrowserHelper.isBrowserEnv) {
  BrowserHelper.cacheFlags();
}
BrowserHelper._$name = "BrowserHelper";

// ../Core/lib/Core/helper/StringHelper.js
var charsToEncode;
var entitiesToDecode;
var htmlEncodeRe;
var htmlDecodeRe;
var camelLettersRe = /([a-z])([A-Z])/g;
var crlfRe = /[\n\r]/g;
var escapeRegExpRe = /[.*+?^${}()|[\]\\]/g;
var htmlRe = /[&<]/;
var idRe = /(^[^a-z]+[^\w]+)/gi;
var whiteSpaceRe = /\s+/;
var domIdRe = /^[^a-z]+|[^\w:.-]+/gi;
var htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10));
var htmlEncoder = (m, captured) => charsToEncode[captured];
var hyphenateCamelLetters = (all, g1, g2) => {
  return `${g1}-${g2.toLowerCase()}`;
};
var separateCamelLetters = (all, g1, g2) => {
  return `${g1} ${g2.toLowerCase()}`;
};
var replaceNonIdChar = (c) => {
  if (c) {
    return `_x${[...c].map((ch) => ch.charCodeAt(0).toString(16)).join("")}`;
  }
  return "__blank__";
};
var hyphenateCache = {};
var separatedCache = {};
var ancestors = [];
var circularReplacer = function(key, value) {
  if (value && typeof value === "object") {
    while (ancestors.length && ancestors[ancestors.length - 1] !== this) {
      ancestors.pop();
    }
    if (ancestors.includes(value)) {
      return "[Circular]";
    }
    ancestors.push(value);
  }
  return value;
};
var _StringHelper = class _StringHelper {
  //region Transform
  /**
   * Capitalizes the first letter of a string, "myString" -> "MyString".
   * @param {String} string The string to capitalize
   * @returns {String} The capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static capitalize(string2) {
    return string2 && string2[0].toUpperCase() + string2.substr(1);
  }
  /**
   * Makes the first letter of a string lowercase, "MyString" -> "myString".
   * @param {String} string The string to un-capitalize.
   * @returns {String} The un-capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static uncapitalize(string2) {
    return string2 && string2[0].toLowerCase() + string2.substr(1);
  }
  /**
   * Converts the passed camelCased string to a hyphen-separated string. eg "minWidth" -> "min-width"
   * @param {String} string The string to convert.
   * @returns {String} The string with adjoining lower and upper case letters
   * separated by hyphens and converted to lower case.
   * @category String formatting
   * @internal
   */
  static hyphenate(string2) {
    const cached = hyphenateCache[string2];
    if (cached) {
      return cached;
    }
    return hyphenateCache[string2] = string2.replace(camelLettersRe, hyphenateCamelLetters);
  }
  /**
   * Converts the passed camelCased string to a capitalized, space-separated string. eg "startDate" -> "Start date".
   * @param {String} string The string to convert.
   * @returns {String} The string with spaces separating words.
   * @category String formatting
   * @internal
   */
  static separate(string2) {
    const cached = separatedCache[string2];
    if (cached) {
      return cached;
    }
    return separatedCache[string2] = this.capitalize(string2.replace(camelLettersRe, separateCamelLetters));
  }
  /**
   * Creates an alphanumeric identifier from any passed string. Encodes spaces and non-alpha characters.
   * @param {String} inString The string from which to strip non-identifier characters.
   * @returns {String}
   * @category Misc
   * @internal
   */
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }
  static makeValidDomId(id, replaceValue = "") {
    if (id == null) {
      return null;
    }
    return String(id).replace(domIdRe, replaceValue);
  }
  //endregion
  //region Html
  /**
   * Escapes special RegExp characters.
   * @param {String} string String to escape
   * @privateparam {String} [flags] Optional flags
   * @returns {String} Escaped string
   */
  static escapeRegExp(string2, flags) {
    let ret = string2.replace(escapeRegExpRe, "\\$&");
    if (flags !== void 0) {
      ret = new RegExp(ret, flags);
    }
    return ret;
  }
  /**
   * This method decodes HTML entities and returns the original HTML.
   *
   * See also {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   */
  static decodeHtml(str) {
    return str && String(str).replace(htmlDecodeRe, htmlDecoder);
  }
  /**
   * This method encodes HTML entities and returns a string that can be placed in the document and produce the
   * original text rather than be interpreted as HTML. Using this method with user-entered values prevents those
   * values from executing as HTML (i.e., a cross-site scripting or "XSS" security issue).
   *
   * See also {@link #function-decodeHtml-static}.
   * @param {String|Number} str
   * @returns {String}
   * @category HTML
   */
  static encodeHtml(str = "") {
    return str && String(str).replace(htmlEncodeRe, htmlEncoder);
  }
  /**
   * This method is similar to {@link #function-encodeHtml-static} except that `\n` and `\r` characters in the
   * given `str` are replaced by `<br>` tags _after_ first being encoded by {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   * @internal
   */
  static encodeHtmlBR(str) {
    var _a4;
    return (_a4 = _StringHelper.encodeHtml(str)) == null ? void 0 : _a4.replace(crlfRe, "<br>");
  }
  /**
   * Returns `true` if the provided `text` contains special HTML characters.
   * @param {String} text
   * @returns {Boolean}
   * @category HTML
   * @internal
   */
  static isHtml(text) {
    return typeof text === "string" && htmlRe.test(text || "");
  }
  /**
   * Initializes HTML entities used by {@link #function-encodeHtml-static} and {@link #function-decodeHtml-static}.
   * @param {Object} [mappings] An object whose keys are characters that should be encoded and values are the HTML
   * entity for the character.
   * @private
   */
  static initHtmlEntities(mappings) {
    mappings = mappings || {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const chars = Object.keys(mappings);
    charsToEncode = mappings;
    entitiesToDecode = chars.reduce((prev, val) => {
      prev[mappings[val]] = val;
      return prev;
    }, {});
    htmlEncodeRe = new RegExp(`([${chars.map((c) => "[-]".includes(c) ? "\\" + c : c).join("")}])`, "g");
    htmlDecodeRe = new RegExp(`(${Object.values(mappings).join("|")}|&#[0-9]+;)`, "ig");
  }
  //endregion
  //region JSON
  /**
   * Parses JSON inside a try-catch block. Returns null if the string could not be parsed.
   *
   * @param {String} string String to parse
   * @returns {Object} Resulting object or `null` if parse failed
   * @category JSON
   */
  static safeJsonParse(string2) {
    let parsed = null;
    try {
      parsed = JSON.parse(string2);
    } catch (e) {
    }
    return parsed;
  }
  /**
   * Stringifies an object inside a try-catch block. Returns null if an exception is encountered.
   *
   * See [JSON.stringify on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
   * for more information on the arguments.
   *
   * @param {Object} object The object to stringify
   * @param {Function|'circular'|String[]|Number[]} [replacer] A function or array of string/number used to determine
   * properties to include in the JSON string. Also accepts the string 'circular' to use a built-in replacer handling
   * circular references, by replacing them with `'[Circular]'`.
   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value) for more
   * information.
   * @param {String|Number} [space] Number of spaces to indent or string used as whitespace
   * @returns {String} Resulting object or null if stringify failed
   * @category JSON
   */
  static safeJsonStringify(object, replacer = null, space = null) {
    let result = null;
    try {
      if (replacer === "circular") {
        ancestors.length = 0;
        replacer = circularReplacer;
      }
      result = JSON.stringify(object, replacer, space);
    } catch (e) {
    }
    return result;
  }
  //endregion
  //region Split & join
  /**
   * Joins all given paths together using the separator as a delimiter and normalizes the resulting path.
   * @param paths {Array} array of paths to join
   * @param pathSeparator [{String}] path separator. Default value is '/'
   * @returns {String}
   * @category Misc
   * @internal
   */
  static joinPaths(paths, pathSeparator = "/") {
    return paths.join(pathSeparator).replace(new RegExp("\\" + pathSeparator + "+", "g"), pathSeparator);
  }
  /**
   * Returns the provided string split on whitespace. If the string is empty or consists of only whitespace, the
   * returned array will be empty. If `str` is not a string, it is simply returned. This allows `null` or already
   * split strings (arrays) to be passed through.
   *
   * For example:
   * ```
   *  console.log(StringHelper.split(' abc def xyz   '));
   *  > ['abc', 'def', 'xyz']
   *  console.log(StringHelper.split(''));
   *  > []
   * ```
   * Compare to the standard `split()` method:
   * ```
   *  console.log(' abc def xyz   '.split(/\s+/));
   *  > ['', 'abc', 'def', 'xyz', '']
   *  console.log(''.split(/\s+/));
   *  > ['']
   * ```
   * @param {String} str
   * @param {String|RegExp} delimiter
   * @returns {String[]}
   * @category Misc
   * @internal
   */
  static split(str, delimiter = whiteSpaceRe) {
    let ret = str;
    if (typeof ret === "string") {
      ret = str.trim();
      ret = ret ? ret.split(delimiter) : [];
    }
    return ret;
  }
  //endregion
  //region XSS
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xss`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * @param {TemplateStringsArray} strings The template string array
   * @param {...any} values The interpolated values in the template string
   * @returns {String} The encoded string
   * See {@link Core.helper.StringHelper#function-encodeHtml-static}.
   */
  static xss(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtml(values[i]);
    }
    return buf.join("");
  }
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks. Unlike {@link Core.helper.StringHelper#function-xss-static}, this method converts `\n` and
   * `\r` characters into `<br>` tags.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xssBR`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * See {@link Core.helper.StringHelper#function-encodeHtmlBR-static}.
   * @internal
   */
  static xssBR(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtmlBR(values[i]);
    }
    return buf.join("");
  }
  //endregion
  //region JavaScript string
  /**
   * Converts a value to a JavaScript string (not JSON).
   *
   * For example a date to `"new Date(y, m, d)"`, an array to `"[...]"` etc.
   *
   * @param {*} value
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptValue(value, options) {
    const type = Objects.typeOf(value);
    if (type === "boolean" || type === "string" || type === "number" || value === null) {
      return _StringHelper.safeJsonStringify(value);
    }
    if (value === globalThis) {
      return "window";
    }
    if (type === "date") {
      return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;
    }
    if (type === "array") {
      return `[${value.map((v) => _StringHelper.toJavaScriptValue(v, options))}]`;
    }
    if (type === "object" || type === "instance") {
      return this.toJavaScriptString(value, options);
    }
    if (type === "function") {
      let contents = value.toString();
      if (contents.match(/^async (\w+?)\(/)) {
        contents = contents.replace(/^async (\w+?)\(/, "async function(");
      } else if (!contents.startsWith("async(") && contents.match(/^(\w+?)\(/)) {
        contents = contents.replace(/^(\w+?)\(/, "function(");
      }
      return contents;
    }
    if (type === "class") {
      if (value.toJavaScriptValue) {
        return value.toJavaScriptValue(options);
      }
      return Object.prototype.hasOwnProperty.call(value, "$name") ? value.$name : value.name;
    }
  }
  /**
   * Converts an object into a JavaScript string (not JSON).
   *
   * For example `{ a: 1, b: [2, 3] }` -> `"'{ a: 1, b: [2, 3] }'"`
   *
   * @param {Object} obj
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptString(obj, options = {}) {
    var _a4;
    const level = (_a4 = options.level) != null ? _a4 : 0, intendSize = 2;
    return "{\n" + Object.keys(obj).map(
      (key) => (
        // All properties in an object are indented one step further than the object itself
        " ".repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `"${key}"` : key) + `: ${_StringHelper.toJavaScriptValue(obj[key], { ...options, level: level + 1 })}`
      )
    ).join(",\n") + // Closing brace is indented to same level as the object
    "\n" + " ".repeat(level * intendSize) + "}";
  }
  /**
   * Escapes " and \ in CSS attribute selectors, e.g. [data-id="somevalue"]
   *
   * Usage:
   * ```javascript
   * document.querySelector(StringHelper.cssAttributeQuery('data-id', 'id with & \\ chars'))
   * ```
   *
   * @param {String} attr
   * @param {String|Number} value
   * @returns {String}
   */
  static encodeAttributeSelector(attr, value) {
    return `[${attr}="${String(value).replace(/["\\]/g, "\\$&")}"]`;
  }
  /**
   * Generates a UUID. Uses `Crypto.randomUUID()` if available, otherwise generates a random UUID using
   * `Crypto.getRandomValues()`.
   *
   * @returns {String}
   */
  static generateUUID() {
    var _a4;
    if (BrowserHelper.supportsRandomUUID) {
      return globalThis.crypto.randomUUID();
    }
    if ((_a4 = globalThis.crypto) == null ? void 0 : _a4.getRandomValues) {
      return ("10000000-1000-4000-8000" + -1e11).replace(
        /[018]/g,
        (c) => (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    return `${Date.now()}-${++_StringHelper.fakeNodeUUIDIndex}`;
  }
  //endregion
};
//endregion
//region UUID
__publicField(_StringHelper, "fakeNodeUUIDIndex", 0);
var StringHelper = _StringHelper;
StringHelper.initHtmlEntities();
StringHelper._$name = "StringHelper";

// ../Core/lib/Core/helper/util/Objects.js
var { hasOwnProperty: hasOwnProperty2, toString } = Object.prototype;
var { isFrozen } = Object;
var afterRe = /\s*<\s*/;
var beforeRe = /\s*>\s*/;
var blendOptions = {};
var typeCache = {};
var emptyObject = Object.freeze({});
var Objects = class _Objects {
  static assign(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          dest[key] = source[key];
        }
      }
    }
    return dest;
  }
  static assignIf(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          if (!(key in dest) || dest[key] === void 0) {
            dest[key] = source[key];
          }
        }
      }
    }
    return dest;
  }
  static blend(dest, source, options) {
    options = options || blendOptions;
    dest = dest || {};
    const { clone = _Objects.clone, merge = _Objects.blend } = options;
    if (Array.isArray(source)) {
      if (source.length > 1) {
        source.forEach((s) => {
          dest = _Objects.blend(dest, s, options);
        });
        return dest;
      }
      source = source[0];
    }
    if (source) {
      let destValue, key, value;
      for (key in source) {
        value = source[key];
        if (value && _Objects.isObject(value)) {
          destValue = dest[key];
          options.key = key;
          if (destValue && _Objects.isObject(destValue)) {
            if (isFrozen(destValue)) {
              dest[key] = destValue = clone(destValue, options);
            }
            value = merge(destValue, value, options);
          } else {
            value = isFrozen(value) ? value : clone(value, options);
          }
        }
        dest[key] = value;
      }
    }
    return dest;
  }
  static clone(value, handler) {
    let cloned = value, key;
    if (value && typeof value === "object") {
      const options = handler && typeof handler === "object" && handler;
      if (options) {
        handler = null;
      }
      if (_Objects.isObject(value)) {
        if (value.skipClone) {
          cloned = value;
        } else {
          cloned = {};
          for (key in value) {
            cloned[key] = _Objects.clone(value[key]);
          }
        }
      } else if (Array.isArray(value)) {
        cloned = [];
        for (key = value.length; key-- > 0; ) {
          cloned[key] = _Objects.clone(value[key]);
        }
      } else if (_Objects.isDate(value)) {
        cloned = new Date(value.getTime());
      } else if (handler) {
        cloned = handler(value);
      }
    }
    return cloned;
  }
  static createTruthyKeys(source) {
    const keys = StringHelper.split(source), result = keys && {};
    if (keys) {
      for (const key of keys) {
        if (key) {
          result[key] = true;
        }
      }
    }
    return result;
  }
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   */
  static getPath(object, path) {
    return path.split(".").reduce((result, key) => {
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Returns value for a given path in the object, placing a passed default value in at the
   * leaf property and filling in undefined properties all the way down.
   * @param {Object} object Object to get path value for.
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {*} [defaultValue] Optionally the value to put in as the `someKey` property.
   * @returns {*} Value at the leaf position of the path.
   */
  static getPathDefault(object, path, defaultValue2) {
    const keys = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], length = keys.length - 1;
    return keys.reduce((result, key, index) => {
      if (defaultValue2 && !(key in result)) {
        result[key] = index === length ? defaultValue2 : {};
      }
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Finds a property descriptor for the passed object from all inheritance levels.
   * @param {Object} object The Object whose property to find.
   * @param {String} propertyName The name of the property to find.
   * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`
   */
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let o = object; o && !result && !_Objects.hasOwn(o, "isBase"); o = Object.getPrototypeOf(o)) {
      result = Object.getOwnPropertyDescriptor(o, propertyName);
    }
    return result;
  }
  /**
   * Determines if the specified path exists
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean}
   */
  static hasPath(object, path) {
    return path.split(".").every((key) => {
      if (object && key in object) {
        object = object[key];
        return true;
      }
      return false;
    });
  }
  static getTruthyKeys(source) {
    const keys = [];
    for (const key in source) {
      if (source[key]) {
        keys.push(key);
      }
    }
    return keys;
  }
  static getTruthyValues(source) {
    const values = [];
    for (const key in source) {
      if (source[key]) {
        values.push(source[key]);
      }
    }
    return values;
  }
  static isClass(object) {
    var _a4;
    if (typeof object === "function" && ((_a4 = object.prototype) == null ? void 0 : _a4.constructor) === object) {
      return true;
    }
    return false;
  }
  static isDate(object) {
    return Boolean(object == null ? void 0 : object.getUTCDate) && _Objects.typeOf(object) === "date";
  }
  /**
   * Check if passed object is a Promise or contains `then` method.
   * Used to fix problems with detecting promises in code with `instance of Promise` when
   * Promise class is replaced with any other implementation like `ZoneAwarePromise` in Angular.
   * Related to these issues:
   * https://github.com/bryntum/support/issues/791
   * https://github.com/bryntum/support/issues/2990
   *
   * @param {Object} object object to check
   * @returns {Boolean} truthy value if object is a Promise
   * @internal
   */
  static isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) === object || typeof (object == null ? void 0 : object.then) === "function";
    }
    throw new Error("Promise not supported in your environment");
  }
  static isEmpty(object) {
    if (object && typeof object === "object") {
      for (const p in object) {
        return false;
      }
    }
    return true;
  }
  static isObject(value) {
    const C = value == null ? void 0 : value.constructor;
    return Boolean(
      C ? (
        // An in-frame instance of Object
        C === Object || // Detect cross-frame objects, but exclude instance of custom classes named Object. typeOf(value) is
        // "object" even for instances of a class and typeOf(C) is "function" for all constructors. We'll have
        // to settle for relying on the fact that getPrototypeOf(Object.prototype) === null.
        // NOTE: this issue does come up in Scheduler unit tests at least.
        C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype)
      ) : value && typeof value === "object"
    );
  }
  static isInstantiated(object) {
    return object ? typeof object === "object" && !_Objects.isObject(object) : false;
  }
  static merge(dest, ...sources) {
    return _Objects.blend(dest, sources);
  }
  /**
   * Merges two "items" objects. An items object is a simple object whose keys act as identifiers and whose values
   * are "item" objects. An item can be any object type. This method is used to merge such objects while maintaining
   * their property order. Special key syntax is used to allow a source object to insert a key before or after a key
   * in the `dest` object.
   *
   * For example:
   * ```javascript
   *  let dest = {
   *      foo : {},
   *      bar : {},
   *      fiz : {}
   *  }
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "bar", "fiz"]
   *
   *  dest = mergeItems(dest, {
   *      'zip > bar' : {}    // insert "zip" before "bar"
   *      'bar < zap' : {}    // insert "zap" after "bar"
   *  });
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "zip", "bar", "zap", "fiz"]
   * ```
   *
   * @param {Object} dest The destination object.
   * @param {Object|Object[]} src The source object or array of source objects to merge into `dest`.
   * @param {Object} [options] The function to use to merge items.
   * @param {Function} [options.merge] The function to use to merge items.
   * @returns {Object} The merged object. This will be the `dest` object.
   * @internal
   */
  static mergeItems(dest, src, options) {
    options = options || blendOptions;
    let anchor, delta, index, indexMap, key, shuffle, srcVal;
    const { merge = _Objects.blend } = options;
    dest = dest || {};
    if (Array.isArray(src)) {
      src.forEach((s) => {
        dest = _Objects.mergeItems(dest, s, options);
      });
    } else if (src) {
      for (key in src) {
        srcVal = src[key];
        anchor = null;
        if (key.includes(">")) {
          [key, anchor] = key.split(beforeRe);
          delta = 0;
        } else if (key.includes("<")) {
          [anchor, key] = key.split(afterRe);
          delta = 1;
        }
        if (key in dest) {
          if (srcVal && dest[key] && merge) {
            options.key = key;
            srcVal = merge(dest[key], srcVal, options);
          }
          dest[key] = srcVal;
        } else if (!anchor) {
          dest[key] = srcVal;
          indexMap == null ? void 0 : indexMap.set(key, indexMap.size);
        } else {
          if (!indexMap) {
            indexMap = /* @__PURE__ */ new Map();
            index = 0;
            for (const k in dest) {
              indexMap.set(k, index++);
            }
          }
          index = indexMap.get(anchor);
          dest[key] = srcVal;
          if (index == null && delta) {
            index = indexMap.size;
          } else {
            shuffle = shuffle || [];
            index = (index || 0) + delta;
            for (const item of indexMap) {
              const [k, v] = item;
              if (index <= v) {
                shuffle && (shuffle[indexMap.size - v - 1] = k);
                indexMap.set(k, v + 1);
              }
            }
            if (shuffle) {
              while (shuffle.length) {
                const k = shuffle.pop(), v = dest[k];
                delete dest[k];
                dest[k] = v;
              }
            }
          }
          indexMap.set(key, index);
        }
      }
    }
    return dest;
  }
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   */
  static setPath(object, path, value) {
    path.split(".").reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;
      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }
      return result[key];
    }, object);
    return object;
  }
  static typeOf(value) {
    let trueType, type;
    if (value === null) {
      type = "null";
    } else if (value !== value) {
      type = "nan";
    } else {
      type = typeof value;
      if (type === "object") {
        if (value.isBase) {
          type = "instance";
        } else if (Array.isArray(value)) {
          type = "array";
        } else if (!(type = typeCache[trueType = toString.call(value)])) {
          typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase();
        }
      } else if (type === "function" && value.isBase) {
        type = "class";
      }
    }
    return type;
  }
};
Object.defineProperty(Objects, "hasOwn", {
  // When available, this avoids an extra layer of function call around it:
  value: Object.hasOwn || ((object, property) => hasOwnProperty2.call(object, property))
});
Objects._$name = "Objects";

// ../Core/lib/Core/helper/VersionHelper.js
var VersionHelper = class _VersionHelper {
  /**
   * Set version for specified product
   * @private
   * @param {String} product
   * @param {String} version
   */
  static setVersion(product, version) {
    product = product.toLowerCase();
    VH[product] = {
      version,
      isNewerThan(otherVersion) {
        return _VersionHelper.semanticCompareVersion(otherVersion, version, "<");
      },
      isOlderThan(otherVersion) {
        return _VersionHelper.semanticCompareVersion(otherVersion, version, ">");
      }
    };
    let bundleFor = "";
    if (typeof productName !== "undefined") {
      bundleFor = productName;
    }
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, "-")}`;
    if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {
      if (globalThis.bryntum[globalKey] === true) {
        if (this.isTestEnv) {
          globalThis.BUNDLE_EXCEPTION = true;
        } else {
          let errorProduct = bundleFor || product;
          if (errorProduct === "core") {
            errorProduct = "grid";
          }
          let capitalized = StringHelper.capitalize(errorProduct);
          if (errorProduct === "schedulerpro") {
            capitalized = "SchedulerPro";
          }
          throw new Error(
            `The Bryntum ${capitalized} bundle was loaded multiple times by the application.

Common reasons you are getting this error includes:

* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)
* Imports point to both sources and bundle
* Imports do not use the shortest relative path, JS treats them as different files
* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files
* Imports missing file type, verify they all end in .js

See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information

`
          );
        }
      } else {
        globalThis.bryntum[globalKey] = true;
      }
    }
  }
  /**
   * Get (previously set) version for specified product
   * @private
   * @param {String} product
   */
  static getVersion(product) {
    product = product.toLowerCase();
    if (!VH[product]) {
      throw new Error("No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.");
    }
    return VH[product].version;
  }
  /**
   * Checks the version1 against the passed version2 using the comparison operator.
   * Supports `rc`, `beta`, `alpha` release states. Eg. `1.2.3-alpha-1`.
   * State which is not listed above means some version below `alpha`.
   * @param {String} version1 The version to test against
   * @param {String} version2 The version to test against
   * @param {String} [comparison] The comparison operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static semanticCompareVersion(version1, version2, comparison = "=") {
    version1 = version1 || "";
    version2 = version2 || "";
    const version1Arr = version1.split(/[-.]/), version2Arr = version2.split(/[-.]/), isLower = comparison.includes("<"), normalizeArr = (arr, maxLength) => {
      const states = ["rc", "beta", "alpha"], result = arr.map((v) => {
        if (states.includes(v)) {
          return -states.indexOf(v) - 2;
        }
        const res = Number.parseInt(v);
        return Number.isNaN(res) ? -states.length : res;
      });
      while (result.length < maxLength) {
        result.push(-1);
      }
      return result;
    }, compareArr = () => {
      const maxLength = Math.max(version1Arr.length, version2Arr.length), arr1 = normalizeArr(version1Arr, maxLength), arr2 = normalizeArr(version2Arr, maxLength);
      for (let i = 0; i < maxLength; i++) {
        if (arr1[i] !== arr2[i]) {
          return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];
        }
      }
      return true;
    };
    switch (comparison) {
      case "=":
        return version1 === version2;
      case "<=":
      case ">=":
        return version1 === version2 || compareArr();
      case "<":
      case ">":
        return version1 !== version2 && compareArr();
    }
    return false;
  }
  /**
   * Checks the passed product against the passed version using the passed test.
   * @param {String} product The name of the product to test the version of
   * @param {String} version The version to test against
   * @param {String} operator The test operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static checkVersion(product, version, operator) {
    return _VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);
  }
  /**
   * Based on a comparison of current product version and the passed version this method either outputs a console.warn
   * or throws an error.
   * @param {String} product The name of the product
   * @param {String} invalidAsOfVersion The version where the offending code is invalid (when any compatibility layer
   * is actually removed).
   * @param {String} message Required! A helpful warning message to show to the developer using a deprecated API.
   * @internal
   */
  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = VH.checkVersion(product, invalidAsOfVersion, "<");
    if (justWarn) {
      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }
  /**
   * Returns truthy value if environment is in testing mode
   * @returns {Boolean}
   * @internal
   **/
  static get isTestEnv() {
    var _a4, _b, _c;
    const isTestEnv = Boolean((_a4 = globalThis.bryntum) == null ? void 0 : _a4.isTestEnv);
    try {
      return isTestEnv || Boolean((_c = (_b = globalThis.parent) == null ? void 0 : _b.bryntum) == null ? void 0 : _c.isTestEnv);
    } catch (e) {
      return isTestEnv;
    }
  }
  static get isDebug() {
    let result = false;
    return result;
  }
};
var VH = VersionHelper;
if (BrowserHelper.isBrowserEnv) {
  if (VH.isTestEnv) {
    BrowserHelper._isHoverableDevice = true;
  }
  globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {
    getVersion: VH.getVersion.bind(VH),
    checkVersion: VH.checkVersion.bind(VH),
    deprecate: VH.deprecate.bind(VH),
    license: "d173947d-27b2-11ed-9a0f-d094663d5c88"
  });
}
VersionHelper._$name = "VersionHelper";

// ../Core/lib/Core/Config.js
var { defineProperty, getOwnPropertyDescriptor } = Reflect;
var { hasOwnProperty: hasOwnProperty3, toString: toString2 } = Object.prototype;
var instancePropertiesSymbol = Symbol("instanceProperties");
var configuringSymbol = Symbol("configuring");
var lazyConfigValues = Symbol("lazyConfigValues");
var DATE_TYPE = toString2.call(/* @__PURE__ */ new Date());
var whitespace = /\s+/;
var createClsProps = (result, cls) => {
  result[cls] = 1;
  return result;
};
var Config = class _Config {
  /**
   * Returns the `Config` instance for the given `name` and `options`.
   * @param {String} name The name of the config (e.g., 'text' for the text config).
   * @param {Object} [options] Config behavior options.
   * @returns {Core.Config}
   * @internal
   */
  static get(name, options) {
    const { cache } = this, baseCfg = cache[name] || (cache[name] = new _Config(name));
    let cfg = baseCfg, key;
    if (options) {
      key = _Config.makeCacheKey(name, options);
      if (!(cfg = key && cache[key])) {
        cfg = baseCfg.extend(options);
        if (key) {
          cache[key] = cfg;
        }
      }
    }
    return cfg;
  }
  constructor(name) {
    const me = this, cap = name[0].toUpperCase() + name.substr(1);
    me.base = me;
    me.name = name;
    me.field = "_" + name;
    me.capName = cap;
    me.changer = "change" + cap;
    me.initializing = "initializing" + cap;
    me.updater = "update" + cap;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's getter and setter.
   * @property {Object}
   * @private
   */
  get descriptor() {
    let descriptor = this._descriptor;
    if (!descriptor || !hasOwnProperty3.call(this, "_descriptor")) {
      this._descriptor = descriptor = this.makeDescriptor();
    }
    return descriptor;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's initter.
   * @property {Object}
   * @private
   */
  get initDescriptor() {
    let descriptor = this._initDescriptor;
    if (!descriptor || !hasOwnProperty3.call(this, "_initDescriptor")) {
      this._initDescriptor = descriptor = this.makeInitter();
    }
    return descriptor;
  }
  /**
   * This method compares two values for semantic equality. By default, this is based on the `===` operator. This
   * is often overridden for configs that accept `Date` or array values.
   * @param {*} value1
   * @param {*} value2
   * @returns {Boolean}
   * @internal
   */
  equal(value1, value2) {
    return value1 === value2;
  }
  /**
   * Extends this config with a given additional set of options. These objects are just prototype extensions of this
   * instance.
   * @param {Object} options
   * @returns {Core.Config}
   * @internal
   */
  extend(options) {
    const cfg = Object.assign(Object.create(this), options), { equal: equal2, merge } = options, { equalityMethods } = _Config;
    if (typeof equal2 === "string") {
      if (equal2.endsWith("[]")) {
        cfg.equal = _Config.makeArrayEquals(equalityMethods[equal2.substr(0, equal2.length - 2)]);
      } else {
        cfg.equal = equalityMethods[equal2];
      }
    }
    if (typeof merge === "string") {
      cfg.merge = _Config.mergeMethods[merge];
    }
    return cfg;
  }
  /**
   * Defines the property on a given target object via `Reflect.defineProperty()`. If the object has its own getter,
   * it will be preserved. It is invalid to define a setter.
   * @param {Object} target
   * @internal
   */
  define(target) {
    const existing = getOwnPropertyDescriptor(target, this.name);
    let descriptor = this.descriptor;
    if (existing && existing.get) {
      descriptor = Object.assign({}, descriptor);
      descriptor.get = existing.get;
    }
    defineProperty(target, this.name, descriptor);
  }
  /**
   * Defines the property initter on the `target`. This is a property getter/setter that propagates the configured
   * value when the property is read.
   * @param {Object} target
   * @param {*} value
   * @internal
   */
  defineInitter(target, value) {
    const { name } = this, properties = target[instancePropertiesSymbol];
    let lazyValues, prop;
    if (!properties[name] && /* assign */
    (prop = getOwnPropertyDescriptor(target, name)) && !("value" in prop)) {
      properties[name] = prop;
    }
    defineProperty(target, name, this.initDescriptor);
    if (this.lazy) {
      lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = /* @__PURE__ */ new Map());
      lazyValues.set(name, value);
    }
  }
  /**
   * Returns an equality function for arrays of a base type, for example `'date'`.
   * @param {Function} [fn] The function to use to compare array elements. By default, operator `===` is used.
   * @returns {Function}
   * @private
   */
  static makeArrayEquals(fn) {
    return (value1, value2) => {
      let i, equal2 = value1 && value2 && value1.length === (i = value2.length);
      if (equal2 && Array.isArray(value1) && Array.isArray(value2)) {
        if (fn) {
          while (equal2 && i-- > 0) {
            equal2 = fn(value1[i], value2[i]);
          }
        } else {
          while (equal2 && i-- > 0) {
            equal2 = value1[i] === value2[i];
          }
        }
      } else {
        equal2 = fn ? fn(value1, value2) : value1 === value2;
      }
      return equal2;
    };
  }
  /**
   * Returns the key to use in the Config `cache`.
   * @param {String} name The name of the config property.
   * @param {Object} options The config property options.
   * @returns {String}
   * @private
   */
  static makeCacheKey(name, options) {
    const keys = Object.keys(options).sort();
    for (let key, type, value, i = keys.length; i-- > 0; ) {
      value = options[key = keys[i]];
      if (value == null && value === false) {
        keys.splice(i, 1);
      } else {
        type = typeof value;
        if (type === "function") {
          return null;
        }
        if (type === "string") {
          keys[i] = `${key}:"${value}"`;
        } else if (type === "number") {
          keys[i] = `${key}:${value}`;
        }
      }
    }
    return keys.length ? `${name}>${keys.join("|")}` : name;
  }
  /**
   * Creates and returns a property descriptor for this config suitable to be passed to `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeDescriptor() {
    const config = this, { base, field, changer, updater, name } = config;
    if (base !== config && base.equal === config.equal) {
      return base.descriptor;
    }
    return {
      get() {
        var _a4;
        (_a4 = this.configObserver) == null ? void 0 : _a4.get(name, this);
        return this[field];
      },
      set(value) {
        var _a4, _b;
        const me = this;
        let was = me[field], applied, newValue;
        if (typeof value === "string") {
          let resolvedValue = value;
          if (value.startsWith("up.")) {
            resolvedValue = (_a4 = me.owner) == null ? void 0 : _a4.resolveProperty(value.slice(3));
          } else if (value.startsWith("this.")) {
            resolvedValue = me.resolveProperty(value.slice(5));
          }
          if (resolvedValue !== void 0 && typeof resolvedValue !== "function") {
            value = resolvedValue;
          }
        }
        if (me[changer]) {
          applied = (newValue = me[changer](value, was)) === void 0 && 1;
          if (!applied) {
            value = newValue;
            was = me[field];
          }
        }
        if (!applied && !(config.equal === equal ? was === value : config.equal(was, value))) {
          me[field] = value;
          applied = 2;
          (_b = me[updater]) == null ? void 0 : _b.call(me, value, was);
        }
        if (applied && !me.isDestroyed && !me.onConfigChange.$nullFn) {
          me.onConfigChange({ name, value, was, config, applied });
        }
      }
    };
  }
  /**
   * Creates and returns a property descriptor for this config's initter suitable to pass to
   * `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeInitter() {
    const config = this;
    if (config !== config.base) {
      if (config.lazy) {
        return config.makeLazyInitter();
      }
      return config.base.initDescriptor;
    }
    return config.makeBasicInitter();
  }
  makeBasicInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this;
        config.removeInitter(me);
        me[initializing] = true;
        me[name] = me[configuringSymbol][name];
        me[initializing] = false;
        me.configDone[name] = true;
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this.configDone[name] = true;
        this[name] = value;
      }
    };
  }
  makeLazyInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this, value = me[lazyConfigValues].get(name);
        config.removeInitter(me);
        if (!me.isDestroying) {
          me[initializing] = true;
          me[name] = value;
          me[initializing] = false;
        }
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this[name] = value;
      }
    };
  }
  /**
   * Removes the property initter and restores the instance to its original form.
   * @param {Object} instance
   * @private
   */
  removeInitter(instance) {
    const { name } = this, instanceProperty = instance[instancePropertiesSymbol][name], lazyValues = instance[lazyConfigValues];
    if (instanceProperty) {
      defineProperty(instance, name, instanceProperty);
    } else {
      delete instance[name];
    }
    if ((lazyValues == null ? void 0 : lazyValues.delete(name)) && !lazyValues.size) {
      delete instance[lazyConfigValues];
    }
  }
  setDefault(cls, value) {
    defineProperty(cls.prototype, this.field, {
      configurable: true,
      writable: true,
      // or else "this._value = x" will fail
      value
    });
  }
  /**
   * This method combines (merges) two config values. This is called in two cases:
   *
   *  - When a derived class specifies the value of a config defined in a super class.
   *  - When a value is specified in the instance config object.
   *
   * @param {*} newValue In the case of derived classes, this is the config value of the derived class. In the case
   * of the instance config, this is the instance config value.
   * @param {*} currentValue In the case of derived classes, this is the config value of the super class. In the case
   * of the instance config, this is the class config value.
   * @param {Object} metaNew The class meta object from which the `newValue` is coming. This parameter is `null` if
   * the `newValue` is from an instance configuration.
   * @param {Object} metaCurrent The class meta object from which the `currentValue` is coming. This parameter is
   * `null` if the `currentValue` is not from a class configuration.
   * @returns {*}
   * @internal
   */
  merge(newValue, currentValue) {
    if (currentValue && newValue && Objects.isObject(newValue)) {
      if (currentValue.isBase) {
        return currentValue.setConfig(newValue);
      }
      if (Objects.isObject(currentValue)) {
        newValue = Objects.merge(Objects.clone(currentValue), newValue);
      }
    }
    return newValue;
  }
};
var { prototype } = Config;
var { equal } = prototype;
Config.symbols = {
  configuring: configuringSymbol,
  instanceProperties: instancePropertiesSymbol,
  lazyConfigs: lazyConfigValues
};
Config.cache = /* @__PURE__ */ Object.create(null);
Config.equalityMethods = {
  array: Config.makeArrayEquals(),
  date(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    if (value1 && value2 && toString2.call(value1) === DATE_TYPE && toString2.call(value2) === DATE_TYPE) {
      return value1.getTime() === value2.getTime();
    }
    return false;
  },
  strict: Config.equal = equal
};
Config.mergeMethods = {
  distinct(newValue, oldValue) {
    let ret = oldValue ? oldValue.slice() : [];
    if (newValue != null) {
      if (Objects.isObject(newValue)) {
        if (oldValue === void 0) {
          ret = newValue;
        } else {
          let key, index;
          for (key in newValue) {
            index = ret.indexOf(key);
            if (newValue[key]) {
              if (index < 0) {
                ret.push(key);
              }
            } else if (index > -1) {
              ret.splice(index, 1);
            }
          }
        }
      } else if (Array.isArray(newValue)) {
        newValue.forEach((v) => !ret.includes(v) && ret.push(v));
      } else if (!ret.includes(newValue)) {
        ret.push(newValue);
      }
    }
    return ret;
  },
  merge: Config.merge = prototype.merge,
  classList(newValue, oldValue) {
    if (typeof newValue === "string") {
      if (!newValue.length) {
        return oldValue;
      }
      newValue = newValue.split(whitespace);
    }
    if (Array.isArray(newValue)) {
      newValue = newValue.reduce(createClsProps, {});
    }
    return Config.merge(newValue, oldValue);
  },
  objects(newValue, oldValue) {
    return newValue === true ? oldValue || {} : Config.merge(newValue, oldValue);
  },
  replace(newValue) {
    return newValue;
  },
  items(newValue, oldValue, metaNew, metaCurrent) {
    if (metaCurrent) {
      return Objects.mergeItems(oldValue, newValue, {
        merge: (oldValue2, newValue2) => prototype.merge(newValue2, oldValue2)
      });
    }
    return prototype.merge(newValue, oldValue);
  }
};
Object.assign(prototype, {
  _descriptor: null,
  _initDescriptor: null,
  /**
   * A function that compares values for equality. This test is used to determine if the `update` method should be
   * called when the setter is invoked.
   *
   * To handle `Date` values:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              date : {
   *                  $config : {
   *                      equal : 'date'
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateDate(date) {
   *          // date has changed
   *      }
   *  }
   * ```
   *
   * Also useful for some configs:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              bar : {
   *                  $config : {
   *                      equal : ObjectHelper.isEqual
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateBar(value) {
   *          // value has changed
   *      }
   *  }
   * ```
   * @config {Function} equal
   * @internal
   */
  /**
   * Indicates that this config property should not automatically initialize during construction. When this property
   * is set to `true`, initialization is triggered by the first use of the config property's getter.
   *
   * This property can alternatively be set to a string, in which case it can be initialized as a group using the
   * {@link Core.Base#function-triggerConfigs} method which will initialize all lazy configs with the same value for
   * this property. Note: the config will still initialize on first use if that occurs prior to the call to
   * `triggerConfigs`.
   * @config {Boolean|String}
   * @default
   * @internal
   */
  lazy: false,
  /**
   * Indicates that this config property should automatically be set to `null` on destroy.
   * @config {Boolean}
   * @default
   * @internal
   */
  nullify: false,
  /**
   * Indicates that this config participates in rendering. This has does not affect the behavior of the property
   * directly, but allows classes that perform rendering to detect which config changes will affect the rendered
   * result.
   * @config {Boolean}
   * @default
   * @internal
   */
  render: false
});
Config._$name = "Config";

// ../Core/lib/Core/Base.js
var MetaClass = class {
  constructor(options) {
    options && Object.assign(this, options);
  }
  getInherited(name, create = true) {
    var _a4;
    let ret = this[name];
    if (!(name in this)) {
      ret = (_a4 = this.super) == null ? void 0 : _a4.getInherited(name, create);
      if (ret || create) {
        this[name] = ret = Object.create(ret || null);
      }
    }
    return ret;
  }
};
var { getPrototypeOf } = Object;
var { hasOwn } = Objects;
var { defineProperty: defineProperty2 } = Reflect;
var metaSymbol = Symbol("classMetaData");
var mixinTagSymbol = Symbol("mixinTag");
var originalConfigSymbol = Symbol("originalConfig");
var createdAtSymbol = Symbol("createdAt");
var configuringSymbol2 = Config.symbols.configuring;
var instancePropertiesSymbol2 = Config.symbols.instanceProperties;
var lazyConfigsSymbol = Config.symbols.lazyConfigs;
var defaultConfigOptions = { merge: "replace", simple: true };
var emptyFn = () => {
};
var newMeta = (o) => new MetaClass(o);
var setupNames = {
  /* foo : 'setupFoo' */
};
var emptyObject2 = Object.freeze({});
var emptyArray = Object.freeze([]);
var Base = class _Base {
  static get isBase() {
    return true;
  }
  get isBase() {
    return true;
  }
  // defaultConfig & properties made private to not spam all other classes
  /**
   * A class property getter to add additional, special class properties.
   *
   * For example, a class adds a `declarable` class property like so:
   * ```
   *  class Something extends Base {
   *      static get declarable() {
   *          return ['extra'];
   *      }
   *
   *      static setupExtra(cls, meta) {
   *          // use cls.extra
   *      }
   *  }
   * ```
   * A derived class can then specify this property like so:
   * ```
   *  class Derived extends Something {
   *      static get extra() {
   *          // return extra information
   *      }
   *  }
   * ```
   * When the `Derived` class is initialized, the `setupExtra()` method is called and `Derived` is passed as the
   * argument. It is also the `this` pointer, but the parameter is minifiable. The second argument passed is the
   * `$meta` object for the class.
   *
   * Classes are initialized at the first occurrence of the following:
   *
   * - An instance is created
   * - The class `$meta` property is accessed
   *
   * @member {String[]} declarable
   * @static
   * @category Configuration
   * @internal
   */
  static get declarable() {
    return [
      "declarable",
      /**
       * A class property getter for the configuration properties of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Label` might declare a `text` config like so:
       * ```javascript
       *  class Label extends Base {
       *      static get configurable() {
       *          return {
       *              text : null
       *          };
       *      }
       *  }
       * ```
       * The `text` config is automatically inherited by classes derived from Label. By implementing
       * `get configurable()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both.
       *
       * When a config property is declared in this way, the class author can also implement either of two
       * special methods that will be called when the config property is assigned a new value:
       *
       *  - `changeText()`
       *  - `updateText()`
       *
       * In the example above, the `Label` class could implement a `changeText()` method, an `updateText()`
       * method, or both. The generated property setter ensures these methods will be called when the `text`
       * property is assigned.
       *
       * The generated setter (for `text` in this example) performs the following steps:
       *
       *  - If the class defines a `changeText()` method, call it passing the new value and the current value:
       *    `changeText(newText, oldText)`.<br>
       *    Then:
       *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing
       *      further. The assumption is that the changer method has done all that is required.
       *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.
       *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:
       *    * Update the stored config value in `this._text`.
       *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.
       *      `updateText(newText, oldText)`
       *
       * #### Resolving a value from an owner
       * By specifying a value starting with `'up.'` for a config, the config system will resolve that value by
       * examining the ownership hierarchy. It will walk up the hierarchy looking for a property matching the name
       * (or dot separated path) after 'up.'. If one is found, the value will be read and used as the initial
       * value.
       *
       * ```javascript
       * class Parent extends Base {
       *     static get configurable() {
       *         return [
       *           'importantValue'
       *         ]
       *     }
       * }
       *
       * class Child extends Base {
       *     static get configurable() {
       *         return [
       *           'value'
       *         ]
       *     }
       * }
       *
       * const parent = new Parent({
       *     importantValue : 123
       * });
       *
       * const child = new Child({
       *     owner : parent,
       *     // Will be resolved from the owner
       *     value : 'up.importantValue'
       * });
       *
       * console.log(child.value); // logs 123
       * ```
       * Please note that this is for now a one way one time binding, the value will only be read initially and
       * not kept up to date on later changes.
       *
       * #### Value Merging
       * When a config property value is an object, the value declared by the base class is merged with values
       * declared by derived classes and the value passed to the constructor.
       * ```javascript
       *  class Example extends Base {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  foo : 1,
       *                  bar : 2
       *              }
       *          };
       *      }
       *  }
       *
       *  class Example2 extends Example {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  bar : 42,
       *                  zip : 'abc'
       *              }
       *          };
       *      }
       *  }
       *
       *  let ex = new Example2({
       *      config : {
       *          zip : 'xyz'
       *      }
       *  });
       * ```
       * The result of the merge would set `config` to:
       * ```javascript
       *  ex.foo = {
       *      foo : 1,    // from Example
       *      bar : 42,   // from Example2
       *      zip : 'xyz' // from constructor
       *  }
       * ```
       *
       * #### Config Options
       * Some config properties require additional options such as declarative information about the config that
       * may be useful to automate some operation. Consider a `Button`. It could declare that its `text` config
       * affects the rendered HTML by applying a `render` property to the config definition. Its base class could
       * then examine the config definition to find this property.
       *
       * To support this, config options ca be declared like so:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : {
       *                      render : true
       *                  }
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `$config` property can alternatively be just the names of the options that should be enabled (set
       * to `true`).
       *
       * For example, the following is equivalent to the above:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : 'render'
       *              }
       *          };
       *  }
       * ```
       *
       * #### Default Value
       * It is common to set a config to a `null` value to take advantage of internal optimizations for `null`
       * values. In most cases the fact that this produces `undefined` as the actual initial value of the config
       * is acceptable. When this is not acceptable, a config can be declared like so:
       * ```javascript
       *  class Widget {
       *      static get configurable() {
       *          return {
       *              disabled : {
       *                  $config : null,
       *                  value   : null,
       *                  default : false
       *              }
       *          };
       *  }
       * ```
       * The `default` property above determines the value of the config while still gaining the benefits of
       * minimal processing due to the `null` value of the `value` property.
       * @member {Object} configurable
       * @static
       * @category Configuration
       * @internal
       */
      "configurable",
      /**
       * A class property getter for the default configuration of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Store` might declare its `url` config like so:
       * ```
       *  class Store extends Base {
       *      static get defaultConfig() {
       *          return {
       *              url : null
       *          };
       *      }
       *  }
       * ```
       * The `url` config is automatically inherited by classes derived from Store. By implementing
       * `get defaultConfig()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both. When defining new configs, however, `configurable` is preferred.
       *
       * Config properties introduced to a class by this declaration do not participate in value merging and do
       * not get a generated setter. Config properties introduced by a base class using `configurable` can be
       * set to a different value using `defaultConfig` and in doing so, the values will be merged as appropriate
       * for `configurable`.
       *
       * @member {Object} defaultConfig
       * @static
       * @category Configuration
       * @internal
       */
      "defaultConfig",
      /**
       * A class property getter for the default values of internal properties for this class.
       * @member {Object} properties
       * @static
       * @category Configuration
       * @internal
       */
      "properties",
      /**
       * A class property getter for properties that will be applied to the class prototype.
       * @member {Object} prototypeProperties
       * @static
       * @category Configuration
       * @internal
       */
      "prototypeProperties"
    ];
  }
  /**
   * Base constructor, passes arguments to {@link #function-construct}.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @function constructor
   * @category Lifecycle
   * @advanced
   */
  constructor(...args) {
    const me = this, C = me.constructor;
    if (me.$meta.class !== C) {
      emptyFn(C.$meta);
    }
    me.construct(...args);
    me.afterConstruct();
    me.isConstructing = false;
  }
  /**
   * Factory version of the Base constructor. Merges all arguments to create a config object that is passed along to
   * the constructor.
   * @param {...Object} [configs] Allows passing multiple config objects
   * @returns {Core.Base} New instance
   * @private
   */
  static new(...configs) {
    configs = configs.filter((c) => c);
    return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);
  }
  /**
   * Base implementation applies configuration.
   *
   * Subclasses need only implement this if they have to initialize instance specific
   * properties required by the class. Often a `construct` method is
   * unnecessary. All initialization of incoming configuration properties can be
   * done in a `set propName` implementation.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @category Lifecycle
   * @advanced
   */
  construct(...args) {
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }
  /**
   * Destroys the provided objects by calling their {@link #function-destroy} method.
   * Skips empty values or objects that are already destroyed.
   *
   * ```javascript
   * Base.destroy(myButton, toolbar1, helloWorldMessageBox);
   * ```
   * @param {...Object} [args] Objects to be destroyed
   * @category Lifecycle
   * @advanced
   */
  static destroy(...args) {
    const shredder = (object) => {
      if (object == null ? void 0 : object.destroy) {
        object.destroy();
      } else if (Array.isArray(object)) {
        object.forEach(shredder);
      }
    };
    shredder(args);
  }
  /**
   * Destroys this object.
   *
   * {@advanced}
   * This is primarily accomplished by calling {@link #function-doDestroy}, however, prior to
   * calling `doDestroy`, {@link #property-isDestroying} is set to `true`. After {@link #function-doDestroy} returns,
   * {@link #property-isDestroyed} is set to `true`.
   *
   * Do not override this method in subclasses. To provide class-specific cleanup, implement {@link #function-doDestroy}
   * instead.
   * {/@advanced}
   *
   * @category Lifecycle
   */
  destroy() {
    const me = this, { id } = me;
    me.isDestroying = true;
    me.destroy = emptyFn;
    me.doDestroy();
    Object.setPrototypeOf(me, null);
    for (const key in me) {
      if (key !== "destroy" && key !== "isDestroying") {
        delete me[key];
      }
    }
    delete me[originalConfigSymbol];
    me.isDestroyed = true;
    me.id = id;
  }
  /**
   * This method is required to help `unused` getters to survive production build process. Some tools, like angular,
   * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.
   * @internal
   * @param getter Getter to evaluate
   */
  _thisIsAUsedExpression(getter) {
  }
  static get $$name() {
    return hasOwn(this, "$name") && this.$name || // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwn(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.startConfigure.
   *
   * This is called by the Base class before setting configuration properties, but after
   * the active initial getters have been set, so all configurations are available.
   *
   * This method allows all classes in the hierarchy to force some configs to be evaluated before others.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  startConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.
   *
   * This is called by the Base class before exiting the {@link #function-configure} method.
   *
   * At this point, all configs have been applied, but the `isConfiguring` property is still set.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * into the config phase.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  finishConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been
   * called. At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @category Lifecycle
   */
  afterConfigure() {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.
   *
   * This is called by the Base class after the {@link #function-construct} method has been
   * called.
   *
   * At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @function afterConstruct
   * @category Lifecycle
   */
  afterConstruct() {
  }
  /**
   * Provides a way of calling callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   *
   * If a named function is not found, an error is thrown. If the function should be only called when present,
   * and may not be present, add a `?` as a suffix.
   *
   * @param {String|Function} fn The function to call, or the name of the function to call.
   * @param {Object} thisObject The `this` object of the function.
   * @param {Object[]} args The argument list to pass.
   * @category Misc
   * @advanced
   */
  callback(fn, thisObject, args = emptyArray) {
    const { handler, thisObj } = this.resolveCallback(fn, thisObject === "this" ? this : thisObject) || emptyObject2;
    return handler == null ? void 0 : handler.apply(thisObj, args);
  }
  resolveProperty(propertyPath) {
    let thisObj = this;
    while (thisObj) {
      if (_Base.hasConfigPath(thisObj, propertyPath, true)) {
        return Objects.getPath(thisObj, propertyPath);
      }
      thisObj = thisObj.owner;
    }
    return void 0;
  }
  /**
   * Provides a way of locating callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   * @param {String|Function} handler The function to call, or the name of the function to call.
   * @param {Object} thisObj The `this` object of the function.
   * @param {Boolean} [enforceCallability = true] Pass `false` if the function may not exist, and a null return value is acceptable.
   * @returns {Object} `{ handler, thisObj }`
   * @category Misc
   * @advanced
   */
  resolveCallback(handler, thisObj = this, enforceCallability = true) {
    if (handler == null ? void 0 : handler.substring) {
      if (handler.endsWith("?")) {
        enforceCallability = false;
        handler = handler.substring(0, handler.length - 1);
      }
      if (handler.startsWith("up.")) {
        handler = handler.substring(3);
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner)
          ;
        if (!thisObj) {
          return;
        }
      } else if (handler.startsWith("this.")) {
        handler = handler.substring(5);
        thisObj = this;
      }
      if (!thisObj || !(thisObj instanceof Object)) {
        return;
      }
      handler = thisObj[handler];
    }
    if (typeof handler === "function") {
      return { handler, thisObj };
    }
    if (enforceCallability) {
      throw new Error(`No method named ${handler} on ${thisObj.$$name || "thisObj object"}`);
    }
  }
  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const { handler, thisObj } = this.resolveCallback(inHandler, inThisObj);
      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  /**
   * Delays the execution of the passed function by the passed time quantum, or if the time is omitted
   * or not a number, delays until the next animation frame. Note that this will use
   * {@link Core.mixin.Delayable#function-setTimeout} || {@link Core.mixin.Delayable#function-requestAnimationFrame}
   * if this class mixes in `Delayable`, otherwise it uses the global methods. The function will
   * be called using `this` object as its execution scope.
   * @param {Function} fn The function to call on a delay.
   * @param {Number} [delay] The number of milliseconds to delay.
   * @param {String} [name] The name of delay
   * @returns {Number} The created timeout id.
   * @private
   */
  delay(fn, delay, name = fn.name || fn) {
    fn = this.setTimeout ? fn : fn.bind(this);
    const invoker = this.setTimeout ? this : globalThis;
    return invoker[typeof delay === "number" ? "setTimeout" : "requestAnimationFrame"](fn, delay, name);
  }
  /**
   * Classes implement this method to provide custom cleanup logic before calling `super.doDestroy()`. The general
   * pattern is as follows:
   *
   * ```javascript
   *  class Foo extends Base {
   *      doDestroy() {
   *          // perform custom cleanup
   *
   *          super.doDestroy();
   *      }
   *  }
   * ```
   *
   * This method is called by {@link #function-destroy} which also prevents multiple calls from reaching `doDestroy`.
   * Prior to calling `doDestroy`, {@link #property-isDestroying} is set to `true`. Upon return, the object is fully
   * destructed and {@link #property-isDestroyed} is set to `true`.
   *
   * Do not call this method directly. Instead call {@link #function-destroy}.
   * @category Lifecycle
   * @advanced
   */
  doDestroy() {
    const me = this, { nullify } = me.$meta;
    if (nullify) {
      for (let i = 0; i < nullify.length; ++i) {
        if (me[nullify[i].field] != null) {
          me[nullify[i].name] = null;
        }
      }
    }
  }
  /**
   * Destroys the named properties if they have been initialized, and if they have a `destroy` method.
   * Deletes the property from this object. For example:
   *
   *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');
   *
   * @param {String} properties The names of the properties to destroy.
   * @internal
   * @category Lifecycle
   */
  destroyProperties(...properties) {
    var _a4, _b;
    const me = this;
    let key;
    for (key of properties) {
      if (key in me && (!me[configuringSymbol2] || !me[configuringSymbol2][key])) {
        (_b = (_a4 = me[key]) == null ? void 0 : _a4.destroy) == null ? void 0 : _b.call(_a4);
        delete me[key];
      }
    }
  }
  /**
   * Called by the Base constructor to apply configs to this instance. This must not be called.
   * @param {Object} config The configuration object from which instance properties are initialized.
   * @private
   * @category Lifecycle
   */
  configure(config = {}) {
    const me = this, meta = me.$meta, { beforeConfigure } = config, configs = meta.configs, fullConfig = me.getDefaultConfiguration();
    let cfg, key, value;
    me.initialConfig = config;
    me.isConfiguring = true;
    Object.assign(me, me.getProperties());
    for (key in config) {
      value = config[key];
      cfg = configs[key];
      fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;
    }
    if (beforeConfigure) {
      delete fullConfig.beforeConfigure;
      beforeConfigure(me, fullConfig);
    }
    me.setConfig(me[originalConfigSymbol] = fullConfig, true);
    me.isConfiguring = false;
  }
  /**
   * Returns the value of the specified config property. This is a method to allow
   * property getters to be explicitly called in a way that does not get optimized out.
   *
   * The following triggers the getter call, but optimizers will remove it:
   *
   *      inst.foo;   // also raises "expression has no side-effects" warning
   *
   * Instead, do the following to trigger a getter:
   *
   *      inst.getConfig('foo');
   *
   * @param {String} name
   * @internal
   * @category Configuration
   */
  getConfig(name) {
    return this[name];
  }
  /**
   * Sets configuration options this object with all the properties passed in the parameter object.
   * Timing is taken care of. If the setter of one config is called first, and references
   * the value of another config which has not yet been set, that config will be set just
   * in time, and the *new* value will be used.
   * @param {Object} config An object containing configurations to change.
   * @category Lifecycle
   * @advanced
   */
  setConfig(config, isConstructing) {
    var _a4;
    const me = this, wasConfiguring = me[configuringSymbol2], configDone = wasConfiguring ? me.configDone : me.configDone = {}, configs = me.$meta.configs, pendingLazy = me[lazyConfigsSymbol];
    let cfg, key;
    me[instancePropertiesSymbol2] = {};
    me[configuringSymbol2] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;
    for (key in config) {
      if (config[key] != null || hasOwn(config, key)) {
        cfg = configs[key] || Config.get(key);
        if (!(pendingLazy == null ? void 0 : pendingLazy.has(key))) {
          cfg.defineInitter(me, config[key]);
        }
        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }
    if (isConstructing) {
      me.startConfigure(config);
    }
    for (key in config) {
      if (!configDone[key] && !(isConstructing && ((_a4 = configs[key]) == null ? void 0 : _a4.lazy))) {
        me[key] = config[key];
      }
    }
    if (wasConfiguring) {
      me[configuringSymbol2] = wasConfiguring;
    } else {
      delete me[configuringSymbol2];
    }
    if (isConstructing) {
      me.finishConfigure(config);
    }
    return me;
  }
  /**
   * Returns `true` if this instance has a non-null value for the specified config. This will not activate a lazy
   * config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  hasConfig(name) {
    var _a4;
    const me = this, config = me[configuringSymbol2];
    return Boolean(
      me["_" + name] != null || // value has been assigned to backing property
      ((_a4 = me[lazyConfigsSymbol]) == null ? void 0 : _a4.get(name)) != null || // a lazy value is pending
      // config value has not been assigned but will be
      !me.configDone[name] && config && (config[name] != null || hasOwn(config, name))
    );
  }
  /**
   * Determines if the specified config property exists in an instance of {@link Core.Base}
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean}
   * @internal
   */
  static hasConfigPath(object, path) {
    return path.split(".").every((key) => {
      var _a4, _b, _c;
      const config = (_b = (_a4 = object == null ? void 0 : object.$meta) == null ? void 0 : _a4.configs) == null ? void 0 : _b[key], isConfig = config && config.descriptor.get === ((_c = Objects.getPropertyDescriptor(object, key)) == null ? void 0 : _c.get);
      if (isConfig ? object.hasConfig(key) : key in object) {
        object = object[key];
        return Object !== void 0;
      }
      return false;
    });
  }
  /**
   * Returns the value of an uningested config *without* ingesting the config or transforming
   * it from its raw value using its `changeXxxxx` method.
   *
   * @param {String} name The name of the config property.
   * @returns {*} The raw incoming config value.
   * @internal
   */
  peekConfig(name) {
    const me = this, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2];
    if (lazyConfig == null ? void 0 : lazyConfig.has(name)) {
      return lazyConfig.get(name);
    }
    if (config && name in config) {
      if (me.configDone[name]) {
        return me[name];
      }
      if (config[name] != null || hasOwn(config, name)) {
        return config[name];
      }
    }
  }
  /**
   * Ensures that the specified config is initialized if it is needed. If there is a config value specified, and it
   * was initialized by this call, this method returns `true`. If there was a config value specified, and it was
   * already initialized, this method returns `false`. If there was no value specified for the given config, this
   * method returns `null`.
   *
   * This is not the same as just reading the property, because some property getters exist that do not actually just
   * read the config value back, but instead produce some result. Reading such properties to incidentally trigger a
   * possible config initializer can lead to incorrect results. For example, the Combo items config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  triggerConfig(name) {
    const me = this, { configDone } = me, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2], triggered = (lazyConfig == null ? void 0 : lazyConfig.has(name)) || config && (config[name] != null || hasOwn(config, name)) ? !configDone[name] : null;
    if (triggered) {
      me.getConfig(name);
    }
    return triggered;
  }
  /**
   * This call will activate any pending {@link Core.Config#config-lazy} configs that were assigned a string value
   * equal to the `group` parameter.
   *
   * @param {String} group The config property group as defined by a matching {@link Core.Config#config-lazy} value.
   * @returns {String[]} The names of any configs triggered by this call or `null` if no configs were triggered.
   * @internal
   */
  triggerConfigs(group) {
    const me = this, configs = me.$meta.configs, lazyConfigs = me[lazyConfigsSymbol], triggered = lazyConfigs ? [...lazyConfigs.keys()].filter((k) => configs[k].lazy === group) : emptyArray;
    for (const key of triggered) {
      me.triggerConfig(key);
    }
    return triggered.length ? triggered : null;
  }
  onConfigChange() {
  }
  // declared above because lint/IDE get angry about not declaring the args...
  /**
   * This method is called when any config changes.
   * @param {Object} info Object containing information regarding the config change.
   * @param {String} info.name The name of the config that changed.
   * @param {*} info.value The new value of the config.
   * @param {*} info.was The previous value of the config.
   * @param {Core.Config} info.config The `Config` object for the changed config property.
   * @method onConfigChange
   * @internal
   * @category Configuration
   */
  /**
   * Returns a *copy* of the full configuration which was used to configure this object.
   * @property {Object}
   * @category Lifecycle
   * @readonly
   * @advanced
   */
  get config() {
    const result = {}, myConfig = this[originalConfigSymbol];
    for (const key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }
  // region Extract config
  static processConfigValue(currentValue, options) {
    if (currentValue === globalThis) {
      return globalThis;
    } else if (Array.isArray(currentValue)) {
      return currentValue.map((v) => _Base.processConfigValue(v, options));
    } else if (currentValue instanceof _Base) {
      if (options.visited.has(currentValue)) {
        return;
      }
      return currentValue.getCurrentConfig(options);
    } else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {
      return null;
    } else if (Objects.isObject(currentValue)) {
      const result = {};
      for (const key in currentValue) {
        if (key !== "owner") {
          result[key] = _Base.processConfigValue(currentValue[key], options);
        }
      }
      return result;
    }
    return currentValue;
  }
  // Recursively get the value of a config. Only intended to be called by getCurrentConfig()
  getConfigValue(name, options) {
    var _a4;
    const me = this, lazyConfigs = me[lazyConfigsSymbol];
    if (!((_a4 = me.$meta.configs[name]) == null ? void 0 : _a4.lazy)) {
      return _Base.processConfigValue(me[name], options);
    }
    if (lazyConfigs == null ? void 0 : lazyConfigs.has(name)) {
      return _Base.processConfigValue(lazyConfigs.get(name), options);
    }
  }
  // Allows removing / adding configs before values are extracted
  preProcessCurrentConfigs() {
  }
  // Extract the current values for all initially used configs, in a format that can be used to create a new instance.
  // Not intended to be called by any other code than getConfigString()
  getCurrentConfig(options = {}) {
    const me = this, configs = options.configs === "all" ? me.config : Objects.clone(me.initialConfig), skip = options.skip || {}, visited = options.visited || (options.visited = /* @__PURE__ */ new Set()), depth = options.depth || (options.depth = 0), result = {};
    if (visited.has(me)) {
      return void 0;
    }
    visited.add(me);
    this.preProcessCurrentConfigs(configs);
    for (const name in configs) {
      if (skip[name]) {
        continue;
      }
      const value = me.getConfigValue(name, { ...options, depth: depth + 1 });
      if (value !== void 0) {
        result[name] = value;
      }
    }
    return result;
  }
  // Extract the current values for all initially used configs and convert them to a JavaScript string
  getConfigString(options = {}) {
    return StringHelper.toJavaScriptString(this.getCurrentConfig(options));
  }
  // Experimental helper function, extracts the currently used configs and wraps them as an app, returning code as a
  // string.
  //
  // This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
  //
  getTestCase(options = {}) {
    const Product = this.isGantt ? "Gantt" : this.isSchedulerPro ? "SchedulerPro" : this.isCalendar ? "Calendar" : this.isScheduler ? "Scheduler" : this.isGrid ? "Grid" : this.isTaskBoard ? "TaskBoard" : null;
    if (Product) {
      const product = Product.toLowerCase(), bundlePath = `../../build/${product}.module.js`;
      let preamble, postamble;
      if (options.import === "static") {
        preamble = `import * as module from "${bundlePath}";Object.assign(window, module);`;
        postamble = "";
      } else {
        preamble = `import("${bundlePath}").then(module => { Object.assign(window, module);
`;
        postamble = "});";
      }
      const version = VersionHelper.getVersion(product);
      if (version) {
        preamble += `
console.log('${Product} ${version}');
`;
      }
      return `${preamble}      
const ${product} = new ${Product}(${this.getConfigString(options)});
${postamble}`;
    }
  }
  /**
   * Experimental helper function, extracts the currently used configs and wraps them as an app, downloading the
   * resulting JS file.
   *
   * This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
   * @category Misc
   */
  downloadTestCase(options = {}) {
    options.output = "return";
    const app = this.getTestCase(options);
    BrowserHelper.download(`app.js`, "data:application/javascript;charset=utf-8," + escape(app));
  }
  //endregion
  /**
   * Registers this class type with its Factory
   * @category Misc
   * @advanced
   */
  static initClass() {
    return this.$meta.class;
  }
  /**
   * The class's {@link #property-$meta-static meta} object.
   * @member {Object} $meta
   * @internal
   * @category Misc
   */
  /**
   * An object owned by this class that does not share properties with its super class.
   *
   * This object may contain other properties which are added as needed and are not documented here.
   *
   * @property {Object} $meta The class meta object.
   * @property {Function} $meta.class The class constructor that owns the meta object.
   * @property {Object} $meta.super The `$meta` object for the super class. This is `null` for `Base`.
   * @property {Object} $meta.config The object holding the default configuration values for this class.
   * @property {Object} $meta.configs An object keyed by config name that holds the defined configs for the class.
   * The value of each property is a {@link Core/Config} instance.
   * @property {Boolean} $meta.forkConfigs This will be `true` if the default configuration values for this class
   * (in the `config` property of the meta object) must be forked to avoid object sharing, or if the object can be
   * passed to `Object.create()` for efficiency.
   * @property {Function[]} $meta.hierarchy The array of classes in the ancestry of this class. This will start with
   * `Base` at index 0 and ends with this class.
   * @property {Function[]} $meta.properties The array of classes that define a "static get properties()" getter.
   * @internal
   * @static
   * @category Misc
   */
  static get $meta() {
    if (!hasOwn(this, metaSymbol)) {
      const meta = this[metaSymbol] = new MetaClass();
      meta.class = this;
      this.setupClass(meta);
      return meta;
    }
    return this[metaSymbol];
  }
  /**
   * This optional class method is called when a class is mixed in using the {@link #function-mixin-static mixin()}
   * method.
   * @internal
   */
  static onClassMixedIn() {
  }
  /**
   * Returns the merge of the `baseConfig` and `config` config objects based on the configs defined by this class.
   * @param {Object} baseConfig The base config or defaults.
   * @param {...Object} configs One or more config objects that takes priority over `baseConfig`.
   * @returns {Object}
   * @internal
   */
  static mergeConfigs(baseConfig, ...configs) {
    const classConfigs = this.$meta.configs, result = Objects.clone(baseConfig) || {};
    let config, i, key, value;
    for (i = 0; i < configs.length; ++i) {
      config = configs[i];
      if (config) {
        for (key in config) {
          value = config[key];
          if (classConfigs[key]) {
            value = classConfigs[key].merge(value, result[key]);
          } else if (result[key] && value) {
            value = Config.merge(value, result[key]);
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  /**
   * Applies one or more `mixins` to this class and returns the produced class constructor.
   *
   * For example, instead of writing this:
   * ```
   *  class A extends Delayable(Events(Localizable(Base))) {
   *      // ...
   *  }
   * ```
   *
   * Using this method, one would write this:
   * ```
   *  class A extends Base.mixin(Localizable, Events, Delayable) {
   *      // ...
   *  }
   * ```
   * If one of the mixins specified has already been mixed into the class, it will be ignored and not mixed in a
   * second time.
   * @param {...Function} mixins
   * @returns {Function}
   * @category Misc
   * @advanced
   */
  static mixin(...mixins) {
    let C = this, i;
    for (i = 0; i < mixins.length; ++i) {
      const mixin = mixins[i], tag = mixin[mixinTagSymbol] || (mixin[mixinTagSymbol] = Symbol("mixinTag"));
      if (C[tag]) {
        continue;
      }
      C = mixin(C);
      C[tag] = true;
      if (hasOwn(C, "onClassMixedIn")) {
        C.onClassMixedIn();
      }
    }
    return C;
  }
  /**
   * This method is called only once for any class. This can occur when the first instance is created or when the
   * `$meta` object is first requested.
   * @param {Object} meta The `$meta` object for the class.
   * @internal
   * @category Misc
   */
  static setupClass(meta) {
    var _a4;
    const cls = meta.class, base = getPrototypeOf(cls).$meta, name = cls.$$name, names = base.names, proto3 = cls.prototype;
    defineProperty2(proto3, "$meta", {
      value: meta
    });
    Object.assign(meta, {
      super: base,
      config: Object.create(base.config),
      configs: Object.create(base.configs),
      declarables: base.declarables,
      forkConfigs: base.forkConfigs,
      hierarchy: Object.freeze([...base.hierarchy, cls]),
      names: names.includes(name) ? names : Object.freeze([...names, name]),
      properties: base.properties,
      nullify: (_a4 = base.nullify) == null ? void 0 : _a4.slice()
    });
    if (names !== meta.names) {
      const isName = `is${name}`, defineIsProperty = (obj) => {
        if (!hasOwn(obj, isName)) {
          defineProperty2(obj, isName, {
            get() {
              return true;
            }
          });
        }
      };
      defineIsProperty(proto3);
      defineIsProperty(cls);
    }
    for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {
      decl = meta.declarables[i];
      if (hasOwn(cls, decl)) {
        setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);
        cls[setupName](cls, meta);
      }
    }
  }
  /**
   * This method is called as part of `setupClass()`. It will process the `configurable()` return object and the
   * `defaultConfig` return object.
   * @param {Object} meta The `meta` object for this class.
   * @param {Object} configs The config definition object.
   * @param {Boolean} simple `true` when processing `defaultConfig` and `false` when processing `configurable`.
   * @private
   * @category Configuration
   */
  static setupConfigs(meta, configs, simple) {
    const classConfigValues = meta.config, classConfigs = meta.configs, cls = meta.class, superMeta = meta.super;
    let { nullify } = meta, cfg, defaultValue2, options, setDefault, value, wasNullify;
    for (const name in configs) {
      value = configs[name];
      if (simple) {
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, defaultConfigOptions);
        } else {
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
      } else {
        defaultValue2 = options = setDefault = void 0;
        if (value && typeof value === "object" && "$config" in value) {
          options = value.$config;
          if (options && !Objects.isObject(options)) {
            options = Objects.createTruthyKeys(options);
          }
          setDefault = "default" in value;
          defaultValue2 = setDefault ? value.default : defaultValue2;
          value = value.value;
        }
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, options);
          cfg.define(cls.prototype);
          setDefault = !(cfg.field in cls.prototype);
          wasNullify = false;
        } else {
          wasNullify = cfg.nullify;
          if (options) {
            cfg = cfg.extend(options);
          }
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        if (setDefault) {
          cfg.setDefault(cls, defaultValue2);
        }
        if (cfg.nullify && !wasNullify) {
          (nullify || (nullify = meta.nullify || (meta.nullify = []))).push(cfg);
        }
      }
      if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {
        meta.forkConfigs = true;
      }
      classConfigs[name] = cfg;
      classConfigValues[name] = value;
    }
  }
  static setupConfigurable(cls, meta) {
    cls.setupConfigs(meta, cls.configurable, false);
  }
  static setupDefaultConfig(cls, meta) {
    cls.setupConfigs(meta, cls.defaultConfig, true);
  }
  static setupDeclarable(cls, meta) {
    const declarable = cls.declarable;
    let all = meta.declarables, forked, i;
    for (i = 0; i < declarable.length; ++i) {
      if (!all.includes(declarable[i])) {
        if (!forked) {
          meta.declarables = forked = all = all.slice();
        }
        all.push(declarable[i]);
      }
    }
  }
  static setupProperties(cls, meta) {
    meta.properties = meta.super.properties.slice();
    meta.properties.push(cls);
    Object.freeze(meta.properties);
  }
  static setupPrototypeProperties(cls) {
    Object.assign(cls.prototype, cls.prototypeProperties);
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  static getDefaultConfiguration() {
    const meta = this.$meta, config = meta.forkConfigs ? _Base.fork(meta.config) : Object.create(meta.config);
    if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv && config.testConfig && globalThis.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }
    return config;
  }
  static fork(obj) {
    let ret = obj, key, value;
    if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {
      ret = Object.create(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (Objects.isObject(value)) {
            ret[key] = _Base.fork(value);
          } else if (Array.isArray(value)) {
            ret[key] = value.slice();
          }
        }
      }
    }
    return ret;
  }
  /**
   * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getProperties() {
    const hierarchy = this.$meta.properties, result = {};
    for (let i = 0; i < hierarchy.length; i++) {
      const desc = Object.getOwnPropertyDescriptor(hierarchy[i], "properties");
      Object.assign(result, desc.get !== void 0 ? hierarchy[i].properties : Objects.clone(desc.value));
    }
    return result;
  }
  static get superclass() {
    return getPrototypeOf(this);
  }
  /**
   * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object
   * starting from the `topClass` class (which defaults to `Base`).
   *
   * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`
   * @param {Function} [topClass] The topmost class constructor to start from.
   * @returns {Function[]} The class hierarchy of this instance.
   * @private
   * @category Configuration
   */
  classHierarchy(topClass) {
    const hierarchy = this.$meta.hierarchy, index = topClass ? hierarchy.indexOf(topClass) : 0;
    return index > 0 ? hierarchy.slice(index) : hierarchy;
  }
  /**
   * Checks if an obj is of type using object's $$name property and doing string comparison of the property with the
   * type parameter.
   *
   * @param {String} type
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  static isOfTypeName(type) {
    return this.$meta.names.includes(type);
  }
  /**
   * Removes all event listeners that were registered with the given `name`.
   * @param {String|Symbol} name The name of the event listeners to be removed.
   * @category Events
   * @advanced
   */
  detachListeners(name) {
    let detachers = this.$detachers;
    detachers = detachers == null ? void 0 : detachers[name];
    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }
  /**
   * Tracks a detacher function for the specified listener name.
   * @param {String} name The name assigned to the associated listeners.
   * @param {Function} detacher The detacher function.
   * @private
   */
  trackDetacher(name, detacher2) {
    const detachers = this.$detachers || (this.$detachers = {}), bucket = detachers[name] || (detachers[name] = []);
    bucket.push(detacher2);
  }
  /**
   * Removes all detacher functions for the specified `Events` object. This is called
   * by the `removeAllListeners` method on that object which is typically called by its
   * `destroy` invocation.
   * @param {Core.mixin.Events} eventer The `Events` instance to untrack.
   * @private
   */
  untrackDetachers(eventer) {
    const detachers = this.$detachers;
    if (detachers) {
      for (const name in detachers) {
        const bucket = detachers[name];
        for (let i = bucket.length; i-- > 0; ) {
          if (bucket[i].eventer === eventer) {
            bucket.splice(i, 1);
          }
        }
      }
    }
  }
};
var proto = Base.prototype;
proto.onConfigChange.$nullFn = emptyFn.$nullFn = true;
Base[metaSymbol] = proto.$meta = newMeta({
  class: Base,
  config: Object.freeze({}),
  configs: /* @__PURE__ */ Object.create(null),
  declarables: Base.declarable,
  forkConfigs: false,
  hierarchy: Object.freeze([Base]),
  names: Object.freeze(["Base"]),
  nullify: null,
  properties: Object.freeze([]),
  super: null
});
Object.assign(proto, {
  $detachers: null,
  configObserver: null,
  /**
   * This property is set to `true` before the `constructor` returns.
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isConstructing: true,
  /**
   * This property is set to `true` by {@link #function-destroy} after destruction.
   *
   * It is also one of the few properties that remains on the object after returning from `destroy()`. This property
   * is often checked in code paths that may encounter a destroyed object (like some event handlers) or in the
   * destruction path during cleanup.
   *
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   */
  isDestroyed: false,
  /**
   * This property is set to `true` on entry to the {@link #function-destroy} method. It remains on the objects after
   * returning from `destroy()`. If {@link #property-isDestroyed} is `true`, this property will also be `true`, so
   * there is no need to test for both (for example, `comp.isDestroying || comp.isDestroyed`).
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isDestroying: false
});
Base.emptyFn = emptyFn;
VersionHelper.setVersion("core", "5.6.11");
Base._$name = "Base";

// ../Core/lib/Core/helper/ArrayHelper.js
var ArrayHelper = class _ArrayHelper {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== void 0 && !(Array.isArray(item) && item.length === 0) && item !== "")
        res.push(item);
      return res;
    }, []);
  }
  /**
   * Similar to [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
   * this method creates an array from an `iterable` object. Where `Array.from()` accepts a mapper function as the
   * second argument, this method accepts a `filter` function as its second argument. If a mapper function is also
   * needed, it can be passed as the third argument. Unlike `Array.from()`, if this method is passed `null`, it will
   * return an empty array.
   * @param {Array} iterable The iterable object to convert (must support `for-of` loop iteration).
   * @param {Function} [filter] A function to apply to each item of the `iterable` which must return a truthy value
   * to include that item in the resulting array.
   * @param {Function} [map] A function to apply to each item of the `iterable` that returns the actual value to put
   * into the returned array. If a `filter` is also supplied, this method is only called for those items that pass
   * the filter test.
   * @returns {Array}
   */
  static from(iterable, filter, map) {
    const array = [];
    if (iterable) {
      for (const it of iterable) {
        if (!filter || filter(it)) {
          array.push(map ? map(it) : it);
        }
      }
    }
    return array;
  }
  /**
   * Remove one or more items from an array
   * @param {Array} array Array to remove from
   * @param {Object[]|Set} items One or more items to remove, or one Set containing items to remove
   * @returns {Boolean} Returns true if any item was removed
   */
  static remove(array, ...items2) {
    let index, item, removed = false;
    items2 = items2[0] instanceof Set ? [...items2[0]] : items2;
    for (let i = 0; i < items2.length; i++) {
      item = items2[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }
    return removed;
  }
  /**
   * Calculates the insertion index of a passed object into the passed Array according
   * to the passed comparator function. Note that the passed Array *MUST* already be ordered.
   * @param {Object} item The item to calculate the insertion index for.
   * @param {Array} array The array into which the item is to be inserted.
   * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.
   * @param {Object} comparatorFn.lhs The left object to compare.
   * @param {Object} comparatorFn.rhs The right object to compare.
   * @param {Number} index The possible correct index to try first before a binary
   * search is instigated.
   * @internal
   */
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return this.binarySearch(array, item, comparatorFn);
  }
  /**
   * Similar to the native `Array.find()` call, but this finds the *last* element in the array for which
   * the passed function returns a truthy value.
   * @param {Object[]} array The array to find in.
   * @param {Function} fn The testing function.
   * @param {Object} [thisObj] The scope (`this` reference) in which to call the function.
   */
  static findLast(array, fn, thisObj) {
    for (let { length } = array, i = length - 1; i >= 0; i--) {
      if (fn.call(thisObj, array[i], i, array)) {
        return array[i];
      }
    }
  }
  /**
   * This method returns the index that a given item would be inserted into the
   * given (sorted) `array`. Note that the given `item` may or may not be in the
   * array. This method will return the index of where the item *should* be.
   *
   * For example:
   *
   *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
   *      var index = ArrayHelper.binarySearch(array, 'E');
   *
   *      console.log('index: ' + index);
   *      // logs "index: 2"
   *
   *      array.splice(index, 0, 'E');
   *
   *      console.log('array : ' + array.join(''));
   *      // logs "array: ADEGKORX"
   *
   * @param {Object[]} array The array to search.
   * @param {Object} item The item that you want to insert into the `array`.
   * @param {Number} [begin=0] The first index in the `array` to consider.
   * @param {Number} [end=array.length] The index that marks the end of the range
   * to consider. The item at this index is *not* considered.
   * @param {Function} [compareFn] The comparison function that matches the sort
   * order of the `array`. The default `compareFn` compares items using less-than
   * and greater-than operators.
   * @returns {Number} The index for the given item in the given array based on
   * the passed `compareFn`.
   */
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }
    return begin;
  }
  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  /**
   * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with
   * clones of the supplied item.
   * @param {Number} count Number of entries to create
   * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)
   * @param {Function} [fn] An optional function that is called for each item added, to allow processing
   * @returns {Array} A new populated array
   */
  static fill(count, itemOrArray = {}, fn = null) {
    const result = [], items2 = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];
    for (let i = 0; i < count; i++) {
      for (const item of items2) {
        const processedItem = Object.assign({}, item);
        if (fn) {
          fn(processedItem, i);
        }
        result.push(processedItem);
      }
    }
    return result;
  }
  /**
   * Populates an array with the return value from `fn`.
   * @param {Number} count Number of entries to create
   * @param {Function} fn A function that is called `count` times, return value is added to array
   * @param {Number} fn.index Current index in the array
   * @privateparam {Boolean} [oneBased] Add 1 to the index before calling the fn (making it 1 based)
   * @returns {Array} A new populated array
   */
  static populate(count, fn, oneBased = false) {
    const items2 = [];
    for (let i = 0; i < count; i++) {
      items2.push(fn(i + (oneBased ? 1 : 0)));
    }
    return items2;
  }
  /**
   * Pushes `item` on to the `array` if not already included
   * @param {Array}  array Array to push to
   * @param {...Object} items Item(s) to push if not already included
   */
  static include(array, ...items2) {
    for (const item of items2) {
      if (!array.includes(item)) {
        array.push(item);
      }
    }
  }
  /**
   * Returns a new array with the unique items from the supplied array.
   * @param {Array} array Input array
   * @returns {Array} New array with unique items
   */
  static unique(array) {
    return [...new Set(array)];
  }
  // Kept for future reference : Wanted to create an indexer on Stores.
  static allowNegative(array) {
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== "string") {
          return Reflect.get(target, name, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }
        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== "string") {
          return Reflect.set(target, name, value, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }
        target[index < 0 ? target.length + index : index] = value;
        return true;
      }
    });
  }
  static delta(a, b, useRelativeNaming = false) {
    if (!b) {
      return useRelativeNaming ? { toAdd: a, toRemove: [], toKeep: [] } : { onlyInA: a, onlyInB: [], inBoth: [] };
    }
    const onlyInA = [], onlyInB = [], inBoth = /* @__PURE__ */ new Set(), bSet = new Set(b);
    for (let i = 0; i < a.length; i++) {
      const item = a[i];
      if (bSet.has(item)) {
        inBoth.add(item);
      } else {
        onlyInA.push(item);
      }
    }
    for (let i = 0; i < b.length; i++) {
      const item = b[i];
      if (!inBoth.has(item)) {
        onlyInB.push(item);
      }
    }
    if (useRelativeNaming) {
      return { toAdd: onlyInA, toRemove: onlyInB, toKeep: inBoth };
    }
    return { onlyInA, onlyInB, inBoth: [...inBoth] };
  }
  /**
   * Returns the passed object wrapped in an array. Special handling of the following cases:
   * * Passing an array returns it as is
   * * Passing a `Set` returns it converted to an Array
   * * Passing `null`/`undefined` returns the passed value
   *
   * ```javascript
   * const records = ArrayHelper.asArray(record);
   *
   * // { id : 1 } -> [{ id : 1 }]
   * // [{ id : 1 }] -> [{ id : 1 }]
   * ```
   *
   * @param {*} arrayOrObject
   * @returns {Array|null}
   * @internal
   */
  static asArray(arrayOrObject) {
    if (arrayOrObject == null) {
      return arrayOrObject;
    }
    if (arrayOrObject instanceof Set) {
      return Array.from(arrayOrObject);
    }
    return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];
  }
  /**
   * Identity function that returns its input.
   * @param {*} Any value
   * @returns {*} The input value
   * @internal
   */
  static identity(x) {
    return x;
  }
  /**
   * Transform an array into a key:value dictionary using the specified
   * key and value getters. Does not group values, so only one result will
   * appear in the output for a given key.
   *
   * ```javascript
   * const input = [{
   *     id: '1',
   *     other: 'one'
   * },{
   *     id: '2',
   *     other: 'two'
   * }];
   *
   * keyBy(input, rec => rec.id)
   *
   * // {
   * //    '1': { id: '1', other: 'one' },
   * //    '2': { id: '2', other: 'two' }
   * // }
   * ```
   *
   * @param {Array} array Array from which to build dictionary
   * @param {Function|String} getKey Function to produce the key for a given array entry, or a string property name to read
   * @param {Function} getValue Optional function to transform array elements. Defaults to returning the element itself
   * @returns {Object} A key->value dictionary with keys as returned by `getKey` and values returned by `getValue`
   * @internal
   */
  static keyBy(array, keyGetter, valueGetter = _ArrayHelper.identity) {
    const getKey = typeof keyGetter === "string" ? (o) => o == null ? void 0 : o[keyGetter] : keyGetter, getValue = typeof valueGetter === "string" ? (o) => o == null ? void 0 : o[valueGetter] : valueGetter;
    return array.reduce((dict, next) => {
      dict[getKey(next)] = getValue(next);
      return dict;
    }, {});
  }
  /**
   * Combines provided arrays of by aggregating their element values.
   * For example the below code sums up numeric elements of the arrays:
   *
   * ```javascript
   * ArrayHelper.aggregate(
   *     [
   *         [0,   1,  2, 33]
   *         [10,  1, -1],
   *         [100, 1, -1]
   *     ],
   *     entry => entry || 0, // "|| 0" here to make it work for different array sizes
   *     (aggregated, entry) => aggregated + entry, // aggregate by summing up
   *     () => 0 //initial value is zero
   * );
   *
   * // returns [111, 3, 0, 33] array
   * ```
   *
   * @param {Array[]} arrays Array to combine
   * @param {Function} getEntryValueFn Function that extracts an array entry for aggregating.
   * @param {Function} aggregatorFn A function to execute for each element in the arrays. It's purpose is to
   * aggregate the element value to the corresponding entry of the resulting array.
   * The function's return value becomes the value of the `aggregated` parameter on the next invocation of
   * `aggregatorFn`.
   * The function is called with the following arguments:
   *
   * @param {Object} aggregatorFn.aggregated Resulting array entry value. On the first call
   * `getInitialValueFn` result.
   * @param {Object} aggregatorFn.entry Current entry to aggregate into `aggregated`.
   * @param {Number} aggregatorFn.arrayIndex Index of current array (in the provided `arrays`).
   * @param {Object[]} aggregatorFn.entryIndex Index of the current entry.
   * @param {Object} aggregationContext A shared object providing extra aggregation call context.
   * @param {Function} getInitialValueFn Function that returns an initial value for the combined array entries.
   * @param {Object} [aggregationContext] Optional object that is passed to all of the above functions that can
   * be used for keeping some additional parameters used when aggregating.
   * Out of the box the object will contain `arrays` and `targetArray` properties containing
   * input and resulting arrays respectively.
   */
  static aggregate(arrays, getEntryValueFn, aggregatorFn, getInitialValueFn, aggregationContext = {}) {
    const rowLength = arrays.length, columnLength = arrays[0].length, result = [];
    aggregationContext.targetArray = result;
    aggregationContext.arrays = arrays;
    for (let colIndex = 0; colIndex < columnLength; colIndex++) {
      aggregationContext.entryIndex = colIndex;
      result.push(getInitialValueFn(colIndex, aggregationContext));
    }
    for (let rowIndex = 0; rowIndex < rowLength; rowIndex++) {
      const row = arrays[rowIndex];
      aggregationContext.rowIndex = rowIndex;
      for (let colIndex = 0; colIndex < columnLength; colIndex++) {
        aggregationContext.entryIndex = colIndex;
        const entryValue = getEntryValueFn(row[colIndex], aggregationContext);
        result[colIndex] = aggregatorFn(result[colIndex], entryValue, rowIndex, colIndex, aggregationContext);
      }
    }
    return result;
  }
  /**
   * Group an array by keys (either the values in a specified property name, or the results of a string-generating function accepting
   * an array entry as input), returning an Object with those keys, whose values are arrays containing the array entries that
   * produced that key.
   *
   * ```javascript
   * const input = [{
   *     id: 1,
   *     color: 'red'
   * },{
   *     id: 2,
   *     color: 'green'
   * },{
   *     id: 3,
   *     color: 'green'
   * }];
   *
   * groupBy(input, 'color')
   *
   * // {
   * //    'red': [ { id: '1', color: 'red' } ],
   * //    'green': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   *
   * groupBy(input, rec => rec.color?.substr(0, 1))
   *
   * // {
   * //    'r': [ { id: '1', color: 'red' } ],
   * //    'g': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   * ```
   *
   * @param {Object} array Array from which to build dictionary
   * @param {Function|String} getGroupKey Function to produce the key for a given array entry, or a string property name to read
   * @returns {Object} A key->value[] dictionary with keys as returned by `getKey` and arrays of matching items in original order as values
   * @internal
   */
  static groupBy(array, groupKeyGetter) {
    const getKey = typeof groupKeyGetter === "string" ? (o) => o == null ? void 0 : o[groupKeyGetter] : groupKeyGetter;
    return array.reduce((grouped, value) => {
      const key = getKey(value);
      (grouped[key] = grouped[key] || []).push(value);
      return grouped;
    }, {});
  }
  static groupByIndexed(array, getKey) {
    return array.reduce((grouped, value) => {
      const key = getKey(value);
      let existing = grouped.get(key);
      if (existing === void 0) {
        existing = /* @__PURE__ */ new Set();
        grouped.set(key, existing);
      }
      existing.add(value);
      return grouped;
    }, /* @__PURE__ */ new Map());
  }
};
ArrayHelper._$name = "ArrayHelper";

// ../Core/lib/Core/helper/FunctionHelper.js
var commaSepRe = /,\s*/;
var decompiledSym = Symbol("decompiled");
var fnRe1 = /^\s*(async\s+)?([a-z_]\w*)\s*=>([\s\S]+)$/i;
var fnRe2 = /^\s*(async\s*)?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)\s+=>([\s\S]+)$/i;
var fnRe3 = /^(\s*async)?(?:\s*function)?(?:\s*([a-z_]\w*))?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)([\s\S]+)$/i;
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
var FunctionHelper = class _FunctionHelper {
  /**
   * Inserts a function after the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', () => { console.log('after') });
   *
   *  instance.method();
   *  > method
   *  > after
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * The value returned by the original method is passed as the first argument to `fn` followed by all the arguments
   * passed by the caller.
   *
   * If `fn` returns a value (not `undefined`), that value is returned from the method call instead of the value
   * returned by the original method.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', (ret, x) => {
   *      console.log('after', ret, x);
   *      return x / 2;
   *  });
   *
   *  console.log(instance.method(50));
   *  > method 50
   *  > after 100 50
   *  > 25
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call after `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @param {Object} [options] Additional options
   * @param {Boolean} [options.return=true] Specify `false` to not include the return value of the hooked method as
   * the first argument to `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static after(object, method, fn, thisObj, options) {
    const named = typeof fn === "string", withReturn = (options == null ? void 0 : options.return) !== false, hook = (...args) => {
      const origResult = hook.$nextHook.call(object, ...args), hookResult = (thisObj == null ? void 0 : thisObj.isDestroyed) ? void 0 : withReturn ? named ? thisObj[fn](origResult, ...args) : fn.call(thisObj, origResult, ...args) : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
      return hookResult === void 0 ? origResult : hookResult;
    };
    return _FunctionHelper.hookMethod(object, method, hook);
  }
  /**
   * Inserts a function before the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', () => { console.log('before') });
   *
   *  instance.method();
   *  > before
   *  > method
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * If `fn` returns `false`, the original method is not invoked and `false` is returned to the caller.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2;
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', x => {
   *      console.log('before', x);
   *      return false;
   *  });
   *
   *  console.log(instance.method(50));
   *  > before 50
   *  > false
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call before `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static before(object, method, fn, thisObj) {
    const named = typeof fn === "string", hook = (...args) => {
      const ret = (thisObj == null ? void 0 : thisObj.isDestroyed) ? 0 : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
      return ret === false ? ret : hook.$nextHook.call(object, ...args);
    };
    return _FunctionHelper.hookMethod(object, method, hook);
  }
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }
  static bindAll(obj) {
    for (const key in obj) {
      if (typeof obj[key] === "function") {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  /**
   * Returns a function which calls the passed `interceptor` function first, and the passed `original` after
   * as long as the `interceptor` does not return `false`.
   * @param {Function} original The function to call second.
   * @param {Function} interceptor The function to call first.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the return value from the `original` function **if it was called**, else `false`.
   */
  static createInterceptor(original, interceptor, thisObj) {
    return function(...args) {
      const theThis = thisObj || this;
      if (interceptor.call(theThis, ...args) !== false) {
        return original.call(theThis, ...args);
      }
      return false;
    };
  }
  /**
   * Returns a function which calls the passed `sequence` function after calling
   * the passed `original`.
   * @param {Function} original The function to call first.
   * @param {Function} sequence The function to call second.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the value returned from the sequence if it returned a value, else the return
   * value from the original function.
   */
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args), sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [extraArgs] The argument list to append to those passed to the function.
   * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
   * @returns {Function} A function which calls the passed `fn` only if at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createThrottled(fn, buffer, thisObj, extraArgs, alt2) {
    let lastCallTime = -Number.MAX_VALUE, callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn.apply(thisObj, callArgs);
    }, result = function(...args) {
      const elapsed = performance.now() - lastCallTime;
      callArgs = args;
      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }
        if (alt2) {
          callArgs.push.apply(callArgs, extraArgs);
          alt2.apply(thisObj, callArgs);
        }
      }
    };
    result.cancel = () => clearTimeout(timerId);
    return result;
  }
  /**
   * Create a "debounced" function which will call on the "trailing edge" of a timer period.
   * When first invoked will wait until the buffer period has expired to call the function, and
   * more calls within that time will restart the timer.
   *
   * This is useful for responding to keystrokes, but deferring action until the user pauses typing.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [args] The argument list to append to those passed to the function.
   * @returns {Function} A function which calls the passed `fn` when at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createBuffered(fn, buffer, thisObj, args) {
    let callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      result.isPending = false;
      callArgs.push.apply(callArgs, args);
      fn.apply(thisObj, callArgs);
    }, result = function(...args2) {
      callArgs = args2;
      if (timerId) {
        clearTimeout(timerId);
      }
      result.isPending = true;
      timerId = setTimeout(invoke, buffer);
    };
    result.cancel = () => {
      result.isPending = false;
      clearTimeout(timerId);
    };
    return result;
  }
  static decompile(fn) {
    if (!(decompiledSym in fn)) {
      const code = fn.toString();
      let m = fnRe1.exec(code), args, body, name, decompiled, t;
      if (m) {
        args = [m[2]];
        body = m[3];
      } else if (m = fnRe2.exec(code)) {
        t = m[2].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[3];
      } else if (m = fnRe3.exec(code)) {
        name = m[2];
        t = m[3].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[4];
      }
      body = body == null ? void 0 : body.trim();
      fn[decompiledSym] = decompiled = m && {
        args,
        async: Boolean(m[1]),
        body: (body == null ? void 0 : body.startsWith("{")) ? body.substring(1, body.length - 1).trim() : body
      };
      if (name) {
        decompiled.name = name;
      }
    }
    return fn[decompiledSym];
  }
  static hookMethod(object, method, hook) {
    hook.$nextHook = object[method];
    object[method] = hook;
    return () => {
      var _a4;
      if (hasOwnProperty4.call(object, method)) {
        let f = object[method], next;
        if (f === hook) {
          if (((_a4 = Object.getPrototypeOf(object)) == null ? void 0 : _a4[method]) === hook.$nextHook) {
            delete object[method];
          } else {
            object[method] = hook.$nextHook;
          }
        } else {
          for (; next = f == null ? void 0 : f.$nextHook; f = next) {
            if (next === hook) {
              f.$nextHook = hook.$nextHook;
              break;
            }
          }
        }
      }
    };
  }
  /**
   * Protects the specified `method` on a given `object` such that calling it will not throw exceptions.
   * @param {Object} object The object whose method is to be protected.
   * @param {String} method The name of the method to protect.
   * @param {Function} [handler] An optional function to call for any thrown exceptions.
   * @internal
   */
  static noThrow(object, method, handler) {
    const fn = object[method];
    object[method] = (...args) => {
      try {
        return fn.apply(object, args);
      } catch (e) {
        return handler == null ? void 0 : handler(e);
      }
    };
  }
  static returnTrue() {
    return true;
  }
  static animate(duration, fn, thisObj, easing = "linear") {
    let cancel = false;
    const result = new Promise((resolve) => {
      const start = performance.now(), iterate = () => {
        const progress = Math.min((performance.now() - start) / duration, 1), delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;
        if (!cancel) {
          if (fn.call(thisObj, this.easingFunctions[easing](progress)) === false) {
            resolve();
          }
        }
        if (cancel || progress === 1) {
          delayable.requestAnimationFrame(() => resolve());
        } else {
          delayable.requestAnimationFrame(iterate);
        }
      };
      iterate();
    });
    result.cancel = () => {
      cancel = true;
      result.cancelled = true;
      return false;
    };
    return result;
  }
};
var half = 0.5;
var e1 = 1.70158;
var e2 = 7.5625;
var e3 = 1.525;
var e4 = 2 / 2.75;
var e5 = 2.25 / 2.75;
var e6 = 1 / 2.75;
var e7 = 1.5 / 2.75;
var e8 = 2.5 / 2.75;
var e9 = 2.625 / 2.75;
var e10 = 0.75;
var e11 = 0.9375;
var e12 = 0.984375;
var s1 = 1.70158;
var s2 = 1.70158;
FunctionHelper.easingFunctions = {
  linear: (t) => t,
  easeInQuad: (t) => Math.pow(t, 2),
  easeOutQuad: (t) => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: (t) => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: (t) => Math.pow(t, 3),
  easeOutCubic: (t) => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: (t) => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: (t) => Math.pow(t, 4),
  easeOutQuart: (t) => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: (t) => Math.pow(t, 5),
  easeOutQuint: (t) => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: (t) => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: (t) => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: (t) => t * t * ((e1 + 1) * t - e1),
  easeOutBack: (t) => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: (t) => {
    let v1 = s1;
    return (t /= half) < 1 ? half * (t * t * (((v1 *= e3) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= e3) + 1) * t + v1) + 2);
  },
  elastic: (t) => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: (t) => {
    let v2 = s2;
    return (t /= half) < 1 ? half * (t * t * (((v2 *= e3) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= e3) + 1) * t + v2) + 2);
  },
  swingFrom: (t) => t * t * ((e1 + 1) * t - e1),
  swingTo: (t) => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: (t) => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: (t) => Math.pow(t, 4),
  easeTo: (t) => Math.pow(t, 0.25)
};
FunctionHelper._$name = "FunctionHelper";

// ../Core/lib/Core/mixin/Events.js
var { isArray } = Array;
var { hasOwnProperty: hasOwnProperty5 } = Object.prototype;
var specialProperties = {
  thisObj: 1,
  detachable: 1,
  once: 1,
  detacher: 1,
  prio: 1,
  args: 1,
  expires: 1,
  buffer: 1,
  throttle: 1,
  name: 1,
  $internal: 1
};
var priorityComparator = (a, b) => b.prio - a.prio;
var Events_default = (Target) => class Events extends (Target || Base) {
  constructor() {
    super(...arguments);
    __publicField(this, "eventsSuspended", null);
  }
  static get $name() {
    return "Events";
  }
  //region Events
  /**
   * Fires before an object is destroyed.
   * @event beforeDestroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when an object is destroyed.
   * @event destroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when any other event is fired from the object.
   *
   * **Note**: `catchAll` is fired for both public and private events. Please rely on the public events only.
   * @event catchAll
   * @param {Object} event The Object that contains event details
   * @param {String} event.type The type of the event which is caught by the listener
   * @typings event -> {{[key: string]: any, type: string}}
   */
  //endregion
  static get declarable() {
    return [
      /**
       * The list of deprecated events as an object, where `key` is an event name which is deprecated and
       * `value` is an object which contains values for
       * {@link Core.helper.VersionHelper#function-deprecate-static VersionHelper}:
       * - product {String} The name of the product;
       * - invalidAsOfVersion {String} The version where the offending code is invalid (when any compatibility
       *   layer is actually removed);
       * - message {String} Warning message to show to the developer using a deprecated API;
       *
       * For example:
       *
       * ```javascript
       * return {
       *     click : {
       *         product            : 'Grid',
       *         invalidAsOfVersion : '1.0.0',
       *         message            : 'click is deprecated!'
       *     }
       * }
       * ```
       *
       * @name deprecatedEvents
       * @returns {Object}
       * @static
       * @internal
       */
      "deprecatedEvents"
    ];
  }
  static setupDeprecatedEvents(cls, meta) {
    const all = meta.getInherited("deprecatedEvents"), add = cls.deprecatedEvents;
    for (const eventName in add) {
      all[eventName.toLowerCase()] = all[eventName] = add[eventName];
    }
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Set to true to call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       *
       * @config {Boolean} callOnFunctions
       * @category Misc
       * @default false
       */
      /**
       * The listener set for this object.
       *
       * An object whose property names are the names of events to handle, or options which modifiy
       * __how__ the handlers are called.
       *
       * See {@link #function-addListener} for details about the options.
       *
       * Listeners can be specified in target class config and they will be merged with any listeners specified in
       * the instantiation config. Class listeners will be fired first:
       *
       * ```javascript
       * class MyStore extends Store({
       *     static get configurable() {
       *         return {
       *             listeners : {
       *                 myCustomEvent() {
       *                 },
       *                 load : {
       *                     prio : 10000,
       *                     fn() { // this load listener handles things first }
       *                 }
       *             }
       *         }
       *     }
       * });
       *
       * let store = new MyStore({
       *   listeners: {
       *     load: () => { // This load listener runs after the class's },
       *     ...
       *   }
       * });
       * ```
       *
       * ### Handlers as function name
       *
       * Object event handlers may be specified as a function __name__. If a string is specified, it is the name
       * of the function in the `thisObj` object.
       *
       * If the string begins with `up.`, this object's ownership hierarchy
       * (if present) is scanned for an object which implements that function name:
       *
       * ```javascript
       * new Popup({
       *     tbar : {
       *         items : {
       *             myCombo : {
       *                 type      : 'combo',
       *                 editable  : false,
       *                 label     : 'Type',
       *                 listeners : {
       *                     // Look in owner chain for this function name
       *                     change : 'up.onFilterChange'
       *                 },
       *                 items     : [
       *                     'Event',
       *                     'Task',
       *                     'Appointment'
       *                 ]
       *             }
       *         }
       *     },
       *     items : {
       *         ...
       *     },
       *     onFilterChange({ value }) {
       *         // Handle event type selection here
       *     }
       * });
       *```
       *
       * @config {Object}
       * @category Common
       */
      listeners: {
        value: null,
        $config: {
          merge(newValue, currentValue) {
            if (newValue !== null) {
              if (!newValue) {
                return currentValue;
              }
              if (currentValue) {
                newValue = newValue ? [newValue] : [];
                newValue.push[isArray(currentValue) ? "apply" : "call"](newValue, currentValue);
              }
            }
            return newValue;
          }
        }
      },
      /**
       * Internal listeners, that cannot be removed by the user.
       * @config {Object}
       * @internal
       */
      internalListeners: null,
      /**
       * An object where property names with a truthy value indicate which events should bubble up the ownership
       * hierarchy when triggered.
       *
       * ```javascript
       * const container = new Container({
       *     items : [
       *        { type : 'text', bubbleEvents : { change : true }}
       *     ],
       *
       *     listeners : {
       *         change() {
       *             // Will catch change event from the text field
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object}
       * @category Misc
       */
      bubbleEvents: null
    };
  }
  destroy() {
    this.trigger("beforeDestroy");
    super.destroy();
  }
  //endregion
  //region Init
  construct(config, ...args) {
    if (this.configuredListeners = config == null ? void 0 : config.listeners) {
      config = Objects.assign({}, config);
      delete config.listeners;
    }
    super.construct(config, ...args);
    this.processConfiguredListeners();
  }
  processConfiguredListeners() {
    if (this.configuredListeners) {
      const me = this, { isConfiguring } = me;
      me.isConfiguring = false;
      me.listeners = me.configuredListeners;
      me.configuredListeners = null;
      me.isConfiguring = isConfiguring;
    }
  }
  /**
   * Auto detaches listeners registered from start, if set as detachable
   * @internal
   */
  doDestroy() {
    this.trigger("destroy");
    this.removeAllListeners(false);
    super.doDestroy();
  }
  static setupClass(meta) {
    super.setupClass(meta);
    Events.prototype.onListen.$nullFn = true;
    Events.prototype.onUnlisten.$nullFn = true;
  }
  //endregion
  //region Listeners
  /**
   * Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.addListener({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.addListener('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  addListener(config, thisObj, oldThisObj) {
    var _a4;
    if (isArray(config)) {
      for (let i = 0, { length } = config; i < length; i++) {
        this.addListener(config[i], thisObj);
      }
      return;
    }
    const me = this, deprecatedEvents = me.$meta.getInherited("deprecatedEvents");
    if (typeof config === "string") {
      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: oldThisObj
      });
    } else {
      thisObj = config.thisObj = config.thisObj !== void 0 ? config.thisObj : thisObj;
      for (const key in config) {
        if (!specialProperties[key] && config[key] != null) {
          const eventName = key.toLowerCase(), deprecatedEvent = deprecatedEvents == null ? void 0 : deprecatedEvents[eventName], events = me.eventListeners || (me.eventListeners = {}), specs = ArrayHelper.asArray(config[key]);
          if (deprecatedEvent) {
            const { product, invalidAsOfVersion, message } = deprecatedEvent;
            VersionHelper.deprecate(product, invalidAsOfVersion, message);
          }
          for (const listenerSpec of specs) {
            const expires = listenerSpec.expires || config.expires, listener = {
              fn: typeof listenerSpec === "object" ? listenerSpec.fn : listenerSpec,
              thisObj: listenerSpec.thisObj !== void 0 ? listenerSpec.thisObj : thisObj,
              args: listenerSpec.args || config.args,
              prio: listenerSpec.prio !== void 0 ? listenerSpec.prio : config.prio !== void 0 ? config.prio : 0,
              once: listenerSpec.once !== void 0 ? listenerSpec.once : config.once !== void 0 ? config.once : false,
              buffer: listenerSpec.buffer || config.buffer,
              throttle: listenerSpec.throttle || config.throttle,
              $internal: config.$internal,
              catchAll: key === "catchAll"
            };
            if (expires) {
              const { alt: alt2 } = expires, delay = alt2 ? expires.delay : expires, name2 = config.name || key, fn = () => {
                me.un(eventName, listener);
                if (alt2 && !listener.called) {
                  me.callback(alt2, thisObj);
                }
              };
              if (me.isDelayable) {
                me.setTimeout({
                  fn,
                  name: name2,
                  cancelOutstanding: true,
                  delay
                });
              } else {
                globalThis.setTimeout(fn, delay);
              }
            }
            let listeners = events[eventName] || (events[eventName] = []);
            if (listeners.$firing) {
              events[eventName] = listeners = listeners.slice();
            }
            listeners.splice(
              ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length),
              0,
              listener
            );
            if (!me.onListen.$nullFn && listeners.length < 2) {
              me.onListen(eventName);
            }
            (_a4 = me.afterAddListener) == null ? void 0 : _a4.call(me, eventName, listener);
          }
        }
      }
      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }
      if (thisObj && thisObj !== me) {
        me.attachAutoDetacher(config, thisObj);
      }
      const detachable = config.detachable !== false, name = config.name, destroy = config.expires || detachable || name ? () => {
        if (!me.isDestroyed) {
          me.removeListener(config, thisObj);
        }
      } : null;
      if (destroy) {
        destroy.eventer = me;
        destroy.listenerName = name;
        if (name && (thisObj == null ? void 0 : thisObj.trackDetacher)) {
          thisObj.trackDetacher(name, destroy);
        }
        if (config.expires) {
          me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);
        }
        if (detachable) {
          return destroy;
        }
      }
    }
  }
  /**
   * Alias for {@link #function-addListener}. Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.on({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.on('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  on(config, thisObj, oldThisObj) {
    return this.addListener(config, thisObj, oldThisObj);
  }
  /**
   * Internal convenience method for adding an internal listener, that cannot be removed by the user.
   *
   * Alias for `on({ $internal : true, ... })`. Only supports single argument form.
   *
   * @internal
   */
  ion(config) {
    config.$internal = true;
    return this.on(config);
  }
  /**
   * Shorthand for {@link #function-removeListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} [thisObj] `this` reference for all listeners, or the listener function
   * @param {Object} [oldThisObj] `this` The `this` object for the legacy way of adding listeners
   */
  un(...args) {
    this.removeListener(...args);
  }
  updateInternalListeners(internalListeners, oldInternalListeners) {
    oldInternalListeners == null ? void 0 : oldInternalListeners.detach();
    if (internalListeners) {
      internalListeners.detach = this.ion(internalListeners);
    }
  }
  get listeners() {
    return this.eventListeners;
  }
  changeListeners(listeners) {
    if (this.isConfiguring) {
      this.getConfig("internalListeners");
      if (listeners) {
        this.on(listeners, this);
      }
    } else {
      if (Array.isArray(listeners)) {
        for (let i = 0, l = listeners[0], { length } = listeners; i < length; l = listeners[++i]) {
          if (!("thisObj" in l)) {
            listeners[i] = Objects.assign({ thisObj: this }, l);
          }
        }
      } else if (listeners && !("thisObj" in listeners)) {
        listeners = Objects.assign({ thisObj: this }, listeners);
      }
      return listeners;
    }
  }
  updateListeners(listeners, oldListeners) {
    oldListeners && this.un(oldListeners);
    listeners && this.on(listeners);
  }
  /**
   * Removes an event listener. Same API signature as {@link #function-addListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} thisObj `this` reference for all listeners, or the listener function
   * @param {Object} oldThisObj `this` The `this` object for the legacy way of adding listeners
   */
  removeListener(config, thisObj = config.thisObj, oldThisObj) {
    const me = this;
    if (typeof config === "string") {
      return me.removeListener({ [config]: thisObj }, oldThisObj);
    }
    Object.entries(config).forEach(([eventName, listenerToRemove]) => {
      var _a4;
      if (!specialProperties[eventName] && listenerToRemove != null) {
        eventName = eventName.toLowerCase();
        const { eventListeners } = me, index = me.findListener(eventName, listenerToRemove, thisObj);
        if (index >= 0) {
          let listeners = eventListeners[eventName];
          (_a4 = me.afterRemoveListener) == null ? void 0 : _a4.call(me, eventName, listeners[index]);
          if (listeners.length > 1) {
            if (listeners.$firing) {
              eventListeners[eventName] = listeners = listeners.slice();
            }
            listeners.splice(index, 1);
          } else {
            delete eventListeners[eventName];
            if (!me.onUnlisten.$nullFn) {
              me.onUnlisten(eventName);
            }
          }
        }
      }
    });
    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }
  /**
   * Finds the index of a particular listener to the named event. Returns `-1` if the passed
   * function/thisObj listener is not present.
   * @param {String} eventName The name of an event to find a listener for.
   * @param {String|Function} listenerToFind The handler function to find.
   * @param {Object} defaultThisObj The `thisObj` for the required listener.
   * @internal
   */
  findListener(eventName, listenerToFind, defaultThisObj) {
    var _a4;
    const eventListeners = (_a4 = this.eventListeners) == null ? void 0 : _a4[eventName], fn = listenerToFind.fn || listenerToFind, thisObj = listenerToFind.thisObj || defaultThisObj;
    if (eventListeners) {
      for (let listenerEntry, i = 0, { length } = eventListeners; i < length; i++) {
        listenerEntry = eventListeners[i];
        if (listenerEntry.fn === fn && listenerEntry.thisObj === thisObj) {
          return i;
        }
      }
    }
    return -1;
  }
  /**
   * Check if any listener is registered for the specified eventName
   * @param {String} eventName
   * @returns {Boolean} `true` if listener is registered, otherwise `false`
   * @advanced
   */
  hasListener(eventName) {
    var _a4;
    return Boolean((_a4 = this.eventListeners) == null ? void 0 : _a4[eventName == null ? void 0 : eventName.toLowerCase()]);
  }
  /**
   * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name
   * before relaying, for example add -> storeAdd
   * ```
   * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:
   * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.
   * store.relayAll(grid, 'store');
   *
   * grid.on('storeLoad', () => console.log('Store loaded');
   * ```
   * @param {Core.mixin.Events} through Object to relay the events through, needs to mix Events mixin in
   * @param {String} prefix Prefix to add to event name
   * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase
   * @advanced
   */
  relayAll(through, prefix, transformCase = true) {
    if (!this.relayAllTargets) {
      this.relayAllTargets = [];
    }
    const { relayAllTargets } = this;
    through.ion({
      beforeDestroy: ({ source }) => {
        if (source === through) {
          const configs = relayAllTargets.filter((r) => r.through === through);
          configs.forEach((config) => ArrayHelper.remove(relayAllTargets, config));
        }
      }
    });
    relayAllTargets.push({ through, prefix, transformCase });
  }
  /**
   * Removes all listeners registered to this object by the application.
   */
  removeAllListeners(preserveInternal = true) {
    var _a4;
    const listeners = this.eventListeners;
    let i, thisObj;
    for (const event in listeners) {
      const bucket = listeners[event];
      for (i = bucket.length; i-- > 0; ) {
        const cfg = bucket[i];
        if (!cfg.$internal || !preserveInternal) {
          this.removeListener(event, cfg);
          thisObj = cfg.thisObj;
          (_a4 = thisObj == null ? void 0 : thisObj.untrackDetachers) == null ? void 0 : _a4.call(thisObj, this);
        }
      }
    }
  }
  relayEvents(source, eventNames, prefix = "") {
    const listenerConfig = { detachable: true, thisObj: this };
    eventNames.forEach((eventName) => {
      listenerConfig[eventName] = (event, ...params) => {
        return this.trigger(prefix + eventName, event, ...params);
      };
    });
    return source.on(listenerConfig);
  }
  /**
   * This method is called when the first listener for an event is added.
   * @param {String} eventName
   * @internal
   */
  onListen() {
  }
  /**
   * This method is called when the last listener for an event is removed.
   * @param {String} eventName
   * @internal
   */
  onUnlisten() {
  }
  destructorInterceptor() {
    const { autoDetachers, target, oldDestructor } = this;
    for (let i = 0; i < autoDetachers.length; i++) {
      const { dispatcher, config } = autoDetachers[i];
      if (!dispatcher.isDestroyed) {
        dispatcher.removeListener(config, target);
      }
    }
    oldDestructor.call(target);
  }
  /**
   * Internal function used to hook destroy() calls when using thisObj
   * @private
   */
  attachAutoDetacher(config, thisObj) {
    const target = config.thisObj || thisObj, destructorName = "doDestroy" in target ? "doDestroy" : "destroy";
    if (destructorName in target) {
      let { $autoDetachers } = target;
      if (!$autoDetachers) {
        target.$autoDetachers = $autoDetachers = [];
      }
      if (!target.$oldDestructor) {
        target.$oldDestructor = target[destructorName];
        target[destructorName] = this.destructorInterceptor.bind({
          autoDetachers: $autoDetachers,
          oldDestructor: target.$oldDestructor,
          target
        });
      }
      $autoDetachers.push({ config, dispatcher: this });
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }
  /**
   * Internal function used restore hooked destroy() calls when using thisObj
   * @private
   */
  detachAutoDetacher(config) {
    const target = config.thisObj;
    if (target.$oldDestructor && !target.isDestroying) {
      ArrayHelper.remove(
        target.$autoDetachers,
        target.$autoDetachers.find((detacher2) => detacher2.config === config && detacher2.dispatcher === this)
      );
      if (!target.$autoDetachers.length) {
        target["doDestroy" in target ? "doDestroy" : "destroy"] = target.$oldDestructor;
        target.$oldDestructor = null;
      }
    }
  }
  /**
   * Internal function used to run a callback function after an event is triggered
   * @private
   */
  once(eventName, callback) {
    return this.on({
      [eventName]: () => this.callback(callback),
      once: true
    });
  }
  //endregion
  //region Promise based workflow
  // experimental, used in tests to support async/await workflow
  await(eventName, options = { checkLog: true, resetLog: true, args: null }) {
    const me = this;
    if (options === false) {
      options = { checkLog: false };
    }
    const { args } = options;
    return new Promise((resolve) => {
      var _a4;
      if (options.checkLog && ((_a4 = me._triggered) == null ? void 0 : _a4[eventName])) {
        resolve();
        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }
      if (args) {
        const detacher2 = me.on({
          [eventName]: (...params) => {
            const argsOk = typeof args === "function" ? args(...params) : Object.keys(args).every((key) => {
              return key in params[0] && params[0][key] === args[key];
            });
            if (argsOk) {
              resolve(...params);
              if (options.resetLog) {
                me.clearLog(eventName);
              }
              detacher2();
            }
          },
          prio: -1e4
          // Let others do their stuff first
        });
      } else {
        me.on({
          [eventName]: (...params) => {
            resolve(...params);
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -1e4,
          // Let others do their stuff first
          once: true
          // promises can only be resolved once anyway
        });
      }
    });
  }
  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }
  //endregion
  //region Trigger
  /**
   * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener
   * makes function return false.
   * @param {String} eventName Event name for which to trigger listeners
   * @param {Object} [param] Single parameter passed on to listeners, source property will be added to it (this)
   * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget
   * ownership hierarchy. For example up a `Menu`->`parent` Menu tree, or a `Field`->`Container` tree.
   * @typings param -> {{bubbles?: boolean, [key: string]: any}}
   * @returns {Boolean|Promise} Returns false if any listener returned `false`, or a `Promise` yielding
   * `true` / `false` based on what is returned from the async listener functions, otherwise `true`
   * @async
   * @advanced
   */
  trigger(eventName, param) {
    var _a4, _b, _c, _d;
    const me = this, name = eventName.toLowerCase(), {
      eventsSuspended,
      relayAllTargets,
      callOnFunctions
    } = me;
    let listeners = (_a4 = me.eventListeners) == null ? void 0 : _a4[name], handlerPromises;
    if (!me._triggered) {
      me._triggered = {};
    }
    me._triggered[eventName] = true;
    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) {
        eventsSuspended.queue.push(arguments);
      }
      return true;
    }
    if ((_b = me.eventListeners) == null ? void 0 : _b.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);
      listeners.sort(priorityComparator);
    }
    if (!listeners && !relayAllTargets && !callOnFunctions) {
      return true;
    }
    if (param) {
      if (!("source" in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }
    if (param.type !== name) {
      if (param.constructor !== Object) {
        Reflect.defineProperty(param, "type", { get: () => name });
      } else {
        param.type = name;
      }
    }
    param.eventName = eventName;
    if (!("bubbles" in param) && ((_c = me.bubbleEvents) == null ? void 0 : _c[eventName])) {
      param.bubbles = me.bubbleEvents[eventName];
    }
    if (callOnFunctions) {
      const fnName = "on" + StringHelper.capitalize(eventName);
      if (fnName in me) {
        const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;
        let inhibit;
        if (Objects.isPromise(result)) {
          (handlerPromises || (handlerPromises = [])).push(result);
        } else {
          inhibit = result === false || inhibit;
        }
        if (!me.isDestroyed && hasOwnProperty5.call(me, fnName) && !((_d = me.pluginFunctionChain) == null ? void 0 : _d[fnName])) {
          const myProto = Object.getPrototypeOf(me);
          if (fnName in myProto) {
            const result2 = myProto[fnName].call(me, param);
            if (Objects.isPromise(result2)) {
              (handlerPromises || (handlerPromises = [])).push(result2);
            } else {
              inhibit = result2 === false || inhibit;
            }
            if (me.isDestroyed) {
              return;
            }
          }
        }
        if (inhibit) {
          return false;
        }
      }
    }
    let ret;
    if (listeners) {
      let i = 0, internalAbort = false;
      listeners.$firing = true;
      for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {
        const listener = listeners[i];
        if (ret === false && !listener.$internal) {
          continue;
        }
        let handler, thisObj = listener.thisObj;
        if (!thisObj || !thisObj.isDestroyed) {
          listener.called = true;
          if (listener.once) {
            me.removeListener(name, listener);
          }
          if (typeof listener.fn === "string") {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }
            if (!handler) {
              const result2 = me.resolveCallback(listener.fn);
              handler = result2.handler;
              thisObj = result2.thisObj;
            }
          } else {
            handler = listener.fn;
          }
          if (listener.buffer) {
            if (!listener.bufferFn) {
              const buffer = Number(listener.buffer);
              if (typeof buffer !== "number" || isNaN(buffer)) {
                throw new Error(`Incorrect type for buffer, got "${buffer}" (expected a Number)`);
              }
              listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);
            }
            handler = listener.bufferFn;
          }
          if (listener.throttle) {
            const throttle = Number(listener.throttle);
            if (typeof throttle !== "number" || isNaN(throttle)) {
              throw new Error(`Incorrect type for throttle, got "${throttle}" (expected a Number)`);
            }
            if (!listener.throttledFn) {
              listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);
            }
            handler = listener.throttledFn;
          }
          const result = handler.call(thisObj || me, ...listener.args || [], param);
          if (ret !== false) {
            ret = result;
          }
          if (listener.$internal && result === false) {
            internalAbort = true;
          }
          if (Objects.isPromise(result)) {
            result.$internal = listener.$internal;
            (handlerPromises || (handlerPromises = [])).push(result);
          }
        }
      }
      listeners.$firing = false;
      if (internalAbort) {
        return false;
      }
    }
    relayAllTargets == null ? void 0 : relayAllTargets.forEach((config) => {
      let name2 = eventName;
      if (config.transformCase) {
        name2 = StringHelper.capitalize(name2);
      }
      if (config.prefix) {
        name2 = config.prefix + name2;
      }
      if (config.through.trigger(name2, param) === false) {
        return false;
      }
    });
    if (param.bubbles && me.owner && !me.owner.isDestroyed) {
      return me.owner.trigger(eventName, param);
    }
    handlerPromises = handlerPromises == null ? void 0 : handlerPromises.filter((p) => ret !== false || p.$internal);
    if (handlerPromises == null ? void 0 : handlerPromises.length) {
      return new Promise((resolve) => {
        Promise.all(handlerPromises).then((promiseResults) => {
          const finalResult = !promiseResults.some((result) => result === false);
          resolve(finalResult);
        });
      });
    }
    return ret !== false;
  }
  /**
   * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while
   * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.
   * @param {Boolean} queue Specify true to queue events triggered while suspended
   * @advanced
   */
  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = { shouldQueue: queue, queue: [], count: 0 });
    eventsSuspended.count++;
  }
  /**
   * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.
   * @returns {Boolean} `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).
   * @advanced
   */
  resumeEvents() {
    const suspended = this.eventsSuspended;
    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;
        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }
    return !Boolean(this.eventsSuspended);
  }
  //endregion
};

// ../Core/lib/Core/helper/AsyncHelper.js
var AsyncHelper = class {
  /**
   * Returns a promise that resolves on next animation frame.
   * ```
   *  async method() {
   *      // do work
   *      await AsyncHelper.animationFrame();
   *      // do more work
   *  }
   * ```
   * @async
   */
  static animationFrame() {
    return new Promise((resolve) => {
      requestAnimationFrame(resolve);
    });
  }
  /**
   * Returns a promise that resolves after a specified number of milliseconds.
   * ```
   *  async method() {
   *      await AsyncHelper.sleep(10);
   *      // ...
   *  }
   * ```
   * @param {Number} millis The number of milliseconds to sleep.
   * @async
   */
  static sleep(millis) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, millis);
    });
  }
  /**
   * Returns a promise that resolves as soon as possible, allowing the browser to minimally process other messages.
   * This is the shortest possible delay the browser offers, so be aware that it does not necessarily allow the
   * browser to paint or reflow if used in a long loop. It does, however, allow other async methods to execute.
   * ```
   *  async method() {
   *      await AsyncHelper.yield();
   *      // ...
   *  }
   * ```
   * @async
   */
  static yield() {
    return Promise.resolve();
  }
};
AsyncHelper._$name = "AsyncHelper";

// ../Core/lib/Core/helper/AjaxHelper.js
var paramValueRegExp = /^(\w+)=(.*)$/;
var parseParams = function(paramString) {
  const result = {}, params = paramString.split("&");
  for (const nameValuePair of params) {
    const [match, name, value] = paramValueRegExp.exec(nameValuePair), decodedName = decodeURIComponent(name), decodedValue = decodeURIComponent(value);
    if (match) {
      let paramValue = result[decodedName];
      if (paramValue) {
        if (!Array.isArray(paramValue)) {
          paramValue = result[decodedName] = [paramValue];
        }
        paramValue.push(decodedValue);
      } else {
        result[decodedName] = decodedValue;
      }
    }
  }
  return result;
};
var _AjaxHelper = class _AjaxHelper {
  /**
   * Make a request (using GET) to the specified url.
   * @param {String} url URL to `GET` from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static get(url, options) {
    return this.fetch(url, options);
  }
  /**
   * POST data to the specified URL.
   * @param {String} url URL to `POST` to
   * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === "string")) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers["Content-Type"] = options.headers["Content-Type"] || "application/json";
    }
    return this.fetch(url, Object.assign({
      method: "POST",
      body: payload
    }, options));
  }
  /**
   * Fetch the specified resource using the `fetch` API.
   * @param {String} url URL to fetch from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static fetch(url, options) {
    let controller;
    options = Objects.merge({}, _AjaxHelper.DEFAULT_FETCH_OPTIONS, options);
    if (typeof AbortController !== "undefined") {
      controller = options.abortController = new AbortController();
      options.signal = controller.signal;
    }
    if (!("credentials" in options)) {
      options.credentials = "include";
    }
    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        let paramsAdded = false;
        if (options.headers && options.addQueryParamsToBody === true) {
          const contentType = new Headers(options.headers).get("Content-Type");
          let bodyClass;
          switch (contentType) {
            case "application/x-www-form-urlencoded":
              bodyClass = URLSearchParams;
              break;
            case "multipart/form-data":
              bodyClass = FormData;
              break;
          }
          if (bodyClass) {
            const body = options.body || (options.body = new bodyClass());
            if (body instanceof bodyClass) {
              params.forEach(([key, value]) => body.set(key, value));
              paramsAdded = true;
            }
          }
        }
        if (!paramsAdded) {
          url += (url.includes("?") ? "&" : "?") + params.map(
            ([param, value]) => `${param}=${encodeURIComponent(value)}`
          ).join("&");
        }
      }
    }
    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then(
        (response) => {
          if (options.parseJson) {
            response.json().then((json) => {
              response.parsedJson = json;
              resolve(response);
            }).catch((error) => {
              response.parsedJson = null;
              response.error = error;
              reject(response);
            });
          } else {
            resolve(response);
          }
        }
      ).catch((error) => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;
    promise.abort = function() {
      controller == null ? void 0 : controller.abort();
    };
    return promise;
  }
  /**
   * Registers the passed URL to return the passed mocked up Fetch Response object to the
   * AjaxHelper's promise resolve function.
   * @param {String} url The url to return mock data for
   * @param {Object|Function} response A mocked up Fetch Response object which must contain
   * at least a `responseText` property, or a function to which the `url` and a `params` object
   * and the `Fetch` `options` object is passed which returns that.
   * @param {String} response.responseText The data to return.
   * @param {Boolean} [response.synchronous] resolve the Promise immediately
   * @param {Number} [response.delay=100] resolve the Promise after this number of milliseconds.
   */
  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;
    if (!_AjaxHelper.originalFetch) {
      _AjaxHelper.originalFetch = _AjaxHelper.fetch;
      _AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }
  }
  static async mockAjaxFetch(url, options) {
    const urlAndParams = url.split("?");
    let result = this.mockAjaxMap[urlAndParams[0]], parsedJson = null;
    if (result) {
      if (typeof result === "function") {
        result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }
      try {
        parsedJson = (options == null ? void 0 : options.parseJson) && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }
      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: "OK",
        url,
        parsedJson,
        text: () => new Promise((resolve) => {
          resolve(result.responseText);
        }),
        json: () => new Promise((resolve) => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function(resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function() {
            resolve(result);
          }, "delay" in result ? result.delay : 100);
        }
      });
    } else {
      return _AjaxHelper.originalFetch(url, options);
    }
  }
};
/**
 * Sets default options for {@link #function-fetch-static AjaxHelper#fetch()} calls. Please see
 * {@link #typedef-FetchOptions} and
 * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details.
 *
 * ```javascript
 * // default content-type for all requests will be "application/json"
 * AjaxHelper.DEFAULT_FETCH_OPTIONS = {
 *     headers : {
 *         'content-type' : 'application/json'
 *     }
 * };
 * ```
 * @member {FetchOptions} DEFAULT_FETCH_OPTIONS
 * @static
 */
__publicField(_AjaxHelper, "DEFAULT_FETCH_OPTIONS", {});
var AjaxHelper = _AjaxHelper;
AjaxHelper._$name = "AjaxHelper";

// ../Core/lib/Core/localization/LocaleHelper.js
var global = typeof self !== "undefined" ? self : typeof globalThis !== "undefined" ? globalThis : null;
var _LocaleHelper = class _LocaleHelper {
  /**
   * Merges all properties of provided locale objects into new locale object.
   * Locales are merged in order they provided and locales which go later replace
   * same properties of previous locales.
   * @param {...Object} locales Locales to merge
   * @returns {Object} Merged locale
   */
  static mergeLocales(...locales) {
    const result = {};
    locales.forEach((locale4) => {
      Object.keys(locale4).forEach((key) => {
        if (typeof locale4[key] === "object") {
          result[key] = { ...result[key], ...locale4[key] };
        } else {
          result[key] = locale4[key];
        }
      });
    });
    return result;
  }
  /**
   * Removes all properties from `locale` that are present in the provided `toTrim`.
   * @param {Object} locale Locale to process
   * @param {Object} toTrim Object enumerating properties that should be removed.
   * When `false` throws exceptions in such cases.
   */
  static trimLocale(locale4, toTrim) {
    const remove = (key, subKey) => {
      if (locale4[key]) {
        if (subKey) {
          if (locale4[key][subKey]) {
            delete locale4[key][subKey];
          }
        } else {
          delete locale4[key];
        }
      }
    };
    Object.keys(toTrim).forEach((key) => {
      if (Object.keys(toTrim[key]).length > 0) {
        Object.keys(toTrim[key]).forEach((subKey) => remove(key, subKey));
      } else {
        remove(key);
      }
    });
  }
  /**
   * Normalizes locale object to {@link Locale} type.
   *
   * Supported configs:
   *
   * ```javascript
   * LocaleHelper.normalizeLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * and for backward compatibility
   *
   * ```javascript
   * LocaleHelper.normalizeLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   * @param {String|Object} nameOrConfig String name of locale or locale object
   * @param {Object} [config] Locale object
   * @returns {Locale} Locale object
   * @internal
   */
  static normalizeLocale(nameOrConfig, config) {
    if (!nameOrConfig) {
      throw new Error(`"nameOrConfig" parameter can not be empty`);
    }
    if (typeof nameOrConfig === "string") {
      if (!config) {
        throw new Error(`"config" parameter can not be empty`);
      }
      if (config.locale) {
        config.name = nameOrConfig || config.name;
      } else {
        config.localeName = nameOrConfig;
      }
    } else {
      config = nameOrConfig;
    }
    let locale4 = {};
    if (config.name || config.locale) {
      locale4 = Object.assign({
        localeName: config.name
      }, config.locale);
      config.desc && (locale4.localeDesc = config.desc);
      config.code && (locale4.localeCode = config.code);
      config.path && (locale4.localePath = config.path);
    } else {
      if (!config.localeName) {
        throw new Error(`"config" parameter doesn't have "localeName" property`);
      }
      locale4 = Object.assign({}, config);
    }
    for (const key of ["name", "desc", "code", "path"]) {
      if (locale4[key]) {
        delete locale4[key];
      }
    }
    if (!locale4.localeName) {
      throw new Error(`Locale name can not be empty`);
    }
    return locale4;
  }
  /**
   * Get/set currently published locales.
   * Returns an object with locales.
   *
   * Example:
   *
   * ```javascript
   * const englishLocale = LocaleHelper.locales.En;
   * ```
   *
   * `englishLocale` contains {@link Locale} object.
   *
   * @readonly
   * @member {Locales} locales
   * @static
   */
  static get locales() {
    return global.bryntum.locales || {};
  }
  static set locales(locales) {
    global.bryntum.locales = locales;
  }
  /**
   * Get/set current locale name. Defaults to "En"
   * @member {String} localeName
   * @static
   */
  static get localeName() {
    return global.bryntum.locale || "En";
  }
  static set localeName(localeName) {
    global.bryntum.locale = localeName || _LocaleHelper.localeName;
  }
  /**
   * Get current locale config specified by {@link #property-localeName-static}.
   * If no current locale specified, returns default `En` locale or first published locale
   * or empty locale object if no published locales found.
   * @readonly
   * @member {Locales} locale
   * @static
   */
  static get locale() {
    return _LocaleHelper.localeName && this.locales[_LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || { localeName: "", localeDesc: "", localeCoode: "" };
  }
  /**
   * Publishes a locale to make it available for applying.
   * Published locales are available in {@link #property-locales-static}.
   *
   * Recommended usage:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * for backward compatibility (prior to `5.3.0` version):
   *
   * ```javascript
   * LocaleHelper.publishLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   *
   * Publishing a locale will automatically merge it's localization keys with existing locale matching by locale name,
   * replacing existing one with new. To replace existing locale entirely pass `true` to optional `config` parameter.
   *
   * Example:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * }, true);
   * ```
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object.
   * Not used if locale object is passed as first method parameter.
   * Path `true` value and locale object as first method parameter to publish locale without merging with existing one.
   * @returns {Locale} Locale object
   */
  static publishLocale(nameOrConfig, config) {
    const { locales } = global.bryntum, locale4 = _LocaleHelper.normalizeLocale(nameOrConfig, config), { localeName } = locale4;
    if (!locales[localeName] || config === true) {
      locales[localeName] = locale4;
    } else {
      locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale4 || {});
    }
    return locales[localeName];
  }
};
__publicField(_LocaleHelper, "skipLocaleIntegrityCheck", false);
var LocaleHelper = _LocaleHelper;
global.bryntum = global.bryntum || {};
global.bryntum.locales = global.bryntum.locales || {};
LocaleHelper._$name = "LocaleHelper";

// ../Core/lib/Core/localization/LocaleManager.js
var LocaleManager = class extends Events_default(Base) {
  static get defaultConfig() {
    return {
      // Enable strict locale checking by default for tests
      throwOnMissingLocale: VersionHelper.isTestEnv
    };
  }
  construct(...args) {
    var _a4;
    const me = this;
    super.construct(...args);
    if (BrowserHelper.isBrowserEnv) {
      const scriptTag = document.querySelector("script[data-default-locale]");
      if (scriptTag) {
        me.applyLocale(scriptTag.dataset.defaultLocale);
      } else if ((_a4 = me.locale) == null ? void 0 : _a4.localeName) {
        me.applyLocale(me.locale.localeName);
      }
    }
  }
  /**
   * Get/set currently registered locales.
   * Alias for {@link Core.localization.LocaleHelper#property-locales-static LocaleHelper.locales}.
   * @readonly
   * @member {Locales} locales
   */
  get locales() {
    return LocaleHelper.locales;
  }
  set locales(locales) {
    LocaleHelper.locales = locales;
  }
  /**
   * Get/set currently used locale.
   * Setter calls {@link #function-applyLocale}.
   * @member {Locales} locale
   * @accepts {String|Locale}
   */
  set locale(nameOrConfig) {
    this.applyLocale(nameOrConfig);
  }
  get locale() {
    return LocaleHelper.locale;
  }
  /**
   * Publishes a locale to make it available for applying.
   * @deprecated Since 5.3.0. Use {@link Core.localization.LocaleHelper#function-publishLocale-static LocaleHelper.publishLocale} instead.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object.
   * @param {Locale} [config] Locale object. Not used if object is passed as first method parameter
   * @returns {Locale} published locale object is passed as first method parameter
   * @function registerLocale
   */
  registerLocale(nameOrConfig, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead");
    LocaleHelper.publishLocale(nameOrConfig, config);
  }
  /**
   * Extends locale specified by name to add additional translations and applies it.
   * @deprecated Since 5.3.0. Use {@link #function-applyLocale} instead.
   *
   * @param {String} name Name of locale (for example `En` or `SvSE`).
   * @param {Locale} config Locale object
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @function extendLocale
   */
  extendLocale(name, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead");
    const locale4 = LocaleHelper.publishLocale(name, config);
    return this.applyLocale(locale4, true);
  }
  /**
   * Applies a locale by string name or publishes new locale configuration with
   * {@link Core.localization.LocaleHelper#function-publishLocale-static} and applies it.
   * If locale is specified by string name, like 'En', it must be published before applying it.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object. Pass `true` to reapply locale which is passed as first method parameter.
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @fires locale
   * @async
   * @function applyLocale
   */
  applyLocale(nameOrConfig, config, ignoreError = false) {
    const me = this;
    let localeConfig;
    if (typeof nameOrConfig === "string") {
      if (typeof config !== "object") {
        localeConfig = me.locales[nameOrConfig];
        if (!localeConfig) {
          if (ignoreError) {
            return true;
          }
          throw new Error(`Locale "${nameOrConfig}" is not published. Publish with LocaleHelper.publishLocale() before applying.`);
        }
      } else {
        localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);
      }
    } else {
      localeConfig = LocaleHelper.publishLocale(nameOrConfig);
    }
    if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {
      return me.locale;
    }
    LocaleHelper.localeName = localeConfig.localeName;
    const triggerLocaleEvent = () => {
      me.trigger("locale", localeConfig);
    };
    if (localeConfig.localePath) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.localePath).then((response) => {
          response.text().then((text) => {
            const parseLocale = new Function(text);
            parseLocale();
            if (BrowserHelper.isBrowserEnv) {
              localeConfig = me.locales[localeConfig.localeName];
              if (localeConfig) {
                delete localeConfig.localePath;
              }
            }
            triggerLocaleEvent();
            resolve(localeConfig);
          });
        }).catch((response) => reject(response));
      });
    }
    triggerLocaleEvent();
    return localeConfig;
  }
  /**
   * Loads a locale using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request.
   * @private
   * @param {String} path Path to locale file
   * @async
   */
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
  /**
   * Specifies if {@link Core.localization.Localizable#function-L-static Localizable.L()} function would throw error if no localization found at runtime.
   *
   * @member {Boolean} throwOnMissingLocale
   * @default false
   */
  set throwOnMissingLocale(value) {
    this._throwOnMissingLocale = value;
  }
  get throwOnMissingLocale() {
    return this._throwOnMissingLocale;
  }
};
var LocaleManagerSingleton = new LocaleManager();
var LocaleManager_default = LocaleManagerSingleton;

// ../Core/lib/Core/localization/Localizable.js
var ObjectProto = Object.getPrototypeOf(Object);
var localeRe = /L{.*?}/g;
var capturelocaleRe = /L{(.*?)}/g;
var classMatchRe = /((.*?)\.)?(.+)/g;
var escape2 = (txt) => txt.replace(/{(\d+)}/gm, "[[$1]]");
var unescape = (txt) => txt.replace(/\[\[(\d+)]]/gm, "{$1}");
var emptyObject3 = Object.freeze(/* @__PURE__ */ Object.create(null));
var Localizable_default = (Target) => class Localizable extends (Target || Base) {
  static get $name() {
    return "Localizable";
  }
  static get configurable() {
    return {
      /**
       * A class translations of which are used for translating this entity.
       * This is often used when translations of an item are defined on its container class.
       * For example:
       *
       * ```js
       * // Toolbar class that has some predefined items
       * class MyToolbar extends Toolbar {
       *
       *     static get $name() {
       *         return 'MyToolbar';
       *     }
       *
       *     static get defaultConfig() {
       *         return {
       *             // this specifies default configs for the items
       *             defaults : {
       *                 // will tell items to use the toolbar locale
       *                 localeClass : this
       *             },
       *
       *             items : [
       *                 // The toolbar has 2 buttons and translation for their texts will be searched in
       *                 // the toolbar locales
       *                 { text : 'Agree' },
       *                 { text : 'Disagree' }
       *             ]
       *         };
       *     }
       *
       *    ...
       * }
       * ```
       * So if one makes a locale for the `MyToolbar` class that will include `Agree` and `Disagree` string translations:
       * ```js
       *     ...
       *     MyToolbar : {
       *         Agree    : 'Yes, I agree',
       *         Disagree : 'No, I do not agree'
       *     }
       * ```
       * They will be used for the toolbar buttons and the button captions will say `Yes, I agree` and `No, I do not agree`.
       *
       * @config {Core.Base}
       * @typings {typeof Base}
       * @category Misc
       * @advanced
       */
      localeClass: null,
      /**
       * Set to `false` to disable localization of this object.
       * @config {Boolean}
       * @default true
       * @category Misc
       * @advanced
       */
      localizable: null,
      /**
       * List of properties which values should be translated automatically upon a locale applying.
       * In case there is a need to localize not typical value (not a String value or a field with re-defined setter/getter),
       * you could use 'localeKey' meta configuration.
       * Example:
       * ```js
       *  static get configurable() {
       *     return {
       *          localizableProperties : ['width'],
       *
       *          width : {
       *              value   : '54em', // default value here
       *              $config : {
       *                  localeKey : 'L{editorWidth}' // name of the property that will be used in localization file
       *              }
       *          }
       *      };
       *  }
       * ```
       * @config {String[]}
       * @category Misc
       * @advanced
       */
      localizableProperties: {
        value: [],
        $config: {
          merge: "distinct"
        }
      }
    };
  }
  static clsName(cls) {
    var _a4, _b;
    return typeof cls === "string" ? cls : cls === ObjectProto ? "Object" : cls.$$name || cls.name || ((_a4 = cls.prototype) == null ? void 0 : _a4.$$name) || ((_b = cls.prototype) == null ? void 0 : _b.name);
  }
  static parseLocaleString(text) {
    const matches = [];
    let m;
    if (text == null ? void 0 : text.includes("L{")) {
      text = escape2(text);
      capturelocaleRe.lastIndex = 0;
      while ((m = capturelocaleRe.exec(text)) != null) {
        classMatchRe.lastIndex = 0;
        const classMatch = classMatchRe.exec(m[1]);
        matches.push({
          match: unescape(m[0]),
          localeKey: unescape(classMatch[3]),
          localeClass: classMatch[2]
        });
      }
    }
    return matches.length > 0 ? matches : [{
      match: text,
      localeKey: text,
      localeClass: void 0
    }];
  }
  construct(config = {}, ...args) {
    super.construct(config, ...args);
    LocaleManager_default.ion({ locale: "updateLocalization", thisObj: this });
    this.updateLocalization();
  }
  get localeClass() {
    return this._localeClass || null;
  }
  localizeProperty(property) {
    var _a4, _b, _c;
    const me = this, currentValue = Objects.getPath(me, property), localeKey = ((_a4 = me.$meta.configs[property]) == null ? void 0 : _a4.localeKey) || ((_c = (_b = me.fieldMap) == null ? void 0 : _b[property]) == null ? void 0 : _c.defaultValue);
    let localizedValue;
    if (localeKey) {
      localizedValue = Localizable.localize(localeKey, me, me.localeClass || me);
      if (localizedValue && !(property in (me.initialConfig || emptyObject3)) && !(property in (me.originalData || emptyObject3))) {
        Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);
      }
    } else if (typeof currentValue === "string") {
      me.originalLocales = me.originalLocales || {};
      localizedValue = Objects.getPath(me.originalLocales, property);
      if (localizedValue === void 0) {
        Objects.setPath(me.originalLocales, property, currentValue);
        localizedValue = currentValue;
      }
      if (localizedValue) {
        Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));
      }
    }
    return localizedValue || currentValue;
  }
  /**
   * Method that is triggered when applying a locale to the instance
   * (happens on the instance construction steps and when switching to another locale).
   *
   * The method can be overridden to dynamically translate the instance when locale is switched.
   * When overriding the method please make sure you call `super.updateLocalization()`.
   * @category Misc
   * @advanced
   */
  updateLocalization() {
    var _a4, _b;
    if (this.localizable !== false) {
      (_a4 = this.localizableProperties) == null ? void 0 : _a4.forEach(this.localizeProperty, this);
      (_b = this.trigger) == null ? void 0 : _b.call(this, "localized");
    }
  }
  static getTranslation(text, templateData, localeCls) {
    const locale4 = LocaleManager_default.locale;
    let result = null, clsName, cls;
    if (locale4) {
      for (const { match, localeKey, localeClass } of this.parseLocaleString(text)) {
        const translate = (clsName2) => {
          var _a4;
          const translation = (_a4 = locale4[clsName2]) == null ? void 0 : _a4[localeKey];
          if (translation) {
            if (typeof translation === "function") {
              result = templateData != null ? translation(templateData) : translation;
            } else if (typeof translation === "object" || text === match) {
              result = translation;
            } else {
              result = (result || text).replace(match, translation);
            }
            if (typeof translation === "string" && translation.includes("L{")) {
              result = this.getTranslation(translation, templateData, localeCls);
            }
          }
          return translation;
        };
        let success2 = false;
        for (cls = localeCls; cls && (clsName = Localizable.clsName(cls)); cls = Object.getPrototypeOf(cls)) {
          if (success2 = translate(clsName)) {
            break;
          } else if (typeof cls === "string") {
            break;
          }
        }
        if (!success2 && localeClass) {
          translate(localeClass);
        }
      }
    }
    return result;
  }
  /**
   * Get localized string, returns `null` if no localized string found.
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @internal
   */
  static localize(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    let translation = null;
    localeClasses.some((cls) => {
      translation = Localizable.getTranslation(text, templateData, cls);
      return translation != null;
    });
    return translation;
  }
  /**
   * Get localized string, returns value of `text` if no localized string found.
   *
   * If {@link Core.localization.LocaleManager#property-throwOnMissingLocale LocaleManager.throwOnMissingLocale}
   * is `true` then calls to `L()` will throw `Localization is not found for 'text' in 'ClassName'` exception when no
   * localization is found.
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @static
   * @returns {String}
   * @advanced
   */
  static L(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const translation = this.localize(text, templateData, ...localeClasses);
    if (translation == null && LocaleManager_default.throwOnMissingLocale && text.includes("L{")) {
      throw new Error(`Localization is not found for '${text}' in '${localeClasses.map((cls) => Localizable.clsName(cls)).join(", ")}'. ${LocaleManager_default.locale.localeName ? `Locale : ${LocaleManager_default.locale.localeName}` : ""}`);
    }
    return translation != null ? translation : text;
  }
  /**
   * Convenience function that can be called directly on the class that mixes Localizable in
   *
   * ```javascript
   * button.text = grid.L('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @category Misc
   * @advanced
   */
  L(text, templateData) {
    const { localeClass, constructor } = this;
    if (localeClass && Localizable.clsName(localeClass) !== Localizable.clsName(constructor)) {
      return Localizable.L(text, templateData, localeClass, constructor);
    } else {
      return Localizable.L(text, templateData, constructor);
    }
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @static
   * @category Misc
   * @advanced
   */
  static optionalL(text, templateData = void 0, ...localeClasses) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text);
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const result = Localizable.L(text, templateData, ...localeClasses);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @param {Boolean} [preventThrow] Prevent throwing error even if localized text matches `L{foo}`
   * @returns {String}
   * @category Misc
   * @internal
   */
  optionalL(text, templateData = this, preventThrow = false) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;
    const result = this.L(text, templateData);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Get the global LocaleManager
   * @property {Core.localization.LocaleManager}
   * @typings {typeof LocaleManager}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeManager() {
    return LocaleManager_default;
  }
  /**
   * Get the global LocaleHelper
   * @property {Core.localization.LocaleHelper}
   * @typings {typeof LocaleHelper}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeHelper() {
    return LocaleHelper;
  }
};

// ../Core/lib/Core/localization/En.js
var locale = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  Object: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Ok: "OK",
    Week: "Week",
    None: "None"
  },
  ColorPicker: {
    noColor: "No color"
  },
  Combo: {
    noResults: "No results",
    recordNotCommitted: "Record could not be added",
    addNewValue: (value) => `Add ${value}`
  },
  FilePicker: {
    file: "File"
  },
  Field: {
    badInput: "Invalid field value",
    patternMismatch: "Value should match a specific pattern",
    rangeOverflow: (value) => `Value must be less than or equal to ${value.max}`,
    rangeUnderflow: (value) => `Value must be greater than or equal to ${value.min}`,
    stepMismatch: "Value should fit the step",
    tooLong: "Value should be shorter",
    tooShort: "Value should be longer",
    typeMismatch: "Value is required to be in a special format",
    valueMissing: "This field is required",
    invalidValue: "Invalid field value",
    minimumValueViolation: "Minimum value violation",
    maximumValueViolation: "Maximum value violation",
    fieldRequired: "This field is required",
    validateFilter: "Value must be selected from the list"
  },
  DateField: {
    invalidDate: "Invalid date input"
  },
  DatePicker: {
    gotoPrevYear: "Go to previous year",
    gotoPrevMonth: "Go to previous month",
    gotoNextMonth: "Go to next month",
    gotoNextYear: "Go to next year"
  },
  NumberFormat: {
    locale: "en-US",
    currency: "USD"
  },
  DurationField: {
    invalidUnit: "Invalid unit"
  },
  TimeField: {
    invalidTime: "Invalid time input"
  },
  TimePicker: {
    hour: "Hour",
    minute: "Minute",
    second: "Second"
  },
  List: {
    loading: "Loading...",
    selectAll: "Select All"
  },
  GridBase: {
    loadMask: "Loading...",
    syncMask: "Saving changes, please wait..."
  },
  PagingToolbar: {
    firstPage: "Go to first page",
    prevPage: "Go to previous page",
    page: "Page",
    nextPage: "Go to next page",
    lastPage: "Go to last page",
    reload: "Reload current page",
    noRecords: "No records to display",
    pageCountTemplate: (data) => `of ${data.lastPage}`,
    summaryTemplate: (data) => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
  },
  PanelCollapser: {
    Collapse: "Collapse",
    Expand: "Expand"
  },
  Popup: {
    close: "Close"
  },
  UndoRedo: {
    Undo: "Undo",
    Redo: "Redo",
    UndoLastAction: "Undo last action",
    RedoLastAction: "Redo last undone action",
    NoActions: "No items in the undo queue"
  },
  FieldFilterPicker: {
    equals: "equals",
    doesNotEqual: "does not equal",
    isEmpty: "empty",
    isNotEmpty: "not empty",
    contains: "contains",
    doesNotContain: "does not contain",
    startsWith: "starts with",
    endsWith: "ends with",
    isOneOf: "one of",
    isNotOneOf: "not one of",
    isGreaterThan: "greater than",
    isLessThan: "less than",
    isGreaterThanOrEqualTo: "greater or equals",
    isLessThanOrEqualTo: "less or equals",
    isBetween: "between",
    isNotBetween: "not between",
    isBefore: "before",
    isAfter: "after",
    isToday: "today",
    isTomorrow: "tomorrow",
    isYesterday: "yesterday",
    isThisWeek: "this week",
    isNextWeek: "next week",
    isLastWeek: "last week",
    isThisMonth: "this month",
    isNextMonth: "next month",
    isLastMonth: "last month",
    isThisYear: "this year",
    isNextYear: "next year",
    isLastYear: "last year",
    isYearToDate: "year to date",
    isTrue: "true",
    isFalse: "false",
    selectAProperty: "Select property",
    selectAnOperator: "Select operator",
    caseSensitive: "Case-sensitive",
    and: "and",
    dateFormat: "D/M/YY",
    selectValue: "Select value",
    selectOneOrMoreValues: "Select value(s)",
    enterAValue: "Enter value",
    enterANumber: "Enter number",
    selectADate: "Select date",
    selectATime: "Select time"
  },
  FieldFilterPickerGroup: {
    addFilter: "Add filter"
  },
  DateHelper: {
    locale: "en-US",
    weekStartDay: 0,
    nonWorkingDays: {
      0: true,
      6: true
    },
    weekends: {
      0: true,
      6: true
    },
    unitNames: [
      { single: "millisecond", plural: "ms", abbrev: "ms" },
      { single: "second", plural: "seconds", abbrev: "s" },
      { single: "minute", plural: "minutes", abbrev: "min" },
      { single: "hour", plural: "hours", abbrev: "h" },
      { single: "day", plural: "days", abbrev: "d" },
      { single: "week", plural: "weeks", abbrev: "w" },
      { single: "month", plural: "months", abbrev: "mon" },
      { single: "quarter", plural: "quarters", abbrev: "q" },
      { single: "year", plural: "years", abbrev: "yr" },
      { single: "decade", plural: "decades", abbrev: "dec" }
    ],
    unitAbbreviations: [
      ["mil"],
      ["s", "sec"],
      ["m", "min"],
      ["h", "hr"],
      ["d"],
      ["w", "wk"],
      ["mo", "mon", "mnt"],
      ["q", "quar", "qrt"],
      ["y", "yr"],
      ["dec"]
    ],
    parsers: {
      L: "MM/DD/YYYY",
      LT: "HH:mm A",
      LTS: "HH:mm:ss A"
    },
    ordinalSuffix: (number) => {
      const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
      let suffix = "th";
      if (!hasSpecialCase) {
        const lastDigit = number[number.length - 1];
        suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
      }
      return number + suffix;
    }
  }
};
var En_default = LocaleHelper.publishLocale(locale);

// ../Core/lib/Core/helper/DateHelper.js
var { toString: toString3 } = Object.prototype;
var DATE_TYPE2 = toString3.call(/* @__PURE__ */ new Date());
var tempDate = /* @__PURE__ */ new Date();
var MS_PER_HOUR = 1e3 * 60 * 60;
var defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value;
var rangeFormatPartRe = /([ES]){([^}]+)}/g;
var enOrdinalSuffix = (number) => {
  const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
  let suffix = "th";
  if (!hasSpecialCase) {
    const lastDigit = number[number.length - 1];
    suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
  }
  return number + suffix;
};
var useIntlFormat = (name, options, date) => {
  const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale2, options));
  return formatter.format(date);
};
var formatTime = (name, options, date, isShort = false) => {
  let strTime = useIntlFormat(name, options, date);
  if (/am|pm/i.test(strTime)) {
    strTime = strTime.replace(/^0/, "");
    if (isShort) {
      strTime = strTime.replace(/:00/, "");
    }
  }
  return strTime;
};
var getDayDiff = (end, start) => Math.floor((end.getTime() - start.getTime() - (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1;
var normalizeDay = (day2) => day2 >= 0 ? day2 : day2 + 7;
var msRegExp = /([^\w])(S+)/gm;
var msReplacer = (match, g1) => g1 + "SSS";
var splitRegExp = /[:.\-/\s]/;
var locale2 = "en-US";
var ordinalSuffix = enOrdinalSuffix;
var formatCache = {};
var formatRedirects = {};
var intlFormatterCache = {};
var parserCache = {};
var redirectFormat = (format) => {
  const intlConfig = intlFormatConfigs[format];
  if (!intlConfig) {
    throw new Error("Only international formats should be used here");
  }
  if (formatRedirects[format] !== void 0) {
    return formatRedirects[format];
  }
  const intl = new Intl.DateTimeFormat(locale2, intlConfig), fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map((part) => {
    const type = part.type, intlCfg = intlConfig[type];
    if (type === "literal") {
      return part.value.replace(/,/g, "");
    } else if (type === "day") {
      return intlCfg === "numeric" ? "D" : "DD";
    } else if (type === "month") {
      return intlCfg === "short" ? "MMM" : intlCfg === "long" ? "MMMM" : intlCfg === "numeric" ? "M" : "MM";
    } else if (type === "year") {
      return intlCfg === "numeric" ? "YYYY" : "YY";
    }
  }).join("");
  return formatRedirects[format] = fmt;
};
var DEFAULT_YEAR = 2020;
var DEFAULT_MONTH = 0;
var DEFAULT_DAY = 1;
var intlFormatConfigs = {
  l: { year: "numeric", month: "numeric", day: "numeric" },
  ll: { year: "numeric", month: "short", day: "numeric" }
};
var formats = {
  // 1, 2, ... 11, 12
  M: (date) => date.getMonth() + 1,
  //date.toLocaleDateString(locale, { month : 'numeric' }),
  // 1st, 2nd, 3rd, 4th, ... 11th, 12th
  Mo: (date) => ordinalSuffix(formats.M(date).toString()),
  // 01, 02, ...
  MM: (date) => (date.getMonth() + 1).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { month : '2-digit' }),
  // Jan, Feb, ...
  MMM: (date) => useIntlFormat("MMM", { month: "short" }, date),
  // January, February, ...
  MMMM: (date) => useIntlFormat("MMMM", { month: "long" }, date),
  // 1, 2, ...
  Q: (date) => Math.ceil((date.getMonth() + 1) / 3),
  // 1st, 2nd, ...
  Qo: (date) => ordinalSuffix(formats.Q(date).toString()),
  // 1, 2, ...
  D: (date) => date.getDate(),
  //date.toLocaleDateString(locale, { day : 'numeric' }),
  // 1st, 2nd, ...
  Do: (date) => ordinalSuffix(formats.D(date).toString()),
  // 01, 02, ...
  DD: (date) => date.getDate().toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { day : '2-digit' }),
  // 1, 2, ..., 365, 365
  DDD: (date) => Math.ceil(
    (new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) - new Date(date.getFullYear(), 0, 0, 12, 0, 0)) / validConversions.day.millisecond
  ),
  // 1st, 2nd, ...
  DDDo: (date) => ordinalSuffix(formats.DDD(date).toString()),
  // 001, 002, ...
  DDDD: (date) => formats.DDD(date).toString().padStart(3, "0"),
  // 0, 1, ..., 6
  d: (date) => date.getDay(),
  // 0th, 1st, ...
  do: (date) => ordinalSuffix(date.getDay().toString()),
  // S, M, ...
  d1: (date) => useIntlFormat("d1", { weekday: "narrow" }, date).substr(0, 1),
  // Su, Mo, ...
  dd: (date) => formats.ddd(date).substring(0, 2),
  // Sun, Mon, ...
  ddd: (date) => useIntlFormat("ddd", { weekday: "short" }, date),
  // Sunday, Monday, ...
  dddd: (date) => useIntlFormat("dddd", { weekday: "long" }, date),
  u: (date) => {
    const formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;
  },
  uu: (date) => {
    const formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;
  },
  e: (date) => date.getDay(),
  E: (date) => date.getDay() + 1,
  // ISO week, 1, 2, ...
  W: (date) => DateHelper.getWeekNumber(date)[1],
  Wo: (date) => ordinalSuffix(formats.W(date).toString()),
  WW: (date) => formats.W(date).toString().padStart(2, "0"),
  // ISO week, 1, 2, ... with localized 'Week ' prefix
  Wp: (date) => `${DateHelper.localize("L{Week}")} ${formats.W(date)}`,
  WWp: (date) => `${DateHelper.localize("L{Week}")} ${formats.WW(date)}`,
  Wp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.W(date)}`,
  WWp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.WW(date)}`,
  // 1979, 2018
  Y: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // 79, 18
  YY: (date) => (date.getFullYear() % 100).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { year : '2-digit' }),
  // 1979, 2018
  YYYY: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // AM, PM
  A: (date) => date.getHours() < 12 ? "AM" : "PM",
  a: (date) => date.getHours() < 12 ? "am" : "pm",
  // 0, 1, ... 23
  H: (date) => date.getHours(),
  // 00, 01, ...
  HH: (date) => date.getHours().toString().padStart(2, "0"),
  // 1, 2, ... 12
  h: (date) => date.getHours() % 12 || 12,
  // 01, 02, ...
  hh: (date) => formats.h(date).toString().padStart(2, "0"),
  // 1, 2, ... 24
  k: (date) => date.getHours() || 24,
  // 01, 02, ...
  kk: (date) => formats.k(date).toString().padStart(2, "0"),
  // Locale specific (0 -> 24 or 1 AM -> 12 PM)
  K: (date) => formatTime("K", { hour: "numeric" }, date),
  // Locale specific (00 -> 24 or 1 AM -> 12 PM)
  KK: (date) => formatTime("KK", { hour: "2-digit" }, date),
  // 0, 1, ... 59
  m: (date) => date.getMinutes(),
  //date.toLocaleTimeString(locale, { minute : 'numeric' }),
  // 00, 01, ...
  mm: (date) => formats.m(date).toString().padStart(2, "0"),
  // 0, 1, ... 59
  s: (date) => date.getSeconds(),
  //date.toLocaleTimeString(locale, { second : 'numeric' }),
  // 00, 01, ...
  ss: (date) => formats.s(date).toString().padStart(2, "0"),
  // 0, 1, ... 9 which are 000, 100, 200 ... 900 in milliseconds
  S: (date) => Math.floor(date.getMilliseconds() / 100).toString(),
  // 00, 01, ... 99 which are 000, 010, 020 ... 990 in milliseconds
  SS: (date) => Math.floor(date.getMilliseconds() / 10).toString().padStart(2, "0"),
  // 000, 001, ... 999 in milliseconds
  SSS: (date) => date.getMilliseconds().toString().padStart(3, "0"),
  z: (date) => useIntlFormat("z", { timeZoneName: "short" }, date),
  zz: (date) => useIntlFormat("zz", { timeZoneName: "long" }, date),
  Z: (date) => DH.getGMTOffset(date),
  LT: (date) => formatTime("LT", { hour: "2-digit", minute: "2-digit" }, date),
  // if minutes is 0, doesn't show it
  LST: (date) => formatTime("LST", { hour: "numeric", minute: "2-digit" }, date, true),
  LTS: (date) => formatTime("LTS", { hour: "2-digit", minute: "2-digit", second: "2-digit" }, date),
  L: (date) => useIntlFormat("L", { year: "numeric", month: "2-digit", day: "2-digit" }, date),
  l: (date) => useIntlFormat("l", intlFormatConfigs.l, date),
  LL: (date) => useIntlFormat("LL", { year: "numeric", month: "long", day: "numeric" }, date),
  ll: (date) => useIntlFormat("ll", intlFormatConfigs.ll, date),
  LLL: (date) => useIntlFormat("LLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  lll: (date) => useIntlFormat("lll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  LLLL: (date) => useIntlFormat("LLLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "long"
  }, date),
  llll: (date) => useIntlFormat("llll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "short"
  }, date)
};
var formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length);
var formatRegexp = `^(?:${formatKeys.join("|")})`;
var emptyFn2 = () => ({});
var isNumber = (str) => numberRegex.test(str);
var parseMilliseconds = (str) => isNumber(str) && { milliseconds: parseInt(str.padEnd(3, "0").substring(0, 3)) };
var parsers = {
  YYYY: (str) => {
    const year = parseInt(str);
    return { year: year >= 1e3 && year <= 9999 ? year : NaN };
  },
  Y: (str) => ({ year: parseInt(str) }),
  YY: (str) => {
    const year = parseInt(str);
    return { year: year + (year > 1968 ? 1900 : 2e3) };
  },
  M: (str) => ({ month: parseInt(str) - 1 }),
  MM: (str) => ({ month: parseInt(str) - 1 }),
  Mo: (str) => ({ month: parseInt(str) - 1 }),
  MMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  MMMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  DD: (str) => ({ date: parseInt(str) }),
  D: (str) => ({ date: parseInt(str) }),
  Do: (str) => ({ date: parseInt(str) }),
  DDD: emptyFn2,
  DDDo: emptyFn2,
  DDDD: emptyFn2,
  d: emptyFn2,
  do: emptyFn2,
  d1: emptyFn2,
  dd: emptyFn2,
  ddd: emptyFn2,
  dddd: emptyFn2,
  Q: emptyFn2,
  Qo: emptyFn2,
  W: emptyFn2,
  Wo: emptyFn2,
  WW: emptyFn2,
  e: emptyFn2,
  E: emptyFn2,
  HH: (str) => ({ hours: parseInt(str) }),
  hh: (str) => ({ hours: parseInt(str) }),
  mm: (str) => ({ minutes: parseInt(str) }),
  H: (str) => ({ hours: parseInt(str) }),
  m: (str) => ({ minutes: parseInt(str) }),
  ss: (str) => ({ seconds: parseInt(str) }),
  s: (str) => ({ seconds: parseInt(str) }),
  S: parseMilliseconds,
  SS: parseMilliseconds,
  SSS: parseMilliseconds,
  A: (str) => ({ amPm: str.toLowerCase() }),
  a: (str) => ({ amPm: str.toLowerCase() }),
  L: "MM/DD/YYYY",
  LT: "HH:mm A",
  LTS: "HH:mm:ss A",
  l: { type: "dynamic", parser: () => redirectFormat("l") },
  ll: { type: "dynamic", parser: () => redirectFormat("ll") },
  // Can either be Z (=UTC, 0) or +-HH:MM
  Z: (str) => {
    if (!str || !timeZoneRegEx.test(str) && str !== "Z") {
      return null;
    }
    let timeZone = 0;
    if (str !== "Z") {
      const matches = timeZoneRegEx.exec(str);
      if (matches) {
        const sign = matches[1] === "+" ? 1 : -1, hours = parseInt(matches[2]) || 0, minutes = parseInt(matches[3]) || 0;
        timeZone = sign * (hours * 60 + minutes);
      } else {
        timeZone = -1 * (/* @__PURE__ */ new Date()).getTimezoneOffset();
      }
    }
    return { timeZone };
  }
};
var parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length);
var parserRegexp = new RegExp(`(${parserKeys.join("|")})`);
var localeStrRegExp = new RegExp("^(LL|LLL|lll|LLLL|llll)$");
var validConversions = {
  // The units below assume:
  // 30 days in a month, 91 days for a quarter and 365 for a year
  // 52 weeks per year, 4 per month, 13 per quarter
  // 3652 days per decade (assuming two of the years will be leap with 366 days)
  decade: {
    decade: 1,
    year: 10,
    quarter: 40,
    month: 120,
    week: 520,
    day: 3652,
    hour: 24 * 3652,
    minute: 1440 * 3652,
    second: 86400 * 3652,
    millisecond: 864e5 * 3652
  },
  year: {
    decade: 0.1,
    year: 1,
    quarter: 4,
    month: 12,
    week: 52,
    day: 365,
    hour: 24 * 365,
    minute: 1440 * 365,
    second: 86400 * 365,
    millisecond: 864e5 * 365
  },
  quarter: {
    decade: 1 / 40,
    year: 1 / 4,
    quarter: 1,
    month: 3,
    week: 4,
    day: 91,
    hour: 24 * 91,
    minute: 1440 * 91,
    second: 86400 * 91,
    millisecond: 864e5 * 91
  },
  month: {
    decade: 1 / 120,
    year: 1 / 12,
    quarter: 1 / 3,
    month: 1,
    week: 4,
    day: -30,
    hour: -24 * 30,
    minute: -1440 * 30,
    second: -86400 * 30,
    millisecond: -864e5 * 30
  },
  week: {
    decade: -1 / 520,
    year: -1 / 52,
    quarter: -1 / 13,
    month: -1 / 4,
    day: 7,
    hour: 168,
    minute: 10080,
    second: 604800,
    millisecond: 6048e5
  },
  day: {
    decade: -1 / 3652,
    year: -1 / 365,
    quarter: -1 / 91,
    month: -1 / 30,
    week: 1 / 7,
    hour: 24,
    minute: 1440,
    second: 86400,
    millisecond: 864e5
  },
  hour: {
    decade: -1 / (3652 * 24),
    year: -1 / (365 * 24),
    quarter: -1 / (91 * 24),
    month: -1 / (30 * 24),
    week: 1 / 168,
    day: 1 / 24,
    minute: 60,
    second: 3600,
    millisecond: 36e5
  },
  minute: {
    decade: -1 / (3652 * 1440),
    year: -1 / (365 * 1440),
    quarter: -1 / (91 * 1440),
    month: -1 / (30 * 1440),
    week: 1 / 10080,
    day: 1 / 1440,
    hour: 1 / 60,
    second: 60,
    millisecond: 6e4
  },
  second: {
    decade: -1 / (3652 * 86400),
    year: -1 / (365 * 86400),
    quarter: -1 / (91 * 86400),
    month: -1 / (30 * 86400),
    week: 1 / 604800,
    day: 1 / 86400,
    hour: 1 / 3600,
    minute: 1 / 60,
    millisecond: 1e3
  },
  millisecond: {
    decade: -1 / (3652 * 864e5),
    year: -1 / (365 * 864e5),
    quarter: -1 / (91 * 864e5),
    month: -1 / (30 * 864e5),
    week: 1 / 6048e5,
    day: 1 / 864e5,
    hour: 1 / 36e5,
    minute: 1 / 6e4,
    second: 1 / 1e3
  }
};
var normalizedUnits = {
  ms: "millisecond",
  milliseconds: "millisecond",
  s: "second",
  seconds: "second",
  m: "minute",
  mi: "minute",
  min: "minute",
  minutes: "minute",
  h: "hour",
  hours: "hour",
  d: "day",
  days: "day",
  w: "week",
  weeks: "week",
  M: "month",
  mo: "month",
  mon: "month",
  months: "month",
  q: "quarter",
  quarters: "quarter",
  y: "year",
  years: "year",
  dec: "decade",
  decades: "decade"
};
var withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i;
var noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i;
var canonicalUnitNames = [
  "millisecond",
  "second",
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year",
  "decade"
];
var canonicalUnitAbbreviations = [
  ["mil"],
  ["s", "sec"],
  ["m", "min"],
  ["h", "hr"],
  ["d"],
  ["w", "wk"],
  ["mo", "mon", "mnt"],
  ["q", "quar", "qrt"],
  ["y", "yr"],
  ["dec"]
];
var deltaUnits = [
  "decade",
  "year",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var dateProperties = [
  "milliseconds",
  "seconds",
  "minutes",
  "hours",
  "date",
  "month",
  "year"
];
var parseNumber = (n) => {
  const result = parseFloat(n);
  return isNaN(result) ? null : result;
};
var numberRegex = /^[0-9]+$/;
var timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/;
var unitMagnitudes = {
  millisecond: 0,
  second: 1,
  minute: 2,
  hour: 3,
  day: 4,
  week: 5,
  month: 6,
  quarter: 7,
  year: 8,
  decade: 9
};
var snapFns = {
  round(number, step = 1) {
    return Math.round(number / step) * step;
  },
  floor(number, step = 1) {
    return Math.floor(number / step) * step;
  },
  ceil(number, step = 1) {
    return Math.ceil(number / step) * step;
  }
};
var keyCache = {};
var _DateHelper = class _DateHelper extends Localizable_default() {
  static get $name() {
    return "DateHelper";
  }
  //region Parse & format
  /**
   * Get/set the default format used by `format()` and `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ssZ'`
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34Z'`).
   * @member {String}
   */
  static set defaultFormat(format) {
    DH._defaultFormat = format;
  }
  static get defaultFormat() {
    return DH._defaultFormat || "YYYY-MM-DDTHH:mm:ssZ";
  }
  /**
   * Get/set the default format used by `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ss.SSSZ'` or {@link #property-defaultFormat-static}
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34.123Z'`).
   * @member {String}
   */
  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }
  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || "YYYY-MM-DDTHH:mm:ss.SSSZ";
  }
  static buildParser(format) {
    const parts = format.split(parserRegexp), parser = [];
    if (parts.length === 1 || localeStrRegExp.test(format)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        if (index !== 0 || curr !== "") {
          if (parserRegexp.test(curr)) {
            const localeParsers = this.localize("L{parsers}") || {}, fn = localeParsers[curr] || parsers[curr];
            if (curr === "Z" && index < array.length - 2) {
              throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);
            }
            const parserObj = typeof fn === "function" || typeof fn === "string" ? fn : fn.parser();
            if (typeof parserObj === "string") {
              const nestedParsers = DH.buildParser(parserObj), lastItem = nestedParsers.pop();
              delete lastItem.last;
              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parserObj;
            }
          } else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, "pattern")) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }
    parser[parser.length - 1].last = true;
    return parser;
  }
  /**
   * A utility function to create a sortable string key for the passed date or ms timestamp using the `'YYYY-MM-DD'`
   * format.
   * @param {Number|Date} ms The Date instance or ms timestamp to generate a key for
   * @returns {String} Date/timestamp as a string with `'YYYY-M-D'` format
   * @internal
   */
  static makeKey(ms) {
    if (ms.length === 10) {
      return ms;
    }
    if (ms.getTime) {
      ms = ms.getTime();
    }
    const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];
    if (cached) {
      return cached;
    }
    tempDate.setTime(ms);
    const month2 = tempDate.getMonth() + 1, date = tempDate.getDate();
    return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate.getFullYear()}-${month2 < 10 ? "0" + month2 : month2}-${date < 10 ? "0" + date : date}`;
  }
  /**
   * A utility function to parse a sortable string to a date using the `'YYYY-MM-DD'` format.
   * @param {String} key The string to return a date for
   * @returns {Date} new Date instance
   * @internal
   */
  static parseKey(key) {
    return DH.parse(key, "YYYY-MM-DD");
  }
  /**
   * Returns a date created from the supplied string using the specified format. Will try to create even if format
   * is left out, by first using the default format (see {@link #property-defaultFormat-static}, by default
   * `YYYY-MM-DDTHH:mm:ssZ`) and then using `new Date(dateString)`.
   * Supported tokens:
   *
   * | Unit        | Token | Description                                      |
   * |-------------|-------|--------------------------------------------------|
   * | Year        | YYYY  | 4-digits year, like: 2018                        |
   * |             | Y     | numeric, any number of digits                    |
   * |             | YY    | < 68 -> 2000, > 68 -> 1900                       |
   * | Month       | MM    | 01 - 12                                          |
   * | Month       | MMM   | Short name of the month                          |
   * | Date        | DD    | 01 - 31                                          |
   * | Hour        | HH    | 00 - 23 or 1 - 12                                |
   * | Minute      | mm    | 00 - 59                                          |
   * | Second      | ss    | 00 - 59                                          |
   * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]                    |
   * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]                  |
   * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ]                |
   * | AM/PM       | A     | AM or PM                                         |
   * |             | a     | am or pm                                         |
   * | TimeZone    | Z     | Z for UTC or +-HH:mm. Local timezone if left out |
   * | Predefined  | L     | Long date, MM/DD/YYYY                            |
   * |             | LT    | Long time, HH:mm A                               |
   *
   * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale
   * `SvSE.js`.
   *
   * NOTE: If no date parameters are provided then `Jan 01 2020` is used as a default date.
   *
   * {@note}Note that date strings without timezone information ('Z' or '+-HH:mm') will be in the local timezone. Eg.
   * '2024-05-14' -> local time, '2024-05-14Z' -> UTC{/@note}
   *
   * @param {String} dateString Date string
   * @param {String} [format] Date format (or {@link #property-defaultParseFormat-static} if left out)
   * @returns {Date} new Date instance parsed from the string
   * @category Parse & format
   */
  static parse(dateString, format = DH.defaultParseFormat, strict = false) {
    if (dateString instanceof Date) {
      return dateString;
    }
    if (typeof dateString !== "string" || !dateString) {
      return null;
    }
    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };
    format = format.replace(msRegExp, msReplacer);
    let parser = parserCache[format], result;
    if (!parser) {
      parser = parserCache[format] = DH.buildParser(format);
    }
    if (dateString.includes("\u202F")) {
      dateString = dateString.replace(/\s/g, " ");
    }
    parser.reduce((dateString2, parser2) => {
      var _a4;
      if (parser2.last) {
        Object.assign(config, parser2.fn(dateString2));
      } else {
        let splitAt;
        if (parser2.splitter === "T" && dateString2.indexOf("T") === -1) {
          splitAt = dateString2.indexOf(" ");
        } else {
          const timeZoneIndex = dateString2.indexOf("+");
          let { splitter } = parser2;
          if (!strict && splitRegExp.test(splitter)) {
            splitter = splitRegExp;
          }
          splitAt = parser2.splitter !== "" ? dateString2.search(typeof splitter === "string" ? StringHelper.escapeRegExp(splitter) : splitter) : ((_a4 = parser2.pattern) == null ? void 0 : _a4.length) || -1;
          if (timeZoneIndex > -1 && splitAt > timeZoneIndex) {
            splitAt = -1;
          }
        }
        let part, rest;
        if (splitAt === -1 || parser2.pattern === "SSS" && dateString2.match(/^\d+Z$/)) {
          const chunks = dateString2.split(/([Z\-+])/);
          if (chunks.length === 1) {
            part = dateString2;
            rest = "";
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString2.substring(0, splitAt) || dateString2;
          rest = dateString2.substring(splitAt + parser2.splitter.length);
        }
        if (parser2.fn) {
          const res = parser2.fn(part);
          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }
        return rest;
      }
    }, dateString);
    if (config.year && !config.date) {
      config.date = 1;
    }
    if (config.date > 31 || config.month > 12) {
      return null;
    }
    const date = DH.create(config, strict);
    if (date) {
      result = date;
    } else if (!strict) {
      result = new Date(dateString);
    }
    return result;
  }
  /**
   * Creates a date from a date definition object. The object can have the following properties:
   * - year
   * - month
   * - date (day in month)
   * - hours
   * - minutes
   * - seconds
   * - milliseconds
   * - amPm : 'am' or 'pm', implies 12-hour clock
   * - timeZone : offset from UTC in minutes
   * @param {Object} definition
   * @param {Number} definition.year
   * @param {Number} [definition.month]
   * @param {Number} [definition.date]
   * @param {Number} [definition.hours]
   * @param {Number} [definition.minutes]
   * @param {Number} [definition.seconds]
   * @param {Number} [definition.milliseconds]
   * @param {Number} [definition.amPm]
   * @param {Number} [definition.timeZone]
   * @returns {Date} new Date instance
   * @category Parse & format
   */
  static create(definition, strict = false) {
    const def = { ...definition };
    let invalid = isNaN(def.year) || strict && (isNaN(def.month) || isNaN(def.date)), useUTC = false;
    if (!invalid) {
      let allNull = true;
      dateProperties.forEach((property) => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }
        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }
    if (invalid) {
      return null;
    }
    if (def.amPm === "am") {
      def.hours = def.hours % 12;
    } else if (def.amPm === "pm") {
      def.hours = def.hours % 12 + 12;
    }
    if ("timeZone" in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }
    if (strict && (def.year == null || def.month == null || def.date == null)) {
      return null;
    }
    const args = [
      defaultValue(def.year, DEFAULT_YEAR),
      defaultValue(def.month, DEFAULT_MONTH),
      defaultValue(def.date, DEFAULT_DAY),
      def.hours,
      def.minutes,
      def.seconds,
      def.milliseconds
    ];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }
  static toUTC(date) {
    return new Date(Date.UTC(
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds(),
      date.getUTCMilliseconds()
    ));
  }
  /**
   * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.
   * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):
   *
   * | Unit                  | Token | Description & output                  |
   * |-----------------------|-------|---------------------------------------|
   * | Year                  | YYYY  | 2018                                  |
   * |                       | YY    | 18                                    |
   * |                       | Y     | 2018                                  |
   * | Quarter               | Q     | 3                                     |
   * |                       | Qo    | 3rd                                   |
   * | Month                 | MMMM  | September                             |
   * |                       | MMM   | Sep                                   |
   * |                       | MM    | 09                                    |
   * |                       | Mo    | 9th                                   |
   * |                       | M     | 9                                     |
   * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |
   * |                       | Wo    | 37th                                  |
   * |                       | W     | 37                                    |
   * |                       | WWp   | Week 37 (localized prefix, zero pad)  |
   * |                       | Wp    | Week 37 (localized prefix)            |
   * |                       | WWp0  | W37 (localized prefix)                |
   * |                       | Wp0   | W37 (localized prefix)                |
   * | Date                  | DDDD  | Day of year, 3 digits                 |
   * |                       | DDDo  | Day of year, ordinal                  |
   * |                       | DDD   | Day of year                           |
   * |                       | DD    | 09                                    |
   * |                       | Do    | 9th                                   |
   * |                       | D     | 9                                     |
   * | Weekday               | dddd  | Sunday                                |
   * |                       | ddd   | Sun                                   |
   * |                       | dd    | Su                                    |
   * |                       | d1    | S                                     |
   * |                       | do    | 0th                                   |
   * |                       | d     | 0                                     |
   * | Hour                  | HH    | 18 (00 - 23)                          |
   * |                       | H     | 18 (0 - 23)                           |
   * |                       | hh    | 06 (00 - 12)                          |
   * |                       | h     | 6 (0 - 12)                            |
   * |                       | KK    | 19 (01 - 24)                          |
   * |                       | K     | 19 (1 - 24)                           |
   * |                       | kk    | 06 or 18, locale determines           |
   * |                       | k     | 6 or 18, locale determines            |
   * | Minute                | mm    | 07                                    |
   * |                       | m     | 7                                     |
   * | Second                | ss    | 08                                    |
   * |                       | s     | 8                                     |
   * | Millisecond           | S     | 1 (100ms)                             |
   * |                       | SS    | 14 (140ms)                            |
   * |                       | SSS   | 145 (145ms)                           |
   * | AM/PM                 | A     | AM or PM                              |
   * |                       | a     | am or pm                              |
   * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
   * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
   * |                       | LST   | Depends on 12 or 24 hour clock        |
   * |                       |       | 12h, H : 1d, m : 0 or 2d              |
   * |                       |       | 24h, H : 2d, m : 2d                   |
   * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
   * |                       | l     | Y: n, M : n, D : n                    |
   * |                       | LL    | Y: n, M : long (l), D : n             |
   * |                       | ll    | Y: n, M : short (s), D : n            |
   * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
   * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
   * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
   * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
   *
   * Some examples:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14
   * ```
   *
   * Arbitrary text can be embedded in the format string by wrapping it with {}:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
   * ```
   *
   * @param {Date} date Date
   * @param {String} [format] Desired format (uses `defaultFormat` if left out)
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static format(date, format = DH.defaultFormat) {
    if (!date || isNaN(date)) {
      return null;
    }
    let formatter = formatCache[format], output = "";
    if (!formatter) {
      formatter = formatCache[format] = [];
      for (let i = 0; i < format.length; i++) {
        const formatMatch = format.slice(i).match(formatRegexp), predefined = formatMatch == null ? void 0 : formatMatch[0];
        if (predefined) {
          const localeFormats = this.localize("L{formats}") || {}, fn = localeFormats[predefined] || formats[predefined];
          formatter.push(fn);
          i += predefined.length - 1;
        } else if (format[i] === "{") {
          const index = format.indexOf("}", i + 1);
          if (index === -1) {
            formatter.push(format.substr(i + 1));
            i = format.length;
          } else {
            formatter.push(format.substring(i + 1, index));
            i = index;
          }
        } else {
          formatter.push(format[i]);
        }
      }
    }
    formatter.forEach((step) => {
      if (typeof step === "string") {
        output += step;
      } else {
        output += step(date);
      }
    });
    return output;
  }
  /**
   * Formats a range of `dates` using the specified `format`. Because two dates are involved, the `format` specifier
   * uses the tokens `S{}` and `E{}`. The text contained between the `{}` is the {@link #function-format-static format}
   * for the start date or end date, respectively. Text not inside these tokens is retained verbatim.
   *
   * For example:
   *
   * ```javascript
   *  DateHelper.formatRange(dates, 'S{DD MMM YYYY} - E{DD MMM YYYY}');
   * ```
   *
   * The above will format `dates[0]` based on the `S{DD MMM YYYY}` segment and `dates[1] using `E{DD MMM YYYY}`. The
   * `' - '` between these will remain between the two formatted dates.
   *
   * @param {Date[]} dates An array of start date and end date (`[startDate, endDate]`)
   * @param {String} format The format specifier
   * @returns {String}
   */
  static formatRange(dates, format) {
    return format.replace(
      rangeFormatPartRe,
      (s, which, fmt) => _DateHelper.format(dates[which === "S" ? 0 : 1], fmt)
    );
  }
  /**
   * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the
   * first argument, it then uses `amount = 1`.
   *
   * For example:
   *
   * ```javascript
   * asMilliseconds('hour') == asMilliseconds(1, 'hour')
   * ```
   *
   * @param {Number|String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)
   * @param {String} [unit] Time unit (s, hour, months etc.)
   * @returns {Number}
   * @category Parse & format
   */
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === "string") {
      unit = amount;
      amount = 1;
    }
    return DH.as("millisecond", amount, unit);
  }
  /**
   * Converts the passed Date to an accurate number of months passed since the epoch start.
   * @param {Date} time The Date to find the month value of
   * @returns {Number} The number of months since the system time epoch start. May be a fractional value
   */
  static asMonths(time) {
    const monthLength = DH.as("ms", DH.daysInMonth(time), "day"), fraction = (time.valueOf() - DH.startOf(time, "month").valueOf()) / monthLength;
    return time.getYear() * 12 + time.getMonth() + fraction;
  }
  static monthsToDate(months) {
    const intMonths = Math.floor(months), fraction = months - intMonths, result = new Date(0, intMonths), msInMonth = DH.as("ms", DH.daysInMonth(result), "days");
    result.setTime(result.getTime() + fraction * msInMonth);
    return result;
  }
  /**
   * Converts a millisecond time delta to a human-readable form. For example `1000 * 60 * 60 * 50`
   * milliseconds would be rendered as `'2 days, 2 hours'`.
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `'2d, 2h'` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {String} [options.separator] The separator to use
   * @param {Boolean} [options.asString] Pass `false` to return the result as an array, eg ['2d', '2h'] for the above example
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static formatDelta(delta, options) {
    let abbrev, unitName;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
    }
    const deltaObj = this.getDelta(delta, options), result = [], sep = (options == null ? void 0 : options.separator) || (abbrev ? "" : " ");
    for (unitName in deltaObj) {
      result.push(`${deltaObj[unitName]}${sep}${unitName}`);
    }
    return (options == null ? void 0 : options.asString) === false ? result : result.join(", ");
  }
  /**
   * Converts a millisecond time delta to an object structure. For example `1000 * 60 * 60 * 50`
   * milliseconds the result would be as:
   *
   * ```javascript
   * {
   *     day  : 2,
   *     hour : 2
   * }
   *```
   *
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `{ d: 2, h: 2 }` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {Boolean} [options.ignoreLocale] Pass true to return unlocalized unit name. Requires `abbrev` to be false
   * @param {String} [options.maxUnit] Name of the maximum unit in the output. e.g. if you pass `day` then you'll get
   * `{ h: 25 }` instead of `{ d: 1, h: 1 }`
   * @returns {Object} The object with the values for each unit
   */
  static getDelta(delta, options) {
    let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
      precision = DH.normalizeUnit(options.precision);
      maxUnit = options.maxUnit;
      ignoreLocale = !abbrev && options.ignoreLocale;
    }
    const result = {}, getUnit = abbrev ? DH.getShortNameOfUnit : DH.getLocalizedNameOfUnit;
    const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;
    for (unitName of units) {
      d = DH.as(unitName, delta);
      done = precision === unitName;
      d = Math[done ? "round" : "floor"](d);
      if (d || done && !result.length) {
        result[ignoreLocale ? unitName : getUnit.call(DH, unitName, d !== 1)] = d;
        delta -= DH.as("ms", d, unitName);
      }
      if (done || !delta) {
        break;
      }
    }
    return result;
  }
  /**
   * Converts the specified amount of one unit (`fromUnit`) into an amount of another unit (`toUnit`).
   * @param {String} toUnit The name of units to convert to, eg: `'ms'`
   * @param {Number|String} amount The time to convert. Either the magnitude number form or a duration string such as '2d'
   * @param {String} [fromUnit='ms'] If the amount was passed as a number, the units to use to convert from
   * @returns {Number}
   * @category Parse & format
   */
  static as(toUnit, amount, fromUnit = "ms") {
    if (typeof amount === "string") {
      amount = DH.parseDuration(amount);
    }
    if (typeof amount === "object") {
      fromUnit = amount.unit;
      amount = amount.magnitude;
    }
    if (toUnit === fromUnit) {
      return amount;
    }
    toUnit = DH.normalizeUnit(toUnit);
    fromUnit = DH.normalizeUnit(fromUnit);
    if (toUnit === fromUnit) {
      return amount;
    } else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }
  static formatContainsHourInfo(format) {
    const stripEscapeRe = /(\\.)/g, hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format.replace(stripEscapeRe, ""));
  }
  /**
   * Returns `true` for 24-hour format.
   * @param {String} format Date format
   * @returns {Boolean} `true` for 24-hour format
   * @category Parse & format
   */
  static is24HourFormat(format) {
    return DH.format(DH.getTime(13, 0, 0), format).includes("13");
  }
  //endregion
  //region Manipulate
  /**
   * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.
   * @param {Date|String} date Original date
   * @param {Number|String|Core.data.Duration|DurationConfig} amount Amount of days, hours etc. or a string representation of a duration
   * as accepted by {@link #function-parseDuration-static} or an object with `{ magnitude, unit }` properties
   * @param {DurationUnitShort} [unit='ms'] Unit for amount
   * @privateparam {Boolean} [clone=true] Pass `false` to affect the original
   * @returns {Date} New calculated date
   * @category Manipulate
   */
  static add(date, amount, unit = "ms", clone = true) {
    let d;
    if (typeof date === "string") {
      d = DH.parse(date);
    } else if (clone) {
      d = new Date(date.getTime());
    } else {
      d = date;
    }
    if (typeof amount === "string") {
      const duration = _DateHelper.parseDuration(amount);
      amount = duration.magnitude;
      unit = duration.unit;
    } else if (amount && typeof amount === "object") {
      unit = amount.unit;
      amount = amount.magnitude;
    }
    if (!unit || amount === 0) {
      return d;
    }
    unit = DH.normalizeUnit(unit);
    switch (unit) {
      case "millisecond":
        d.setTime(d.getTime() + amount);
        break;
      case "second":
        d.setTime(d.getTime() + amount * 1e3);
        break;
      case "minute":
        d.setTime(d.getTime() + amount * 6e4);
        break;
      case "hour":
        d.setTime(d.getTime() + amount * 36e5);
        break;
      case "day":
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
          if (d.getHours() === 23 && date.getHours() === 0) {
            d.setHours(d.getHours() + 1);
          }
        } else {
          d.setTime(d.getTime() + amount * 864e5);
        }
        break;
      case "week":
        d.setDate(d.getDate() + amount * 7);
        break;
      case "month": {
        let day2 = d.getDate();
        if (day2 > 28) {
          day2 = Math.min(day2, DH.getLastDateOfMonth(DH.add(DH.getFirstDateOfMonth(d), amount, "month")).getDate());
        }
        d.setDate(day2);
        d.setMonth(d.getMonth() + amount);
        break;
      }
      case "quarter":
        DH.add(d, amount * 3, "month", false);
        break;
      case "year":
        d.setFullYear(d.getFullYear() + amount);
        break;
      case "decade":
        d.setFullYear(d.getFullYear() + amount * 10);
        break;
    }
    return d;
  }
  /**
   * Calculates the difference between two dates, in the specified unit.
   * @param {Date} start First date
   * @param {Date} end Second date
   * @param {DurationUnitShort} [unit='ms'] Unit to calculate difference in
   * @param {Boolean} [fractional=true] Specify false to round result
   * @returns {Number} Difference in the specified unit
   * @category Manipulate
   */
  static diff(start, end, unit = "ms", fractional = true) {
    unit = DH.normalizeUnit(unit);
    if (!start || !end)
      return 0;
    let amount;
    switch (unit) {
      case "year":
        amount = DH.diff(start, end, "month") / 12;
        break;
      case "quarter":
        amount = DH.diff(start, end, "month") / 3;
        break;
      case "month":
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        if (amount === 0 && fractional) {
          amount = DH.diff(start, end, "day", fractional) / DH.daysInMonth(start);
        }
        break;
      case "week":
        amount = DH.diff(start, end, "day") / 7;
        break;
      case "day": {
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1e3) / 864e5;
        break;
      }
      case "hour":
        amount = (end - start) / 36e5;
        break;
      case "minute":
        amount = (end - start) / 6e4;
        break;
      case "second":
        amount = (end - start) / 1e3;
        break;
      case "millisecond":
        amount = end - start;
        break;
    }
    return fractional ? amount : Math.round(amount);
  }
  /**
   * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it
   * in place.
   * @param {Date} date Original date
   * @param {String} [unit='day'] Start of this unit, `'day'`, `'month'` etc
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @param {Number} [weekStartDay] The first day of week, `0-6` (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static startOf(date, unit = "day", clone = true, weekStartDay = DH.weekStartDay) {
    if (!date) {
      return null;
    }
    unit = DH.normalizeUnit(unit);
    if (clone) {
      date = DH.clone(date);
    }
    switch (unit) {
      case "year":
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "quarter":
        date.setMonth((DH.get(date, "quarter") - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "month":
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "week": {
        const dayOfWeek = date.getDay();
        let delta = dayOfWeek - weekStartDay;
        if (delta < 0) {
          delta += 7;
        }
        date.setDate(date.getDate() - delta);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      case "day":
        date.setHours(0, 0, 0, 0);
        return date;
      case "hour":
        date.getMinutes() > 0 && date.setMinutes(0);
      case "minute":
        date.getSeconds() > 0 && date.setSeconds(0);
      case "second":
        date.getMilliseconds() > 0 && date.setMilliseconds(0);
      case "millisecond":
        return date;
    }
  }
  /**
   * Returns the end point of the passed date, that is 00:00:00 of the day after the passed date.
   * @param {Date} date The date to return the end point of
   * @returns {Date} Manipulated date
   */
  static endOf(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  }
  /**
   * Creates a clone of the specified date
   * @param {Date} date Original date
   * @returns {Date} Cloned date
   * @category Manipulate
   */
  static clone(date) {
    return new Date(date.getTime());
  }
  /**
   * Removes time from a date (same as calling {@link #function-startOf-static startOf(date)}).
   * @param {Date} date Date to remove time from
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static clearTime(date, clone = true) {
    if (!date) {
      return null;
    }
    if (clone) {
      date = new Date(date.getTime());
    }
    date.setHours(0, 0, 0, 0);
    return date;
  }
  static midnight(date, inclusive) {
    let ret = DH.clearTime(date);
    if (inclusive && ret < date) {
      ret = DH.add(ret, 1, "d");
    }
    return ret;
  }
  /**
   * Returns the elapsed milliseconds from the start of the specified date.
   * @param {Date} date Date to remove date from
   * @param {DurationUnitShort} [unit='ms'] The time unit to return
   * @returns {Number} The elapsed milliseconds from the start of the specified date
   * @category Manipulate
   */
  static getTimeOfDay(date, unit = "ms") {
    const t = date.getHours() * validConversions.hour.millisecond + date.getMinutes() * validConversions.minute.millisecond + date.getSeconds() * validConversions.second.millisecond + date.getMilliseconds();
    return unit === "ms" ? t : DH.as(unit, t, "ms");
  }
  /**
   * Sets a part of a date (in place).
   * @param {Date} date Date to manipulate
   * @param {String|Object} unit Part of date to set, for example `'minute'`. Or an object like `{ second: 1, minute: 1 }`
   * @param {Number} amount Value to set
   * @returns {Date} Passed date instance modified according to the arguments
   * @category Manipulate
   */
  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }
    if (typeof unit === "string") {
      switch (DH.normalizeUnit(unit)) {
        case "millisecond":
          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }
          break;
        case "second":
          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }
          break;
        case "minute":
          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }
          break;
        case "hour":
          date.setHours(amount);
          break;
        case "day":
        case "date":
          date.setDate(amount);
          break;
        case "week":
          throw new Error("week not implemented");
        case "month":
          date.setMonth(amount);
          break;
        case "quarter":
          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;
        case "year":
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit).sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit2, amount2]) => {
        DH.set(date, unit2, amount2);
      });
    }
    return date;
  }
  static setDateToMidday(date, clone = true) {
    return DH.set(DH.clearTime(date, clone), "hour", 12);
  }
  /**
   * Constrains the date within a min and a max date.
   * @param {Date} date The date to constrain
   * @param {Date} [min] Min date
   * @param {Date} [max] Max date
   * @returns {Date} The constrained date
   * @category Manipulate
   */
  static constrain(date, min2, max) {
    if (min2 != null) {
      date = DH.max(date, min2);
    }
    return max == null ? date : DH.min(date, max);
  }
  /**
   * Returns time with default year, month, and day (Jan 1, 2020).
   * @param {Number|Date} hours Hours value or the full date to extract the time of
   * @param {Number} [minutes=0] Minutes value
   * @param {Number} [seconds=0] Seconds value
   * @param {Number} [ms=0] Milliseconds value
   * @returns {Date} A new default date with the time extracted from the given date or from the time values provided individually
   * @category Manipulate
   */
  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }
    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }
  /**
   * Copies hours, minutes, seconds, milliseconds from one date to another.
   *
   * @param {Date} targetDate The target date
   * @param {Date} sourceDate The source date
   * @returns {Date} The adjusted target date
   * @category Manipulate
   * @static
   */
  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }
  //endregion
  //region Comparison
  static get isDSTEnabled() {
    const year = (/* @__PURE__ */ new Date()).getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return jan.getTimezoneOffset() !== jul.getTimezoneOffset();
  }
  static isDST(date) {
    const year = date.getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }
  /**
   * Determines if a date precedes another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first precedes second, otherwise false
   * @category Comparison
   */
  static isBefore(first, second) {
    return first < second;
  }
  /**
   * Determines if a date succeeds another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first succeeds second, otherwise false
   * @category Comparison
   */
  static isAfter(first, second) {
    return first > second;
  }
  /**
   * Checks if two dates are equal.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Boolean} `true` if the dates are equal
   * @category Comparison
   */
  static isEqual(first, second, unit = null) {
    if (unit === null) {
      return first && second && first.getTime() === second.getTime();
    }
    return DH.startOf(first, unit) - DH.startOf(second, unit) === 0;
  }
  /**
   * Compares two dates using the specified precision.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Number} `0` = equal, `-1` = first before second, `1` = first after second
   * @category Comparison
   */
  static compare(first, second, unit = null) {
    if (unit) {
      first = DH.startOf(first, unit);
      second = DH.startOf(second, unit);
    }
    if (first < second)
      return -1;
    if (first > second)
      return 1;
    return 0;
  }
  /**
   * Coerces the passed Date between the passed minimum and maximum values.
   * @param {Date} date The date to clamp between the `min` and `max`
   * @param {Date} min The minimum Date
   * @param {Date} max The maximum Date
   * @returns {Date} If the passed `date` is valid, a *new* Date object which is clamped between the `min` and `max`
   */
  static clamp(date, min2, max) {
    if (!isNaN(date)) {
      if (min2 != null) {
        date = Math.max(date, min2);
      }
      if (max != null) {
        date = Math.min(date, max);
      }
      return new Date(date);
    }
  }
  static isSameDate(first, second) {
    return DH.compare(first, second, "d") === 0;
  }
  static isSameTime(first, second) {
    return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds() && first.getMilliseconds() === second.getMilliseconds();
  }
  /**
   * Checks if date is the start of specified unit.
   * @param {Date} date Date
   * @param {DurationUnit} unit Time unit
   * @returns {Boolean} `true` if date is the start of specified unit
   * @category Comparison
   */
  static isStartOf(date, unit) {
    return DH.isEqual(date, DH.startOf(date, unit));
  }
  /**
   * Checks if this date is `>= start` and `< end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesser(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }
  /**
   * Checks if this date is `>= start` and `<= end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }
  /**
   * Returns `true` if dates intersect.
   * @param {Date} date1Start Start date of first span
   * @param {Date} date1End End date of first span
   * @param {Date} date2Start Start date of second span
   * @param {Date} date2End End date of second span
   * @returns {Boolean} Returns `true` if dates intersect
   * @category Comparison
   */
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return DH.betweenLesser(date1Start, date2Start, date2End) || DH.betweenLesser(date2Start, date1Start, date1End);
  }
  /**
   * Compare two units. Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal.
   * @param {DurationUnit} unit1 The 1st unit
   * @param {DurationUnit} unit2 The 2nd unit
   * @returns {Number} Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal
   * @category Comparison
   */
  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[DH.normalizeUnit(unit1)] - unitMagnitudes[DH.normalizeUnit(unit2)]);
  }
  /**
   * Returns `true` if the first time span completely 'covers' the second time span.
   *
   * ```javascript
   * DateHelper.timeSpanContains(
   *     new Date(2010, 1, 2),
   *     new Date(2010, 1, 5),
   *     new Date(2010, 1, 3),
   *     new Date(2010, 1, 4)
   * ) ==> true
   * DateHelper.timeSpanContains(
   *   new Date(2010, 1, 2),
   *   new Date(2010, 1, 5),
   *   new Date(2010, 1, 3),
   *   new Date(2010, 1, 6)
   * ) ==> false
   * ```
   *
   * @param {Date} spanStart The start date for initial time span
   * @param {Date} spanEnd The end date for initial time span
   * @param {Date} otherSpanStart The start date for the 2nd time span
   * @param {Date} otherSpanEnd The end date for the 2nd time span
   * @returns {Boolean} `true` if the first time span completely 'covers' the second time span
   * @category Comparison
   */
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }
  //endregion
  //region Query
  /**
   * Get the first day of week, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.weekStartDay` parameter.
   * @property {Number}
   * @readonly
   */
  static get weekStartDay() {
    if (DH._weekStartDay == null) {
      DH._weekStartDay = this.localize("L{weekStartDay}") || 0;
    }
    return DH._weekStartDay;
  }
  /**
   * Get non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   *
   * @property {Object<Number,Boolean>}
   * @readonly
   */
  static get nonWorkingDays() {
    return { ...this.localize("L{nonWorkingDays}") };
  }
  /**
   * Get non-working days as an array of day indices, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   *
   * ```javascript
   * [ 0, 6 ] // Sunday & Saturday
   * ```
   *
   * @property {Number[]}
   * @readonly
   * @internal
   */
  static get nonWorkingDaysAsArray() {
    return Object.keys(this.nonWorkingDays).map(Number);
  }
  /**
   * Get weekend days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * Weekends are days which are declared as weekend days by the selected country and defined by the current locale's
   * `DateHelper.weekends` parameter.
   * To get non-working days see {@link #property-nonWorkingDays-static}.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   * @property {Object<Number,Boolean>}
   * @readonly
   * @internal
   */
  static get weekends() {
    return { ...this.localize("L{weekends}") };
  }
  /**
   * Get the specified part of a date.
   * @param {Date} date
   * @param {DurationUnit} unit Part of date, hour, minute etc.
   * @returns {Number} The requested part of the specified date
   * @category Query
   */
  static get(date, unit) {
    switch (DH.normalizeUnit(unit)) {
      case "millisecond":
        return date.getMilliseconds();
      case "second":
        return date.getSeconds();
      case "minute":
        return date.getMinutes();
      case "hour":
        return date.getHours();
      case "date":
      case "day":
        return date.getDate();
      case "week":
        return formats.W(date);
      case "month":
        return date.getMonth();
      case "quarter":
        return Math.floor(date.getMonth() / 3) + 1;
      case "year":
        return date.getFullYear();
    }
    return null;
  }
  /**
   * Get number of days in the current year for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Days in year
   * @category Query
   * @internal
   */
  static daysInYear(date) {
    const fullYear = date.getFullYear(), duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);
    return this.as("day", duration);
  }
  /**
   * Get number of days in the current month for the supplied date.
   * @param {Date} date Date which month should be checked
   * @returns {Number} Days in month
   * @category Query
   */
  static daysInMonth(date) {
    return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();
  }
  /**
   * Get number of hours in the current day for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Hours in day
   * @category Query
   * @internal
   */
  static hoursInDay(date) {
    const fullYear = date.getFullYear(), month2 = date.getMonth(), day2 = date.getDate(), duration = new Date(fullYear, month2, day2 + 1) - new Date(fullYear, month2, day2);
    return this.as("hour", duration);
  }
  /**
   * Converts unit related to the date to actual amount of milliseconds in it. Takes into account leap years and
   * different duration of months.
   * @param {Date} date Date
   * @param {DurationUnit} unit Time unit
   * @returns {Number} Returns amount of milliseconds
   * @internal
   */
  static getNormalizedUnitDuration(date, unit) {
    let result;
    switch (unit) {
      case "month":
        result = DH.asMilliseconds(DH.daysInMonth(date), "day");
        break;
      case "year":
        result = DH.asMilliseconds(DH.daysInYear(date), "day");
        break;
      case "day":
        result = DH.asMilliseconds(DH.hoursInDay(date), "hour");
        break;
      default:
        result = DH.asMilliseconds(unit);
    }
    return result;
  }
  /**
   * Get the first date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }
  /**
   * Get the last date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }
  /**
   * Get the earliest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Earliest date
   * @category Query
   */
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }
  /**
   * Get the latest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Latest date
   * @category Query
   */
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }
  /**
   * Get an incremented date. Incrementation based on specified unit and optional amount.
   * @param {Date} date Date
   * @param {DurationUnit} unit Time unit
   * @param {Number} [increment=1] Increment amount
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   * @category Query
   */
  static getNext(date, unit, increment = 1, weekStartDay = DH.weekStartDay) {
    if (unit === "week") {
      const dt = DH.clone(date), day2 = dt.getDay();
      DH.startOf(dt, "day", false);
      DH.add(dt, weekStartDay - day2 + 7 * (increment - (weekStartDay <= day2 ? 0 : 1)), "day", false);
      if (dt.getDay() !== weekStartDay) {
        DH.add(dt, 1, "hour");
      }
      return dt;
    }
    return DH.startOf(DH.add(date, increment, unit), unit, false);
  }
  /**
   * Checks if date object is valid.
   *
   * For example:
   *
   * ```javascript
   * date = new Date('foo')
   * date instanceof Date // true
   * date.toString() // Invalid Date
   * isNaN(date) // true
   * DateHelper.isValidDate(date) // false
   *
   * date = new Date()
   * date instanceof Date // true
   * date.toString() // Mon Jan 13 2020 18:27:38 GMT+0300 (GMT+03:00)
   * isNaN(date) // false
   * DateHelper.isValidDate(date) // true
   * ```
   *
   * @param {Date} date Date
   * @returns {Boolean} `true` if date object is valid
   */
  static isValidDate(date) {
    return DH.isDate(date) && !isNaN(date);
  }
  /**
   * Checks if value is a date object. Allows to recognize date object even from another context,
   * like the top frame when used in an iframe.
   *
   * @param {*} value Value to check
   * @returns {Boolean} `true` if value is a date object
   */
  static isDate(value) {
    return value && toString3.call(value) === DATE_TYPE2;
  }
  /**
   * Get the start of the next day.
   * @param {Date} date Date
   * @param {Boolean} [clone=false] Clone date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} Passed Date or new Date instance, depending on the `clone` flag
   * @category Query
   */
  static getStartOfNextDay(date, clone = false, noNeedToClearTime = false) {
    let nextDay = DH.add(noNeedToClearTime ? date : DH.clearTime(date, clone), 1, "day");
    if (nextDay.getDate() === date.getDate()) {
      const offsetNextDay = DH.add(DH.clearTime(date, clone), 2, "day").getTimezoneOffset(), offsetDate = date.getTimezoneOffset();
      nextDay = DH.add(nextDay, offsetDate - offsetNextDay, "minute");
    }
    return nextDay;
  }
  /**
   * Get the end of previous day.
   * @param {Date} date Date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} New Date instance
   * @category Query
   */
  static getEndOfPreviousDay(date, noNeedToClearTime = false) {
    const dateOnly = noNeedToClearTime ? date : DH.clearTime(date, true);
    if (dateOnly - date) {
      return dateOnly;
    } else {
      return DH.add(dateOnly, -1, "day");
    }
  }
  /**
   * Returns a string describing the specified week. For example, `'39, September 2020'` or `'40, Sep - Oct 2020'`.
   * @param {Date} startDate Start date
   * @param {Date} [endDate] End date
   * @returns {String} String describing the specified week
   * @internal
   */
  static getWeekDescription(startDate, endDate = startDate) {
    const monthDesc = startDate.getMonth() === endDate.getMonth() ? _DateHelper.format(startDate, "MMMM") : `${_DateHelper.format(startDate, "MMM")} - ${_DateHelper.format(endDate, "MMM")}`, week = _DateHelper.getWeekNumber(startDate);
    return `${week[1]}, ${monthDesc} ${week[0]}`;
  }
  /**
   * Get week number for the date.
   * @param {Date} date The date
   * @param {Number} [weekStartDay] The first day of week, 0-6 (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Number[]} year and week number
   * @category Query
   */
  static getWeekNumber(date, weekStartDay = _DateHelper.weekStartDay) {
    const jan01 = new Date(date.getFullYear(), 0, 1), dec31 = new Date(date.getFullYear(), 11, 31), firstDay = normalizeDay(jan01.getDay() - weekStartDay), lastDay = normalizeDay(dec31.getDay() - weekStartDay), dayNumber = getDayDiff(date, jan01);
    let weekNumber;
    if (firstDay < 4) {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;
    } else {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);
    }
    if (weekNumber) {
      let year = date.getFullYear();
      if (weekNumber === 53 && lastDay < 3) {
        year++;
        weekNumber = 1;
      }
      return [year, weekNumber];
    }
    const lastWeekOfLastYear = _DateHelper.getWeekNumber(new Date(date.getFullYear() - 1, 11, 31))[1];
    return [date.getFullYear() - 1, lastWeekOfLastYear];
  }
  //endregion
  //region Unit helpers
  /**
   * Turns `(10, 'day')` into `'10 days'` etc.
   * @param {Number} count Amount of unit
   * @param {DurationUnit} unit Unit, will be normalized (days, d -> day etc.)
   * @returns {String} Amount formatted to string
   * @category Unit helpers
   */
  static formatCount(count, unit) {
    unit = DH.normalizeUnit(unit);
    if (count !== 1)
      unit += "s";
    return count + " " + unit;
  }
  /**
   * Get the ratio between two units ( year, month -> 1/12 ).
   * @param {DurationUnit} baseUnit Base time unit
   * @param {DurationUnit} unit Time unit
   * @param {Boolean} [acceptEstimate=false] If `true`, process negative values of validConversions
   * @returns {Number} Ratio
   * @category Unit helpers
   */
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DH.normalizeUnit(baseUnit);
    unit = DH.normalizeUnit(unit);
    if (baseUnit === unit)
      return 1;
    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DH.as(unit, 1, baseUnit);
    }
    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DH.as(baseUnit, 1, unit);
    }
    return -1;
  }
  /**
   * Returns a localized abbreviated form of the name of the duration unit.
   * For example in the `EN` locale, for `'qrt'` it will return `'q'`.
   * @param {DurationUnit} unit Duration unit
   * @returns {String} Localized abbreviated form of the name of the duration unit
   * @category Unit helpers
   */
  static getShortNameOfUnit(unit) {
    unit = DH.parseTimeUnit(unit);
    return DH.unitLookup[unit].abbrev;
  }
  /**
   * Returns a localized full name of the duration unit.
   *
   * For example in the `EN` locale, for `'d'` it will return either
   * `'day'` or `'days'`, depending on the `plural` argument
   *
   * Preserves casing of first letter.
   *
   * @static
   * @param {DurationUnit} unit Time unit
   * @param {Boolean} [plural=false] Whether to return a plural name or singular
   * @returns {String} Localized full name of the duration unit
   * @category Unit helpers
   */
  static getLocalizedNameOfUnit(unit, plural = false) {
    const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();
    unit = DH.normalizeUnit(unit);
    unit = DH.parseTimeUnit(unit);
    unit = DH.unitLookup[unit][plural ? "plural" : "single"];
    if (capitalize) {
      unit = StringHelper.capitalize(unit);
    }
    return unit;
  }
  /**
   * Normalizes a unit for easier usage in conditionals. For example `'year'`, `'years'`, `'y'` -> `'year'`.
   * @param {DurationUnit} unit Time unit
   * @returns {String} Normalized unit name
   * @category Unit helpers
   */
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }
    const unitLower = unit.toLowerCase();
    if (unitLower === "date") {
      return unitLower;
    }
    return canonicalUnitNames.includes(unitLower) ? unitLower : normalizedUnits[unit] || normalizedUnits[unitLower];
  }
  static getUnitByName(name) {
    return DH.normalizeUnit(name) || DH.normalizeUnit(DH.parseTimeUnit(name));
  }
  /**
   * Returns a duration of the timeframe in the given unit.
   * @param {Date} start The start date of the timeframe
   * @param {Date} end The end date of the timeframe
   * @param {DurationUnit} unit Duration unit
   * @privateparam {Boolean} [doNotRound]
   * @returns {Number} The duration in the units
   * @category Unit helpers
   * @ignore
   */
  static getDurationInUnit(start, end, unit, doNotRound) {
    return DH.diff(start, end, unit, doNotRound);
  }
  /**
   * Checks if two date units align.
   * @private
   * @param {String} majorUnit Major time unit
   * @param {String} minorUnit Minor time unit
   * @returns {Boolean} `true` if two date units align
   * @category Unit helpers
   */
  static doesUnitsAlign(majorUnit, minorUnit) {
    return !(majorUnit !== minorUnit && minorUnit === "week");
  }
  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] - 1] || null;
  }
  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] + 1] || null;
  }
  /**
   * Rounds the passed Date value to the nearest `increment` value.
   *
   * Optionally may round relative to a certain base time point.
   *
   * For example `DH.round(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would round to 9:45 because that's the nearest integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when rounding to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to round
   * @param {String|Number} increment A millisecond value by which to round the time
   * May be specified in string form eg: `'15 minutes'`
   * @param {Date} [base] The start from which to apply the rounding
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static round(time, increment, base, weekStartDay) {
    return DH.snap("round", time, increment, base, weekStartDay);
  }
  /**
   * Floor the passed Date value to the nearest `increment` value.
   *
   * Optionally may floor relative to a certain base time point.
   *
   * For example `DH.floor(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would floor to 9:15 because that's the closest lower integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when flooring to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to floor
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to floor the time.
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the flooring
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static floor(time, increment, base, weekStartDay) {
    return DH.snap("floor", time, increment, base, weekStartDay);
  }
  /**
   * Ceils the passed Date value to the nearest `increment` value.
   *
   * Optionally may ceil relative to a certain base time point.
   *
   * For example `DH.ceil(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would ceil to 9:45 because that's the closest higher integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when ceiling to weeks. Use weekStartDay argument which default to the configured
   * {@link #property-weekStartDay-static} dictates what the base of a week is
   *
   * @param {Date} time The time to ceil
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to ceil the time
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the ceiling
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static ceil(time, increment, base, weekStartDay) {
    return DH.snap("ceil", time, increment, base, weekStartDay);
  }
  /**
   * Implementation for round, floor and ceil.
   * @internal
   */
  static snap(operation, time, increment, base, weekStartDay = DH.weekStartDay) {
    const snapFn = snapFns[operation];
    if (typeof increment === "string") {
      increment = DH.parseDuration(increment);
    }
    if (Objects.isObject(increment)) {
      const magnitude = increment.magnitude || increment.increment;
      switch (increment.unit) {
        case "week": {
          if (!base) {
            const weekDay = time.getDay();
            base = DH.add(
              DH.clearTime(time),
              weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7),
              "day"
            );
          }
          return DH[operation](time, `${magnitude * 7} days`, base);
        }
        case "month": {
          time = DH.asMonths(time);
          let resultMonths;
          if (base) {
            base = DH.asMonths(base);
            resultMonths = base + snapFn(time - base, magnitude);
          } else {
            resultMonths = snapFn(time, magnitude);
          }
          return DH.monthsToDate(resultMonths);
        }
        case "quarter":
          return DH[operation](time, `${magnitude * 3} months`, base);
        case "year":
          return DH[operation](time, `${magnitude * 12} months`, base);
        case "decade":
          return DH[operation](time, `${magnitude * 10} years`, base);
      }
      increment = DH.as("ms", magnitude, increment.unit);
    }
    const timeUtcOffset = time.getTimezoneOffset() * 1e3 * 60;
    if (base) {
      const baseUtcOffset = base.getTimezoneOffset() * 1e3 * 60, diff = time - base + baseUtcOffset - timeUtcOffset, snappedDate = new Date(base.getTime() + snapFn(diff, increment)), dstChange = baseUtcOffset - snappedDate.getTimezoneOffset() * 1e3 * 60;
      if (dstChange) {
        DH.add(snappedDate, -dstChange, "ms", false);
      }
      return new Date(snappedDate);
    } else {
      return new Date(snapFn(time.valueOf() - timeUtcOffset, increment) + timeUtcOffset);
    }
  }
  //endregion
  //region Date picker format
  /**
   * Parses a typed duration value according to locale rules.
   *
   * The value is taken to be a string consisting of the numeric magnitude and the units:
   * - The numeric magnitude can be either an integer or a float value. Both `','` and `'.'` are valid decimal separators.
   * - The units may be a recognised unit abbreviation of this locale or the full local unit name.
   *
   * For example:
   * `'2d'`, `'2 d'`, `'2 day'`, `'2 days'` will be turned into `{ magnitude : 2, unit : 'day' }`
   * `'2.5d'`, `'2,5 d'`, `'2.5 day'`, `'2,5 days'` will be turned into `{ magnitude : 2.5, unit : 'day' }`
   *
   * **NOTE:** Doesn't work with complex values like `'2 days, 2 hours'`
   *
   * @param {String} value The value to parse
   * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude
   * @param {String} [defaultUnit] Default unit to use if only magnitude passed
   * @returns {DurationConfig} If successfully parsed, the result contains two properties, `magnitude` being a number, and
   * `unit` being the canonical unit name, *NOT* a localized name. If parsing was unsuccessful, `null` is returned
   * @category Parse & format
   */
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    var _a4;
    const durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex, match = durationRegEx.exec(value);
    if (value == null || !match) {
      return null;
    }
    const magnitude = parseNumber((_a4 = match[1]) == null ? void 0 : _a4.replace(",", ".")), unit = DH.parseTimeUnit(match[2]) || defaultUnit;
    if (!unit) {
      return null;
    }
    return {
      magnitude,
      unit
    };
  }
  /**
   * Parses a typed unit name, for example `'ms'` or `'hr'` or `'yr'` into the
   * canonical form of the unit name which may be passed to {@link #function-add-static}
   * or {@link #function-diff-static}.
   * @param {*} unitName Time unit name
   * @category Parse & format
   */
  static parseTimeUnit(unitName) {
    const unitMatch = unitName == null ? null : DH.durationRegEx.exec(unitName.toLowerCase());
    if (!unitMatch) {
      return null;
    }
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }
  //endregion
  //region Internal
  static getGMTOffset(date = /* @__PURE__ */ new Date()) {
    if (!date) {
      return;
    }
    const offsetInMinutes = date.getTimezoneOffset();
    if (!offsetInMinutes)
      return "Z";
    return (offsetInMinutes > 0 ? "-" : "+") + Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, "0") + ":" + Math.abs(offsetInMinutes % 60).toString().padStart(2, "0");
  }
  static fillDayNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-01T12:00:00"), dayNames = DH._dayNames || [], dayShortNames = DH._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;
    for (let day2 = 2; day2 < 9; day2++) {
      tempDate2.setDate(day2);
      dayNames.push(DH.format(tempDate2, "dddd"));
      dayShortNames.push(DH.format(tempDate2, "ddd"));
    }
    DH._dayNames = dayNames;
    DH._dayShortNames = dayShortNames;
  }
  static getDayNames() {
    return DH._dayNames;
  }
  static getDayName(day2) {
    return DH._dayNames[day2];
  }
  static getDayShortNames() {
    return DH._dayShortNames;
  }
  static getDayShortName(day2) {
    return DH._dayShortNames[day2];
  }
  static fillMonthNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-15T12:00:00"), monthNames = DH._monthNames || [], monthShortNames = DH._monthShortNames || [], monthNamesIndex = {}, monthShortNamesIndex = {};
    monthNames.length = 0;
    monthShortNames.length = 0;
    for (let month2 = 0; month2 < 12; month2++) {
      tempDate2.setMonth(month2);
      const monthName = DH.format(tempDate2, "MMMM");
      monthNames.push(monthName);
      const monthShortName = DH.format(tempDate2, "MMM");
      monthShortNames.push(monthShortName);
      monthNamesIndex[monthName.toLowerCase()] = { name: monthName, value: month2 };
      monthShortNamesIndex[monthShortName.toLowerCase()] = { name: monthShortName, value: month2 };
    }
    DH._monthNames = monthNames;
    DH._monthShortNames = monthShortNames;
    DH._monthNamesIndex = monthNamesIndex;
    DH._monthShortNamesIndex = monthShortNamesIndex;
  }
  static getMonthShortNames() {
    return DH._monthShortNames;
  }
  static getMonthShortName(month2) {
    return DH._monthShortNames[month2];
  }
  static getMonthNames() {
    return DH._monthNames;
  }
  static getMonthName(month2) {
    return DH._monthNames[month2];
  }
  static set locale(name) {
    locale2 = name;
    intlFormatterCache = {};
    formatCache = {};
    formatRedirects = {};
  }
  static get locale() {
    return locale2;
  }
  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this, unitLookup = {};
    let unitAbbrRegEx = "";
    for (let i = 0; i < unitAbbreviations.length; i++) {
      const abbreviations = unitAbbreviations[i], unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];
      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? "|" : ""}(`;
      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }
      locale2 = me.localize("L{locale}") || "en-US";
      if (locale2 !== "en-US") {
        const canonicalAbbreviations = canonicalUnitAbbreviations[i];
        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }
      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;
    }
    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
  static applyLocale() {
    const me = this, unitAbbreviations = me.localize("L{unitAbbreviations}") || [], unitNames = me.unitNames = me.localize("L{unitNames}");
    if (unitNames === "unitNames") {
      return;
    }
    locale2 = me.localize("L{locale}") || "en-US";
    if (locale2 === "en-US") {
      ordinalSuffix = enOrdinalSuffix;
    } else {
      ordinalSuffix = me.localize("L{ordinalSuffix}") || ordinalSuffix;
    }
    formatCache = {};
    formatRedirects = {};
    parserCache = {};
    intlFormatterCache = {};
    DH._weekStartDay = null;
    DH.setupDurationRegEx(unitNames, unitAbbreviations);
    DH.fillDayNames();
    DH.fillMonthNames();
  }
  //endregion
};
__publicField(_DateHelper, "MS_PER_DAY", MS_PER_HOUR * 24);
var DateHelper = _DateHelper;
var DH = DateHelper;
DH.useIntlFormat = useIntlFormat;
LocaleManager_default.ion({
  locale: "applyLocale",
  prio: 1e3,
  thisObj: DH
});
if (LocaleManager_default.locale) {
  DH.applyLocale();
}
DateHelper._$name = "DateHelper";

// ../Core/lib/Core/helper/ObjectHelper.js
var { hasOwn: hasOwn2 } = Objects;
var toFixedFix = 1.005.toFixed(2) === "1.01" ? null : function(number, fractionDigits) {
  const split = number.toString().split("."), newNumber = +(!split[1] ? split[0] : split.join(".") + "1");
  return number.toFixed.call(newNumber, fractionDigits);
};
var ObjectHelper = class _ObjectHelper extends Objects {
  // These methods are inherited from Objects (an internal class) but need to be documented here for public use.
  // This is primarily because static methods, while inherited by JavaScript classes, are not displayed in derived
  // classes in the docs.
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`. Unlike `Object.assign`, this copy
   * also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assign
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, only including properties that does
   * not already exist on `dest`. Unlike `Object.assign`, this copy also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assignIf
   * @static
   */
  /**
   * Creates a deep copy of the `value`. Simple objects ({@link #function-isObject-static}, arrays and `Date` objects
   * are cloned. The enumerable properties of simple objects and the elements of arrays are cloned recursively.
   * @param {*} value The value to clone.
   * @param {Function} [handler] An optional function to call for values of types other than simple object, array or
   * `Date`. This function should return the clone of the `value` passed to it. It is only called for truthy values
   * whose `typeof` equals `'object'`.
   * @param {*} handler.value The value to clone.
   * @returns {*} The cloned value.
   * @method clone
   * @static
   */
  /**
   * Converts a list of names (either a space separated string or an array), into an object with those properties
   * assigned truthy values. The converse of {@link #function-getTruthyKeys-static}.
   * @param {String|String[]} source The list of names to convert to object form.
   * @method createTruthyKeys
   * @static
   */
  /**
   * Gathers the names of properties which have truthy values into an array.
   *
   * This is useful when gathering CSS class names for complex element production.
   * Instead of appending to an array or string which may already contain the
   * name, and instead of contending with space separation and concatenation
   * and conditional execution, just set the properties of an object:
   *
   *     cls = {
   *         [this.selectedCls] : this.isSelected(thing),
   *         [this.dirtyCls] : this.isDirty(thing)
   *     };
   *
   * @param {Object} source Source of keys to gather into an array.
   * @returns {String[]} The keys which had a truthy value.
   * @method getTruthyKeys
   * @static
   */
  /**
   * Gathers the values of properties which are truthy into an array.
   * @param {Object} source Source of values to gather into an array.
   * @returns {String[]} The truthy values from the passed object.
   * @method getTruthyValues
   * @static
   */
  /**
   * Tests whether a passed object has any enumerable properties.
   * @param {Object} object
   * @returns {Boolean} `true` if the passed object has no enumerable properties.
   * @method isEmpty
   * @static
   */
  /**
   * Returns `true` if the `value` is a simple `Object`.
   * @param {Object} value
   * @returns {Boolean} `true` if the `value` is a simple `Object`.
   * @method isObject
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, recursing when the properties of
   * both the source and `dest` are objects.
   * ```
   *  const o = {
   *      a : 1,
   *      b : {
   *          c : 2
   *      }
   *  };
   *  const o2 = {
   *      b : {
   *          d : 3
   *      }
   *  }
   *
   *  console.log(merge(o, o2));
   *
   *  > { a : 1, b : { c : 2, d : 3 } }
   * ```
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method merge
   * @static
   */
  /**
   * Returns the specific type of the given `value`. Unlike the `typeof` operator, this function returns the text
   * from the `Object.prototype.toString` result allowing `Date`, `Array`, `RegExp`, and others to be differentiated.
   * ```
   *  console.log(typeOf(null));
   *  > null
   *
   *  console.log(typeOf({}));
   *  > object
   *
   *  console.log(typeOf([]));
   *  > array
   *
   *  console.log(typeOf(new Date()));
   *  > date
   *
   *  console.log(typeOf(NaN));
   *  > nan
   *
   *  console.log(typeOf(/a/));
   *  > regexp
   * ```
   * @param {*} value
   * @returns {String}
   * @method typeOf
   * @static
   */
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   * @method getPath
   * @static
   */
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   * @method setPath
   * @static
   */
  /**
   * Creates a new object where key is a property in array item (`ref` by default) or index in the array and value is array item.
   *
   * From:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar'
   *     }
   * ]
   * ```
   *
   * To:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo',
   *         ref  : 'fooItem'
   *     },
   *     1 : {
   *         text : 'bar'
   *     }
   * }
   * ```
   *
   * @param {Object[]} arrayOfItems Array to transform.
   * @param {String} [prop] Property to read the key from. `ref` by default.
   * @returns {Object} namedItems
   */
  static transformArrayToNamedObject(arrayOfItems, prop = "ref") {
    const namedItems = {};
    arrayOfItems.forEach((item, index) => {
      const key = item[prop] != null && item[prop].toString().length ? item[prop] : index;
      namedItems[key] = item;
    });
    return namedItems;
  }
  /**
   * Creates a new array from object values and saves key in a property (`ref` by default) of each item.
   *
   * From:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo'
   *     },
   *     1 : {
   *         text : 'bar'
   *     },
   *     barItem : false // will be ignored
   * }
   * ```
   *
   * To:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar',
   *          ref : 1
   *     }
   * ]
   * ```
   *
   * @param {Object} namedItems Object to transform.
   * @param {String} [prop] Property to save the key to. `ref` by default.
   * @returns {Object[]} arrayOfItems
   */
  static transformNamedObjectToArray(namedItems, prop = "ref") {
    return Object.keys(namedItems).filter((key) => namedItems[key]).map((key) => {
      const item = namedItems[key];
      item[prop] = key;
      return item;
    });
  }
  /**
   * Checks if two values are equal. Basically === but special handling of dates.
   * @param {*} a First value
   * @param {*} b Second value
   * @param {Boolean} [useIsDeeply=false] Pass `true` to match arrays using a deep equality check.
   * @param {Boolean} [matchNullish=false] Pass `true` to have nullish (`undefined` and `null`) evaluated as equal.
   * @returns {*} true if values are equal, otherwise false
   */
  static isEqual(a, b, useIsDeeply = false, matchNullish = false) {
    if (!matchNullish && (a === null && b !== null || a === void 0 && b !== void 0 || b === null && a !== null || b === void 0 && a !== void 0)) {
      return false;
    }
    if (a == null || b == null) {
      return a == null && b == null;
    }
    if (a === b) {
      return true;
    }
    const typeA = typeof a, typeB = typeof b;
    if (typeA === typeB) {
      switch (typeA) {
        case "number":
        case "string":
        case "boolean":
          return a === b;
      }
      switch (true) {
        case (a instanceof Date && b instanceof Date):
          return a.getTime() === b.getTime();
        case (Array.isArray(a) && Array.isArray(b)):
          return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;
        case (typeA === "object" && a.constructor.prototype === b.constructor.prototype):
          return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : StringHelper.safeJsonStringify(a, "circular") === StringHelper.safeJsonStringify(b, "circular");
      }
    }
    return String(a) === String(b);
  }
  /**
   * Checks if two objects are deeply equal
   * @param {Object} a
   * @param {Object} b
   * @param {Object} [options] Additional comparison options
   * @param {Object} [options.ignore] Map of property names to ignore when comparing
   * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.
   * Return false to prevent comparison
   * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation
   * result or anything else to let `isEqual` handle the comparison
   * @returns {Boolean}
   */
  static isDeeplyEqual(a, b, options = {}) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    const aKeys = OH.keys(a, options.ignore), bKeys = OH.keys(b, options.ignore);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i], bKey = bKeys[i];
      if (aKey !== bKey) {
        return false;
      }
      const aVal = a[aKey], bVal = b[bKey];
      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(
          aKey,
          {
            value: aVal,
            object: a
          },
          {
            value: bVal,
            object: b
          }
        ) === false) {
          continue;
        }
      }
      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });
        if (result === false) {
          return false;
        }
        if (result === true) {
          continue;
        }
      }
      if (!OH.isEqual(aVal, bVal, options)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if value B is partially equal to value A.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if values are partially equal, false otherwise
   */
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) !== -1;
  }
  /**
   * Checks if value a is smaller than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a < b
   */
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }
  /**
   * Checks if value a is bigger than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a > b
   */
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }
  /**
   * Used by the Base class to make deep copies of defaultConfig blocks
   * @private
   */
  static fork(obj) {
    let ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = OH.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter
   * unless the property already exists in the `dest`.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyPropertiesIf(dest, source, props) {
    if (source) {
      for (const prop of props) {
        if (!(prop in dest) && prop in source) {
          dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
  /**
   * Returns an array containing the keys and values of all enumerable properties from every prototype level for the
   * object. If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve entries.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @returns {Array}
   * @internal
   */
  static entries(object, ignore) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push([p, object[p]]);
        }
      }
    }
    return result;
  }
  /**
   * Populates an `object` with the provided `entries`.
   * @param {Array} entries The key/value pairs (2-element arrays).
   * @param {Object} [object={}] The object onto which to add `entries`.
   * @returns {Object} The passed `object` (by default, a newly created object).
   * @internal
   */
  static fromEntries(entries, object) {
    object = object || {};
    if (entries) {
      for (let i = 0; i < entries.length; ++i) {
        object[entries[i][0]] = entries[i][1];
      }
    }
    return object;
  }
  /**
   * Returns an array containing all enumerable property names from every prototype level for the object. If `object`
   * is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve property names.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {String[]}
   */
  static keys(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(p, index) : p);
          ++index;
        }
      }
    }
    return result;
  }
  /**
   * Returns an array containing the values of all enumerable properties from every prototype level for the object.
   * If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve values.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {Array}
   * @internal
   */
  static values(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(object[p], index) : object[p]);
          ++index;
        }
      }
    }
    return result;
  }
  //region Path
  /**
   * Checks if a given path exists in an object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean} Returns `true` if path exists or `false` if it does not
   */
  static pathExists(object, path) {
    const properties = path.split(".");
    return properties.every((property) => {
      if (!object || !(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }
  /**
   * Creates a simple single level key-value object from complex deep object.
   * @param {Object} object Object to extract path and values from
   * @returns {Object} Key-value object where key is a path to the corresponding value
   * @internal
   *
   * ```javascript
   * // converts deep object
   * {
   *     foo : {
   *         bar : {
   *             test : 1
   *         }
   *     }
   * }
   * // into a single level object
   * {
   *     'foo.bar.test' : 1
   * }
   * ```
   */
  static pathifyKeys(object, fieldDataSourceMap) {
    const result = {};
    for (const key in object) {
      if (hasOwn2(object, key)) {
        const field = fieldDataSourceMap == null ? void 0 : fieldDataSourceMap[key];
        const usesPathKeys = (field == null ? void 0 : field.type) === "object" || (field == null ? void 0 : field.complexMapping) || !Boolean(fieldDataSourceMap);
        if (usesPathKeys && Array.isArray(object[key])) {
          result[key] = object[key].slice();
        } else if (usesPathKeys && object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);
          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }
    return result;
  }
  /**
   * Removes value for a given path in the object. Doesn't cleanup empty objects.
   * @param {Object} object
   * @param {String} path Dot-separated path, e.g. `obj.child.someKey`
   * @internal
   */
  static deletePath(object, path) {
    path.split(".").reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      }
      if (hasOwn2(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }
  //endregion
  static coerce(from, to) {
    const fromType = Objects.typeOf(from), toType = Objects.typeOf(to), isString = typeof from === "string";
    if (fromType !== toType) {
      switch (toType) {
        case "string":
          return String(from);
        case "number":
          return Number(from);
        case "boolean":
          return isString && (!from || from === "false" || from === "0") ? false : Boolean(from);
        case "null":
          return isString && (!from || from === "null") ? null : false;
        case "undefined":
          return isString && (!from || from === "undefined") ? void 0 : false;
        case "date":
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }
  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto3 = Object.getPrototypeOf(object), existingProperty = Object.getOwnPropertyDescriptor(proto3, propertyName);
    while (!existingProperty && proto3 && deep) {
      proto3 = Object.getPrototypeOf(proto3);
      if (proto3) {
        existingProperty = Object.getOwnPropertyDescriptor(proto3, propertyName);
      }
    }
    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = (v) => {
          existingProperty.set.call(object, v);
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = (v) => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }
  /**
   * Intercepts access to a `property` of a given `object`.
   *
   * ```javascript
   *      ObjectHelper.hookProperty(object, 'prop', class {
   *          get value() {
   *              return super.value;
   *          }
   *          set value(v) {
   *              super.value = v;
   *          }
   *      });
   * ```
   * The use of `super` allows the hook's getter and setter to invoke the object's existing get/set.
   *
   * @param {Object} object
   * @param {String} property
   * @param {Function} hook A `class` defining a `value` property getter and/or setter.
   * @returns {Function} A function that removes the hook when called.
   * @internal
   */
  static hookProperty(object, property, hook) {
    const desc = _ObjectHelper.getPropertyDescriptor(hook.prototype, "value"), existingDesc = _ObjectHelper.getPropertyDescriptor(object, property), fieldName = `_${property}`, base = class {
      get value() {
        return existingDesc ? existingDesc.get.call(this) : this[fieldName];
      }
      set value(v) {
        if (existingDesc) {
          existingDesc.set.call(this, v);
        } else {
          this[fieldName] = v;
        }
      }
    }, baseDesc = _ObjectHelper.getPropertyDescriptor(base.prototype, "value");
    Object.setPrototypeOf(hook.prototype, base.prototype);
    Object.defineProperty(object, property, {
      configurable: true,
      get: desc.get || baseDesc.get,
      set: desc.set || baseDesc.set
    });
    return () => delete object[property];
  }
  /**
   * Changes the passed object and removes all null and undefined properties from it
   * @param {Object} object Target object
   * @param {Boolean} [keepNull] Pass true to only remove undefined properties
   * @returns {Object} Passed object
   */
  static cleanupProperties(object, keepNull = false) {
    Object.entries(object).forEach(([key, value]) => {
      if (keepNull) {
        value === void 0 && delete object[key];
      } else {
        value == null && delete object[key];
      }
    });
    return object;
  }
  /**
   * Changes the passed object and removes all properties from it.
   * Used while mutating when need to keep reference to the object but replace its properties.
   * @param {Object} object Target object
   * @returns {Object} Passed object
   */
  static removeAllProperties(obj) {
    Object.keys(obj).forEach((key) => delete obj[key]);
    return obj;
  }
  //region Assert type
  /**
   * Checks that the supplied value is of the specified type.Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} type Expected type
   * @param {String} name Name of the value, used in error message
   * @param {Boolean} [allowNull] Accept `null` without throwing
   */
  static assertType(value, type, name) {
    const valueType = Objects.typeOf(value);
    if (value != null && valueType !== type) {
      throw new Error(`Incorrect type "${valueType}" for ${name}, expected "${type}"`);
    }
  }
  /**
   * Checks that the supplied value is a plain object. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertObject(value, name) {
    OH.assertType(value, "object", name);
  }
  /**
   * Checks that the supplied value is an instance of a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertInstance(value, name) {
    OH.assertType(value, "instance", name);
  }
  /**
   * Checks that the supplied value is a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertClass(value, name) {
    OH.assertType(value, "class", name);
  }
  /**
   * Checks that the supplied value is a function. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertFunction(value, name) {
    if (typeof value !== "function" || value.isBase || value.$$name) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a function)`);
    }
  }
  /**
   * Checks that the supplied value is a number. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertNumber(value, name) {
    const asNumber = Number(value);
    if (typeof value !== "number" || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }
  /**
   * Checks that the supplied value is a boolean. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertBoolean(value, name) {
    OH.assertType(value, "boolean", name);
  }
  /**
   * Checks that the supplied value is a string. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertString(value, name) {
    OH.assertType(value, "string", name);
  }
  /**
   * Checks that the supplied value is an array. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertArray(value, name) {
    OH.assertType(value, "array", name);
  }
  //endregion
  /**
   * Number.toFixed(), with polyfill for browsers that needs it
   * @param {Number} number
   * @param {Number} digits
   * @returns {String} A fixed point string representation of the passed number.
   */
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }
    return number.toFixed(digits);
  }
  /**
   * Round the passed number to closest passed step value.
   * @param {Number} number The number to round.
   * @param {Number} [step] The step value to round to.
   * @returns {Number} The number rounded to the closest step.
   */
  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }
  /**
   * Round the passed number to the passed number of decimals.
   * @param {Number} number The number to round.
   * @param {Number} digits The number of decimal places to round to.
   * @returns {Number} The number rounded to the passed number of decimal places.
   */
  static round(number, digits) {
    if (digits == null) {
      return number;
    }
    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }
  /**
   * Returns a non-null entry from a Map for a given key path. This enables a specified defaultValue to be added "just
   * in time" which is returned if the key is not already present.
   * @param {Map} map The Map to find the key in (and potentially add to).
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {Object} [defaultValue] Optionally the value to insert if the key is not found.
   */
  static getMapPath(map, path, defaultValue2) {
    const keyPath = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], simpleKey = keyPath.length === 1, topKey = keyPath[0], topValue = map.has(topKey) ? map.get(topKey) : map.set(topKey, simpleKey ? defaultValue2 : {}).get(topKey);
    if (simpleKey) {
      return topValue;
    }
    return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue2);
  }
};
var OH = ObjectHelper;
ObjectHelper._$name = "ObjectHelper";

// ../Core/lib/Core/helper/util/Rectangle.js
var zeroBased;
var allBorders = ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"];
var allMargins = ["margin-top", "margin-right", "margin-bottom", "margin-left"];
var allPaddings = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
var borderNames = {
  t: "border-top-width",
  r: "border-right-width",
  b: "border-bottom-width",
  l: "border-left-width"
};
var paddingNames = {
  t: "padding-top",
  r: "padding-right",
  b: "padding-bottom",
  l: "padding-left"
};
var alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var alignPointRe = /^([trblc])(\d*)$/i;
var edgeNames = [
  "top",
  "right",
  "bottom",
  "left"
];
var edgeIndices = {
  t: 0,
  r: 1,
  b: 2,
  l: 3
};
var defaultAlignments = [
  "b-t",
  "l-r",
  "t-b",
  "r-l"
];
var edgeAligments = {
  bt: 1,
  tb: 1,
  lr: 2,
  rl: 2
};
var emptyArray2 = Object.freeze([]);
var zeroOffsets = Object.freeze([0, 0]);
var matchDimensions = ["width", "height"];
var parseEdges = (top, right = top, bottom = top, left = right) => (
  // use apply() to spread array and apply default values to missing elements
  Array.isArray(top) ? parseEdges.apply(null, top) : [top, right, bottom, left]
);
var parseTRBL = (top, right, bottom, left) => Array.isArray(top) ? parseEdges.apply(null, top) : typeof top.top === "number" ? [top.top, top.right, top.bottom, top.left] : [top, right, bottom, left];
var parseAlign = (alignSpec, rtl) => {
  const parts = alignSpecRe.exec(alignSpec), myEdge = parts[1], targetEdge = parts[3], mO = parseInt(parts[2] || 50), tO = parseInt(parts[4] || 50), myOffset = rtl && !(edgeIndices[myEdge] & 1) ? 100 - mO : mO, targetOffset = rtl && !(edgeIndices[targetEdge] & 1) ? 100 - tO : tO, edgeAligned = edgeAligments[myEdge + targetEdge];
  return {
    myAlignmentPoint: myEdge + myOffset,
    // l0
    myEdge,
    // l
    myOffset,
    // 0
    targetAlignmentPoint: targetEdge + targetOffset,
    // r0
    targetEdge,
    // r
    targetOffset,
    // 0
    startZone: edgeIndices[targetEdge],
    // 1 - start trying zone 1 in TRBL order
    edgeAligned
    // Edge-to-edge align requested
  };
};
var flipAlign = (align) => `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
var createOffsets = (offset) => {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === "number") {
    return [offset, offset];
  }
  return offset;
};
var Rectangle = class _Rectangle {
  /**
   * Constructs a Rectangle
   * @param {Number} x The X coordinate
   * @param {Number} y The Y coordinate
   * @param {Number} width The width
   * @param {Number} height The height
   */
  constructor(x, y, width, height) {
    // Class does not extend Base, so we need to define this
    __publicField(this, "isRectangle", true);
    ObjectHelper.assertNumber(x, "Rectangle.x");
    ObjectHelper.assertNumber(y, "Rectangle.y");
    ObjectHelper.assertNumber(width, "Rectangle.width");
    ObjectHelper.assertNumber(height, "Rectangle.height");
    const me = this;
    if (width < 0) {
      x += width;
      width = -width;
    }
    if (height < 0) {
      y += height;
      height = -height;
    }
    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }
  /**
   * Returns the Rectangle in document based coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s
   * rectangle is returned which is always at `[0, 0]` and encompasses the
   * browser's entire document viewport.
   * @param {HTMLElement|Core.widget.Widget|Core.widget.Mask} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static from(element, relativeTo, ignorePageScroll) {
    if (typeof element === "string") {
      element = document.querySelector(element);
    } else if ((element == null ? void 0 : element.nodeType) === Node.DOCUMENT_FRAGMENT_NODE) {
      element = element.host || element.ownerDocument;
    }
    if (typeof relativeTo === "string") {
      relativeTo = document.querySelector(relativeTo);
    }
    if (element == null || element.isRectangle) {
      return element;
    }
    element = element.element || element;
    if (ignorePageScroll === void 0 && typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = null;
    }
    if (!(relativeTo == null ? void 0 : relativeTo.isRectangle)) {
      if (relativeTo) {
        let { scrollLeft, scrollTop } = relativeTo;
        if (BrowserHelper.isSafari && relativeTo === document.body) {
          scrollLeft = scrollTop = 0;
        }
        relativeTo = _Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
      } else {
        if (!zeroBased) {
          zeroBased = new _Rectangle(0, 0, 0, 0);
        }
        relativeTo = zeroBased;
      }
    }
    const isViewport = element === document || element === globalThis, isSFViewport = element === document.body && document.body.offsetHeight === 0, sfElRect = isSFViewport && element.getBoundingClientRect(), viewRect = isSFViewport ? new _Rectangle(sfElRect.left, sfElRect.top, sfElRect.width, document.body.parentElement.scrollHeight) : isViewport ? new _Rectangle(0, 0, globalThis.innerWidth, globalThis.innerHeight) : element.getBoundingClientRect(), scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [globalThis.pageXOffset, globalThis.pageYOffset];
    return new _Rectangle(
      viewRect.left + scrollOffset[0] - relativeTo.x,
      viewRect.top + scrollOffset[1] - relativeTo.y,
      viewRect.width,
      viewRect.height
    );
  }
  /**
   * Returns the Rectangle in viewport coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s rectangle is returned which is always
   * at `[0, 0]` and encompasses the browser's entire document viewport.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @returns {Core.helper.util.Rectangle} The Rectangle in viewport based coordinates. Relative to the _relativeTo_
   * parameter if provided.
   */
  static fromScreen(element, relativeTo) {
    return _Rectangle.from(
      element,
      relativeTo,
      /* ignorePageScroll = */
      true
    );
  }
  /**
   * Returns the inner Rectangle (within border) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);
      result.x += parseFloat(borders[borderNames.l]);
      result.y += parseFloat(borders[borderNames.t]);
      result.right -= parseFloat(borders[borderNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]);
    }
    return result;
  }
  /**
   * Returns the content Rectangle (within border and padding) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders), padding = DomHelper.getStyleValue(element, allPaddings);
      result.x += parseFloat(borders[borderNames.l]) + parseFloat(padding[paddingNames.l]);
      result.y += parseFloat(borders[borderNames.t]) + parseFloat(padding[paddingNames.t]);
      result.right -= parseFloat(borders[borderNames.r]) + parseFloat(padding[paddingNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]) + parseFloat(padding[paddingNames.b]);
    }
    return result;
  }
  /**
   * Returns the client Rectangle (within border and padding and scrollbars) in document based coordinates of the
   * passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @param {Boolean} [clipStickies] Return the Rectangle *within* any sticky elements docked at the element edges.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static client(element, relativeTo, ignorePageScroll = false, clipStickies, targetEl) {
    const result = this.content(element, relativeTo, ignorePageScroll), scrollbarWidth = DomHelper.scrollBarWidth;
    let padding, stickies = clipStickies ? [...element.children].filter((e) => DomHelper.getStyleValue(e, "position") === "sticky") : emptyArray2;
    if (targetEl) {
      stickies = stickies.filter((e) => !e.contains(targetEl));
    }
    if (scrollbarWidth && !element.classList.contains("b-hide-scroll")) {
      if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, "overflow-y") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-right"));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }
      if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, "overflow-x") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-bottom"));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }
    for (let i = 0, { length } = stickies; i < length; i++) {
      const e = stickies[i], r = this.fromScreen(e);
      if (parseFloat(DomHelper.getStyleValue(e, "left")) === 0) {
        result.x += r.width;
      } else if (parseFloat(DomHelper.getStyleValue(e, "right")) === 0) {
        result.right -= r.width;
      } else if (parseFloat(DomHelper.getStyleValue(e, "top")) === 0) {
        result.y += r.height;
      } else if (parseFloat(DomHelper.getStyleValue(e, "bottom")) === 0) {
        result.bottom -= r.height;
      }
    }
    return result;
  }
  /**
   * Returns the outer Rectangle (including margin) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates.
   * Relative to the _relativeTo_ parameter if passed.
   * @internal
   */
  static outer(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const margin = DomHelper.getStyleValue(element, allMargins);
      result.x -= parseFloat(margin["margin-left"]);
      result.y -= parseFloat(margin["margin-top"]);
      result.right += parseFloat(margin["margin-right"]);
      result.bottom += parseFloat(margin["margin-bottom"]);
    }
    return result;
  }
  /**
   * Returns a new rectangle created as the union of all supplied rectangles.
   * @param {Core.helper.util.Rectangle[]} rectangles
   * @returns {Core.helper.util.Rectangle}
   */
  static union(...rectangles) {
    let { x, y, right, bottom } = rectangles[0], current;
    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];
        if (current.x < x) {
          x = current.x;
        }
        if (current.y < y) {
          y = current.y;
        }
        if (current.right > right) {
          right = current.right;
        }
        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }
    return new _Rectangle(x, y, right - x, bottom - y);
  }
  /**
   * Rounds this Rectangle to the pixel resolution of the current display or to the nearest
   * passed unit which defaults to the current display's [`devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).
   * @param {Number} [devicePixelRatio] device pixel ratio which defaults to `window.devicePixelRatio`
   */
  roundPx(devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const me = this;
    me._x = DomHelper.roundPx(me._x, devicePixelRatio);
    me._y = DomHelper.roundPx(me._y, devicePixelRatio);
    me._width = DomHelper.roundPx(me._width, devicePixelRatio);
    me._height = DomHelper.roundPx(me._height, devicePixelRatio);
    return me;
  }
  // This class doesn't extend Base and extending doesn't seem to be
  // the way to go. Instead we duplicate smallest piece of logic here
  static get $$name() {
    return hasOwnProperty.call(this, "$name") && this.$name || // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwnProperty.call(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Creates a copy of this Rectangle.
   */
  clone() {
    const me = this, result = new _Rectangle(me.x, me.y, me.width, me.height);
    result.isAlignRectangle = me.isAlignRectangle;
    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;
    return result;
  }
  /**
   * Returns `true` if this Rectangle wholly contains the passed rectangle.
   *
   * Note that a {@link Core.helper.util.Rectangle.Point} may be passed.
   * @param {Core.helper.util.Rectangle} other The Rectangle to test for containment within this Rectangle
   * @returns {Boolean} `true` if the other Rectangle is wholly contained within this Rectangle
   */
  contains(other) {
    const me = this;
    if (other.isRectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }
  /**
   * Checks if this Rectangle intersects the passed Rectangle
   * @param {Core.helper.util.Rectangle} other The Rectangle to intersect with this.
   * @param {Boolean} [useBoolean] Specify `true` to return a boolean value instead of constructing a new Rectangle
   * @param {Boolean} [allowZeroDimensions] `true` to consider zero-width or zero-hight rectangles as intersecting if coordinates indicate the intersection
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the intersection Rectangle or `false` if there is no intersection.
   */
  intersect(other, useBoolean = false, allowZeroDimensions = false) {
    const me = this, y = Math.max(me.y, other.y), r = Math.min(me.right, other.right), b = Math.min(me.bottom, other.bottom), x = Math.max(me.x, other.x), intersect = allowZeroDimensions ? b >= y && r >= x : b > y && r > x;
    if (intersect) {
      return useBoolean ? true : new _Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }
  equals(other, round2 = false) {
    const processor = round2 ? (x) => Math.round(x) : (x) => x;
    return other.isRectangle && processor(other.x) === processor(this.x) && processor(other.y) === processor(this.y) && processor(other.width) === processor(this.width) && processor(other.height) === processor(this.height);
  }
  /**
   * Translates this Rectangle by the passed vector. Size is maintained.
   * @param {Number} x The X translation vector.
   * @param {Number} y The Y translation vector.
   * @returns {Core.helper.util.Rectangle} This Rectangle;
   */
  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }
  /**
   * Moves this Rectangle to the passed `x`, `y` position. Size is maintained.
   * @param {Number} x The new X position.
   * @param {Number} y The new Y position.
   * @returns {Core.helper.util.Rectangle}  This Rectangle;
   */
  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }
    if (y != null) {
      this._y = y;
    }
    return this;
  }
  /**
   * Returns the vector which would translate this Rectangle (or Point) to the same position as the other Rectangle (or point)
   * @param {Core.helper.util.Rectangle|Core.helper.util.Rectangle.Point} other The Rectangle or Point to calculate the delta to.
   * @returns {Array} Returns a vector using format `[deltaX, deltaY]`
   * @internal
   */
  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }
  /**
   * The center point of this rectangle.
   * @property {Core.helper.util.Rectangle.Point}
   */
  get center() {
    const result = new Point(this.x + this.width / 2, this.y + this.height / 2, 0, 0);
    result.target = this.target;
    return result;
  }
  /**
   * Get/sets the X coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-width} will change.
   * @property {Number}
   */
  set x(x) {
    const xDelta = x - this._x;
    this._x = x;
    this._width -= xDelta;
  }
  get x() {
    return this._x;
  }
  get start() {
    return this.left;
  }
  /**
   * Alias for x. To match DOMRect.
   * @property {Number}
   */
  set left(x) {
    this.x = x;
  }
  get left() {
    return this.x;
  }
  /**
   * Alias for y. To match DOMRect.
   * @property {Number}
   */
  set top(y) {
    this.y = y;
  }
  get top() {
    return this.y;
  }
  /**
   * Get/sets the Y coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-height} will change.
   * @property {Number}
   */
  set y(y) {
    const yDelta = y - this._y;
    this._y = y;
    this._height -= yDelta;
  }
  get y() {
    return this._y;
  }
  /**
   * Get/sets the width of the Rectangle. Note that the requested {@link #property-right} will change.
   * @property {Number}
   */
  set width(width) {
    this._width = width;
  }
  get width() {
    return this._width;
  }
  /**
   * Get/sets the height of the Rectangle. Note that the requested {@link #property-bottom} will change.
   * @property {Number}
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * Get/sets the right edge of the Rectangle. Note that the requested {@link #property-width} will change.
   *
   * The right edge value is exclusive of the calculated rectangle width. So x=0 and right=10
   * means a width of 10.
   * @property {Number}
   */
  set right(right) {
    this._width = right - this._x;
  }
  get right() {
    return this._x + this._width;
  }
  get end() {
    return this.right;
  }
  /**
   * Get/sets the bottom edge of the Rectangle. Note that the requested {@link #property-height} will change.
   *
   * The bottom edge value is exclusive of the calculated rectangle height. So y=0 and bottom=10
   * means a height of 10.
   * @property {Number}
   */
  set bottom(bottom) {
    this._height = bottom - this._y;
  }
  get bottom() {
    return this._y + this._height;
  }
  getStart(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.right : this.left;
    }
    return this.top;
  }
  getEnd(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.left : this.right;
    }
    return this.bottom;
  }
  get area() {
    return this.width * this.height;
  }
  set minWidth(minWidth) {
    const me = this;
    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      if (!me.isAlignRectangle) {
        me.width = Math.max(me.width, me._minWidth);
      }
    }
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(minHeight) {
    const me = this;
    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      if (!me.isAlignRectangle) {
        me.height = Math.max(me.height, me._minHeight);
      }
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  /**
   * Modifies the bounds of this Rectangle by the specified deltas.
   * @param {Number} x How much to *add* to the x position.
   * @param {Number} y  How much to *add* to the y position.
   * @param {Number} width  How much to add to the width.
   * @param {Number} height  How much to add to the height.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   */
  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }
  /**
   * Modifies the bounds of this rectangle by expanding them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * Number of values passed:
   * - One: all edges are inflated by that value.
   * - Two: values are top/bottom deflation and left/right inflation.
   * - Three: values are top, left/right, and bottom.
   * - Four: the values are top, right, bottom, and left.
   *
   * @param {Number|Number[]|Core.helper.util.Rectangle|DOMRect} top How much to inflate, or the top value if more
   * than one value is passed. If an array is passed, it is spread as the arguments to this method.
   * @param {Number} [right] How much to inflate the right side, or both left and right is only two values passed. If
   * one value is passed, this defaults to the same as `top`.
   * @param {Number} [bottom] How much to inflate the bottom side. If 2 values are passed, this defaults to the `top`
   * value.
   * @param {Number} [left] How much to inflate the left side. If 3 values are passed, this defaults to the `right`
   * value.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  inflate(top, right = top, bottom = top, left = right) {
    [top, right, bottom, left] = parseTRBL(top, right, bottom, left);
    return this.adjust(-left, -top, right, bottom);
  }
  /**
   * Modifies the bounds of this rectangle by reducing them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * Number of values passed:
   * - One: all edges are deflated by that value.
   * - Two: values are top/bottom deflation and left/right deflation.
   * - Three: values are top, left/right, and bottom.
   * - Four: the values are top, right, bottom, and left.
   *
   * @param {Number|Number[]|Core.helper.util.Rectangle|DOMRect} top How much to deflate, or the top value if more
   * than one value is passed. If an array is passed, it is spread as the arguments to this method.
   * @param {Number} [right] How much to deflate the right side, or both left and right is only two values passed. If
   * one value is passed, this defaults to the same as `top`.
   * @param {Number} [bottom] How much to deflate the bottom side. If 2 values are passed, this defaults to the `top`
   * value.
   * @param {Number} [left] How much to deflate the left side. If 3 values are passed, this defaults to the `right`
   * value.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  deflate(top, right = top, bottom = top, left = right) {
    [top, right, bottom, left] = parseTRBL(top, right, bottom, left);
    return this.adjust(left, top, -right, -bottom);
  }
  /**
   * Attempts to constrain this Rectangle into the passed Rectangle. If the `strict` parameter is `true`
   * then this method will return `false` if constraint could not be achieved.
   *
   * If this Rectangle has a `minHeight` or `minWidth` property, size will be adjusted while attempting to constrain.
   *
   * Right and bottom are adjusted first leaving the top and bottom sides to "win" in the case that this Rectangle overflows
   * the constrainTo Rectangle.
   * @param {Core.helper.util.Rectangle} constrainTo The Rectangle to constrain this Rectangle into if possible.
   * @param {Boolean} strict Pass `true` to return false, and leave this Rectangle unchanged if constraint
   * could not be achieved.
   * @returns {Core.helper.util.Rectangle|Boolean} This Rectangle. If `strict` is true, and constraining was not successful, `false`.
   */
  constrainTo(constrainTo, strict) {
    const me = this, originalHeight = me.height, originalY = me.y, minWidth = me.minWidth || me.width, minHeight = me.minHeight || me.height;
    if (me.height >= constrainTo.height) {
      if (strict && minHeight > constrainTo.height) {
        return false;
      }
      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }
    if (me.width >= constrainTo.width) {
      if (strict && minWidth > constrainTo.width) {
        me.y = originalY;
        me.height = originalHeight;
        return false;
      }
      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }
    me.translate.apply(me, me.constrainVector = [
      Math.min(constrainTo.right - me.right, 0),
      Math.min(constrainTo.bottom - me.bottom, 0)
    ]);
    me.translate(Math.max(constrainTo.x - me.x, 0), Math.max(constrainTo.y - me.y, 0));
    return me;
  }
  /**
   * Returns a cloned version of this Rectangle aligned to a target Rectangle, or element or {@link Core.widget.Widget}.
   * @param {Object} spec Alignment specification.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} spec.target The Widget or element or Rectangle to align to.
   * @param {Number[]} [spec.anchorSize] The `[width, height]` of the anchor pointer when in `top` position. The
   * width is the baseline length, and the height is the height of the arrow. If passed, the anchor position
   * will be calculated to be at the centre of the overlap of the two aligned edges and returned in the `anchor`
   * property of the resulting Rectangle:
   *
   *     {
   *         edge: 'top',         // or 'right' or 'bottom' or 'left'
   *         x/y: offset          // dimension to translate and value to translate by.
   *     }
   *
   * @param {Object} [spec.anchorPosition] an `{ x: n, y: n }` anchor translation to be used *if the requested alignment
   * succeeds without violating constraints*. If a fallback alignment is used, the anchor will be centered in the
   * overlap of the aligned edges as usual.
   * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
   * @param {String} spec.align The edge alignment specification string, specifying two points to bring together.
   *
   * Each point is described by an edge initial (`t` for top edge, `b` for bottom edge etc) followed
   * by a percentage along that edge.
   *
   * So the form would be `[trblc][n]-[trblc][n].` The `n` is the percentage offset along that edge
   * which defines the alignment point. This is not valid for alignment point `c` which means the center point.
   *
   * For example `t0-b0' would align this Rectangle's top left corner with the bottom left corner of the `target`.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
   * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
   * to the `minWidth` and `minHeight` properties of this rectangle), then it will try aligning at other edges
   * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
   * @param {Boolean} [spec.axisLock] Specify as a truthy value to fall back to aligning against the opposite
   * edge first if the requested alignment cannot be constrained into the `constrainTo` option. If specified
   * as `'flexible'`, then fallback will continue searching for solutions on the remaining two sides.
   * @param {Boolean} [spec.matchSize] When aligning edge-to-edge, match the length of the aligned-to
   * edge of the target. This is only honored when `axisLock` is enabled and alignment succeeds on the requested axis.
   * If __not__ aligning edge-to-edge, `matchSize` matches both dimensions of the target.
   * @param {Number|Number[]} [spec.offset] The 'x' and 'y' offset values to create an extra margin round the target
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   * @param {Number|Number[]} [spec.constrainPadding] The amount of pixels to pad from the `constrainTo` target,
   * either a single value, or an array of values in CSS edge order.
   * @param {Boolean} [spec.rtl] Pass as true if this is being used in an RTL environment, and aligning 0% to
   * 100% along a horizontal edge must proceed from right to left.
   * @returns {Core.helper.util.Rectangle} A new Rectangle aligned as requested if possible, but if the requested position violates
   * the `constrainTo` Rectangle, the shortest translation from the requested position which obeys constraints will be used.
   */
  alignTo(spec) {
    let result = this.clone(), {
      target,
      constrainTo,
      constrainPadding
    } = spec, calculatedAnchorPosition, zone, resultZone, constrainingToViewport;
    if (target && !target.isRectangle) {
      target = _Rectangle.from(target.element ? target.element : target);
    }
    if (constrainTo) {
      if (!constrainTo.isRectangle) {
        constrainingToViewport = constrainTo === globalThis || constrainTo === document;
        const ignorePageScroll = "ignorePageScroll" in spec ? spec.ignorePageScroll : !constrainingToViewport;
        constrainTo = _Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, ignorePageScroll);
      }
      if (constrainPadding) {
        constrainPadding = parseEdges(constrainPadding);
        constrainPadding[0] = Math.min(constrainPadding[0], target.top);
        constrainPadding[1] = Math.min(constrainPadding[1], constrainTo.right - target.right);
        constrainPadding[2] = Math.min(constrainPadding[2], constrainTo.bottom - target.bottom);
        constrainPadding[3] = Math.min(constrainPadding[3], target.left);
        constrainTo = constrainTo.deflate.apply(constrainTo.clone(), constrainPadding);
      }
    }
    const me = this, targetOffsets = createOffsets(spec.offset), {
      align,
      axisLock,
      anchorSize,
      anchorPosition,
      matchSize,
      position,
      rtl
    } = spec, isPoint = target && (target.width < 2 && target.height < 2), alignSpec = parseAlign(align, rtl), targetConstrainRect = constrainTo && constrainTo.clone(), constraintZones = [], zoneOrder = [{
      zone: zone = alignSpec.startZone,
      align
    }], matchDimension = matchSize && matchDimensions[alignSpec.startZone & 1], originalSize = me[matchDimension];
    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    } else if (!alignSpec.edgeAligned && matchSize) {
      result.width = target.width;
      result.height = target.height;
    }
    if (constrainTo) {
      result.constrainTo(constrainTo);
    }
    if (constrainTo && alignSpec.startZone != null) {
      if (axisLock) {
        zoneOrder.push({
          zone: zone = (zone + 2) % 4,
          align: flipAlign(alignSpec)
        });
        if (axisLock === "flexible") {
          zoneOrder.push({
            zone: zone = (alignSpec.startZone + 1) % 4,
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: zone = (zone + 2) % 4,
            align: defaultAlignments[zone]
          });
        }
      } else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: zone = (zone + 1) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
    }
    if (anchorPosition) {
      const pos = alignSpec.startZone & 1 ? "y" : "x";
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }
    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }
    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;
    if (position) {
      result.moveTo(position.x, position.y);
      result.translate.apply(result, targetOffsets);
      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    } else {
      const centerAligned = alignSpec.myEdge === "c" || alignSpec.targetEdge === "c", offsets = anchorSize && !centerAligned ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets;
      const baseTargetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint), targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets), myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);
      let overlap = !isPoint && result.clone().translate(baseTargetPoint[0] - myPoint[0], baseTargetPoint[1] - myPoint[1]).intersect(target, true);
      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);
      if (overlap) {
        result.translate(-(targetPoint[0] - myPoint[0]), -(targetPoint[1] - myPoint[1]));
        result.translate(baseTargetPoint[0] - myPoint[0], baseTargetPoint[1] - myPoint[1]);
        result.translate(...offsets);
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }
        resultZone = alignSpec.startZone;
      } else if (constrainTo && !constrainTo.contains(result)) {
        const requestedResult = result.clone(), solutions = [];
        let zone2, largestZone;
        calculatedAnchorPosition = null;
        constraintZones[0] = zone2 = constrainTo.clone();
        zone2.bottom = target.y - offsets[1];
        constraintZones[1] = zone2 = constrainTo.clone();
        zone2.x = target.right + offsets[0];
        constraintZones[2] = zone2 = constrainTo.clone();
        zone2.y = target.bottom + offsets[1];
        constraintZones[3] = zone2 = constrainTo.clone();
        zone2.right = target.x - offsets[0];
        for (let i = 0; i < zoneOrder.length; i++) {
          if (matchDimension && i === 2) {
            result[matchDimension] = originalSize;
          }
          zone2 = constraintZones[resultZone = zoneOrder[i].zone];
          result = result.alignTo({
            target,
            offsets,
            align: zoneOrder[i].align
          });
          if (result.constrainTo(zone2, true)) {
            solutions.push({
              result,
              zone: resultZone
            });
            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }
          if (!largestZone || zone2.area > largestZone.area) {
            const r = result.clone();
            switch (resultZone) {
              case 0:
                r.moveTo(null, zone2.bottom - r.height);
                break;
              case 1:
                r.moveTo(zone2.left);
                break;
              case 2:
                r.moveTo(null, zone2.top);
                break;
              case 3:
                r.moveTo(zone2.right - r.width);
                break;
            }
            largestZone = {
              area: zone2.area,
              result: r,
              zone: resultZone
            };
          }
        }
        if (solutions.length) {
          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s12, s22) => {
              const s1TranslationDistance = Math.sqrt((requestedResult.x - s12.result.x) ** 2 + (requestedResult.y - s12.result.y) ** 2), s2TranslationDistance = Math.sqrt((requestedResult.x - s22.result.x) ** 2 + (requestedResult.y - s22.result.y) ** 2);
              return s1TranslationDistance - s2TranslationDistance;
            });
          }
          result = solutions[0].result;
          resultZone = solutions[0].zone;
        } else {
          result = largestZone.result;
          resultZone = largestZone.zone;
          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }
      if (isPoint) {
        result.overlap = overlap = false;
      } else {
        result.overlap = overlap = result.intersect(target, true);
      }
      result.zone = resultZone;
      if (anchorSize && !overlap) {
        if (!calculatedAnchorPosition) {
          const isLeftOrRight = resultZone & 1, start = isLeftOrRight ? "y" : "x", end = isLeftOrRight ? "bottom" : "right", startValue = Math.max(target[start], result[start]), endValue = Math.min(target[end], result[end]);
          let anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2;
          const anchorEnd = anchorStart + anchorSize[0];
          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }
          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }
          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }
        result.anchor = calculatedAnchorPosition;
      }
    }
    return result;
  }
  /**
   * Returns the `[x, y]` position of the specified anchor point of this Rectangle in <edge><offset> format.
   * for example passing "t50" will return the centre point of the top edge, passing "r0" will return the start
   * position of the right edge (the top right corner).
   *
   * Note that the offset defaults to 50, so "t" means the centre of the top edge.
   * @param {String} alignmentPoint The alignment point to calculate. Must match the RegExp `[trbl]\d*`
   * @param {Number[]} margins The `[x, y]` margins to add from the left/right, top/bottom edge.
   * @internal
   */
  getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
    alignmentPoint = String(alignmentPoint);
    const me = this, parts = alignPointRe.exec(alignmentPoint) || alignSpecRe.exec(alignmentPoint), edge = parts && parts[1].toLowerCase(), edgeOffset = parts && Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;
    switch (edge) {
      case "t":
        return [me.x + me.width * edgeOffset, me.y - margins[1]];
      case "r":
        return [me.right + margins[0], me.y + me.height * edgeOffset];
      case "b":
        return [me.x + me.width * edgeOffset, me.bottom + margins[1]];
      case "l":
        return [me.x - margins[0], me.y + me.height * edgeOffset];
      case "c": {
        return [me.x + me.width / 2, me.y + me.height / 2];
      }
    }
  }
  /**
   * Highlights this Rectangle using the highlighting effect of {@link Core.helper.DomHelper}
   * on a transient element which encapsulates the region's area.
   */
  highlight() {
    const me = this, highlightElement = DomHelper.createElement({
      parent: document.body,
      style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
    });
    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }
  /**
   * Visualizes this Rectangle by adding a DOM element which encapsulates the region's area into the provided parent element.
   * @param {DomConfig} config Element config object
   * @returns {Element} The highlight element
   * @internal
   */
  visualize(config, asDomConfig) {
    const me = this, domConfig = ObjectHelper.merge({
      style: {
        left: `${me.x}px`,
        top: `${me.y}px`,
        width: `${me.width}px`,
        height: `${me.height}px`,
        pointerEvents: "none",
        // If this visualization is provided a CSS class, let outside handle position + z-index
        ...config.class ? {} : { position: "absolute", "z-index": 9999999 }
      }
    }, config);
    return asDomConfig ? domConfig : DomHelper.createElement(domConfig);
  }
  toString(delimiter = ",") {
    return [`${this.top}px`, `${this.right}px`, `${this.bottom}px`, `${this.left}px`].join(delimiter);
  }
};
var Point = class extends Rectangle {
  /**
   * Creates a new Point encapsulating the event's page position.
   * @param {Event} event The DOM event
   * @returns {Core.helper.util.Rectangle}
   * @typings ignore
   */
  static from(event, relativeToPage = VersionHelper.checkVersion("core", "6.0", ">=")) {
    const propName = relativeToPage ? "client" : "screen";
    if (event.changedTouches) {
      event = event.changedTouches[0];
    }
    const x = event[`${propName}X`], y = event[`${propName}Y`];
    return new this(x, y);
  }
  /**
   * Constructs a Point
   * @param x The X coordinate
   * @param y The Y coordinate
   */
  constructor(x, y) {
    super(x, y, 0, 0);
  }
  /**
   * Coerces this Point to be within the passed Rectangle. Translates it into the bounds.
   * @param {Core.helper.util.Rectangle} into The Rectangle into which to coerce this Point.
   */
  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
};
Rectangle._$name = "Rectangle";

// ../Core/lib/Core/helper/util/DomClassList.js
var valueSymbol = Symbol("value");
var lengthSymbol = Symbol("length");
var DomClassList = class _DomClassList {
  static change(cls, add, remove, as = "string") {
    remove = _DomClassList.normalize(remove, "object");
    const after = _DomClassList.normalize(cls, "array").filter((c) => !remove[c]);
    if (add) {
      add = _DomClassList.normalize(add, "array");
      for (let i = 0; i < add.length; ++i) {
        if (!after.includes(add[i])) {
          after.push(add[i]);
        }
      }
    }
    return _DomClassList.normalize(after, as);
  }
  static from(classes, returnEmpty) {
    if (classes) {
      if (classes.isDomClassList) {
        returnEmpty = returnEmpty != null ? returnEmpty : true;
      } else {
        returnEmpty = returnEmpty != null ? returnEmpty : Objects.isObject(classes) && !Objects.isEmpty(classes);
        classes = new _DomClassList(classes);
      }
      if (!classes.value && !returnEmpty) {
        classes = null;
      }
    }
    return classes || (returnEmpty ? new _DomClassList() : null);
  }
  /**
   * Converts a class name of any understood type to a desired form.
   * @param {String|String[]|Object|Set|Map|HTMLElement} cls
   * @param {String} as Pass `'object'` to return an object with the class names as its keys (all keys will have a
   * value of `true`), or pass `'array'` to return an array of class names, or pass `'string'` (the default) to
   * return a space-separated string of class names.
   * @returns {String|String[]|Object}
   * @internal
   */
  static normalize(cls, as = "string") {
    cls = cls || "";
    const type = typeof cls, asArray = as === "array", asObject = as === "object", asString = !asArray && !asObject;
    let isString = type === "string", c, i, ret;
    if (type === "object") {
      if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === "function") {
        cls = cls.getAttribute("class") || "";
        isString = true;
      } else if (cls == null ? void 0 : cls.isDomClassList) {
        cls = cls.values;
      } else if (cls instanceof DOMTokenList) {
        cls = Array.from(cls);
      } else if (cls instanceof Map) {
        cls = Array.from(cls.keys()).filter((k) => cls.get(k));
      } else if (cls instanceof Set) {
        cls = Array.from(cls);
      } else if (!Array.isArray(cls)) {
        cls = Objects.getTruthyKeys(cls);
      }
    }
    if (isString) {
      cls = [...new Set(StringHelper.split(cls))];
    }
    for (i = cls.length; i-- > 0; ) {
      c = cls[i];
      if (!c.length) {
        cls.splice(i, 1);
      } else if (c.includes(" ")) {
        cls.splice(i, 1, ...StringHelper.split(c));
      }
    }
    if (asArray) {
      ret = cls;
    } else if (asString) {
      ret = cls.join(" ");
    } else {
      ret = /* @__PURE__ */ Object.create(null);
      for (i = 0; i < cls.length; ++i) {
        ret[cls[i]] = true;
      }
    }
    return ret;
  }
  /**
   * Initializes a new DomClassList.
   * @param {...String|Object} classes The CSS classes as strings or objects.
   * @function constructor
   */
  constructor(...classes) {
    this.process(1, classes);
  }
  /**
   * Clears all class names from this DomClassList instance.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  clear() {
    for (const key in this) {
      this[key] = false;
    }
    return this;
  }
  /**
   * Sets this DomClassList instance to represent the classes passed as either strings or objects.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  set(...classes) {
    return this.clear().process(1, classes);
  }
  // To gain some speed in DomHelper.sync(), faster than instanceof etc
  get isDomClassList() {
    return true;
  }
  /**
   * Returns a clone of this DomClassList with all the same keys set.
   * @returns {Core.helper.util.DomClassList} A clone of this DomClassList.
   */
  clone() {
    return new _DomClassList(this);
  }
  /**
   * Returns a Boolean value, indicating whether this ClassList has the specified CSS class name.
   * @param {String} className CSS class name to check
   * @returns {Boolean} true if this ClassList contains the passed CSS class name, false otherwise
   */
  contains(className) {
    if (typeof className === "string" && className) {
      return Boolean(this[className]);
    }
    return false;
  }
  // An instance of this class may be assigned directly to an element's className
  // it will be coerced to a string value using this method.
  toString() {
    return this.length ? `${this.value} ` : "";
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.
   * @returns {String} A concatenated string value of all the class names in this `DomClassList`
   * separated by spaces.
   */
  trim() {
    return this.value;
  }
  /**
   * Compares this DomClassList to another DomClassList (or class name string of space separated classes).
   * If the same class names (regardless of order) are present, the two are considered equal.
   *
   * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`
   * @param {Core.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.
   * @returns {Boolean} `true` if the two contain the same class names.
   */
  isEqual(other) {
    const otherClasses = _DomClassList.normalize(other, "array"), len = otherClasses.length;
    if (this.length === len) {
      for (let i = 0; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Get/set string value.
   * Class names separated with space.
   * @property {String}
   */
  get value() {
    let value = this[valueSymbol], keys;
    if (value == null) {
      keys = Objects.getTruthyKeys(this);
      this[lengthSymbol] = keys.length;
      this[valueSymbol] = value = keys.join(" ");
    }
    return value;
  }
  set value(value) {
    const me = this, keys = Object.keys(me), len = keys.length;
    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }
    if (value) {
      me.process(1, [value]);
    } else {
      delete me[valueSymbol];
    }
  }
  /**
   * Returns string values as an array.
   * @readonly
   * @property {String[]}
   */
  get values() {
    return Objects.getTruthyKeys(this);
  }
  get length() {
    return this.value ? this[lengthSymbol] : 0;
  }
  process(value, classes) {
    for (let cls, k, i = 0; i < classes.length; i++) {
      if (classes[i]) {
        cls = classes[i];
        if (cls.isDomClassList || Objects.isObject(cls)) {
          for (k in cls) {
            this[k] = value ? cls[k] : !cls[k];
          }
        } else {
          cls = _DomClassList.normalize(classes[i], "array");
          for (k = 0; k < cls.length; ++k) {
            this[cls[k]] = value;
          }
        }
      }
    }
    delete this[valueSymbol];
    return this;
  }
  /**
   * Adds/removes class names according to the passed object's properties.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {Object} classList Object containing properties to set/clear
   */
  assign(classList) {
    for (const cls in classList) {
      if (!this[cls] !== !classList[cls]) {
        this[cls] = classList[cls];
        delete this[valueSymbol];
      }
    }
    return this;
  }
  /**
   * Adds/removes this objects classes to the passed `classList` or element.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {HTMLElement|DOMTokenList} element The element or the element's `classList` to be updated.
   */
  assignTo(element) {
    const classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element, temp = _DomClassList.from(classList);
    temp.add(this);
    classList.value = temp.value;
  }
  /**
   * Add CSS class(es)
   * ```
   * myClassList.add('bold', 'small');
   * ```javascript
   * @param {String|String[]|Object} classes CSS classes to add
   */
  add(...classes) {
    return this.process(1, classes);
  }
  /**
   * Remove CSS class(es)
   * ```javascript
   * myClassList.remove('bold', 'small');
   * ```
   * @param {String} classes CSS classes to remove
   */
  remove(...classes) {
    return this.process(0, classes);
  }
  /**
   * Toggles the passed CSS class name.
   *
   * If the `force` parameter is passed, `true` means add the class name, `false` means remove it.
   *
   * ```javascript
   * myClassList.toggle('bold', isImportant);
   * ```
   * @param {String} className CSS class to toggle
   * @param {Boolean} [force] `true` to add the class, `false` to remove it.
   * @returns {Boolean} `true` if the operation changed the value.
   */
  toggle(className, flag = Boolean(!this[className])) {
    flag = Boolean(flag);
    if (Boolean(this[className]) !== flag) {
      this[className] = flag;
      delete this[valueSymbol];
      return true;
    }
  }
  /**
   * Analogous to the `String#split` method, but with no delimiter
   * parameter. This method returns an array containing the individual
   * CSS class names set.
   * @returns {String[]} The individual class names in this `DomClassList`
   */
  split() {
    return Objects.getTruthyKeys(this);
  }
  forEach(fn) {
    return Objects.getTruthyKeys(this).forEach(fn);
  }
};
DomClassList.prototype[valueSymbol] = null;
DomClassList._$name = "DomClassList";

// ../Core/lib/Core/helper/EventHelper.js
var touchProperties = [
  "clientX",
  "clientY",
  "pageX",
  "pageY",
  "screenX",
  "screenY"
];
var isOption = {
  element: 1,
  thisObj: 1,
  once: 1,
  delegate: 1,
  delay: 1,
  capture: 1,
  passive: 1,
  throttled: 1,
  autoDetach: 1,
  expires: 1,
  block: 1
};
var configurable = true;
var returnTrueProp = {
  configurable,
  value: true
};
var normalizedKeyNames = {
  Spacebar: "Space",
  Del: "Delete",
  Esc: "Escape",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown"
};
var specialKeys = {
  Control: "ctrl",
  Alt: "alt",
  Shift: "shift"
};
var specialKeyRe = /^(ctrl|shift|alt|meta)$/;
var eventProps = [
  "altKey",
  "bubbles",
  "button",
  "buttons",
  "cancelBubble",
  "cancelable",
  "clientX",
  "clientY",
  "ctrlKey",
  "layerX",
  "layerY",
  "metaKey",
  "pageX",
  "pageY",
  "returnValue",
  "screenX",
  "screenY",
  "shiftKey"
];
var _EventHelper = class _EventHelper {
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.changedTouches[0] || event.touches[0], touchProperties);
  }
  /**
   * For use when synthesizing events from native DOM events. Copies valid properties from the passed
   * event into the destination object;
   * @param {Object} dest Destination object
   * @param {Event} event The event whose properties to copy
   * @returns {Object} An event construction object.
   * @internal
   */
  static copyEvent(dest, event) {
    return ObjectHelper.copyProperties(dest, event, eventProps);
  }
  /**
   * Returns the `[x, y]` coordinates of the event in the viewport coordinate system.
   * @param {Event} event The event
   * @returns {Number[]} The coordinate.
   */
  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }
    return [event.clientX, event.clientY];
  }
  /**
   * Returns the pixel distance between two mouse/touch/pointer events.
   * @param {Event} event1 The first event.
   * @param {Event} event2 The second event.
   * @returns {Number} The distance in pixels between the two events.
   */
  static getDistanceBetween(event1, event2, options) {
    const xy1 = EH.getXY(event1), xy2 = EH.getXY(event2), xDistance = xy1[0] - xy2[0], yDistance = xy1[1] - xy2[1];
    if (options == null ? void 0 : options.x) {
      return xDistance;
    }
    if (options == null ? void 0 : options.y) {
      return yDistance;
    }
    return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));
  }
  /**
   * Returns a {@link Core.helper.util.Rectangle.Point} which encapsulates the `pageX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Rectangle.Point} The page point.
   */
  static getPagePoint(event) {
    return new Point(event.pageX, event.pageY);
  }
  /**
   * Returns a {@link Core.helper.util.Rectangle.Point} which encapsulates the `clientX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Rectangle.Point} The page point.
   */
  static getClientPoint(event) {
    return new Point(event.clientX, event.clientY);
  }
  /**
   * Add a listener or listeners to an element
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   * @param {EventTarget} element The event target to add a listener/listeners to.
   * @param {String|Object} eventName Either a string, being the name of the event to listen for,
   * or an options object containing event names and options as keys. See the options parameter
   * for details, or the {@link #function-on-static} method for details.
   * @param {Function} [handler] If the second parameter is a string event name, this is the handler function.
   * @param {ElementListenerConfig} [options] If the second parameter is a string event name, this is the options.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {
      if (typeof eventName === "string") {
        options = Object.assign({
          element,
          [eventName]: handler
        }, options);
      } else {
        options = Object.assign({
          element
        }, eventName);
      }
    } else {
      options = element;
    }
    return EH.on(options);
  }
  /**
   * Adds a listener or listeners to an element.
   * all property names other than the options listed below are taken to be event names,
   * and the values as handler specs.
   *
   * A handler spec is usually a function reference or the name of a function in the `thisObj`
   * option.
   *
   * But a handler spec may also be an options object containing a `handler` property which is
   * the function or function name, and local options, including `element` and `thisObj`
   * which override the top level options.
   *
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   *  Usage example
   *
   * ```javascript
   * construct(config) {
   *     super.construct(config);
   *
   *     // Add auto detaching event handlers to this Widget's reference elements
   *     EventHelper.on({
   *         element : this.iconElement,
   *         click   : '_handleIconClick',
   *         thisObj : this,
   *         contextmenu : {
   *             element : document,
   *             handler : '_handleDocumentContextMenu'
   *         }
   *     });
   * }
   *```
   *
   * The `click` handler on the `iconElement` calls `this._handleIconClick`.
   *
   * The `contextmenu` handler is added to the `document` element, but the `thisObj`
   * is defaulted in from the top `options` and calls `this._handleDocumentContextMenu`.
   *
   * Note that on touch devices, `dblclick` and `contextmenu` events are synthesized.
   * Synthesized events contain a `browserEvent` property containing the final triggering
   * event of the gesture. For example a synthesized `dblclick` event would contain a
   * `browserEvent` property which is the last `touchend` event. A synthetic `contextmenu`
   * event will contain a `browserEvent` property which the longstanding `touchstart` event.
   *
   * @param {ElementListenerConfig} options The full listener specification.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static on(options) {
    const element = options.element, thisObj = options.thisObj, handlerDetails = [];
    for (const eventName in options) {
      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];
        if (typeof handlerSpec !== "object") {
          handlerSpec = {
            handler: handlerSpec
          };
        }
        const targetElement = handlerSpec.element || element;
        handlerDetails.push(EH.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }
    const detacher2 = () => {
      for (let handlerSpec, i = 0; i < handlerDetails.length; i++) {
        handlerSpec = handlerDetails[i];
        EH.removeEventListener(handlerSpec[0], handlerSpec[1], handlerSpec[2]);
      }
      handlerDetails.length = 0;
    };
    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher2, thisObj);
    }
    return detacher2;
  }
  /**
   * Used internally to add a single event handler to an element.
   * @param {EventTarget} element The event target to add the handler to.
   * @param {String} eventName The name of the event to add a handler for.
   * @param {Function|String|Object} handlerSpec Either a function to call, or
   * the name of a function to call in the `thisObj`, or an object containing
   * the handler local options.
   * @param {Function|String} [handlerSpec.handler] Either a function to call, or
   * the name of a function to call in the `thisObj`.
   * @param {EventTarget} [handlerSpec.element] Optionally a local event target for the listener.
   * @param {Object} [handlerSpec.thisObj] A local `this` specification for the handler.
   * @param {Object} defaults The `options` parameter from the {@link #function-addListener-static} call.
   * @private
   */
  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = EH.createHandler(element, eventName, handlerSpec, defaults), { spec } = handler, expires = handlerSpec.expires || defaults.expires, options = spec.capture != null || spec.passive != null ? {
      capture: spec.capture,
      passive: spec.passive
    } : void 0;
    element.addEventListener(eventName, handler, options);
    if (expires) {
      const thisObj = handlerSpec.thisObj || defaults.thisObj, delayable = (thisObj == null ? void 0 : thisObj.isDelayable) ? thisObj : globalThis, { alt: alt2 } = expires, delay = alt2 ? expires.delay : expires, { spec: spec2 } = handler;
      spec2.expires = expires;
      spec2.timerId = delayable[typeof delay === "number" ? "setTimeout" : "requestAnimationFrame"](() => {
        spec2.timerId = null;
        EH.removeEventListener(element, eventName, handler);
        if (alt2 && !handler.called) {
          (typeof alt2 === "string" ? thisObj[alt2] : alt2).call(thisObj);
        }
      }, delay, `listener-timer-${performance.now()}`);
    }
    return [element, eventName, handler, options];
  }
  // composedPath throws in salesforce
  // https://github.com/bryntum/support/issues/4432
  static getComposedPathTarget(event) {
    return event.composedPath()[0] || event.path[0];
  }
  static fixEvent(event) {
    var _a4, _b, _c;
    if (event.fixed) {
      return event;
    }
    const { type, target } = event;
    if (((target == null ? void 0 : target.shadowRoot) || ((_b = (_a4 = target == null ? void 0 : target.getRootNode) == null ? void 0 : _a4.call(target)) == null ? void 0 : _b.host)) && event.composedPath) {
      const targetElement = this.getComposedPathTarget(event), originalTarget = target;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
      Object.defineProperty(event, "originalTarget", {
        value: originalTarget,
        configurable
      });
    }
    Object.defineProperty(event, "fixed", returnTrueProp);
    if (type.startsWith("key")) {
      const normalizedKeyName = normalizedKeyNames[event.key];
      if (normalizedKeyName) {
        Object.defineProperty(event, "key", {
          value: normalizedKeyName,
          configurable
        });
      }
      if (event.key === " " && !event.code) {
        Object.defineProperty(event, "code", {
          value: "Space",
          configurable
        });
      }
    }
    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, "ctrlKey", returnTrueProp);
    }
    if (target && "offsetX" in event) {
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetX")) {
        Object.defineProperty(event, "borderOffsetX", {
          get: () => {
            return event.offsetX + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-left-width")));
          }
        });
      }
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetY")) {
        Object.defineProperty(event, "borderOffsetY", {
          get: () => {
            return event.offsetY + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-top-width")));
          }
        });
      }
    }
    if ((target == null ? void 0 : target.nodeType) === Element.DOCUMENT_NODE && "clientX" in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if ((target == null ? void 0 : target.nodeType) === Element.TEXT_NODE) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if (((_c = event.relatedTarget) == null ? void 0 : _c.nodeType) === Element.TEXT_NODE) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, "relatedTarget", {
        value: relatedTargetElement,
        configurable
      });
    }
    if (type.startsWith("touch") && event.touches.length) {
      this.normalizeEvent(event);
    }
    return event;
  }
  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay = handlerSpec.delay || defaults.delay, throttled = handlerSpec.throttled || defaults.throttled, block = handlerSpec.block || defaults.block, once = "once" in handlerSpec ? handlerSpec.once : defaults.once, capture = "capture" in handlerSpec ? handlerSpec.capture : defaults.capture, passive = "passive" in handlerSpec ? handlerSpec.passive : defaults.passive, delegate = "delegate" in handlerSpec ? handlerSpec.delegate : defaults.delegate, wrappedFn = handlerSpec.handler, expires = handlerSpec.expires, thisObj = handlerSpec.thisObj || defaults.thisObj, { rtlSource = thisObj } = thisObj || {};
    let handler = (event, ...args) => {
      if (EH.playingDemo && event.isTrusted) {
        return;
      }
      if (thisObj == null ? void 0 : thisObj.isDestroyed) {
        return;
      }
      event = EH.fixEvent(event, rtlSource == null ? void 0 : rtlSource.rtl);
      handler.called = true;
      (typeof wrappedFn === "string" ? thisObj[wrappedFn] : wrappedFn).call(thisObj, event, ...args);
      delete event.target;
      delete event.relatedTarget;
      delete event.originalTarget;
      delete event.key;
      delete event.code;
      delete event.ctrlKey;
      delete event.fixed;
    };
    if (block) {
      const wrappedFn2 = handler;
      let lastCallTime, lastTarget;
      handler = (e, ...args) => {
        const now2 = performance.now();
        if (!lastCallTime || e.target !== lastTarget || now2 - lastCallTime > block) {
          lastTarget = e.target;
          lastCallTime = now2;
          wrappedFn2(e, ...args);
        }
      };
    }
    if (delay != null) {
      const wrappedFn2 = handler, delayable = (thisObj == null ? void 0 : thisObj.setTimeout) ? thisObj : globalThis;
      handler = (...args) => {
        delayable.setTimeout(() => {
          wrappedFn2(...args);
        }, delay);
      };
    }
    if (throttled != null) {
      let alt2, buffer = throttled;
      if (throttled.buffer) {
        alt2 = (e) => {
          return throttled.alt.call(EH, EH.fixEvent(e, rtlSource == null ? void 0 : rtlSource.rtl));
        };
        buffer = throttled.buffer;
      }
      if (thisObj == null ? void 0 : thisObj.isDelayable) {
        handler = thisObj.throttle(handler, {
          delay: buffer,
          throttled: alt2
        });
      } else {
        handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt2);
      }
    }
    if (once) {
      const wrappedFn2 = handler;
      handler = (...args) => {
        EH.removeEventListener(element, eventName, handler);
        wrappedFn2(...args);
      };
    }
    if (delegate) {
      const wrappedFn2 = handler;
      handler = (event, ...args) => {
        var _a4;
        event = EH.fixEvent(event, rtlSource == null ? void 0 : rtlSource.rtl);
        const delegatedTarget = ((_a4 = event.target.closest) == null ? void 0 : _a4.call) && event.target.closest(delegate);
        if (!delegatedTarget) {
          return;
        }
        Object.defineProperty(event, "currentTarget", {
          get: () => delegatedTarget,
          configurable: true
        });
        wrappedFn2(event, ...args);
      };
    }
    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => EH.removeEventListener(element, eventName, handler), thisObj);
    }
    handler.spec = {
      delay,
      throttled,
      block,
      once,
      thisObj,
      capture,
      expires,
      passive,
      delegate
    };
    return handler;
  }
  static removeEventListener(element, eventName, handler) {
    const { expires, timerId, thisObj, capture } = handler.spec;
    if ((expires == null ? void 0 : expires.alt) && timerId) {
      const delayable = (thisObj == null ? void 0 : thisObj.isDelayable) ? thisObj : globalThis;
      delayable[typeof expires.delay === "number" ? "clearTimeout" : "cancelAnimationFrame"](timerId);
    }
    element.removeEventListener(eventName, handler, capture);
  }
  /**
   * Calls a callback when the described animation completes.
   *
   * @param {Object} detail
   * @param {HTMLElement} detail.element The element which is being animated.
   * @param {String|RegExp} [detail.animationName] The name of the animation to wait for.
   * @param {String} [detail.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Function} detail.handler The function to call on animation end.
   * @param {Number} [detail.duration] Optional fallback time to wait until calling the callback.
   * @param {Object} [detail.thisObj] The `this` reference to call the callback with.
   * @param {Array} [detail.args] Optional arguments to call the callback with.
   * @param {Core.mixin.Delayable} [detail.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [detail.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @returns {Function} a function which detaches the animation end listener.
   */
  static onTransitionEnd({
    element,
    animationName,
    property,
    handler,
    mode = animationName ? "animation" : "transition",
    duration = DomHelper[`get${mode === "transition" ? "Property" : ""}${StringHelper.capitalize(mode)}Duration`](element, property),
    timeout,
    thisObj = globalThis,
    args = [],
    timerSource,
    runOnDestroy
  }) {
    let timerId, maxDurationTimerId;
    timerSource = timerSource || (thisObj.isDelayable ? thisObj : globalThis);
    const { isDelayable } = timerSource, now2 = performance.now(), transitionTimerId = `transitionTimer${now2}`, timeoutTimerId = `timeoutTimer${now2}`, callbackArgs = [element, property, ...args], doCallback = () => {
      detacher2();
      if (!thisObj.isDestroyed) {
        if (thisObj.callback) {
          thisObj.callback(handler, thisObj, callbackArgs);
        } else {
          handler.apply(thisObj, callbackArgs);
        }
      }
    }, detacher2 = EH.on({
      element,
      [`${mode}end`]({ animationName: endedAnimation, propertyName, target }) {
        var _a4, _b;
        if (target === element) {
          if (propertyName === property || (endedAnimation == null ? void 0 : endedAnimation.match(animationName))) {
            if (timerId) {
              if (maxDurationTimerId) {
                (_a4 = timerSource.clearTimeout) == null ? void 0 : _a4.call(timerSource, isDelayable ? timeoutTimerId : maxDurationTimerId);
              }
              (_b = timerSource.clearTimeout) == null ? void 0 : _b.call(timerSource, isDelayable ? transitionTimerId : timerId);
              timerId = null;
            }
            doCallback();
          }
        }
      }
    });
    if (timeout) {
      maxDurationTimerId = timerSource.setTimeout(doCallback, Math.max(timeout, (duration || 0) + 100), timeoutTimerId);
    }
    if (duration != null) {
      timerId = timerSource.setTimeout(doCallback, duration + 50, transitionTimerId, runOnDestroy);
    }
    return detacher2;
  }
  /**
   * Waits for the described animation completes.
   *
   * @param {Object} config
   * @param {HTMLElement} config.element The element which is being animated.
   * @param {String|RegExp} [config.animationName] The name of the animation to wait for.
   * @param {String} [config.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Number} [config.duration] Optional fallback time to wait until calling the callback.
   * @param {Core.mixin.Delayable} [config.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [config.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @async
   */
  static async waitForTransitionEnd(config) {
    return new Promise((resolve) => {
      config.handler = resolve;
      _EventHelper.onTransitionEnd(config);
    });
  }
  /**
   * Private function to wrap the passed function. The returned wrapper function to be used as
   * a `touchend` handler which will call the passed function passing a fabricated `dblclick`
   * event if there is a `click` within 300ms.
   * @param {Element} element element
   * @param {String|Function} handler The handler to call.
   * @param {Object} thisObj The owner of the function.
   * @private
   */
  static createDblClickWrapper(element, handler, thisObj) {
    let startId, secondListenerDetacher, tapholdTimer;
    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EH.on({
          element,
          // We only get here if a touchstart arrives within 300ms of a click
          touchstart: (secondStart) => {
            startId = secondStart.changedTouches[0].identifier;
            secondStart.preventDefault();
          },
          touchend: (secondClick) => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();
              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;
              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true), offsetX = secondClick.changedTouches[0].pageX - targetRect.x, offsetY = secondClick.changedTouches[0].pageY - targetRect.y, dblclickEventConfig = Object.assign({
                browserEvent: secondClick
              }, secondClick), dblclickEvent = new MouseEvent("dblclick", dblclickEventConfig);
              Object.defineProperties(dblclickEvent, {
                target: { value: secondClick.target },
                offsetX: { value: offsetX },
                offsetY: { value: offsetY }
              });
              if (typeof handler === "string") {
                handler = thisObj[handler];
              }
              handler.call(thisObj, dblclickEvent);
            }
          },
          once: true
        });
        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EH.dblClickTime);
      }
    };
  }
  /**
   * Handles various inputs to figure out the name of the special key of the event.
   *
   * ```javascript
   * EventHelper.toSpecialKey('ctrl') // 'ctrlKey'
   * EventHelper.toSpecialKey(true)   // 'ctrlKey', default for PC (Cmd for Mac)
   * EventHelper.toSpecialKey(false)  // false
   * EventHelper.toSpecialKey('foo')  // false
   * ```
   *
   * @param {*} value User input value to process.
   * @param {String} defaultValue Default value to fall back to if `true` value is passed.
   * @returns {Boolean|String} Returns `false` if provided value cannot be converted to special key and special key
   * name otherwise.
   * @internal
   */
  static toSpecialKey(value, defaultValue2 = BrowserHelper.isMac ? "metaKey" : "ctrlKey") {
    let result = false;
    if (value === true) {
      result = defaultValue2;
    } else if (typeof value === "string") {
      value = value.toLowerCase();
      if (value.match(specialKeyRe)) {
        result = `${value}Key`;
      }
    }
    return result;
  }
  /**
   * If keyup event is triggered when special key is pressed, we don't get special key value from properties like
   * `ctrlKey`. Instead we need to read `event.key`. That property uses full name and we use abbreviations, so we
   * need to convert the key.
   * @param {String} code
   * @returns {String}
   * @internal
   */
  static specialKeyFromEventKey(code) {
    return specialKeys[code] || "no-special-key";
  }
};
/**
 * DOM event to trigger name mapping.
 * @internal
 */
__publicField(_EventHelper, "eventNameMap", {
  mousedown: "MouseDown",
  mouseup: "MouseUp",
  click: "Click",
  dblclick: "DblClick",
  contextmenu: "ContextMenu",
  mouseenter: "MouseEnter",
  mouseleave: "MouseLeave",
  mousemove: "MouseMove",
  mouseover: "MouseOver",
  mouseout: "MouseOut",
  keyup: "KeyUp",
  keydown: "KeyDown",
  keypress: "KeyPress"
});
var EventHelper = _EventHelper;
var EH = EventHelper;
EH.longPressTime = 700;
EH.dblClickTime = 300;
if (BrowserHelper.isTouchDevice) {
  EH.on({
    element: document,
    touchmove: (event) => {
      if (event.target.closest(".b-dragging")) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}
EventHelper._$name = "EventHelper";

// ../Core/lib/Core/helper/DomHelper.js
var DEFAULT_FONT_SIZE = 14;
var t0t0 = { align: "t0-t0" };
var ELEMENT_NODE = Node.ELEMENT_NODE;
var TEXT_NODE = Node.TEXT_NODE;
var { isObject } = ObjectHelper;
var numberRe = /[+-]?\d*\.?\d+[eE]?-?\d*/g;
var numberReSrc = numberRe.source;
var translateMatrix2dRe = new RegExp(`matrix\\((?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(${numberReSrc}),\\s?(${numberReSrc})`);
var translateMatrix3dRe = new RegExp(`matrix3d\\((?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(-?\\d*),\\s?(-?\\d*)`);
var translateMatrixRe = new RegExp(`(?:${translateMatrix2dRe.source})|(?:${translateMatrix3dRe.source})`);
var pxTtranslateXRe = new RegExp(`translate(3d|X)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var pxTtranslateYRe = new RegExp(`translate(3d|Y)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var whiteSpaceRe2 = /\s+/;
var semicolonRe = /\s*;\s*/;
var colonRe = /\s*:\s*/;
var digitsRe = /^-?((\d+(\.\d*)?)|(\.?\d+))$/;
var elementPropKey = "$bryntum";
var elementCreateExpandos = {
  elementData: "",
  for: "htmlFor",
  retainElement: ""
};
var elementCreateProperties = {
  // these two are handled by being in elementCreateExpands:
  // elementData  : 1,
  // for          : 1,
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  style: 1,
  dataset: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  class: 1,
  className: 1,
  unmatched: 1,
  // Used by syncId approach
  onlyChildren: 1,
  // Used by sync to not touch the target element itself,
  listeners: 1,
  // eslint-disable-line bryntum/no-listeners-in-lib
  compareHtml: 1,
  // Sync
  syncOptions: 1,
  // Sync
  keepChildren: 1
  // Sync
};
var styleIgnoreProperties = {
  length: 1,
  parentRule: 1,
  style: 1
};
var nativeEditableTags = {
  INPUT: 1,
  TEXTAREA: 1
};
var nativeFocusableTags = {
  BUTTON: 1,
  IFRAME: 1,
  EMBED: 1,
  INPUT: 1,
  OBJECT: 1,
  SELECT: 1,
  TEXTAREA: 1,
  BODY: 1
};
var win = globalThis;
var doc = document;
var emptyObject4 = Object.freeze({});
var arraySlice = Array.prototype.slice;
var immediatePromise = Promise.resolve();
var fontProps = [
  "font-size",
  "font-size-adjust",
  "font-style",
  "font-weight",
  "font-family",
  "font-kerning",
  "font-stretch",
  "line-height",
  "text-transform",
  "text-decoration",
  "letter-spacing",
  "word-break"
];
var isHiddenWidget = (e) => e._hidden;
var mergeChildren = (dest, src, options) => {
  if (options.key === "children") {
    return ObjectHelper.mergeItems(dest, src, options);
  }
  return ObjectHelper.blend(dest, src, options);
};
var isVisible = (e, skipVisibility) => {
  if (e.isConnected) {
    const style = e.ownerDocument.defaultView.getComputedStyle(e);
    return style.getPropertyValue("display") !== "none" && (skipVisibility || style.getPropertyValue("visibility") !== "hidden");
  }
};
var hasLayout = (el) => el && (el === doc.body || Boolean(el.offsetParent) || (el.ownerDocument.defaultView && ("offsetParent" in el && DomHelper.getStyleValue(el, "position") !== "fixed") ? el.offsetParent : hasLayout(el.parentNode)));
var elementOrConfigToElement = (elementOrConfig) => {
  if (elementOrConfig instanceof Node) {
    return elementOrConfig;
  }
  if (typeof elementOrConfig === "string") {
    return DH2.createElementFromTemplate(elementOrConfig);
  }
  return DH2.createElement(elementOrConfig);
};
var canonicalStyles = /* @__PURE__ */ Object.create(null);
var canonicalizeStyle = (name, hasUnit) => {
  const entry = canonicalStyles[name] || [StringHelper.hyphenate(name), hasUnit];
  if (!canonicalStyles[name]) {
    canonicalStyles[entry[0]] = canonicalStyles[name] = entry;
  }
  return entry;
};
var slideInAnimationName = /b-slide-in-from-\w+/;
var scrollStyles = {
  auto: 1,
  scroll: 1
};
var getParent = (node) => {
  const result = node.ownerSVGElement ? node.ownerSVGElement.parentNode : node.parentNode || node.target;
  return (result == null ? void 0 : result.nodeType) === Node.DOCUMENT_FRAGMENT_NODE ? result.host : result;
};
var isElement = (node) => (node == null ? void 0 : node.nodeType) === Node.ELEMENT_NODE;
[
  "top",
  "right",
  "bottom",
  "left",
  "width",
  "height",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "borderSpacing",
  "borderWidth",
  "borderTopWidth",
  "borderRightWidth",
  "borderBottomWidth",
  "borderLeftWidth",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "outlineWidth",
  "textIndent",
  "wordSpacing"
].forEach((name) => canonicalizeStyle(name, true));
var scrollBarWidth = null;
var idCounter = 0;
var themeInfo = null;
var templateElement;
var htmlParser;
var scrollBarMeasureElement;
var DomHelper = class _DomHelper {
  /**
   * Animates the specified element to slide it into view within the visible viewport
   * of its parentElement from the direction of movement.
   *
   * So in a left-to-right Widget, `direction` 1 means it slides in from the right
   * and `direction` -1 means it slides in from the left. RTL reverses the movement.
   *
   * See the forward/backward navigations in {@link Core.widget.DatePicker} for an example
   * of this in action.
   *
   * If "next" should arrive from below and "previous" should arrive from above, add the
   * class `b-slide-vertical` to the element.
   * @param {HTMLElement} element The element to slide in.
   * @param {Number} direction
   * * `1` to slide in from the "next" direction.
   * * `-1` to slide in from the "previous" direction.
   *
   * If the element is inside an RTL widget the directions are reversed.
   * @async
   */
  static async slideIn(element, direction = 1) {
    const cls = `b-slide-in-${direction > 0 ? "next" : "previous"}`, {
      classList,
      parentNode: { classList: pClassList }
    } = element;
    pClassList.add(".b-sliding-child-element");
    classList.add(cls);
    await EventHelper.waitForTransitionEnd({
      element,
      animationName: slideInAnimationName
    });
    classList.remove(cls);
    pClassList.remove(".b-sliding-child-element");
  }
  /**
   * Returns `true` if the passed element is focusable either programmatically or through pointer gestures.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} Returns `true` if the passed element is focusable
   */
  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {
      if (!DH2.isVisible(element) || DH2.Widget.fromElement(element, isHiddenWidget)) {
        return false;
      }
    }
    const nodeName = element.nodeName;
    return nativeFocusableTags[nodeName] || (nodeName === "A" || nodeName === "LINK") && !!element.href || element.getAttribute("tabIndex") != null || element.contentEditable === "true";
  }
  /**
   * Returns `true` if the passed element accepts keystrokes to edit its contents.
   * @returns {Boolean} Returns `true` if the passed element is editable.
   */
  static isEditable(element) {
    return (element.isContentEditable || nativeEditableTags[element.nodeName]) && !(element.readOnly || element.disabled || element.closest("[inert]"));
  }
  /**
   * Returns the rectangle of the element or event which is currently visible in the browser viewport,
   * i.e. user can find it on screen, or `false` if it is scrolled out of view.
   * @param {HTMLElement|Event} target The element or event to test.
   * @param {Boolean} [whole=false] Whether to check that whole element is visible, not just part of it.
   * If this is passed as true, the result will be a boolean, `true` or `false`.
   * @privateparam {Core.widget.Widget} [caller] the Widget aligning to the target.
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the rectangle of the element which is currently visible in
   * the browser viewport, or `false` if it is out of view.
   */
  static isInView(target, whole = false, caller) {
    if (!hasLayout(isElement(target.target) ? target.target : target)) {
      return false;
    }
    const positioned = (caller == null ? void 0 : caller.positioned) && _DomHelper.getStyleValue(caller.element, "position") !== "fixed", docRect = Rectangle.from(globalThis), method = whole ? "contains" : "intersect", cOp = positioned && caller.element.offsetParent, cOpR = positioned && Rectangle.from(cOp);
    docRect.height = doc.scrollingElement.scrollHeight;
    if (target === doc.body) {
      return docRect;
    }
    const result = this.getViewportIntersection(target, docRect, method);
    if (result && positioned) {
      result.translate(doc.scrollingElement.scrollLeft, doc.scrollingElement.scrollTop);
    }
    return positioned && result ? result.translate(-cOpR.x + cOp.scrollLeft, -cOpR.y + cOp.scrollTop) : result;
  }
  /**
   * This method checks that the passed target is visible in all viewports
   * @param {HTMLElement|Event} target The HTML element or Event to check for intersection with all ancestor viewports.
   * @param {Core.helper.util.Rectangle} docRect Window rectangle
   * @param {'contains'|'intersect'} method 'contains' or 'intersect'
   * @returns {Core.helper.util.Rectangle}
   */
  static getViewportIntersection(target, docRect, method) {
    var _a4;
    const eventTarget = isElement(target.target) ? target.target : null, viewportRect = _DomHelper.getVisibleViewport(getParent(target), docRect, eventTarget || target), targetRect = Rectangle.from(eventTarget || target, null, true);
    if (eventTarget) {
      targetRect.translate(target.offsetX + 1, target.offsetY + 1);
      targetRect.height = targetRect.width = 0;
    }
    return (_a4 = viewportRect == null ? void 0 : viewportRect[method]) == null ? void 0 : _a4.call(viewportRect, targetRect, false, true);
  }
  static getVisibleViewport(startElement, docRect, targetEl) {
    const viewports = [];
    let result = docRect;
    for (let viewport = startElement; viewport && viewport !== doc.body; viewport = getParent(viewport)) {
      const style = viewport.ownerDocument.defaultView.getComputedStyle(viewport);
      if ((scrollStyles[style.overflowX] || scrollStyles[style.overflowY]) && style.display !== "contents") {
        viewports.unshift(Rectangle.client(viewport, null, true, true, targetEl));
      }
    }
    for (let i = 0, { length } = viewports; result && i < length; i++) {
      result = result.intersect(viewports[i]);
    }
    return result;
  }
  /**
   * Returns `true` if the passed element is deeply visible. Meaning it is not hidden using `display`
   * or `visibility` and no ancestor node is hidden.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} `true` if deeply visible.
   */
  static isVisible(element) {
    var _a4;
    const document2 = element.ownerDocument;
    let skipVisibility = false;
    for (; element; element = getParent(element)) {
      const style = (_a4 = element.ownerDocument) == null ? void 0 : _a4.defaultView.getComputedStyle(element);
      skipVisibility = skipVisibility || style.getPropertyValue("visibility") === "visible";
      if (element === document2) {
        return true;
      }
      if (isElement(element) && !isVisible(element, skipVisibility)) {
        return false;
      }
    }
    return false;
  }
  /**
   * Returns true if DOM Event instance is passed. It is handy to override to support Locker Service.
   * @param event
   * @internal
   * @returns {Boolean}
   */
  static isDOMEvent(event) {
    return event instanceof Event;
  }
  /**
   * Merges specified source DOM config objects into a `dest` object.
   * @param {DomConfig} dest The destination DOM config object.
   * @param {...DomConfig} sources The DOM config objects to merge into `dest`.
   * @returns {DomConfig} The `dest` object.
   * @internal
   */
  static merge(dest, ...sources) {
    return ObjectHelper.blend(dest, sources, { merge: mergeChildren });
  }
  /**
   * Updates in-place a DOM config object whose `children` property may be an object instead of the typical array.
   * The keys of such objects become the `reference` property upon conversion.
   *
   * @param {DomConfig} domConfig
   * @param {Function} [namedChildren] A function to call for each named child element.
   * @privateparam {Boolean} [ignoreRefs] Not meant to be manually set, used when recursing.
   * @returns {DomConfig} Returns the altered DOM config
   * @internal
   */
  static normalizeChildren(domConfig, namedChildren, ignoreRefs) {
    var _a4;
    let children = domConfig == null ? void 0 : domConfig.children, child, i, name, kids, ref;
    if ((_a4 = domConfig == null ? void 0 : domConfig.syncOptions) == null ? void 0 : _a4.ignoreRefs) {
      ignoreRefs = true;
    }
    if (children && !(domConfig instanceof Node)) {
      if (Array.isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          DH2.normalizeChildren(children[i], namedChildren, ignoreRefs);
        }
      } else {
        kids = children;
        domConfig.children = children = [];
        for (name in kids) {
          child = kids[name];
          if (child == null ? void 0 : child.isWidget) {
            child = child.element;
          }
          ref = !name.startsWith("$") && !DH2.isElement(child);
          ref && (namedChildren == null ? void 0 : namedChildren(
            name,
            /* hoist = */
            !ignoreRefs
          ));
          if (child) {
            if (!(child instanceof Node)) {
              if (child.reference === false) {
                delete child.reference;
              } else if (ref && typeof child !== "string") {
                child.reference = name;
              }
              DH2.normalizeChildren(child, namedChildren, ignoreRefs);
            }
            children.push(child);
          }
        }
      }
    }
    return domConfig;
  }
  static roundPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.round(px / multiplier) * multiplier;
  }
  // For use when we are dividing a DOM element into even parts. The resulting value
  // must be floored to prevent overflow. But only floored to the device's resolution,
  // so raw Math.floor will not work - it would leave empty space in hi resolution screens.
  static floorPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.floor(px * multiplier) / multiplier;
  }
  /**
   * Returns true if element has opened shadow root
   * @param {HTMLElement} element Element to check
   * @returns {Boolean}
   */
  static isCustomElement(element) {
    return Boolean(element == null ? void 0 : element.shadowRoot);
  }
  /**
   * Resolves element from point, checking shadow DOM if required
   * @param {Number} x
   * @param {Number} y
   * @returns {HTMLElement}
   */
  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);
    if (DH2.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }
    return el;
  }
  /**
   * Resolves child element from point __in the passed element's coordinate space__.
   * @param {HTMLElement} parent The element to find the occupying element in.
   * @param {Number|Core.helper.util.Rectangle.Point} x Either the `X` part of a point, or the point to find.
   * @param {Number} [y] The `Y` part of the point.
   * @returns {HTMLElement}
   * @internal
   */
  static childFromPoint(el, x, y, parent = el) {
    const p = y == null ? x : new Rectangle(x, y, 0, 0);
    let result = null;
    Array.from(el.children).reverse().some((el2) => {
      if (Rectangle.from(el2, parent).contains(p)) {
        result = el2.children.length && DH2.childFromPoint(el2, p, null, parent) || el2;
        return true;
      }
    });
    return result;
  }
  /**
   * Converts a name/value pair of a style name and its value into the canonical (hyphenated) name of the style
   * property and a value with the `defaultUnit` suffix appended if no unit is already present in the `value`.
   *
   * For example:
   * ```javascript
   *  const [property, value] = DomHelper.unitize('marginLeft', 50);
   *  console.log(property, value);
   * ```
   *
   * ```
   *  > margin-left 50px
   * ```
   * @param {String} name
   * @param {String|Number} value
   * @param {String} [defaultUnit]
   * @returns {String[]}
   * @internal
   */
  static unitize(name, value, defaultUnit = "px") {
    const [trueName, hasUnits] = canonicalizeStyle(name);
    if (value != null) {
      value = String(value);
      value = hasUnits && digitsRe.test(value) ? value + defaultUnit : value;
    }
    return [trueName, value];
  }
  /**
   * Returns active element checking shadow dom too
   * @readonly
   * @property {HTMLElement}
   */
  static get activeElement() {
    let el = document.activeElement;
    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // returns active element for DOM tree / shadow DOM tree to which element belongs
  static getActiveElement(element) {
    if (element == null ? void 0 : element.isWidget) {
      element = element.element;
    }
    let el = ((element == null ? void 0 : element.getRootNode()) || document).activeElement;
    while (el == null ? void 0 : el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // Returns the visible root (either document.body or a web component shadow root)
  static getRootElement(element) {
    var _a4;
    const root = (_a4 = element.getRootNode) == null ? void 0 : _a4.call(element), { nodeType } = root;
    return nodeType === Node.DOCUMENT_NODE ? root.body : nodeType === Node.DOCUMENT_FRAGMENT_NODE ? root : element.ownerDocument.contains(element) ? element.ownerDocument.body : null;
  }
  // Returns the topmost HTMLElement inside the current context (either document.body or a direct child of a web component shadow root)
  static getOutermostElement(element) {
    var _a4;
    const root = (_a4 = element.getRootNode) == null ? void 0 : _a4.call(element);
    if (root == null ? void 0 : root.body) {
      return root == null ? void 0 : root.body;
    }
    while (element.parentNode !== root && element.parentNode) {
      element = element.parentNode;
    }
    return element;
  }
  static isValidFloatRootParent(element) {
    var _a4;
    return ((_a4 = element.tagName) == null ? void 0 : _a4.toUpperCase()) === "BODY" || // This one allows `rootElement` configured to LWC container element
    element.getRootNode().nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
   * Returns the `id` of the passed element. Generates a unique `id` if the element does not have one.
   * @param {HTMLElement} element The element to return the `id` of.
   */
  static getId(element) {
    return element.id || (element.id = "b-element-" + ++idCounter);
  }
  /**
   * Returns common widget/node ancestor for from/to arguments
   * @param {Core.widget.Widget|HTMLElement} from
   * @param {Core.widget.Widget|HTMLElement} to
   * @returns {Core.widget.Widget|HTMLElement}
   * @internal
   */
  static getCommonAncestor(from, to) {
    var _a4, _b;
    if (from === to) {
      return from;
    }
    while (from && !(((_a4 = from[from.isWidget ? "owns" : "contains"]) == null ? void 0 : _a4.call(from, to)) || from === to)) {
      from = ((_b = from.owner) == null ? void 0 : _b.isWidget) && from.owner !== from ? from.owner : from.parentNode;
    }
    return from;
  }
  //region Internal
  /**
   * Internal convenience fn to allow specifying either an element or a CSS selector to retrieve one
   * @private
   * @param {String|HTMLElement} elementOrSelector element or selector to lookup in DOM
   * @returns {HTMLElement}
   */
  static getElement(elementOrSelector) {
    if (typeof elementOrSelector === "string") {
      return doc.querySelector(elementOrSelector);
    }
    return elementOrSelector;
  }
  /**
   * Sets attributes passed as object to given element
   * @param {String|Element} elementOrSelector
   * @param {Object} attributes
   * @internal
   */
  static setAttributes(elementOrSelector, attributes) {
    const element = DH2.getElement(elementOrSelector);
    if (element && attributes) {
      for (const key in attributes) {
        if (attributes[key] == null) {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, attributes[key]);
        }
      }
    }
  }
  /**
   * Adds the passed string as a space-separated value to the passed attribute in the passed element.
   * @param {String|Element} elementOrSelector The element to manipulate
   * @param {String} attribute The attruibute name
   * @param {String} value The value to add
   */
  static addAttributeValue(elementOrSelector, attribute, value) {
    var _a4;
    const element = DH2.getElement(elementOrSelector);
    if (element && value) {
      element.setAttribute(attribute, [...new Set((_a4 = element.getAttribute(attribute)) == null ? void 0 : _a4.split(" ")).add(value)].join(" "));
    }
  }
  /**
   * Removed the passed string as a space-separated value from the passed attribute in the passed element.
   * @param {String|Element} elementOrSelector The element to manipulate
   * @param {String} attribute The attruibute name
   * @param {String} value The value to remove
   */
  static removeAttributeValue(elementOrSelector, attribute, value) {
    var _a4;
    const element = DH2.getElement(elementOrSelector);
    if (element && value) {
      const values = new Set((_a4 = element.getAttribute(attribute)) == null ? void 0 : _a4.split(" "));
      values.delete(value);
      values.size ? element.setAttribute(attribute, [...values].join(" ")) : element.removeAttribute(attribute);
    }
  }
  /**
   * Sets a CSS [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) style value.
   * @param {String|HTMLElement} element The element to set the style in, or, if just the result is required,
   * the style magnitude to return with units added. If a nullish value is passed, an empty string
   * is returned.
   * @param {String} [style] The name of a style property which specifies a [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length)
   * @param {Number|String} [value] The magnitude. If a number is used, the value will be set in `px` units.
   * @returns {String} The style value string.
   */
  static setLength(element, style, value) {
    if (arguments.length === 1) {
      value = typeof element === "number" ? `${element}px` : element != null ? element : "";
    } else {
      element = DH2.getElement(element);
      value = element.style[style] = typeof value === "number" ? `${value}px` : value != null ? value : "";
    }
    return value;
  }
  /**
   * Returns string percentified and rounded value for setting element's height, width etc.
   * @param {String|Number} value percent value
   * @param {Number} digits number of decimal digits for rounding
   * @returns {string} percentified value or empty string if value can not be parsed
   * @internal
   */
  static percentify(value, digits = 2) {
    const mult = Math.pow(10, digits);
    return value == null || value === "" || isNaN(value) ? "" : `${Math.round(value * mult) / mult}%`;
  }
  //endregion
  //region Children, going down...
  /**
   * Gets the first direct child of `element` that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement}
   * @category Query children
   */
  static getChild(element, selector) {
    return element.querySelector(":scope>" + selector);
  }
  /**
   * Checks if `element` has any child that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {Boolean} true if any child matches selector
   * @category Query children
   */
  static hasChild(element, selector) {
    return DH2.getChild(element, selector) != null;
  }
  /**
   * Returns all child elements (not necessarily direct children) that matches `selector`.
   *
   * If `selector` starts with `'>'` or `'# '`, then all components of the `selector` must match inside of `element`.
   * The scope selector, `:scope` is prepended to the selector (and if `#` was used, it is removed).
   *
   * These are equivalent:
   *
   *      DomHelper.children(el, '# .foo .bar');
   *
   *      el.querySelectorAll(':scope .foo .bar');
   *
   * These are also equivalent:
   *
   *      DomHelper.children(el, '> .foo .bar');
   *
   *      el.querySelectorAll(':scope > .foo .bar');
   *
   * @param {HTMLElement} element The parent element
   * @param {String} selector The CSS selector
   * @returns {HTMLElement[]} Matched elements, somewhere below `element`
   * @category Query children
   */
  static children(element, selector) {
    if (selector[0] === ">" || selector.startsWith("# ")) {
      if (selector[0] === "#") {
        selector = selector.substr(2);
      }
      selector = ":scope " + selector;
    }
    return Array.from(element.querySelectorAll(selector));
  }
  // Salesforce doesn't yet support childElementCount. So we relace all native usages with this wrapper and
  // override it for salesforce environment.
  // https://github.com/bryntum/support/issues/3008
  static getChildElementCount(element) {
    return element.childElementCount;
  }
  /**
   * Looks at the specified `element` and all of its children for the one that first matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either element or an element below it
   * @category Query children
   */
  static down(element, selector) {
    var _a4;
    if (!element) {
      return null;
    }
    if ((_a4 = element.matches) == null ? void 0 : _a4.call(element, selector)) {
      return element;
    }
    selector = ":scope " + selector;
    return element.querySelector(selector);
  }
  /**
   * Checks if childElement is a descendant of parentElement (contained in it or a sub element)
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement} childElement Child element, at any level below parent (includes nested shadow roots)
   * @returns {Boolean}
   * @category Query children
   */
  static isDescendant(parentElement, childElement) {
    const parentRoot = DH2.getRootElement(parentElement), childRoot = DH2.getRootElement(childElement);
    if (childRoot && parentRoot !== childRoot && childRoot.host) {
      return DH2.isDescendant(parentRoot, childRoot.host);
    }
    return parentElement.contains(childElement);
  }
  /**
   * Returns the specified element of the given `event`. If the `event` is an `Element`, it is returned. Otherwise,
   * the `eventName` argument is used to retrieve the desired element property from `event` (this defaults to the
   * `'target'` property).
   * @param {Event|Element} event
   * @param {String} [elementName]
   * @returns {Element}
   */
  static getEventElement(event, elementName = "target") {
    return !event || DH2.isElement(event) ? event : event[elementName];
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM element. If the element can be assured to be from the
   * same document, `instanceof Element` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isElement(value) {
    return (value == null ? void 0 : value.nodeType) === document.ELEMENT_NODE && DH2.isNode(value);
  }
  /**
   * Returns `true` if the provided element is an instance of React Element.
   * All React elements require an additional $$typeof: Symbol.for('react.element') field declared on the object for security reasons.
   * The object which React.createElement() return has $$typeof property equals to Symbol.for('react.element')
   *
   * Sources:
   * https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html
   * https://github.com/facebook/react/pull/4832
   *
   * @param {*} element
   * @returns {Boolean}
   * @internal
   */
  static isReactElement(element) {
    return (element == null ? void 0 : element.$$typeof) === Symbol.for("react.element");
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM node. If the node can be assured to be from the same
   * document, `instanceof Node` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isNode(value) {
    return Boolean(value) && typeof value.nodeType === "number" && !isObject(value);
  }
  /**
   * Iterates over each result returned from `element.querySelectorAll(selector)`. Can also be called with only two
   * arguments, in which case the first argument is used as selector and document is used as the element.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @param {Function} fn Function called for each found element
   * @category Query children
   */
  static forEachSelector(element, selector, fn) {
    if (typeof element === "string") {
      throw new Error("DomHelper.forEachSelector must provide a root element context (for shadow root scenario)");
    }
    DH2.children(element, selector).forEach(fn);
  }
  /**
   * Iterates over the direct child elements of the specified element.
   * @param {HTMLElement} element Parent element
   * @param {Function} fn Function called for each child element
   * @category Query children
   */
  static forEachChild(element, fn) {
    Array.from(element.children).forEach(fn);
  }
  /**
   * Removes each element returned from `element.querySelectorAll(selector)`.
   * @param {HTMLElement} element
   * @param {String} selector
   * @category Query children
   */
  static removeEachSelector(element, selector) {
    DH2.forEachSelector(element, selector, (child) => child.remove());
  }
  /**
  * Removes the passed CSS classes from all descendants of the passed element.
  * @param {HTMLElement} element Outermost element
  * @param {...String} classes CSS classes to remove
  */
  static removeClsGlobally(element, ...classes) {
    classes.forEach((cls) => DH2.forEachSelector(element, "." + cls, (child) => child.classList.remove(cls)));
  }
  //endregion
  //region Parents, going up...
  /**
   * Looks at the specified element and all of its parents for the one that first matches selector.
   * @deprecated Since 5.3.9, use native `element.closest()` instead
   * @param {HTMLElement} element Element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either the passed in element or an element above it
   * @category Query parents
   */
  static up(element, selector) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.up() deprecated, use native `element.closest()` instead");
    return element.closest(selector);
  }
  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false, ancestor, parent = element;
    possibleAncestorParents = ArrayHelper.asArray(possibleAncestorParents);
    while (parent = parent.parentElement) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }
      if (outerElement && parent === outerElement)
        break;
      ancestor = parent;
    }
    if (!found)
      return null;
    return ancestor || element;
  }
  /**
   * Retrieves all parents to the specified element.
   * @param {HTMLElement} element Element
   * @returns {HTMLElement[]} All parent elements, bottom up
   * @category Query parents
   */
  static getParents(element) {
    const parents = [];
    while (element.parentElement) {
      parents.push(element.parentElement);
      element = element.parentElement;
    }
    return parents;
  }
  //endregion
  //region Creation
  /**
   * Converts the passed id to an id valid for usage as id on a DOM element.
   * @param {String} id
   * @returns {String}
   */
  static makeValidId(id, replaceValue = "") {
    return StringHelper.makeValidDomId(id, replaceValue);
  }
  /**
   * Creates an Element, accepts a {@link #typedef-DomConfig} object. Example usage:
   *
   * ```javascript
   * DomHelper.createElement({
   *   tag         : 'table', // defaults to 'div'
   *   className   : 'nacho',
   *   html        : 'I am a nacho',
   *   children    : [ { tag: 'tr', ... }, myDomElement ],
   *   parent      : myExistingElement // Or its id
   *   style       : 'font-weight: bold;color: red',
   *   dataset     : { index: 0, size: 10 },
   *   tooltip     : 'Yay!',
   *   ns          : 'http://www.w3.org/1999/xhtml'
   * });
   * ```
   *
   * @param {DomConfig} config Element config object
   * @param {Object} [options] An object specifying creation options. If this is a boolean value, it is
   * understood to be the `returnAll` option.
   * @param {Boolean} [options.ignoreRefs] Pass `true` to ignore element references.
   * @param {Boolean} [options.returnAll] Specify true to return all elements & child elements created as an array.
   * @privateparam {HTMLElement} [options.replaceElement] Pass element which will be replaced with a created one
   * @returns {HTMLElement|HTMLElement[]|Object<String,HTMLElement>} Single element or array of elements `returnAll` was set to true.
   * If any elements had a `reference` property, this will be an object containing a reference to
   * all those elements, keyed by the reference name.
   * @category Creation
   */
  static createElement(config = {}, options) {
    var _a4, _b;
    let returnAll = options, element, i, ignoreChildRefs, ignoreRefOption, ignoreRefs, key, name, value, refOwner, refs, syncIdField;
    if (typeof returnAll === "boolean") {
      throw new Error("Clean up");
    } else if (options) {
      ignoreRefs = options.ignoreRefs;
      refOwner = options.refOwner;
      refs = options.refs;
      returnAll = options.returnAll;
      syncIdField = options.syncIdField;
      if (ignoreRefs) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefs !== "children";
      }
    }
    if (typeof config.parent === "string") {
      config.parent = document.getElementById(config.parent);
    }
    const parent = config.parent || config.nextSibling && config.nextSibling.parentNode, { dataset, html, reference, syncOptions, text } = config;
    if (syncOptions) {
      syncIdField = syncOptions.syncIdField || syncIdField;
      ignoreRefOption = syncOptions.ignoreRefs;
      if (ignoreRefOption) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefOption !== "children";
        options = {
          ...options,
          ignoreRefs: true
        };
      }
    }
    if (ignoreRefs) {
      refOwner = null;
    }
    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || "svg");
    } else {
      element = doc.createElement(config.tag || "div");
    }
    if (text != null) {
      DH2.setInnerText(element, text);
    } else if (html != null) {
      if (html instanceof DocumentFragment) {
        element.appendChild(html);
      } else {
        element.innerHTML = html;
      }
    }
    if (config.tooltip) {
      DH2.Widget.attachTooltip(element, config.tooltip);
    }
    if (config.style) {
      DH2.applyStyle(element, config.style);
    }
    if (dataset) {
      for (name in dataset) {
        value = dataset[name];
        if (value != null) {
          element.dataset[name] = value;
        }
      }
    }
    if (parent) {
      this.addChild(parent, element, config.nextSibling);
    }
    if (refOwner) {
      element.$refOwnerId = refOwner.id;
    }
    if (reference && !ignoreRefs) {
      if (refOwner) {
        element.$reference = reference;
        refOwner.attachRef(reference, element, config);
      } else {
        if (!refs) {
          options = Object.assign({}, options);
          options.refs = refs = {};
        }
        refs[reference] = element;
        element.setAttribute("data-reference", reference);
      }
    }
    const className = config.className || config.class, keys = Object.keys(config);
    if (className) {
      element.setAttribute("class", DomClassList.normalize(className));
    }
    for (i = 0; i < keys.length; ++i) {
      name = keys[i];
      value = config[name];
      if ((key = elementCreateExpandos[name]) != null) {
        element[key || name] = value;
      } else if (!elementCreateProperties[name] && name && value != null) {
        element.setAttribute(name, value);
      }
    }
    if (!config["aria-hidden"] && !config.role && !config.tabIndex && !_DomHelper.isFocusable(element, true) && !element.htmlFor) {
      element.setAttribute("role", "presentation");
    }
    (_b = options == null ? void 0 : options.callback) == null ? void 0 : _b.call(options, {
      action: "newElement",
      domConfig: config,
      targetElement: element,
      syncId: refOwner ? reference : options.syncIdField && ((_a4 = config.dataset) == null ? void 0 : _a4[options.syncIdField])
    });
    if (returnAll === true) {
      options.returnAll = returnAll = [element];
    } else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }
    if (config.children) {
      if (syncIdField) {
        element.syncIdMap = {};
      }
      ArrayHelper.asArray(config.children).forEach((child) => {
        var _a5, _b2, _c, _d;
        if (child) {
          if (typeof child === "string") {
            const textNode = document.createTextNode(child);
            if (refOwner) {
              textNode.$refOwnerId = refOwner.id;
            }
            element.appendChild(textNode);
          } else if (this.isReactElement(child)) {
            (_a5 = options == null ? void 0 : options.reactCallback) == null ? void 0 : _a5.call(options, {
              jsx: child,
              domConfig: config,
              targetElement: element
            });
          } else if (isNaN(child.nodeType)) {
            child.parent = element;
            if (!child.ns && config.ns) {
              child.ns = config.ns;
            }
            const childElement = DH2.createElement(child, {
              ...options,
              ignoreRefs: (_c = (_b2 = config.syncOptions) == null ? void 0 : _b2.ignoreRef) != null ? _c : ignoreChildRefs
            }), syncId = (_d = child.dataset) == null ? void 0 : _d[syncIdField];
            if (syncId != null) {
              element.syncIdMap[syncId] = childElement;
            }
            delete child.parent;
          } else {
            element.appendChild(child);
          }
        }
      });
    }
    element.lastDomConfig = config;
    const result = refs || returnAll || element;
    if (config.replaceElement) {
      config.replaceElement.replaceWith(result);
    }
    return result;
  }
  /**
   * Create element(s) from a template (html string). Note that
   * `textNode`s are discarded unless the `raw` option is passed
   * as `true`.
   *
   * If the template has a single root element, then the single element will be returned
   * unless the `array` option is passed as `true`.
   *
   * If there are multiple elements, then an Array will be returned.
   *
   * @param {String} template The HTML string from which to create DOM content
   * @param {Object} [options] An object containing properties to modify how the DOM is created and returned.
   * @param {Boolean} [options.array] `true` to return an array even if there's only one resulting element.
   * @param {Boolean} [options.raw] Return all child nodes, including text nodes.
   * @param {Boolean} [options.fragment] Return a DocumentFragment.
   * @private
   */
  static createElementFromTemplate(template, options = emptyObject4) {
    const { array, raw, fragment } = options;
    let result;
    if (DH2.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement("template"))).innerHTML = template;
      result = templateElement.content;
      if (fragment) {
        return result.cloneNode(true);
      }
    } else {
      result = (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, "text/html").body;
      if (fragment) {
        const nodes = result.childNodes;
        result = document.createDocumentFragment();
        while (nodes.length) {
          result.appendChild(nodes[0]);
        }
        return result;
      }
    }
    if (raw) {
      result = result.childNodes;
    } else {
      result = result.children;
    }
    return result.length === 1 && !array ? result[0] : arraySlice.call(result);
  }
  /**
   * Dispatches a MouseEvent of the passed type to the element at the visible centre of the passed element.
   * @param {HTMLElement} targetElement The element whose center receives the mouse event.
   * @param {String} [type=contextmenu] The mouse event type to dispatch.
   * @internal
   */
  static triggerMouseEvent(targetElement, type = "contextmenu") {
    const isInView = this.isInView(targetElement), targetRect = isInView || Rectangle.from(targetElement), targetPoint = targetRect.center, contextmenuEvent = new MouseEvent(type, {
      clientX: targetPoint.x,
      clientY: targetPoint.y,
      offsetX: isInView.width / 2,
      offsetY: isInView.height / 2,
      bubbles: true
    });
    targetElement.dispatchEvent(contextmenuEvent);
  }
  /**
   * Inserts an `element` at first position in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertFirst(into, element) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH2.createElement(element);
    }
    return into.insertBefore(element, into.firstElementChild);
  }
  /**
   * Inserts a `element` before `beforeElement` in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @param {HTMLElement} beforeElement Element before which passed element should be inserted
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH2.createElement(element);
    }
    return beforeElement ? into.insertBefore(element, beforeElement) : DH2.insertFirst(into, element);
  }
  static insertAt(parentElement, newElement, index) {
    const siblings = Array.from(parentElement.children);
    if (index >= siblings.length) {
      return DH2.append(parentElement, newElement);
    }
    const beforeElement = siblings[index];
    return DH2.insertBefore(parentElement, newElement, beforeElement);
  }
  /**
   * Appends element to parentElement.
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement|DomConfig|String} elementOrConfig Element to insert, or an element config passed on to
   * `createElement()`, or an html string passed to `createElementFromTemplate()`
   * @returns {HTMLElement}
   * @category Creation
   */
  static append(parentElement, elementOrConfig) {
    if (elementOrConfig.forEach) {
      if (Array.isArray(elementOrConfig)) {
        elementOrConfig = elementOrConfig.map((elementOrConfig2) => elementOrConfigToElement(elementOrConfig2));
      }
      if (parentElement.append) {
        parentElement.append(...elementOrConfig);
      } else {
        const docFrag = document.createDocumentFragment();
        elementOrConfig.forEach(function(child) {
          docFrag.appendChild(child);
        });
        parentElement.appendChild(docFrag);
      }
      return elementOrConfig;
    } else {
      return parentElement.appendChild(elementOrConfigToElement(elementOrConfig));
    }
  }
  //endregion
  //region Get position
  /**
   * Returns the element's `transform translateX` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} X transform
   * @category Position, get
   */
  static getTranslateX(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateXRe.exec(transformStyle);
    if (matches) {
      return parseFloat(matches[2]);
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH2.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[1] || matches[3]) : 0;
    }
  }
  /**
   * Returns the element's `transform translateY` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} Y coordinate
   * @category Position, get
   */
  static getTranslateY(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateYRe.exec(transformStyle);
    if (matches) {
      const y = parseFloat(matches[matches[1] === "Y" ? 2 : 3]);
      return isNaN(y) ? 0 : y;
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH2.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[2] || matches[4]) : 0;
    }
  }
  /**
   * Gets both X and Y coordinates as an array [x, y]
   * @param {HTMLElement} element
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getTranslateXY(element) {
    return [DH2.getTranslateX(element), DH2.getTranslateY(element)];
  }
  /**
   * Get elements X offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} X offset
   * @category Position, get
   */
  static getOffsetX(element, container = null) {
    return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
  }
  /**
   * Get elements Y offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} Y offset
   * @category Position, get
   */
  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }
  /**
   * Gets elements X and Y offset within containing element as an array [x, y]
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getOffsetXY(element, container = null) {
    return [DH2.getOffsetX(element, container), DH2.getOffsetY(element, container)];
  }
  /**
   * Focus element without scrolling the element into view.
   * @param {HTMLElement} element
   * @deprecated since 5.6.4 Use the native Element focus method with the preventScroll option
   */
  static focusWithoutScrolling(element) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.focusWithoutScrolling() deprecated, Use the native Element focus method with the preventScroll option");
    element.focus({ preventScroll: true });
  }
  /**
   * Get elements X position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset;
  }
  /**
   * Get elements Y position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset;
  }
  /**
   * Returns extremal (min/max) size (height/width) of the element in pixels
   * @param {HTMLElement} element
   * @param {String} style minWidth/minHeight/maxWidth/maxHeight
   * @returns {Number}
   * @internal
   */
  static getExtremalSizePX(element, style) {
    const prop = StringHelper.hyphenate(style), measure = prop.split("-")[1];
    let value = DH2.getStyleValue(element, prop);
    if (/%/.test(value)) {
      if (element.parentElement) {
        value = parseInt(DH2.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }
    return value;
  }
  //endregion
  //region Set position
  /**
   * Set element's `scale`.
   * @param {HTMLElement} element
   * @param {Number} scaleX The value by which the element should be scaled in the X axis (0 to 1)
   * @param {Number} [scaleY] The value by which the element should be scaled in the Y axis (0 to 1).
   * Defaults to `scaleX`
   * @category Position, set
   * @internal
   */
  static setScale(element, scaleX, scaleY = scaleX) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    if (t.length > 1) {
      if (t[0].startsWith("matrix3d")) {
        t[0] = `matrix3d(${scaleX}`;
        t[5] = scaleY;
      } else {
        t[0] = `matrix(${scaleX}`;
        t[3] = scaleY;
      }
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `scale(${scaleX}, ${scaleY})`;
    }
  }
  /**
   * Set element's `X` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} x The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateX(element, x) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    x = DH2.roundPx(x);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 12 : 4] = x;
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }
  /**
   * Set element's `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} y  The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateY(element, y) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    y = DH2.roundPx(y);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }
  /**
   * Set element's style `top`.
   * @param {HTMLElement} element
   * @param {Number|String} y The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setTop(element, y) {
    DH2.setLength(element, "top", y);
  }
  /**
   * Set element's style `left`.
   * @param {HTMLElement} element
   * @param {Number|String} x The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setLeft(element, x) {
    DH2.setLength(element, "left", x);
  }
  static setTopLeft(element, y, x) {
    DH2.setLength(element, "top", y);
    DH2.setLength(element, "left", x);
  }
  static setRect(element, { x, y, width, height }) {
    DH2.setTopLeft(element, y, x);
    DH2.setLength(element, "width", width);
    DH2.setLength(element, "height", height);
  }
  /**
   * Set elements `X` and `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} [x] The `X translation.
   * @param {Number} [y] The `Y translation.
   * @category Position, set
   */
  static setTranslateXY(element, x, y) {
    if (x == null) {
      return DH2.setTranslateY(element, y);
    }
    if (y == null) {
      return DH2.setTranslateX(element, x);
    }
    x = DH2.roundPx(x);
    y = DH2.roundPx(y);
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/), is3d = t[0].startsWith("matrix3d");
    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translate(${x}px, ${y}px)`;
    }
  }
  /**
   * Increase `X` translation
   * @param {HTMLElement} element
   * @param {Number} x The number of pixels by which to increase the element's `X` translation.
   * @category Position, set
   */
  static addTranslateX(element, x) {
    DH2.setTranslateX(element, DH2.getTranslateX(element) + x);
  }
  /**
   * Increase `Y` position
   * @param {HTMLElement} element
   * @param {Number} y The number of pixels by which to increase the element's `Y` translation.
   * @category Position, set
   */
  static addTranslateY(element, y) {
    DH2.setTranslateY(element, DH2.getTranslateY(element) + y);
  }
  /**
   * Increase X position
   * @param {HTMLElement} element
   * @param {Number} x
   * @category Position, set
   */
  static addLeft(element, x) {
    DH2.setLeft(element, DH2.getOffsetX(element) + x);
  }
  /**
   * Increase Y position
   * @param {HTMLElement} element
   * @param {Number} y
   * @category Position, set
   */
  static addTop(element, y) {
    DH2.setTop(element, DH2.getOffsetY(element) + y);
  }
  /**
   * Align the passed element with the passed target according to the align spec.
   * @param {HTMLElement} element The element to align.
   * @param {HTMLElement|Core.helper.util.Rectangle} target The target element or rectangle to align to
   * @param {AlignSpec} [alignSpec] See {@link Core.helper.util.Rectangle#function-alignTo} Defaults to `{ align : 't0-t0' }`
   * @param {Boolean} [round] Round the calculated Rectangles (for example if dealing with scrolling which
   * is integer based).
   */
  static alignTo(element, target, alignSpec = t0t0, round2) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, true);
    const elXY = DH2.getTranslateXY(element), elRect = Rectangle.from(element, true);
    if (round2) {
      elRect.roundPx();
      target.roundPx();
    }
    const targetRect = elRect.alignTo(Object.assign(alignSpec, {
      target
    }));
    DH2.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }
  //endregion
  //region Styles & CSS
  /**
   * Returns a style value or values for the passed element.
   * @param {HTMLElement} element The element to read styles from
   * @param {String|String[]} propName The property or properties to read
   * @param {Boolean} [inline=false] Pass as `true` to read the element's inline style.
   * Note that this could return inaccurate results if CSS rules apply to this element.
   * @returns {String|Object} The value or an object containing the values keyed by the requested property name.
   * @category CSS
   */
  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);
    if (Array.isArray(propName)) {
      const result = {};
      for (const prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }
      return result;
    }
    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }
  /**
   * Returns an object with the parse style values for the top, right, bottom, and left
   * components of the given edge style.
   *
   * The return value is an object with `top`, `right`, `bottom`, and `left` properties
   * for the respective components of the edge style, as well as `width` (the sum of
   * `left` and `right`) and `height` (the sum of `top` and `bottom`).
   *
   * @param {HTMLElement} element
   * @param {String} edgeStyle The element's desired edge style such as 'padding', 'margin',
   * or 'border'.
   * @param {String} [edges='trbl'] A string with one character codes for each edge. Only
   * those edges will be populated in the returned object. By default, all edges will be
   * populated.
   * @returns {Object}
   */
  static getEdgeSize(element, edgeStyle, edges) {
    const suffix = edgeStyle === "border" ? "-width" : "", ret = {
      raw: {}
    };
    for (const edge of ["top", "right", "bottom", "left"]) {
      if (!edges || edges.includes(edge[0])) {
        ret[edge] = parseFloat(
          ret.raw[edge] = DH2.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`)
        );
      }
    }
    ret.width = (ret.left || 0) + (ret.right || 0);
    ret.height = (ret.top || 0) + (ret.bottom || 0);
    return ret;
  }
  /**
   * Splits a style string up into object form. For example `'font-weight:bold;font-size:150%'`
   * would convert to
   *
   * ```javascript
   * {
   *     font-weight : 'bold',
   *     font-size : '150%'
   * }
   * ```
   * @param {String} style A DOM style string
   * @returns {Object} the style declaration in object form.
   */
  static parseStyle(style) {
    if (typeof style === "string") {
      const styles = style.split(semicolonRe);
      style = {};
      for (let i = 0, { length } = styles; i < length; i++) {
        const propVal = styles[i].split(colonRe);
        style[propVal[0]] = propVal[1];
      }
    }
    return style || {};
  }
  /**
   * Applies specified style to the passed element. Style can be an object or a string.
   * @param {HTMLElement} element Target element
   * @param {String|Object} style Style to apply, 'border: 1px solid black' or { border: '1px solid black' }
   * @param {Boolean} [overwrite] Specify `true` to replace style instead of applying changes
   * @category CSS
   */
  static applyStyle(element, style, overwrite = false) {
    if (typeof style === "string") {
      if (overwrite) {
        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {
        element.style.cssText += style;
      }
    } else if (style) {
      if (overwrite) {
        element.style.cssText = "";
      }
      if (style.style && typeof style.style !== "string") {
        style = ObjectHelper.assign({}, style, style.style);
      }
      let key, value;
      for (key in style) {
        if (!styleIgnoreProperties[key]) {
          [key, value] = DH2.unitize(key, style[key]);
          if (value == null) {
            element.style.removeProperty(key);
          } else {
            element.style.setProperty(key, value);
          }
        }
      }
      if (typeof style.style === "string") {
        element.style.cssText += style.style;
      }
    }
  }
  static getCSSText(style) {
    if (typeof style === "string") {
      return style;
    }
    let cssText = "";
    for (const key in style) {
      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }
    return cssText;
  }
  /**
   * Add multiple classes to elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/add add} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static addClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.addClasses should be replaced by native classList.add");
    element.classList.add(...classes);
  }
  /**
   * Remove multiple classes from elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/remove remove} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static removeClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.removeClasses should be replaced by native classList.remove");
    element.classList.remove(...classes);
  }
  /**
   * Toggle multiple classes in elements classList. Helper for toggling multiple classes at once.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @param {Boolean} [force] Specify true to add classes, false to remove. Leave blank to toggle
   * @category CSS
   */
  static toggleClasses(element, classes, force = null) {
    classes = ArrayHelper.asArray(classes);
    if (force === true) {
      element.classList.add(...classes);
    } else if (force === false) {
      element.classList.remove(...classes);
    } else {
      classes.forEach((cls) => element.classList.toggle(cls));
    }
  }
  /**
   * Adds a CSS class to an element during the specified duration
   * @param {HTMLElement} element Target element
   * @param {String} cls CSS class to add temporarily
   * @param {Number} duration Duration in ms, 0 means cls will not be applied
   * @param {Core.mixin.Delayable} delayable The delayable to tie the setTimeout call to
   * @privateparam {String} name Timer name
   * @typings delayable -> {typeof Delayable}
   * @category CSS
   */
  static addTemporaryClass(element, cls, duration, delayable = globalThis, name = cls) {
    if (duration > 0) {
      element.classList.add(cls);
      delayable.setTimeout({
        fn: (cls2) => element.classList.remove(cls2),
        delay: duration,
        name,
        args: [cls],
        cancelOutstanding: true
      });
    }
  }
  /**
   * Reads computed style from the element and returns transition duration for a given property in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @param {String} property Animated property name
   * @returns {Number} Duration in ms
   * @internal
   */
  static getPropertyTransitionDuration(element, property) {
    const style = globalThis.getComputedStyle(element), properties = style.transitionProperty.split(", "), durations = style.transitionDuration.split(", "), index = properties.indexOf(StringHelper.hyphenate(property));
    let result;
    if (index !== -1) {
      result = parseFloat(durations[index]) * 1e3;
    }
    return result;
  }
  /**
   * Reads computed style from the element and returns the animation duration for any
   * attached animation in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @returns {Number} Duration in ms
   * @internal
   */
  static getAnimationDuration(element) {
    return parseFloat(DH2.getStyleValue(element, "animation-duration")) * 1e3;
  }
  //endregion
  //region Effects
  /**
   * Highlights the passed element or Rectangle according to the theme's highlighting rules.
   * Usually an animated framing effect.
   *
   * The framing effect is achieved by adding the CSS class `b-fx-highlight` which references
   * a `keyframes` animation named `b-fx-highlight-animation`. You may override the animation
   * name referenced, or the animation itself in your own CSS.
   *
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or Rectangle to highlight.
   */
  static highlight(element, delayable = globalThis) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }
    return new Promise((resolve) => {
      delayable.setTimeout(() => {
        element.classList.add("b-fx-highlight");
        delayable.setTimeout(() => {
          element.classList.remove("b-fx-highlight");
          resolve();
        }, 1e3);
      }, 0);
    });
  }
  //endregion
  //region Measuring / Scrollbar
  /**
   * Measures the scrollbar width using a hidden div. Caches result
   * @property {Number}
   * @readonly
   */
  static get scrollBarWidth() {
    if (scrollBarWidth === null) {
      const element = scrollBarMeasureElement || (scrollBarMeasureElement = DH2.createElement({
        parent: doc.documentElement,
        className: "b-scrollbar-measure-element",
        style: "position:absolute;top:-9999em;height:100px;overflow-y:scroll"
      }));
      if (element.parentNode !== doc.documentElement) {
        doc.documentElement.appendChild(element);
      }
      scrollBarWidth = element.offsetWidth;
    }
    return scrollBarWidth;
  }
  static get scrollBarPadElement() {
    return {
      className: "b-yscroll-pad",
      children: [{
        className: "b-yscroll-pad-sizer"
      }]
    };
  }
  /**
   * Resets DomHelper.scrollBarWidth cache, triggering a new measurement next time it is read
   */
  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }
  /**
   * Measures the text width using a hidden div
   * @param {String} text
   * @param {HTMLElement} sourceElement
   * @returns {Number} width
   * @category Measure
   */
  static measureText(text, sourceElement, useHTML = false, parentElement = void 0) {
    const offScreenDiv = DH2.getMeasureElement(sourceElement, parentElement);
    offScreenDiv[useHTML ? "innerHTML" : "innerText"] = text;
    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = "";
    return result;
  }
  /**
   * Measures a relative size, such as a size specified in `em` units for the passed element.
   * @param {String} size The CSS size value to measure.
   * @param {HTMLElement} sourceElement
   * @param {Boolean} [round] Pass true to return exact width, not rounded value
   * @returns {Number} size The size in pixels of the passed relative measurement.
   * @category Measure
   */
  static measureSize(size, sourceElement, round2 = true) {
    var _a4;
    if (!size) {
      return 0;
    }
    if (typeof size === "number") {
      return size;
    }
    if (!size.length) {
      return 0;
    }
    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }
    if (sourceElement) {
      const percent = (_a4 = size.includes) == null ? void 0 : _a4.call(size, "%"), offScreenDiv = DH2.getMeasureElement(sourceElement, percent ? sourceElement.parentNode : void 0), { parentElement } = offScreenDiv;
      offScreenDiv.innerHTML = "";
      percent && (parentElement.style.display = "contents");
      offScreenDiv.style.minWidth = offScreenDiv.style.maxWidth = DH2.setLength(size);
      const result = round2 ? offScreenDiv.offsetWidth : offScreenDiv.getBoundingClientRect().width;
      parentElement.style.display = "";
      offScreenDiv.style.minWidth = offScreenDiv.style.maxWidth = offScreenDiv.className = "";
      return result;
    }
    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }
    return isNaN(size) ? 0 : parseInt(size);
  }
  // parentElement allows measurement to happen inside a specific element, allowing scoped css rules to match
  static getMeasureElement(sourceElement, parentElement) {
    parentElement = parentElement || doc.body;
    const sourceElementStyle = win.getComputedStyle(sourceElement), offScreenDiv = parentElement.offScreenDiv = parentElement.offScreenDiv || DH2.createElement({
      parent: parentElement,
      style: "position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict",
      className: "b-measure-element",
      children: [{
        style: "white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none"
      }]
    }, { returnAll: true })[1];
    fontProps.forEach((prop) => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;
    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }
    return offScreenDiv;
  }
  /**
   * Strips the tags from a html string, returning text content.
   *
   * ```javascript
   * DomHelper.stripTags('<div class="custom"><b>Bold</b><i>Italic</i></div>'); // -> BoldItalic
   * ```
   *
   * @internal
   * @param {String} htmlString HTML string
   * @returns {String} Text content
   */
  static stripTags(htmlString) {
    const parser = DH2.$domParser || (DH2.$domParser = new DOMParser()), doc2 = parser.parseFromString(htmlString, "text/html");
    return doc2.body.textContent;
  }
  //endregion
  //region Sync
  /**
   * Sync one source element attributes, children etc. to a target element. Source element can be specified as a html
   * string or an actual HTMLElement.
   *
   * NOTE: This function is superseded by {@link Core/helper/DomSync#function-sync-static DomSync.sync()}, which works
   * with DOM configs. For most usecases, use it instead.
   *
   * @param {String|HTMLElement} sourceElement Source "element" to copy from
   * @param {HTMLElement} targetElement Target element to apply to, can also be specified as part of the config object
   * @returns {HTMLElement} Returns the updated targetElement (which is also updated in place)
   */
  static sync(sourceElement, targetElement) {
    if (typeof sourceElement === "string") {
      if (sourceElement === "") {
        targetElement.innerHTML = "";
        return;
      } else {
        sourceElement = DH2.createElementFromTemplate(sourceElement);
      }
    }
    DH2.performSync(sourceElement, targetElement);
    return targetElement;
  }
  // Internal helper used for recursive syncing
  static performSync(sourceElement, targetElement) {
    if (sourceElement.outerHTML !== targetElement.outerHTML) {
      DH2.syncAttributes(sourceElement, targetElement);
      DH2.syncContent(sourceElement, targetElement);
      DH2.syncChildren(sourceElement, targetElement);
      return true;
    }
    return false;
  }
  // Attributes as map { attr : value, ... }, either from an html element or from a config
  static getSyncAttributes(element) {
    const attributes = {}, names = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.specified) {
        const name = attr.name.toLowerCase();
        attributes[name] = attr.value;
        names.push(name);
      }
    }
    return { attributes, names };
  }
  /**
   * Syncs attributes from sourceElement to targetElement.
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncAttributes(sourceElement, targetElement) {
    const {
      attributes: sourceAttributes,
      names: sourceNames
    } = DH2.getSyncAttributes(sourceElement), {
      attributes: targetAttributes,
      names: targetNames
    } = DH2.getSyncAttributes(targetElement), hasDataset = sourceNames.includes("dataset"), toAdd = sourceNames.filter((attr) => !targetNames.includes(attr)), toRemove = targetNames.filter((attr) => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith("data-"))), toSync = sourceNames.filter((attr) => targetNames.includes(attr));
    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];
        if (attr === "style") {
          DH2.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }
    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];
        if (attr === "style") {
          DH2.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else if (attr === "class" && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === "object")) {
          let classList;
          if (sourceAttributes.class.isDomClassList) {
            classList = sourceAttributes.class;
          } else {
            classList = new DomClassList(sourceAttributes.class);
          }
          if (!classList.isEqual(targetAttributes.class)) {
            targetElement.setAttribute("class", classList);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }
  /**
   * Sync content (innerText) from sourceElement to targetElement
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncContent(sourceElement, targetElement) {
    if (DH2.getChildElementCount(sourceElement) === 0) {
      targetElement.innerText = sourceElement.innerText;
    }
  }
  static setInnerText(targetElement, text) {
    const { firstChild } = targetElement;
    if ((firstChild == null ? void 0 : firstChild.nodeType) === Element.TEXT_NODE) {
      firstChild.data = text;
    } else {
      targetElement.textContent = text;
    }
  }
  /**
   * Sync traversing children
   * @private
   * @param {HTMLElement} sourceElement Source element
   * @param {HTMLElement} targetElement Target element
   */
  static syncChildren(sourceElement, targetElement) {
    const me = this, sourceNodes = arraySlice.call(sourceElement.childNodes), targetNodes = arraySlice.call(targetElement.childNodes);
    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(), targetNode = targetNodes.shift();
      if (sourceNode && sourceNode.nodeType !== TEXT_NODE && sourceNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (targetNode && targetNode.nodeType !== TEXT_NODE && targetNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (!targetNode) {
        targetElement.appendChild(sourceNode);
      } else {
        if (sourceNode.nodeType === targetNode.nodeType) {
          if (sourceNode.nodeType === TEXT_NODE) {
            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {
              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        } else if (sourceNode.nodeType === TEXT_NODE && targetNode.nodeType === ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          const logElement = sourceNode.parentElement || sourceNode;
          throw new Error(`Currently no support for transforming nodeType.
${logElement.outerHTML}`);
        }
      }
    }
    targetNodes.forEach((targetNode) => {
      targetNode.remove();
    });
  }
  /**
   * Replaces the passed element's `className` with the class names
   * passed in either Array or String format or Object.
   *
   * This method compares the existing class set with the incoming class set and
   * avoids mutating the element's class name set if possible.
   *
   * This can avoid browser style invalidations.
   * @param {HTMLElement} element The element whose class list to synchronize.
   * @param {String[]|String|Object} newClasses The incoming class names to set on the element.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static syncClassList(element, newClasses) {
    const { classList } = element, isString = typeof newClasses === "string", newClsArray = isString ? newClasses.split(whiteSpaceRe2) : DomClassList.normalize(newClasses, "array"), classCount = newClsArray.length;
    let changed = classList.length !== classCount, i;
    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }
    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(" ");
    }
    return changed;
  }
  /**
   * Applies the key state of the passed object or DomClassList to the passed element.
   *
   * Properties with a falsy value mean that property name is *removed* as a class name.
   *
   * Properties with a truthy value mean that property name is *added* as a class name.
   *
   * This is different from {@link #function-syncClassList-static}. That sets the `className` of the element to the
   * sum of all its truthy keys, regardless of what the pre-existing value of the `className` was, and ignoring falsy
   * keys.
   *
   * This _selectively_ updates the classes in the `className`. If there is a truthy key, the name is added. If there
   * is a falsy key, the name is removed.
   * @param {HTMLElement} element The element to apply the class list to .
   * @param {Object|Core.helper.util.DomClassList} classes The classes to add or remove.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static updateClassList(element, classes) {
    const { classList } = element;
    let cls, add, changed = false;
    for (cls in classes) {
      add = Boolean(classes[cls]);
      if (classList.contains(cls) !== add) {
        classList[add ? "add" : "remove"](cls);
        changed = true;
      }
    }
    return changed;
  }
  /**
   * Changes the theme to the passed theme name if possible.
   *
   * Theme names are case insensitive. The `href` used is all lower case.
   *
   * To use this method, the `<link rel="stylesheet">` _must_ use the default,
   * Bryntum-supplied CSS files where the `href` end with `<themeName>.css`, so that
   * it can be found in the document, and switched out for a new link with
   * the a modified `href`. The new `href` will use the same path, just
   * with the `themeName` portion substituted for the new name.
   *
   * If no `<link>` with that name pattern can be found, an error will be thrown.
   *
   * If you use this method, you  must ensure that the theme files are
   * all accessible on your server.
   *
   * Because this is an asynchronous operation, a `Promise` is returned.
   * The theme change event is passed to the success function. If the
   * theme was not changed, because the theme name passed is the current theme,
   * nothing is passed to the success function.
   *
   * The theme change event contains two properties:
   *
   *  - `prev` The previous Theme name.
   *  - `theme` The new Theme name.
   *
   * @param {String} newThemeName the name of the theme that should be applied
   * @privateparam {String} [defaultTheme] Optional, the name of the theme that should be used in case of fail
   * @returns {Promise} A promise who's success callback receives the theme change
   * event if the theme in fact changed. If the theme `href` could not be loaded,
   * the failure callback is called, passing the error event caught.
   * @async
   */
  static setTheme(newThemeName, defaultTheme) {
    newThemeName = newThemeName.toLowerCase();
    const { head } = document, oldThemeName = DH2.getThemeInfo(defaultTheme).name.toLowerCase();
    let oldThemeLinks = head.querySelectorAll("[data-bryntum-theme]:not([data-loading])"), loaded = 0;
    if (oldThemeName === newThemeName) {
      return immediatePromise;
    }
    DH2.removeEachSelector(head, "#bryntum-theme[data-loading],link[data-bryntum-theme][data-loading]");
    const themeEvent = {
      theme: newThemeName,
      prev: oldThemeName
    };
    function replaceTheme(oldThemeLink, resolve, reject) {
      const newThemeLink = _DomHelper.createElement({
        tag: "link",
        rel: "stylesheet",
        dataset: {
          loading: true,
          bryntumTheme: true
        },
        href: oldThemeLink.href.replace(oldThemeName, newThemeName),
        nextSibling: oldThemeLink
      });
      newThemeLink.addEventListener("load", () => {
        delete newThemeLink.dataset.loading;
        themeInfo = null;
        if (++loaded === oldThemeLinks.length) {
          oldThemeLinks.forEach((link) => link.remove());
          GlobalEvents_default.trigger("theme", themeEvent);
          resolve(themeEvent);
        }
      });
      newThemeLink.addEventListener("error", (e) => {
        delete newThemeLink.dataset.loading;
        reject(e);
      });
    }
    if (oldThemeLinks.length) {
      return new Promise((resolve, reject) => {
        oldThemeLinks.forEach((oldThemeLink, i) => {
          replaceTheme(oldThemeLink, resolve, reject, i === oldThemeLinks.length - 1);
        });
      });
    } else {
      const oldThemeLink = head.querySelector("#bryntum-theme:not([data-loading])") || head.querySelector(`[href*="${oldThemeName}.css"]:not([data-loading])`);
      if (!(oldThemeLink == null ? void 0 : oldThemeLink.href.includes(`${oldThemeName}.css`))) {
        throw new Error(`Theme link for ${oldThemeName} not found`);
      }
      oldThemeLinks = [oldThemeLink];
      return new Promise((resolve, reject) => replaceTheme(oldThemeLink, resolve, reject));
    }
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently, this has only one property:
   *
   *   - `name` The current theme name.
   * @property {Object}
   * @readonly
   */
  static get themeInfo() {
    return _DomHelper.getThemeInfo();
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently this has only one property:
   *
   *   - `name` The current theme name.
   * @param {String} defaultTheme the name of the theme used as backup value in case of fail
   * @param {HTMLElement} contextElement The element for which to find the theme. If using a
   * web component, the theme will be encapsulated in the web component's encapsulated style
   * so a context element is required. If no web components are in use, this may be omitted and
   * `document.body` will be used.
   * @returns {Object} info, currently it contains only one property - 'name'.
   * @private
   */
  static getThemeInfo(defaultTheme) {
    if (!themeInfo) {
      const testDiv = DH2.createElement({
        parent: document.body,
        className: "b-theme-info"
      }), themeData = DH2.getStyleValue(testDiv, "content", false, ":before");
      if (themeData) {
        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ""));
        } catch (e) {
          themeInfo = null;
        }
      }
      themeInfo = themeInfo || (defaultTheme ? { name: defaultTheme } : null);
      testDiv.remove();
    }
    return themeInfo;
  }
  //endregion
  //region Transition
  static async transition({
    element: outerElement,
    selector = "[data-dom-transition]",
    duration,
    action,
    thisObj = this,
    addTransition = {},
    removeTransition = {}
  }) {
    const scrollers = /* @__PURE__ */ new Set(), beforeElements = Array.from(outerElement.querySelectorAll(selector)), beforeMap = new Map(beforeElements.map((element) => {
      let depth = 0, parent = element.parentElement;
      while (parent && parent !== outerElement) {
        depth++;
        parent = parent.parentElement;
      }
      element.$depth = depth;
      if (element.scrollHeight > element.offsetHeight && getComputedStyle(element).overflow === "auto") {
        element.$scrollTop = element.scrollTop;
        scrollers.add(element);
      }
      const { parentElement } = element, globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, parentElement), style = getComputedStyle(parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [
        element.id,
        { element, globalBounds, localBounds, depth, parentElement }
      ];
    }));
    action.call(thisObj);
    const afterElements = Array.from(outerElement.querySelectorAll(selector)), afterMap = new Map(afterElements.map((element) => {
      const globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, element.parentElement), style = globalThis.getComputedStyle(element.parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [
        element.id,
        { element, globalBounds, localBounds }
      ];
    })), styleProps = ["position", "top", "left", "width", "height", "padding", "margin", "zIndex", "minWidth", "minHeight", "opacity", "overflow"];
    for (const [id, before] of beforeMap) {
      const after = afterMap.get(id);
      if (after) {
        const { element } = after, { style, parentElement } = element, zIndex = parseInt(DH2.getStyleValue(element, "zIndex")), {
          globalBounds,
          localBounds,
          depth,
          parentElement: beforeParent
        } = before, parentChanged = beforeParent !== parentElement;
        ObjectHelper.copyProperties(element.$initial = { parentElement }, style, styleProps);
        let bounds;
        if (parentChanged) {
          after.bounds = after.globalBounds;
          bounds = globalBounds;
          outerElement.appendChild(element);
        } else {
          after.bounds = after.localBounds;
          bounds = localBounds;
          beforeParent.appendChild(element);
        }
        let overflow = "hidden";
        if (scrollers.has(element)) {
          element.$scrollPlaceholder = DH2.createElement({
            parent: element,
            style: {
              height: element.scrollHeight
            }
          });
          overflow = "auto";
        }
        const targetStyle = {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          margin: 0,
          zIndex: depth + (zIndex || 0),
          overflow
        };
        if (element.dataset.domTransition !== "preserve-padding") {
          targetStyle.padding = 0;
        }
        Object.assign(style, targetStyle);
        after.processed = true;
      } else {
        const { element, localBounds: bounds, depth, parentElement } = before;
        element.$initial = { removed: true };
        Object.assign(element.style, {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth,
          overflow: "hidden"
          // Looks weird with content sticking out if height is transitioned
        });
        parentElement.appendChild(element);
        afterMap.set(id, { element, bounds, removed: true, processed: true });
        afterElements.push(element);
      }
    }
    for (const [, after] of afterMap) {
      if (!after.processed) {
        const { element } = after, { style, parentElement } = element, bounds = after.bounds = after.localBounds;
        element.classList.add("b-dom-transition-adding");
        ObjectHelper.copyProperties(element.$initial = { parentElement }, style, styleProps);
        Object.assign(style, {
          position: "absolute",
          top: addTransition.top ? 0 : `${bounds.top}px`,
          left: addTransition.left ? 0 : `${bounds.left}px`,
          width: addTransition.width ? 0 : `${bounds.width}px`,
          height: addTransition.height ? 0 : `${bounds.height}px`,
          opacity: addTransition.opacity ? 0 : null,
          zIndex: parentElement.$depth + 1,
          overflow: "hidden"
          // Looks weird with content sticking out if height is transitioned
        });
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
    }
    outerElement.classList.add("b-dom-transition");
    outerElement.firstElementChild.offsetWidth;
    for (const [, { element, bounds: afterBounds, removed }] of afterMap) {
      if (removed) {
        Object.assign(element.style, {
          top: removeTransition.top ? 0 : `${afterBounds.top}px`,
          left: removeTransition.left ? 0 : `${afterBounds.left}px`,
          width: removeTransition.width ? 0 : `${afterBounds.width}px`,
          height: removeTransition.height ? 0 : `${afterBounds.height}px`,
          opacity: removeTransition.opacity ? 0 : element.$initial.opacity
        });
      } else {
        Object.assign(element.style, {
          top: `${afterBounds.top}px`,
          left: `${afterBounds.left}px`,
          width: `${afterBounds.width}px`,
          height: `${afterBounds.height}px`,
          opacity: element.$initial.opacity
        });
      }
    }
    await AsyncHelper.sleep(duration);
    outerElement.classList.remove("b-dom-transition");
    for (const element of afterElements) {
      if (element.$initial) {
        if (element.$initial.removed) {
          element.remove();
        } else {
          ObjectHelper.copyProperties(element.style, element.$initial, styleProps);
          if (element.$scrollPlaceholder) {
            element.$scrollPlaceholder.remove();
            delete element.$scrollPlaceholder;
          }
          element.classList.remove("b-dom-transition-adding");
          element.$initial.parentElement.appendChild(element);
        }
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
      delete element.$scrollTop;
    }
  }
  //endregion
  static async loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  static isNamedColor(color) {
    return color && !/^(#|hsl|rgb|hwb|lab|lch|oklab|oklch)/.test(color);
  }
  static createColorStyle(color) {
    return (color == null ? void 0 : color.length) ? this.isNamedColor(color) ? `var(--cal-color-${color})` : color : "";
  }
  //#region Salesforce hooks
  // Wrap NodeFilter to support salesforce
  static get NodeFilter() {
    return NodeFilter;
  }
  static addChild(parent, child, sibling) {
    parent.insertBefore(child, sibling);
  }
  static cloneStylesIntoShadowRoot(shadowRoot, removeExisting) {
    return new Promise((resolve, reject) => {
      if (removeExisting) {
        shadowRoot.querySelectorAll('style, link[rel="stylesheet"]').forEach((el) => el.remove());
      }
      const links = document.querySelectorAll('link[rel="stylesheet"]');
      let loadCount = 0;
      links.forEach((node) => {
        const clone = node.cloneNode();
        clone.addEventListener("load", () => {
          loadCount += 1;
          if (loadCount === links.length) {
            resolve();
          }
        });
        clone.addEventListener("error", (e) => {
          reject(clone.href);
        });
        shadowRoot.appendChild(clone);
      });
      document.querySelectorAll("style").forEach((node) => {
        const clone = node.cloneNode();
        clone.innerText = node.innerText;
        shadowRoot.appendChild(clone);
      });
      if (!links.length) {
        resolve();
      }
    });
  }
  //#endregion
};
var DH2 = DomHelper;
var clearTouchTimer;
var clearTouchEvent = () => DH2.isTouchEvent = false;
var setTouchEvent = () => {
  DH2.isTouchEvent = true;
  clearTimeout(clearTouchTimer);
  clearTouchTimer = setTimeout(clearTouchEvent, 400);
};
doc.addEventListener("touchstart", setTouchEvent, true);
doc.addEventListener("touchend", setTouchEvent, true);
DH2.canonicalStyles = canonicalStyles;
DH2.supportsTemplate = "content" in doc.createElement("template");
DH2.elementPropKey = elementPropKey;
DH2.numberRe = numberRe;
if (!("children" in Node.prototype)) {
  const elementFilter = isElement;
  Object.defineProperty(Node.prototype, "children", {
    get: function() {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {
    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
    let i = matches.length;
    while (--i >= 0 && matches.item(i) !== this) {
    }
    return i > -1;
  };
}
if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function(s) {
    let el = this;
    if (!doc.documentElement.contains(el))
      return null;
    do {
      if (el.matches(s))
        return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === el.ELEMENT_NODE);
    return null;
  };
} else {
  Node.prototype.closest = function(selector) {
    var _a4;
    return (_a4 = this.parentNode) == null ? void 0 : _a4.closest(selector);
  };
}
(function(arr) {
  arr.forEach(function(item) {
    if (Object.prototype.hasOwnProperty.call(item, "remove")) {
      return;
    }
    Object.defineProperty(item, "remove", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
globalThis.addEventListener("resize", () => scrollBarWidth = null);
DomHelper._$name = "DomHelper";

// ../Core/lib/Core/GlobalEvents.js
var longpressMoveThreshold = 5;
var isFloatingWidget = (w) => w.floating;
var longPressCancelEvents = {
  touchend: 1,
  pointerup: 1
};
var ignoreModifierKeys = {
  Meta: 1,
  Control: 1,
  Alt: 1
};
var GlobalEvents = new class GlobalEventsHandler extends Base.mixin(Events_default) {
  suspendFocusEvents() {
    focusEventsSuspended = true;
  }
  resumeFocusEvents() {
    focusEventsSuspended = false;
  }
  setupFocusListenersOnce(rootElement, EventHelper2) {
    if (rootElement && !GlobalEvents.observedElements.has(rootElement)) {
      GlobalEvents.setupFocusListeners(rootElement, EventHelper2);
      GlobalEvents.observedElements.add(rootElement);
    }
  }
  detachFocusListeners(rootElement) {
    if (rootElement.$globalEventsDetacher) {
      rootElement.$globalEventsDetacher();
      rootElement.$globalEventsDetacher = null;
      GlobalEvents.observedElements.delete(rootElement);
    }
  }
  // This is imported by EventHelper and that makes the call to set up the listeners
  // `detach` argument is required to not setup more listeners than we need to. In case of salesforce we include floatroot
  // inside the webcomponent element and thus don't need default listeners on document. In regular webcomponents demo we
  // don't need to do it, because with multiple components on one page that would force us to make more complex lookups.
  setupFocusListeners(element = document, EventHelper2, detach = false) {
    let lastPinchPos, pinchCenter, pinchTarget;
    const listeners = {
      element,
      touchstart(touchstart) {
        const { touches: ct } = touchstart;
        if (ct.length === 2 && ct[0].target.closest(".b-widget") && ct[1].target.closest(".b-widget")) {
          lastPinchPos = [ct[0], ct[1]];
          pinchCenter = [
            (lastPinchPos[0].clientX + lastPinchPos[1].clientX) / 2,
            (lastPinchPos[0].clientY + lastPinchPos[1].clientY) / 2
          ];
          pinchTarget = document.elementFromPoint(pinchCenter[0], pinchCenter[1]);
          return;
        }
        if (!globalTouchStart && touchstart.changedTouches.length === 1) {
          globalTouchStart = touchstart.changedTouches[0];
          if (!BrowserHelper.isAndroid) {
            const onMoveOrPointerUp = ({ clientX, clientY, type }) => {
              if (longPressCancelEvents[type] || !globalTouchStart || Math.max(Math.abs(clientX - globalTouchStart.clientX), Math.abs(clientY - globalTouchStart.clientY)) > longpressMoveThreshold) {
                contextMenuTouchId = null;
                touchMoveRemover();
                clearTimeout(tapholdTimer);
              }
            }, touchMoveRemover = EventHelper2.on({
              element: document,
              touchmove: onMoveOrPointerUp,
              touchend: onMoveOrPointerUp,
              pointermove: onMoveOrPointerUp,
              pointerup: onMoveOrPointerUp,
              capture: true
            }), tapholdTimer = setTimeout(() => {
              contextMenuTouchId = globalTouchStart.identifier;
              touchMoveRemover();
              touchstart.target.dispatchEvent(new MouseEvent("contextmenu", EventHelper2.copyEvent({}, touchstart)));
            }, EventHelper2.longPressTime);
          }
        } else {
          globalTouchStart = null;
        }
      },
      touchmove: {
        handler: (touchMove) => {
          const { touches: ct } = touchMove;
          if (ct.length === 2 && lastPinchPos) {
            const pinchPos = [ct[0], ct[1]], delta = EventHelper2.getDistanceBetween(lastPinchPos[0], lastPinchPos[1]) - EventHelper2.getDistanceBetween(pinchPos[0], pinchPos[1]), deltaX = Math.abs(lastPinchPos[0].clientX - lastPinchPos[1].clientX) - Math.abs(pinchPos[0].clientX - pinchPos[1].clientX), deltaY = Math.abs(lastPinchPos[0].clientY - lastPinchPos[1].clientY) - Math.abs(pinchPos[0].clientY - pinchPos[1].clientY);
            if (Math.abs(delta) > 2) {
              const pinch = {
                clientX: pinchCenter[0],
                clientY: pinchCenter[1],
                bubbles: true
              };
              if (GlobalEvents.Widget.convertPinchToMousewheel) {
                touchMove.preventDefault();
                touchMove.stopImmediatePropagation();
                const e13 = new MouseEvent("wheel", { ...pinch, ctrlKey: true });
                e13.deltaY = deltaY;
                e13.deltaX = deltaX;
                pinchTarget.dispatchEvent(e13);
              }
              const e = new MouseEvent("bryntum-pinch", pinch);
              e.deltaY = deltaY;
              e.deltaX = deltaX;
              e.touchMove = touchMove;
              pinchTarget.dispatchEvent(e);
            }
            lastPinchPos = pinchPos;
          }
        },
        passive: false
      },
      // Just this one has to be passive: false so that we are allowed to preventDefault
      // if we are part of a contextmenu longpress emulation. Otherwise the gesture will
      // proceed to cause a mousedown event.
      touchend: {
        handler: (event) => {
          if (event.touches.length !== 2) {
            lastPinchPos = null;
          }
          if (globalTouchStart) {
            if (event.changedTouches[0].identifier === contextMenuTouchId) {
              event.stopImmediatePropagation();
              if (event.cancelable !== false) {
                event.preventDefault();
              }
            } else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globalTouchStart.identifier) {
              GlobalEvents.trigger("globaltap", { event });
            }
            globalTouchStart = null;
          }
        },
        passive: false
      },
      mousedown: {
        handler: (event) => {
          lastInteractionType = "mouse";
          if (!globalTouchStart) {
            GlobalEvents.trigger("globaltap", { event });
          }
          currentMouseDown = event;
          const hasModifierKey = event.ctrlKey || event.altKey || event.shiftKey || event.metaKey;
          if (!currentKeyDown && hasModifierKey) {
            currentKeyDown = new KeyboardEvent("keydown", {
              key: event.ctrlKey ? "Control" : event.shiftKey ? "Shift" : event.altKey ? "Alt" : "Meta",
              ctrlKey: event.ctrlKey,
              altKey: event.altKey,
              shiftKey: event.shiftKey,
              metaKey: event.metaKey
            });
          } else if (currentKeyDown && !hasModifierKey) {
            currentKeyDown = null;
          }
        },
        passive: false
      },
      mouseup() {
        currentMouseDown = null;
      },
      pointerdown: {
        passive: false,
        handler: (event) => {
          var _a4;
          currentPointerDown = event;
          DomHelper.usingKeyboard = false;
          (_a4 = element.classList) == null ? void 0 : _a4.remove("b-using-keyboard");
          if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            DomHelper.removeClsGlobally(element, "b-using-keyboard");
          }
        }
      },
      pointerup: {
        passive: false,
        handler: (event) => {
          if ((currentPointerDown == null ? void 0 : currentPointerDown.pointerId) === event.pointerId) {
            currentPointerDown = null;
          }
        }
      },
      keydown(ev) {
        const { key, target } = ev;
        lastInteractionType = "key";
        currentKeyDown = ev;
        currentOverElement = target;
        if (!ignoreModifierKeys[key]) {
          DomHelper.usingKeyboard = true;
          if (key === "Escape") {
            GlobalEvents.Widget.queryAll((w) => w.isTooltip && w.isVisible).forEach((w) => w.hide());
          }
          if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            for (const node of element.children) {
              if (node.matches(".b-outer")) {
                node.classList.add("b-using-keyboard");
              }
            }
          } else {
            element.classList.add("b-using-keyboard");
          }
        }
      },
      mouseenter(ev) {
        currentOverElement = ev.target;
      },
      keypress() {
        lastInteractionType = "key";
      },
      keyup() {
        currentKeyDown = null;
      },
      focusin(focusin) {
        var _a4;
        const { Widget: Widget2 } = GlobalEvents, { target } = focusin;
        if ((target == null ? void 0 : target.shadowRoot) || (target == null ? void 0 : target._shadowRoot)) {
          return;
        }
        if (target && Widget2.accessibility) {
          const inner = target.firstElementChild || target, rect = Rectangle.from(target), center = rect.center;
          (DomHelper.childFromPoint(inner, rect.width / 2, rect.height / 2) || inner).dispatchEvent(new PointerEvent("pointerover", {
            bubbles: true,
            clientX: center.x,
            clientY: center.y,
            pointerType: "focus"
          }));
        }
        if (focusEventsSuspended || target && !target.isConnected) {
          return;
        }
        const fromElement = !focusin.relatedTarget ? null : focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body, toElement = target || document.body, fromWidget = Widget2.fromElement(fromElement), toWidget = Widget2.fromElement(toElement), commonAncestor = DomHelper.getCommonAncestor(fromWidget, toWidget), backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4), topVisibleModal = Widget2.query(isTopVisibleModal);
        let currentFocus = null;
        if (toElement && toElement !== document.body) {
          currentFocus = DomHelper.getActiveElement(toElement);
        } else {
          currentFocus = DomHelper.getActiveElement(document);
        }
        if (topVisibleModal && !topVisibleModal._isRevertingFocus) {
          if (!toWidget || !topVisibleModal.owns(toWidget) && !(topVisibleModal.element.compareDocumentPosition(toWidget.element) & 4 && toWidget.up(isFloatingWidget))) {
            return topVisibleModal.focus();
          }
        }
        let event = createWidgetEvent("focusout", fromElement, target, fromWidget, toWidget, backwards);
        for (let targetWidget = fromWidget, owner; targetWidget && targetWidget !== commonAncestor; targetWidget = owner) {
          owner = targetWidget.owner;
          if (!targetWidget.isDestroying && targetWidget.onFocusOut) {
            targetWidget.onFocusOut(event);
            if (target && currentFocus !== DomHelper.getActiveElement(target)) {
              return;
            }
          }
        }
        if (commonAncestor && target === commonAncestor.element) {
          if (!commonAncestor.isDestroying && DomHelper.getActiveElement(commonAncestor) === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {
            if (!commonAncestor.element.contains(currentFocus) || commonAncestor.focusDescendant) {
              commonAncestor.setTimeout(() => {
                var _a5;
                return (_a5 = commonAncestor.focus) == null ? void 0 : _a5.call(commonAncestor);
              }, 0);
            }
          }
        } else {
          event = createWidgetEvent("focusin", toElement, fromElement, fromWidget, toWidget, backwards);
          for (let targetWidget = toWidget; targetWidget && targetWidget !== commonAncestor; targetWidget = targetWidget.owner) {
            if (!targetWidget.isDestroying) {
              (_a4 = targetWidget.onFocusIn) == null ? void 0 : _a4.call(targetWidget, event);
            }
          }
        }
        const commonAncestorEl = DomHelper.getCommonAncestor((fromElement == null ? void 0 : fromElement.nodeType) === Element.ELEMENT_NODE ? fromElement : null, toElement) || toElement.parentNode;
        if (commonAncestorEl) {
          event = createWidgetEvent("focusmove", toElement, fromElement, fromWidget, toWidget, backwards, { bubbles: true });
          commonAncestorEl.dispatchEvent(event);
        }
      },
      focusout(focusout) {
        if (focusEventsSuspended) {
          return;
        }
        if (!focusout.relatedTarget || !GlobalEvents.Widget.fromElement(focusout.relatedTarget)) {
          const target = focusout.relatedTarget && focusout.relatedTarget instanceof HTMLElement ? focusout.relatedTarget : null;
          listeners.focusin({
            target,
            relatedTarget: focusout.target
          });
          currentKeyDown = currentMouseDown = null;
        }
      },
      // This will clear keydown and mousedown status on window blur
      blur: {
        element: globalThis,
        handler(event) {
          if (event.target === globalThis) {
            currentKeyDown = null;
            currentMouseDown = null;
          }
        }
      },
      capture: true,
      passive: true
    };
    detach && (detacher == null ? void 0 : detacher());
    detacher = this.detachEvents = element.$globalEventsDetacher = EventHelper2.on(listeners);
  }
  get lastInteractionType() {
    return lastInteractionType;
  }
  get shiftKeyDown() {
    return currentKeyDown == null ? void 0 : currentKeyDown.shiftKey;
  }
  get ctrlKeyDown() {
    return (currentKeyDown == null ? void 0 : currentKeyDown.ctrlKey) || (currentKeyDown == null ? void 0 : currentKeyDown.metaKey);
  }
  get altKeyDown() {
    return currentKeyDown == null ? void 0 : currentKeyDown.altKey;
  }
  get currentOverElement() {
    return currentOverElement;
  }
  isKeyDown(key) {
    return !key ? Boolean(currentKeyDown) : (currentKeyDown == null ? void 0 : currentKeyDown.key) === key || currentKeyDown[(key == null ? void 0 : key.toLowerCase()) + "Key"] === true;
  }
  isMouseDown(button = 0) {
    return (currentMouseDown == null ? void 0 : currentMouseDown.button) === button;
  }
  get currentMouseDown() {
    return currentMouseDown;
  }
  get currentPointerDown() {
    return currentPointerDown;
  }
  get currentTouch() {
    return globalTouchStart;
  }
  get currentKeyDown() {
    return currentKeyDown;
  }
}();
var isTopVisibleModal = (w) => w.isVisible && w.isTopModal;
GlobalEvents.observedElements = /* @__PURE__ */ new Set();
var globalTouchStart;
var contextMenuTouchId;
var focusEventsSuspended = false;
var lastInteractionType;
var currentKeyDown;
var currentMouseDown;
var currentPointerDown;
var currentOverElement;
var detacher;
function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);
  Object.defineProperty(result, "_target", {
    get() {
      return target;
    }
  });
  Object.defineProperty(result, "relatedTarget", {
    get() {
      return relatedTarget;
    }
  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;
  return result;
}
var GlobalEvents_default = GlobalEvents;

// ../Core/lib/Core/mixin/InstancePlugin.js
function getDescriptor(me, fnName) {
  const property = ObjectHelper.getPropertyDescriptor(me, fnName);
  return property && (property.get || property.set) ? property : null;
}
var InstancePlugin = class extends Base.mixin(Events_default, Localizable_default) {
  //region Config
  static get configurable() {
    return {
      clientListeners: null,
      /**
       * The plugin/feature `disabled` state.
       *
       * For a feature that is **off** by default that you want to enable later during runtime,
       * configure it with `disabled : true`.
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : {
       *              disabled : true // on and disabled, can be enabled later
       *          }
       *      }
       * });
       *
       * // enable the feature
       * grid.features.featureName.disabled = false;
       * ```
       *
       * If the feature is **disabled** by default, and you want to include and enable the feature, configure it as `true`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : true // on and enabled, can be disabled later
       *      }
       * });
       *
       * // disable the feature
       * grid.features.featureName.disabled = true;
       * ```
       *
       * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : false // turned off, not included at all
       *      }
       * });
       * ```
       *
       * If the feature is **enabled** by default and you have no need of reconfiguring it,
       * you can omit the feature configuration.
       *
       * @prp {Boolean}
       * @default
       * @category Common
       */
      disabled: false,
      /**
       * The Widget which was passed into the constructor,
       * which is the Widget we are providing extra services for.
       * @member {Core.widget.Widget} client
       * @readonly
       * @category Misc
       * @advanced
       */
      /**
       * The widget which this plugin is to attach to.
       * @config {Core.widget.Widget}
       * @category Misc
       * @advanced
       */
      client: null,
      /**
       * @hideconfigs bubbleEvents, callOnFunctions
       */
      /**
       * @hidefunctions downloadTestCase, destroy
       */
      /**
       * @hideproperties isDestroyed
       */
      /**
       * @hideevents destroy, beforeDestroy
       */
      // The plugins can define their own keyMap which will then be merged with their client's keyMap.
      keyMap: null
    };
  }
  //endregion
  updateClient(client) {
    if (!this.owner) {
      this.owner = client;
    }
  }
  /**
   * This will merge a feature's (subclass of InstancePlugin) keyMap with it's client's keyMap.
   * @private
   */
  updateKeyMap(keyMap) {
    const { client } = this;
    client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));
  }
  //region Init
  /**
   * Call from another instance to add plugins to it.
   *
   * ```javascript
   * InstancePlugin.initPlugins(this, Search, Stripe);
   * ```
   *
   * @param plugInto Instance to mix into (usually this)
   * @param plugins Classes to plug in
   * @internal
   */
  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});
    for (const PluginClass of plugins) {
      property[PluginClass.$$name] = new PluginClass(plugInto);
    }
  }
  /**
   * Simple wrapper for {@link #property-disabled} to make optional chaining simple:
   *
   * ```javascript
   * grid.features.myFeature?.enabled // returns true when feature exists and is enabled
   * ```
   * @returns {Boolean}
   * @internal
   */
  get enabled() {
    return !this.disabled;
  }
  // We can act as an owner of a widget, so must be able to participate in focus reversion
  getFocusRevertTarget() {
    var _a4;
    return (_a4 = this.client) == null ? void 0 : _a4.getFocusRevertTarget();
  }
  construct(...args) {
    const me = this;
    let [plugInto, config] = args, listeners;
    if (args.length === 1) {
      if (ObjectHelper.isObject(plugInto)) {
        config = plugInto;
        plugInto = config.client;
      }
    } else {
      config = ObjectHelper.assign({}, config);
      delete config.client;
    }
    me.client = plugInto;
    super.construct(config);
    me.applyPluginConfig(plugInto);
    listeners = me.clientListeners;
    if (listeners) {
      listeners = ObjectHelper.assign({}, listeners);
      listeners.thisObj = me;
      plugInto.ion(listeners);
    }
  }
  /**
   * Applies config as found in plugInto.pluginConfig, or published all if no config found.
   * @private
   * @param plugInto Target instance to plug into
   */
  applyPluginConfig(plugInto) {
    const me = this, config = me.pluginConfig || me.constructor.pluginConfig;
    if (config) {
      const { assign: assign2, chain, after, before, override } = config;
      assign2 && me.applyAssign(plugInto, assign2);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }
  /**
   * Applies assigning for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyAssign(plugInto, fnNames) {
    fnNames.forEach((fnName) => this.assign(plugInto, fnName));
  }
  /**
   * Applies chaining for specified functions.
   * @private
   * @param plugInto
   * @param functions
   * @param after
   */
  applyChain(plugInto, functions, after = true) {
    if (Array.isArray(functions)) {
      for (const fnName of functions) {
        this.chain(plugInto, fnName, fnName, after);
      }
    } else {
      for (const intoName in functions) {
        this.chain(plugInto, intoName, functions[intoName], after);
      }
    }
  }
  /**
   * Applies override for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyOverride(plugInto, fnNames) {
    const me = this;
    if (!me.overridden) {
      me.overridden = {};
    }
    fnNames.forEach((fnName) => {
      if (!me[fnName]) {
        throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);
      }
      if (typeof plugInto[fnName] === "function") {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }
      plugInto[fnName] = me[fnName].bind(me);
    });
  }
  /**
   * Assigns specified functions.
   * @private
   * @param plugInto
   * @param fnName
   */
  assign(plugInto, fnName) {
    const me = this, property = getDescriptor(me, fnName);
    if (property) {
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }
  //endregion
  //region Chaining
  /**
   * Chains functions. When the function is called on the target class all functions in the chain will be called in
   * the order they were added.
   * @private
   * @param plugInto
   * @param intoName
   * @param hookName
   * @param after
   */
  chain(plugInto, intoName, hookName, after = true) {
    let prio = 0;
    if (typeof intoName === "object") {
      intoName = intoName.fn;
    }
    if (typeof hookName === "object") {
      prio = hookName.prio || 0;
      hookName = hookName.fn;
    }
    const me = this, chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}), hookFn = me[hookName] && me[hookName].bind(me), functionChainRunner = me.functionChainRunner;
    if (!hookFn) {
      throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);
    }
    if (!chains[intoName]) {
      let intoFn = plugInto[intoName];
      if (intoFn) {
        intoFn = intoFn.bind(plugInto);
        intoFn.$this = plugInto;
        intoFn.$prio = 0;
      }
      chains[intoName] = intoFn ? [intoFn] : [];
      plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);
    }
    hookFn.$this = me;
    hookFn.$prio = prio;
    chains[intoName][after ? "push" : "unshift"](hookFn);
    chains[intoName].$sorted = false;
  }
  /**
   * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a
   * function will abort chain.
   * @private
   * @param {Array} chain
   * @param {Array} params
   * @returns {*} value returned from last function in chain (or false if any returns false)
   */
  functionChainRunner(chain, params) {
    let fn, i, returnValue;
    if (!chain.$sorted) {
      chain.sort((a, b) => b.$prio - a.$prio);
      chain.$sorted = true;
    }
    for (i = 0; i < chain.length; i++) {
      fn = chain[i];
      if (!fn.$this.isDestroyed) {
        returnValue = fn(...params);
        if (returnValue === false) {
          break;
        }
      }
    }
    return returnValue;
  }
  //endregion
  /**
   * Called when disabling/enabling the plugin/feature, not intended to be called directly. To enable or disable a
   * plugin/feature, see {@link #property-disabled}.
   *
   * By default removes the cls of the plugin from its client. Override in subclasses to take any other actions necessary.
   * @category Misc
   * @advanced
   */
  doDisable(disable) {
    var _a4, _b, _c, _d;
    const me = this, { constructor } = me, cls = "featureClass" in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`, key = StringHelper.uncapitalize(constructor.$$name);
    if (cls) {
      (_b = (_a4 = me.client) == null ? void 0 : _a4._element) == null ? void 0 : _b.classList[disable ? "remove" : "add"](cls);
    }
    if (!me.isConfiguring) {
      if (disable) {
        me.trigger("disable");
      } else {
        me.trigger("enable");
      }
      (_d = (_c = me.client).syncSplits) == null ? void 0 : _d.call(_c, (other) => {
        const otherFeature = other.features[key];
        if (otherFeature) {
          otherFeature.disabled = disable;
        }
      });
    }
  }
  updateDisabled(disabled) {
    this.doDisable(disabled);
  }
  throwOverrideIsMissing(data) {
    throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);
  }
  // Convenience method to read the rootElement from the owner widget
  get rootElement() {
    return this.client.rootElement;
  }
};
__publicField(InstancePlugin, "$name", "InstancePlugin");
InstancePlugin._$name = "InstancePlugin";

// ../Core/lib/Core/mixin/Pluggable.js
var Pluggable_default = (Target) => class Pluggable extends (Target || Base) {
  static get $name() {
    return "Pluggable";
  }
  /**
   * Specify plugins (an array of classes) in config
   * @config {Function[]} plugins
   * @category Misc
   * @advanced
   */
  /**
   * Map of applied plugins
   * @property {Object<String,Core.mixin.InstancePlugin>}
   * @readonly
   * @category Misc
   * @advanced
   */
  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }
    return this._plugins;
  }
  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins))
        plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }
    this.initPlugins();
  }
  /**
   * Template method which may be implemented in subclasses to initialize any plugins.
   * This method is empty in the `Pluggable` base class.
   * @internal
   */
  initPlugins() {
  }
  /**
   * Adds plugins to an instance.
   * @param {Function[]} plugins The plugins to add
   * @category Misc
   * @advanced
   */
  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }
  /**
   * Checks if instance has plugin.
   * @param {String|Function} pluginClassOrName Plugin or name to check for
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }
  /**
   * Get a plugin instance.
   * @param {String|Function} pluginClassOrName
   * @returns {Core.mixin.InstancePlugin}
   * @category Misc
   * @advanced
   */
  getPlugin(pluginClassOrName) {
    var _a4;
    if (typeof pluginClassOrName === "function") {
      pluginClassOrName = pluginClassOrName.$$name;
    }
    return (_a4 = this.plugins) == null ? void 0 : _a4[pluginClassOrName];
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement this.
  get widgetClass() {
  }
};

// ../Core/lib/Core/mixin/Delayable.js
var { defineProperty: defineProperty3 } = Reflect;
var performance2;
if (BrowserHelper.isBrowserEnv) {
  performance2 = globalThis.performance;
} else {
  performance2 = {
    now() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  };
}
var globalDelays = null;
if (VersionHelper.isTestEnv) {
  const bryntum2 = globalThis.bryntum || (globalThis.bryntum = {});
  globalDelays = bryntum2.globalDelays = {
    timeouts: /* @__PURE__ */ new Map(),
    intervals: /* @__PURE__ */ new Map(),
    animationFrames: /* @__PURE__ */ new Map(),
    idleCallbacks: /* @__PURE__ */ new Map(),
    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    },
    /**
     * Returns filtered delays array
     * @param {Object} options
     * @param {String[]} [options.ignoreTimeouts] array of delays names to ignore
     * @param {Number} [options.maxDelay] maximum delay in milliseconds. Timeouts with bigger delay will be filtered out
     * @param {Boolean} [options.includeIntervals] include intervals
     * @returns {Object[]} array of filtered delays
     * @internal
     */
    getFiltered({ ignoreTimeouts = [], maxDelay = 5e3, includeIntervals = false }) {
      const result = [], scopes = ["timeouts", "animationFrames", "idleCallbacks"];
      if (includeIntervals) {
        scopes.push("intervals");
      }
      for (const scope of scopes) {
        const map = globalDelays[scope];
        for (const [, entry] of map.entries()) {
          if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {
            result.push(entry);
          }
        }
      }
      return result;
    }
  };
}
var asapPromise = Promise.resolve();
var emptyArray3 = Object.freeze([]);
var emptyFn3 = () => {
};
var emptyObject5 = Object.freeze({});
var queueMicrotask = globalThis.queueMicrotask;
var makeInvoker = (me, fn, wrapFn, options) => {
  const named = typeof fn === "string", appendArgs = (options == null ? void 0 : options.appendArgs) || emptyArray3, invoker = () => {
    wrapFn.timerId = null;
    wrapFn.lastCallTime = performance2.now();
    const args = wrapFn.args;
    wrapFn.args = null;
    if (named) {
      me[fn](...args, ...appendArgs);
    } else {
      fn.call(me, ...args, ...appendArgs);
    }
    wrapFn.called = true;
    ++wrapFn.calls;
  };
  if (options) {
    me = options.thisObj || me;
  }
  wrapFn.lastCallTime = -9e9;
  wrapFn.calls = 0;
  wrapFn.invoker = invoker;
  invoker.wrapFn = wrapFn;
  return invoker;
};
var decorateWrapFn = (me, wrapFn, cancelFn = "clearTimeout") => {
  wrapFn.cancel = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.args = wrapFn.timerId = null;
    }
  };
  wrapFn.flush = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.timerId = null;
      wrapFn.invoker();
    }
  };
  wrapFn.now = (...args) => {
    wrapFn.cancel();
    wrapFn.args = args;
    wrapFn.invoker();
  };
  wrapFn.resume = (all) => {
    const n = wrapFn.suspended;
    wrapFn.suspended = all || n < 1 ? 0 : n - 1;
  };
  wrapFn.suspend = () => {
    ++wrapFn.suspended;
  };
  wrapFn.immediate = false;
  wrapFn.suspended = 0;
  wrapFn.timerId = null;
  defineProperty3(wrapFn, "isPending", {
    get() {
      return wrapFn.timerId !== null;
    }
  });
  return wrapFn;
};
var Delayable_default = (Target) => class Delayable extends (Target || Base) {
  static get $name() {
    return "Delayable";
  }
  static get declarable() {
    return [
      /**
       * This class property returns an object that specifies methods to wrap with configurable timer behaviors.
       *
       * It is used like so:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : 500
       *          };
       *      }
       *
       *      expensiveMethod() {
       *          this.things();
       *          this.moreThings();
       *          this.evenMoreThings();
       *      }
       *  }
       * ```
       * With the above in place, consider:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();
       * ```
       * Instead of the above code immediately calling the `expensiveMethod()`, it will start a timer that will
       * invoke the method 500ms later. Because `expensiveMethod()` is an instance method, each instance of `Foo`
       * will have its own timer.
       *
       * NOTE: Only instance methods are currently supported (i.e., only non-`static` methods).
       *
       * #### Options
       * The value of each key configures how the method will be scheduled. If the value is a number, it is
       * promoted to a config object of `type='buffer'` as in the following:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : {
       *                  type  : 'buffer',
       *                  delay : 500
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `type` property of the config object must be one of three values. Other options can be provided
       * depending on the `type`:
       *
       *  - `buffer`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait before calling the underlying method. A
       *       value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the buffer).
       *  - `raf` (short for "request animation frame")<br>
       *  - `idle` (short for "request idle callback") __Not available on Safari__ <br>
       *    Other options:
       *     - `cancelOutstanding` (Boolean) : Set to `true` to cancel any pending animation frame requests and
       *       schedule a new one on each call.
       *     - `immediate` (Boolean) : Set to `true` to call immediately.
       *  - `throttle`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait after each execution before another
       *       execution takes place. A value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the throttle).
       *
       * While `immediate: true` can be specified at the class level, it is more typical to set it on the
       * instance's method as described below.
       *
       * #### Delayable Method API
       * Delayable methods have a consistent API to manage their scheduling. This API is added to the methods
       * themselves.
       *
       * For example:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();         // schedule a call in 500ms
       *  instance.expensiveMethod.isPending; // true
       *  instance.expensiveMethod.cancel();
       *  instance.expensiveMethod.flush();
       *  instance.expensiveMethod.now();
       *
       *  instance.expensiveMethod.delay = 10;
       *  instance.expensiveMethod();         // schedule a call in 10ms
       * ```
       *
       * ##### `isPending` (Boolean, readonly)
       * This boolean property will be `true` if a call has been scheduled, and false otherwise.
       *
       * ##### `cancel()`
       * Cancels a pending call if one has been scheduled. Otherwise this method does nothing.
       *
       * ##### `flush()`
       * Cancels the timer and causes the pending call to execute immediately. If there is no pending call, this
       * method does nothing.
       *
       * ##### `now()`
       * Cancels the timer (if one is pending) and executes the method immediately. If there is no pending call,
       * this method will still call the underlying method.
       *
       * @static
       * @member {Object<String,'raf'|Number|DelayableConfig>} delayable
       * @internal
       */
      "delayable"
    ];
  }
  doDestroy() {
    super.doDestroy();
    this.clearDelayables();
  }
  clearDelayables() {
    const me = this, [idleCallbackIds, animationFrameIds, intervalIds, timeoutMap, timeoutIds, microtasksPending] = [
      me.idleCallbackIds,
      me.animationFrameIds,
      me.intervalIds,
      me.timeoutMap,
      me.timeoutIds,
      me.microtasksPending
    ];
    me.idleCallbackIds = me.animationFrameIds = me.intervalIds = me.timeoutMap = me.timeoutIds = me.microtasksPending = null;
    timeoutIds == null ? void 0 : timeoutIds.forEach((fn, id) => {
      if (typeof fn === "function") {
        fn();
      }
      clearTimeout(id);
      globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
    });
    timeoutMap == null ? void 0 : timeoutMap.forEach((name, id) => clearTimeout(id));
    intervalIds == null ? void 0 : intervalIds.forEach((id) => {
      clearInterval(id);
      globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
    });
    animationFrameIds == null ? void 0 : animationFrameIds.forEach((id) => {
      cancelAnimationFrame(id);
      globalDelays == null ? void 0 : globalDelays.animationFrames.delete(id);
    });
    idleCallbackIds == null ? void 0 : idleCallbackIds.forEach((id) => {
      cancelIdleCallback(id);
      globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(id);
    });
    microtasksPending == null ? void 0 : microtasksPending.forEach((taskDef) => taskDef.cancel());
  }
  /**
   * Check if a named timeout is active
   * @param name
   * @internal
   */
  hasTimeout(name) {
    var _a4;
    return Boolean((_a4 = this.timeoutMap) == null ? void 0 : _a4.has(name));
  }
  /**
   * Returns a function that when called will schedule a call to `fn` via {@link #function-queueMicrotask}.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Boolean|Object} [options] An options object.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function}
   * @internal
   */
  asap(fn, options) {
    const me = this, asapWrapFn = (...params) => {
      if (!asapWrapFn.suspended) {
        asapWrapFn.called = false;
        asapWrapFn.args = params;
        if (asapWrapFn.immediate) {
          invoker();
        } else if (!asapWrapFn.isPending) {
          asapWrapFn.timerId = me.queueMicrotask(invoker);
        }
      }
    }, invoker = makeInvoker(me, fn, asapWrapFn, options);
    return decorateWrapFn(me, asapWrapFn, "cancelMicrotask");
  }
  /**
   * Equivalent to the native [`queueMicrotask`](https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask), but
   * will be cancelled automatically on `destroy`. When `queueMicrotask` is not available, the provided `fn` is
   * called using `Promise.resolve().then(fn)`, which behaves similarly.
   *
   * Returns a function that when called will cancel the impending call. This function can also be viewed as a timer
   * id that can be passed to {@link #function-cancelMicrotask}
   *
   * @param {Function|String} fn The function to call, or name of function in this object to call.
   * @param {Array} [args] The arguments to pass.
   * @param {Object} [options] An object containing the details about that function, and the time delay.
   * @param {Array} [options.args] The arguments to pass if
   * @param {Boolean} [options.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance
   * is destroyed while function is scheduled.
   * @param {Boolean} [options.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.
   * @returns {Function}
   * @internal
   */
  queueMicrotask(fn, args, options) {
    let key, taskDef;
    if (!options && args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    options = options || emptyObject5;
    args = args || options.args || emptyArray3;
    const me = this, string2 = typeof fn === "string", name = string2 ? fn : fn.name, pending = me.microtasksPending || (me.microtasksPending = /* @__PURE__ */ new Map()), cancel = () => pending.delete(key), wrapFn = () => {
      if (taskDef === pending.get(key)) {
        pending.delete(key);
        if (string2) {
          !me.isDestroyed && me[fn](...args);
        } else {
          fn.apply(me, args);
        }
      }
    };
    if (me.isDestroying && !options.runOnDestroy) {
      return emptyFn3;
    }
    key = options.cancelOutstanding ? name || fn : cancel;
    taskDef = { key, name, fn, args, options, cancel, wrapFn };
    cancel.taskDef = taskDef;
    queueMicrotask ? queueMicrotask(wrapFn) : asapPromise.then(wrapFn);
    pending.set(key, taskDef);
    return cancel;
  }
  /**
   * Given the return value from a call to {@link #function-queueMicrotask}, cancels the pending call. This method is
   * provided for symmetry with other timer functions, such as {@link #function-setTimeout}.
   *
   * @param {Function} task The value returned by `queueMicrotask`.
   * @internal
   */
  cancelMicrotask(task) {
    task == null ? void 0 : task();
  }
  /**
   * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will
   * be used to store the timeout id.
   * @param {Object} timeoutSpec An object containing the details about that function, and the time delay.
   * @param {Function|String} timeoutSpec.fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.
   * @param {Number} timeoutSpec.delay The milliseconds to delay the call by.
   * @param {Object[]} timeoutSpec.args The arguments to pass.
   * @param {String} [timeoutSpec.name] The name under which to register the timer. Defaults to `fn.name`.
   * @param {Boolean} [timeoutSpec.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance is destroyed while function is scheduled.
   * @param {Boolean} [timeoutSpec.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.
   * @returns {Number}
   * @internal
   */
  setTimeout({ fn, delay, name, runOnDestroy, cancelOutstanding, args }) {
    if (arguments.length > 1 || typeof arguments[0] === "function") {
      [fn, delay, name, runOnDestroy, cancelOutstanding] = arguments;
    }
    if (typeof fn === "string") {
      name = fn;
    } else if (!name) {
      name = fn.name || fn;
    }
    if (cancelOutstanding) {
      this.clearTimeout(name);
    }
    const me = this, timeoutIds = me.timeoutIds || (me.timeoutIds = /* @__PURE__ */ new Map()), timeoutMap = me.timeoutMap || (me.timeoutMap = /* @__PURE__ */ new Map()), timeoutId = setTimeout(() => {
      if (typeof fn === "string") {
        fn = me[name];
      }
      timeoutIds == null ? void 0 : timeoutIds.delete(timeoutId);
      timeoutMap == null ? void 0 : timeoutMap.delete(name);
      globalDelays == null ? void 0 : globalDelays.timeouts.delete(timeoutId);
      fn.apply(me, args);
    }, delay);
    timeoutIds.set(timeoutId, runOnDestroy ? fn : true);
    globalDelays == null ? void 0 : globalDelays.timeouts.set(timeoutId, {
      fn,
      delay,
      name
      /*, stack : new Error().stack*/
    });
    if (name) {
      timeoutMap.set(name, timeoutId);
    }
    return timeoutId;
  }
  /**
   * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified
   * a name to setTimeout())
   * property to null.
   * @param {Number|String} idOrName timeout id or name
   * @internal
   */
  clearTimeout(idOrName) {
    var _a4;
    let id = idOrName;
    if (typeof id === "string") {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }
    clearTimeout(id);
    (_a4 = this.timeoutIds) == null ? void 0 : _a4.delete(id);
    globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
  }
  /**
   * clearInterval wrapper
   * @param {Number} id
   * @internal
   */
  clearInterval(id) {
    var _a4;
    clearInterval(id);
    (_a4 = this.intervalIds) == null ? void 0 : _a4.delete(id);
    globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
  }
  /**
   * Same as native setInterval, but will be cleared automatically on destroy
   * @param {Function} fn callback method
   * @param {Number} delay delay in milliseconds
   * @param {String} name delay name for debugging
   * @returns {Number}
   * @internal
   */
  setInterval(fn, delay, name) {
    const intervalId = setInterval(fn, delay);
    (this.intervalIds || (this.intervalIds = /* @__PURE__ */ new Set())).add(intervalId);
    globalDelays == null ? void 0 : globalDelays.intervals.set(intervalId, { fn, delay, name });
    return intervalId;
  }
  /**
   * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestAnimationFrame(fn, extraArgs = [], thisObj = this) {
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = /* @__PURE__ */ new Set()), frameId = requestAnimationFrame(() => {
      globalDelays == null ? void 0 : globalDelays.animationFrames.delete(frameId);
      animationFrameIds.delete(frameId) && fn.apply(thisObj, extraArgs);
    });
    animationFrameIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.animationFrames.set(frameId, { fn, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Relays to native requestIdleCallback and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestIdleCallback(fn, extraArgs = [], thisObj = this) {
    const idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = /* @__PURE__ */ new Set()), frameId = requestIdleCallback(() => {
      globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(frameId);
      idleCallbackIds.delete(frameId) && fn.apply(thisObj, extraArgs);
    });
    idleCallbackIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.set(frameId, { fn, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Creates a function which will execute once, on the next animation frame. However many time it is
   * called in one event run, it will only be scheduled to run once.
   * @param {Function|String} fn The function to call, or name of function in this object to call.
   * @param {Object[]} [args] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.
   * @internal
   */
  createOnFrame(fn, args = [], thisObj = this, cancelOutstanding) {
    let rafId;
    const result = (...callArgs) => {
      if (rafId != null && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (rafId == null) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn === "string") {
            fn = thisObj[fn];
          }
          rafId = null;
          callArgs.push(...args);
          fn.apply(thisObj, callArgs);
        });
      }
    };
    result.cancel = () => this.cancelAnimationFrame(rafId);
    return result;
  }
  /**
   * Relays to native cancelAnimationFrame and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelAnimationFrame(handle) {
    var _a4;
    cancelAnimationFrame(handle);
    (_a4 = this.animationFrameIds) == null ? void 0 : _a4.delete(handle);
    globalDelays == null ? void 0 : globalDelays.animationFrames.delete(handle);
  }
  /**
   * Relays to native cancelIdleCallback and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelIdleCallback(handle) {
    var _a4;
    cancelIdleCallback(handle);
    (_a4 = this.idleCallbackIds) == null ? void 0 : _a4.delete(handle);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(handle);
  }
  async nextAnimationFrame() {
    return new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  /**
   * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper
   * resets delay.
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Object|Number} options The delay in milliseconds or an options object.
   * @param {Number} options.delay The delay in milliseconds.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function} Wrapped function to call.
   * @internal
   */
  buffer(fn, options) {
    let delay = options;
    if (options && typeof options !== "number") {
      delay = options.delay;
    } else {
      options = null;
    }
    const bufferWrapFn = (...params) => {
      if (bufferWrapFn.suspended) {
        return;
      }
      const { delay: delay2 } = bufferWrapFn;
      bufferWrapFn.cancel();
      bufferWrapFn.called = false;
      bufferWrapFn.args = params;
      if (bufferWrapFn.immediate || !delay2) {
        invoker();
      } else {
        bufferWrapFn.timerId = this.setTimeout(invoker, delay2);
      }
    }, invoker = makeInvoker(this, fn, bufferWrapFn, options);
    bufferWrapFn.delay = delay;
    return decorateWrapFn(this, bufferWrapFn);
  }
  /**
   * Returns a function that when called will schedule a call to `fn` on the next animation frame.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Boolean|Object} [options] An options object or the `cancelOutstanding` boolean property of it.
   * @param {Boolean} [options.cancelOutstanding] Pass `true` to cancel any pending animation frame requests and
   * schedule a new one on each call to the returned function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function}
   * @internal
   */
  raf(fn, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const rafWrapFn = (...params) => {
      if (rafWrapFn.suspended) {
        return;
      }
      if (rafWrapFn.cancelOutstanding) {
        rafWrapFn.cancel();
      }
      rafWrapFn.called = false;
      rafWrapFn.args = params;
      if (rafWrapFn.immediate) {
        invoker();
      } else if (!rafWrapFn.isPending) {
        rafWrapFn.timerId = this.requestAnimationFrame(invoker);
      }
    }, invoker = makeInvoker(this, fn, rafWrapFn, options);
    rafWrapFn.cancelOutstanding = cancelOutstanding;
    return decorateWrapFn(this, rafWrapFn, "cancelAnimationFrame");
  }
  idle(fn, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const idleWrapFn = (...params) => {
      if (idleWrapFn.suspended) {
        return;
      }
      if (idleWrapFn.cancelOutstanding) {
        idleWrapFn.cancel();
      }
      idleWrapFn.called = false;
      idleWrapFn.args = params;
      if (idleWrapFn.immediate) {
        invoker();
      } else if (!idleWrapFn.isPending) {
        idleWrapFn.timerId = this.requestIdleCallback(invoker);
      }
    }, invoker = makeInvoker(this, fn, idleWrapFn, options);
    idleWrapFn.cancelOutstanding = cancelOutstanding;
    this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);
    return decorateWrapFn(this, idleWrapFn, "cancelIdleCallback");
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Number|Object} options The milliseconds to wait after each execution before another execution takes place
   * or a object containing options.
   * @param {Object} [options.thisObj] `this` reference for the function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Function|String} [options.throttled] A function to call when the invocation is delayed due to buffer
   * time not having expired. If this is a string, it is looked up as a method on `this` instance (or `options.thisObj`
   * instead, if provided). When called, the same arguments are passed as would have been passed to `fn`, including
   * any `options.appendArgs`.
   * @internal
   */
  throttle(fn, options) {
    let delay = options, throttled;
    if (options && typeof options !== "number") {
      delay = options.delay;
      throttled = options.throttled;
    } else {
      options = null;
    }
    const me = this, throttleWrapFn = (...args) => {
      if (throttleWrapFn.suspended) {
        return;
      }
      const { delay: delay2 } = throttleWrapFn, elapsed = performance2.now() - throttleWrapFn.lastCallTime;
      throttleWrapFn.args = args;
      if (throttleWrapFn.immediate || elapsed >= delay2) {
        me.clearTimeout(throttleWrapFn.timerId);
        invoker();
      } else {
        if (!throttleWrapFn.isPending) {
          throttleWrapFn.timerId = me.setTimeout(invoker, delay2 - elapsed);
          throttleWrapFn.called = false;
        }
        if (throttled) {
          throttled.wrapFn.args = args;
          throttled();
        }
      }
    }, invoker = makeInvoker(me, fn, throttleWrapFn, options);
    throttleWrapFn.delay = delay;
    if (throttled) {
      throttled = makeInvoker(me, throttled, () => {
      }, options);
    }
    return decorateWrapFn(me, throttleWrapFn);
  }
  static setupDelayable(cls) {
    cls.setupDelayableMethods(cls.delayable);
  }
  /**
   * This method initializes the `delayable` methods on this class.
   * @param {Object} delayable The `delayable` property.
   * @param {Function} [cls] This parameter will be used internally to process static methods.
   * @private
   */
  static setupDelayableMethods(delayable, cls = null) {
    const me = this, statics = delayable.static, target = cls || me.prototype;
    if (statics) {
      delete delayable.static;
    }
    for (const name in delayable) {
      let options = delayable[name];
      const implName = name + "Now", type = typeof options;
      if (!target[implName]) {
        target[implName] = target[name];
      }
      if (type === "number") {
        options = {
          type: "buffer",
          delay: options
        };
      } else if (type === "string") {
        options = {
          type: options
        };
      }
      defineProperty3(target, name, {
        get() {
          const value = this[options.type]((...params) => {
            this[implName](...params);
          }, options);
          defineProperty3(this, name, { value });
          return value;
        }
      });
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement this.
  get widgetClass() {
  }
};

// ../Core/lib/Core/state/StateStorage.js
var StateStorage = class {
  /**
   * Returns an object with all stored keys and their values as its properties
   * @member {Object}
   */
  get data() {
    return /* @__PURE__ */ Object.create(null);
  }
  /**
   * Returns the stored keys as set by {@link #function-setItem}
   * @member {String[]}
   */
  get keys() {
    return [];
  }
  /**
   * Remove all stored keys
   */
  clear() {
  }
  /**
   * Returns key value as set by {@link #function-setItem}
   * @param {String} key
   * @returns {*}
   */
  getItem(key) {
    return null;
  }
  /**
   * Removes the specified key
   * @param {String} key
   */
  removeItem(key) {
  }
  /**
   * Sets the specified key to the given value
   * @param {String} key
   * @param {*} value The item value
   */
  setItem(key, value) {
  }
};
StateStorage._$name = "StateStorage";

// ../Core/lib/Core/state/StateProvider.js
var Local = class extends StateStorage {
  constructor(stateProvider) {
    super();
    this.prefix = stateProvider.prefix || "";
  }
  get isLocal() {
    return true;
  }
  get data() {
    const data = empty(), keys = this.keys;
    for (const key of keys) {
      data[key] = this.getItem(key);
    }
    return data;
  }
  get keys() {
    return getKeys(this.prefix, this.prefix.length);
  }
  clear() {
    const keys = getKeys(this.prefix);
    for (const key of keys) {
      localStorage.removeItem(key);
    }
  }
  getItem(key) {
    const value = localStorage.getItem(this.prefix + key);
    return value === null ? value : JSON.parse(value);
  }
  removeItem(key) {
    return localStorage.removeItem(this.prefix + key);
  }
  setItem(key, value) {
    return localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }
};
var Memory = class extends StateStorage {
  constructor() {
    super();
    this.clear();
  }
  get isMemory() {
    return true;
  }
  get data() {
    return ObjectHelper.clone(this._data);
  }
  get keys() {
    return Object.keys(this._data);
  }
  clear() {
    this._data = empty();
  }
  getItem(key) {
    return key in this._data ? this._data[key] : null;
  }
  removeItem(key) {
    delete this._data[key];
  }
  setItem(key, value) {
    this._data[key] = value;
  }
};
var empty = () => /* @__PURE__ */ Object.create(null);
var getKeys = (prefix, pos = 0) => {
  const keys = [], count = localStorage.length;
  for (let key, i = 0; i < count; ++i) {
    key = localStorage.key(i);
    key.startsWith(prefix) && keys.push(key.slice(pos));
  }
  return keys;
};
var nullStorage = new StateStorage();
var storageTypes = {
  local: Local,
  memory: Memory
};
var StateProvider = class _StateProvider extends Base.mixin(Delayable_default, Events_default) {
  static get $name() {
    return "StateProvider";
  }
  static get configurable() {
    return {
      /**
       * The key prefix applied when using the `'local'` {@link #config-storage} type.
       * @config {String}
       * @default
       */
      prefix: "bryntum-state:",
      /**
       * Storage instance
       * @member {Core.state.StateStorage} storage
       */
      /**
       * One of the following storage types:
       *  - `local` : Stores data in the browser's `localStorage` using the {@link #config-prefix}.
       *  - `memory` : Stores data in the provider's memory.
       *
       * @config {'local'|'memory'|Core.state.StateStorage}
       * @default
       */
      storage: "local"
    };
  }
  static get delayable() {
    return {
      writeStatefuls: 50
    };
  }
  /**
   * The default {@link Core.mixin.State#config-stateProvider} for stateful objects.
   * @property {Core.state.StateProvider}
   */
  static get instance() {
    return this._instance;
  }
  static set instance(inst) {
    if (inst == null) {
      inst = nullProvider;
    } else {
      if (typeof inst === "string" || ObjectHelper.isClass(inst) || inst instanceof StateStorage) {
        inst = {
          storage: inst
        };
      }
      if (ObjectHelper.isObject(inst)) {
        inst = new _StateProvider(inst);
      }
    }
    this._instance = inst;
  }
  /**
   * Initializes the default `StateProvider` instance for the page. This method can be passed an instance or one of
   * the following type aliases:
   *
   *  - `'local'` : use `localStorage` to store application state (most common)
   *  - `'memory'` : holds application state in the `StateProvider` instance (used when state is saved to a server)
   *
   * Once the `StateProvider` is initialized, components that use {@link Core.mixin.State} and assign components a
   * {@link Core.mixin.State#config-stateId} will use this default provider to automatically save and restore their
   * state.
   *
   * @param {'local'|'memory'|Core.state.StateProvider} inst The state provider storage type ('local' or 'memory') or
   * the `StateProvider` instance.
   * @returns {Core.state.StateProvider}
   */
  static setup(inst) {
    this.instance = inst;
    return this.instance;
  }
  doDestroy() {
    self.writeStatefuls.flush();
    super.doDestroy();
  }
  /**
   * On read, this property returns all state data stored in the provider. On write, this property _adds_ all the
   * given values to the state provider's data. To replace the data, call {@link #function-clear} before assigning
   * this property. This is used to bulk populate this `StateProvider` with data for stateful components.
   * @member {Object}
   */
  get data() {
    return this.storage.data;
  }
  set data(data) {
    if (!data) {
      this.clear();
    } else {
      for (const key in data) {
        this.setValue(key, data[key]);
      }
    }
  }
  /**
   * Clears all state date
   * @returns {Core.state.StateProvider} this instance
   */
  clear() {
    this.storage.clear();
    return this;
  }
  changeStorage(storage) {
    if (storage == null) {
      storage = nullStorage;
    } else {
      if (typeof storage === "string") {
        if (!storageTypes[storage]) {
          throw new Error(`Invalid storage type "${storage}" (expected one of: "${Object.keys(storageTypes).join('", "')}")`);
        }
        storage = storageTypes[storage];
      }
      if (ObjectHelper.isClass(storage)) {
        storage = new storage(this);
      }
    }
    return storage;
  }
  /**
   * This method is called to schedule saving the given `stateful` object.
   * @param {Core.mixin.State} stateful The stateful object to save.
   * @param {Object} [options] An object of options that affect the state saving process.
   * @param {String} [options.id] The key for the saved state.
   * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
   * @internal
   */
  saveStateful(stateful, options) {
    (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);
    this.writeStatefuls();
  }
  /**
   * A delayable method that flushes pending stateful objects.
   * @private
   */
  writeStatefuls() {
    const me = this, { pendingSaves } = me, n = pendingSaves == null ? void 0 : pendingSaves.length, stateIds = [], saved = [];
    me.pendingSaves = null;
    if (n) {
      for (let options, stateful, stateId, i = 0; i < n; ++i) {
        [stateful, options] = pendingSaves[i];
        if (!stateful.isDestroying && stateful.isSaveStatePending) {
          stateId = stateful.saveState({
            ...options,
            immediate: true
          });
          if (stateId) {
            stateIds.push(stateId);
            saved.push(stateful);
          }
        }
      }
      if (stateIds.length) {
        me.trigger("save", {
          stateIds,
          saved
        });
      }
    }
  }
  /**
   * Returns the stored state given its `key`.
   * @param {String} key The identifier of the state to return.
   * @returns {Object}
   */
  getValue(key) {
    this.writeStatefuls.flush();
    return this.storage.getItem(key);
  }
  /**
   * Stores the given state `value` under the specified `key`.
   * @param {String} key The identifier of the state value.
   * @param {Object} value The state value to set.
   * @returns {Core.state.StateProvider} this instance
   */
  setValue(key, value) {
    const me = this, { storage } = me, was = me.getValue(key);
    if (value != null) {
      storage.setItem(key, value);
      me.trigger("set", { key, value, was });
    } else if (was !== null) {
      storage.removeItem(key);
      me.trigger("remove", { key, was });
    }
    return me;
  }
};
var nullProvider = new StateProvider({
  storage: nullStorage
});
StateProvider._instance = nullProvider;
StateProvider._$name = "StateProvider";

// ../Core/lib/Core/mixin/State.js
var primitiveRe = /boolean|number|string/;
var State_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    afterConstruct() {
      super.afterConstruct();
      this.stateProvider && this.loadState();
    }
    finalizeInit() {
      this.stateProvider && this.loadState();
      super.finalizeInit();
    }
    /**
     * Returns `true` if this instance implements the {@link Core.mixin.State} interface.
     * @property {Boolean}
     * @readonly
     * @advanced
     */
    get isStateful() {
      return true;
    }
    /**
     * Returns `true` if this instance is ready to participate in state activities.
     * @property {Boolean}
     * @readonly
     * @internal
     */
    get isStatefulActive() {
      return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;
    }
    // state
    /**
     * Gets or sets a component's state
     * @property {Object}
     * @typings {*}
     * @category State
     */
    get state() {
      return this._state = this.getState();
    }
    set state(state) {
      this._state = state;
      if (state) {
        this.applyState(state);
      }
    }
    // statefulEvents
    updateStatefulEvents(events) {
      var _a5;
      const me = this, listeners = {
        name: "statefulEvents",
        thisObj: me
      };
      me.detachListeners(listeners.name);
      if (events) {
        if (typeof events === "string") {
          events = StringHelper.split(events);
        } else if (!Array.isArray(events)) {
          events = ObjectHelper.getTruthyKeys(events);
        }
        if (events.length) {
          for (const event of events) {
            listeners[event] = "onStatefulEvent";
          }
          (_a5 = me.ion) == null ? void 0 : _a5.call(me, listeners);
        }
      }
    }
    // statefulId
    /**
     * Returns the state key to use for this instance. This will be either the {@link #config-stateId} or the
     * {@link Core.widget.Widget#config-id} (if explicitly specified and {@link #config-stateful} is not `false`).
     * @property {String}
     * @category State
     * @internal
     */
    get statefulId() {
      const me = this, { responsiveState } = me;
      let statefulId = me.stateId;
      if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {
        statefulId = me.id;
      }
      if (statefulId && responsiveState) {
        statefulId = `${statefulId}[${responsiveState}]`;
      }
      return statefulId;
    }
    // statefulness
    /**
     * Returns an object whose truthy keys are the config properties to include in this object's {@link #property-state}.
     * @property {Object}
     * @category State
     * @readonly
     * @private
     */
    get statefulness() {
      const { stateful } = this;
      return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;
    }
    // stateProvider
    get stateProvider() {
      var _a5;
      return (_a5 = this._stateProvider) != null ? _a5 : this._stateId && StateProvider.instance;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Methods
    /**
     * Applies the given `state` to this instance.
     *
     * This method is not called directly, but is called when the {@link #property-state} property is assigned a value.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to handle any
     * config properties that are part of the complex state. The default implementation of this method will only assign
     * those config properties listed in {@link #config-stateful} from the provided `state` object.
     *
     * @param {Object} state The state object to apply to this instance.
     * @category State
     * @advanced
     */
    applyState(state) {
      state = this.pruneState(state);
      if (state) {
        this.setConfig(state);
      }
    }
    /**
     * Returns this object's state information.
     *
     * This method is not called directly, but is called to return the value of the {@link #property-state} property.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to gather the
     * config properties that are part of the complex state. The default implementation of this method will only copy
     * those config properties listed in {@link #config-stateful} to the returned `state` object.
     *
     * @returns {Object}
     * @category State
     * @advanced
     */
    getState() {
      const me = this, {
        initialConfig,
        statefulness,
        isConstructing: defaultState
      } = me, { configs } = me.$meta, source = defaultState ? Object.setPrototypeOf(initialConfig, me.$meta.config) : me;
      let state = null, key, value;
      if (statefulness) {
        state = {};
        for (key in statefulness) {
          if (statefulness[key]) {
            value = source[key];
            if (value == null ? void 0 : value.isStateful) {
              value = value.state;
            } else if (!defaultState) {
              if (ObjectHelper.isDate(value)) {
                value = DateHelper.format(value, "YYYY-MM-DDTHH:mm:ssZ");
              }
              if (configs[key].equal(value, initialConfig == null ? void 0 : initialConfig[key]) || !primitiveRe.test(typeof value)) {
                continue;
              }
            }
            state[key] = value;
          }
        }
      }
      return state;
    }
    /**
     * Loads this object's state from its {@link #config-stateProvider} and applies it to its {@link #property-state}.
     *
     * This method only acts upon its first invocation for a given instance (unless `true` is passed for the `reload`
     * parameter). This allows for flexibility in the timing of that call during the early stages of the instances'
     * lifecycle. To reload the state after this time, manually assign the desired value to the {@link #property-state}
     * property or call this method and pass `reload` as `true`.
     *
     * This method is called automatically during construction when a {@link #config-stateId} or (in some cases) an
     * explicit {@link Core.widget.Widget#config-id} is provided.
     *
     * @param {String} [stateId] An overriding key to use instead of this object's {@link #config-stateId}.
     * @param {Boolean} [reload=false] Pass `true` to load the state even if previously loaded.
     * @category State
     */
    loadState(stateId, reload) {
      if (typeof stateId === "boolean") {
        reload = stateId;
        stateId = null;
      }
      const me = this, { statefulLoaded } = me;
      if (me.isStatefulActive && (reload || !statefulLoaded)) {
        const state = me.loadStatefulData(stateId || (stateId = me.statefulId));
        if (!statefulLoaded && stateId) {
          me.defaultState = me.state;
          me.statefulLoaded = true;
        }
        if (state) {
          me.state = state;
        }
      }
    }
    loadStatefulData(stateId) {
      var _a5;
      stateId = this.isStatefulActive ? stateId || this.statefulId : null;
      return stateId && ((_a5 = this.stateProvider) == null ? void 0 : _a5.getValue(stateId));
    }
    resetDefaultState() {
      if (this.defaultState) {
        this.state = this.defaultState;
      }
    }
    resumeStateful(full = false) {
      this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);
    }
    /**
     * Saves this object's state to its {@link #config-stateProvider}.
     *
     * When a {@link #config-stateId} or (in some cases) an explicit {@link Core.widget.Widget#config-id} is provided,
     * this method will be called automatically any time a config property listed in {@link #config-stateful} changes or
     * when a {@link #config-statefulEvents stateful event} is fired.
     *
     * Derived classes are responsible for calling this method whenever the persistent {@link #property-state} of the
     * object changes.
     *
     * @param {Object|String} [options] Options that affect the state saving process or, if a string, the state `id`.
     * @param {String} [options.id] The state id for the saved state (overrides {@link #config-stateId}).
     * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
     * @category State
     */
    saveState(options) {
      if (typeof options === "string") {
        options = {
          id: options
        };
      } else {
        options = options || {};
      }
      const me = this, { stateProvider } = me, statefulId = options.id || me.isStatefulActive && me.statefulId;
      if (statefulId && stateProvider) {
        if (options.immediate) {
          me.isSaveStatePending = false;
          stateProvider.setValue(statefulId, me.state);
        } else if (!me.isSaveStatePending) {
          me.isSaveStatePending = true;
          stateProvider.saveStateful(me, options);
        }
        return statefulId;
      }
    }
    suspendStateful() {
      ++this.statefulSuspended;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Private / Internal
    onConfigChange({ name, value, was, config }) {
      super.onConfigChange({ name, value, was, config });
      if (!this.isConstructing && this.isStatefulActive && this.statefulId) {
        const { stateful } = this;
        if (Array.isArray(stateful) ? stateful.includes(name) : stateful == null ? void 0 : stateful[name]) {
          this.saveState();
        }
      }
    }
    onStatefulEvent() {
      if (!this.isConstructing) {
        this.saveState();
      }
    }
    /**
     * Returns an object that copies the {@link #config-stateful} config properties from the provided `state` object.
     *
     * @param {Object} state A state object from which to copy stateful configs.
     * @returns {Object}
     * @category State
     * @private
     */
    pruneState(state) {
      const { statefulness } = this;
      if (statefulness) {
        const pruned = {};
        for (const key in state) {
          if (statefulness[key]) {
            pruned[key] = state[key];
          }
        }
        state = pruned;
      }
      return state;
    }
    //---------------------------------------------------------------------------------------------------------------
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {
    }
  }, __publicField(_a4, "$name", "State"), __publicField(_a4, "configurable", {
    /**
     * This value can be one of the following:
     *
     * - `false` to not use an explicitly assigned {@link Core.widget.Widget#config-id} as the component's
     * {@link #config-stateId} (this is only necessary when there is a {@link #config-stateProvider}).
     * - An array of strings naming the config properties to save in the component's {@link #property-state}
     * object.
     * - An object whose truthy keys are the config properties to save in the component's {@link #property-state}
     * object.
     *
     * These last two uses of the `stateful` config property do not apply to components that have a complex
     * state, as described in the {@link Core.mixin.State State mixin documentation}.
     *
     * This config property is typically set by derived classes to a value including any config property that
     * the user can affect via the user interface. For example, the {@link Core.widget.Panel#config-collapsed}
     * config property is listed for a {@link Core.widget.Panel} since the user can toggle this config property
     * using the {@link Core.widget.panel.PanelCollapser#config-tool collapse tool}.
     *
     * @config {Boolean|Object|String[]}
     * @category State
     */
    stateful: {
      value: null,
      $config: {
        merge: "classList"
      }
    },
    /**
     * The events that, when fired by this component, should trigger it to save its state by calling
     * {@link #function-saveState}.
     *
     * ```javascript
     *  class MyStatefulComponent extends Base.mixin(State) {
     *      static get configurable() {
     *          return {
     *              statefulEvents : [ 'change', 'resize' ]
     *          };
     *      }
     *  }
     * ```
     * In the above example, {@link #function-saveState} will be called any time an instance of this class
     * fires the `change` or `resize` event.
     *
     * This config is typically set by derived classes as a way to ensure {@link #function-saveState} is called
     * whenever their persistent state changes.
     *
     * @config {Object|String[]}
     * @category State
     * @default
     */
    statefulEvents: {
      $config: {
        merge: "classList"
      },
      value: ["stateChange"]
    },
    /**
     * The key to use when saving this object's state in the {@link #config-stateProvider}. If this config is
     * not assigned, and {@link #config-stateful} is not set to `false`, the {@link Core.widget.Widget#config-id}
     * (if explicitly specified) will be used as the `stateId`.
     *
     * If neither of these is given, the {@link #function-loadState} and {@link #function-saveState} methods
     * will need to be called directly to make use of the `stateProvider`.
     *
     * For single page applications (SPA's), or multi-page applications (MPA's) that have common, stateful
     * components on multiple pages, the `stateId` should be unique across all stateful components (similar to DOM
     * element id's). MPA's that want each page to be isolated can more easily achieve that isolation using the
     * {@link Core.state.StateProvider#config-prefix}.
     *
     * @config {String}
     * @category State
     */
    stateId: null,
    /**
     * The `StateProvider` to use to save and restore this object's {@link #property-state}. By default, `state`
     * will be saved using the {@link Core.state.StateProvider#property-instance-static default state provider}.
     *
     * This config is useful for multi-page applications that have a set of common components that want to share
     * state across pages, as well as other components that want their state to be isolated. One of these groups
     * of stateful components could be assigned an explicit `stateProvider` while the other group could use the
     * default state provider.
     *
     * @config {Core.state.StateProvider}
     * @category State
     */
    stateProvider: null
  }), __publicField(_a4, "prototypeProperties", {
    statefulLoaded: false,
    statefulSuspended: 0
  }), _a4;
};

// ../Core/lib/Core/mixin/Identifiable.js
var idCounts = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var idTypes = {
  string: 1,
  number: 1
};
var Identifiable_default = (Target) => class Identifiable extends (Target || Base) {
  static get $name() {
    return "Identifiable";
  }
  static get declarable() {
    return [
      "identifiable"
    ];
  }
  static get configurable() {
    return {
      /**
       * The id of this object.  If not specified one will be generated. Also used for lookups through the
       * static `getById` of the class which mixes this in. An example being {@link Core.widget.Widget}.
       *
       * For a {@link Core.widget.Widget Widget}, this is assigned as the `id` of the DOM
       * {@link Core.widget.Widget#config-element element} and must be unique across all elements
       * in the page's `document`.
       * @config {String}
       * @category Common
       */
      id: ""
    };
  }
  static setupIdentifiable(cls, meta) {
    const { identifiable } = cls;
    identifiable.idMap = /* @__PURE__ */ Object.create(null);
    Reflect.defineProperty(cls, "identifiable", {
      get() {
        return identifiable;
      }
    });
  }
  doDestroy() {
    this.constructor.unregisterInstance(this);
    super.doDestroy();
  }
  changeId(id) {
    return (this.hasGeneratedId = !id) ? this.generateAutoId() : id;
  }
  updateId(id, oldId) {
    const me = this, C = me.constructor;
    oldId && C.unregisterInstance(me, oldId);
    if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {
      C.registerInstance(me, id);
    }
  }
  /**
   * This method generates an id for this instance.
   * @returns {String}
   * @internal
   */
  generateAutoId() {
    return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);
  }
  static get all() {
    return Object.values(this.identifiable.idMap);
  }
  /**
   * Generate a new id, using an internal counter and a prefix.
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);
  }
  static registerInstance(instance, instanceId = instance.id) {
    const { idMap } = this.identifiable;
    if (instanceId in idMap && !this.disableThrow) {
      throw new Error("Id " + instanceId + " already in use");
    }
    idMap[instanceId] = instance;
  }
  /**
   * Unregister Identifiable instance, normally done on destruction
   * @param {Object} instance Object to unregister
   * @param {String} id The id of the instance to unregister.
   */
  static unregisterInstance(instance, id = instance.id) {
    const { idMap } = this.identifiable;
    if (idTypes[typeof instance]) {
      delete idMap[instance];
    } else if (idMap[id] === instance) {
      delete idMap[id];
    }
  }
  static getById(id) {
    const idMap = this.identifiable.idMap;
    if (idMap) {
      return idMap[id];
    }
  }
  static get registeredInstances() {
    const idMap = this.identifiable.idMap;
    return idMap ? Object.values(idMap) : [];
  }
};

// ../Core/lib/Core/data/stm/mixin/ModelStm.js
var STM_PROP = Symbol("STM_PROP");
var unrecordedFields = {
  // This field's value is a by product of node insertion and must not be recorded here.
  // It's the node insertion operation which is recorded by STM.
  parentIndex: 1,
  // Ordered parent index is similar to parentIndex - it is recalculated on node insertion. No need to track it
  // https://github.com/bryntum/support/issues/8257
  orderedParentIndex: 1
};
var ModelStm_default = (Target) => class ModelStm extends (Target || Base) {
  static get $name() {
    return "ModelStm";
  }
  static get defaultConfig() {
    return {
      stm: null
    };
  }
  joinStore(store) {
    if (!this.stm) {
      this.stm = store.stm;
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _a4;
    if (this.stm === store.stm) {
      this.stm = null;
    }
    (_a4 = super.unjoinStore) == null ? void 0 : _a4.call(this, store, isReplacing);
  }
  /**
   * Reference to STM manager, if used
   * @member {Core.data.stm.StateTrackingManager}
   * @category Misc
   */
  get stm() {
    return this[STM_PROP];
  }
  set stm(stm) {
    this[STM_PROP] = stm;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123.
  // Triggers before setting the value.
  beforeChronoFieldSet(fieldName, value) {
    var _a4;
    const me = this;
    if (!me.inSetting && ((_a4 = me.stm) == null ? void 0 : _a4.enabled) && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {
      if (me.getFieldDefinition(fieldName)) {
        return { [fieldName]: { value, oldValue: me[fieldName] } };
      }
    }
    return null;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123
  // Triggers after setting the value.
  afterChronoFieldSet(fieldName, value, wasSet) {
    wasSet && this.afterSet(fieldName, value, false, false, wasSet, true);
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    const store = this.firstStore;
    return !(this.constructor.nonPersistableFields[fieldName] || oldValue == null && newValue == null || oldValue === newValue || oldValue instanceof Date && newValue instanceof Date && oldValue.getTime() === newValue.getTime() || fieldName === "id" || fieldName === "$PhantomId" || fieldName === "parentId" && store && store.oldIdMap[oldValue] === store.getById(newValue));
  }
  /**
   * Overridden to store initial data of the changed fields and to notify STM
   * manager about the change action if anything has been changed in result.
   *
   * The method is called from within {@link Core/data/Model#function-set} method.
   *
   * @private
   */
  afterSet(field, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet) {
    const { stm } = this, nonPersistableFields = this.constructor.nonPersistableFields;
    if ((stm == null ? void 0 : stm.isBase) && stm.enabled && !unrecordedFields[field] && !nonPersistableFields[field]) {
      if (wasSet) {
        let shouldRecord;
        const [newData, oldData] = Object.keys(wasSet).reduce(
          (data, fieldName) => {
            const { value: value2, oldValue } = wasSet[fieldName];
            if (this.shouldRecordFieldChange(fieldName, oldValue, value2)) {
              shouldRecord = true;
              data[0][fieldName] = value2;
              data[1][fieldName] = oldValue;
            }
            return data;
          },
          [{}, {}]
        );
        if (shouldRecord) {
          stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);
        }
      }
    }
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to obtain inserted
   * records initial parents and parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterInsertChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeInsertChild(childRecords) {
    var _a4;
    const preResult = ((_a4 = super.beforeInsertChild) == null ? void 0 : _a4.call(this, childRecords)) || [], { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          if (childRecord.root === this.root) {
            result.set(childRecord, {
              parent: childRecord.parent,
              index: childRecord.parent ? childRecord.parentIndex : void 0
            });
          }
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children insertion. Provides it with all necessary context information collected
   * in {@link #function-beforeInsertChild} required to undo/redo the action.
   *
   * @private
   */
  afterInsertChild(index, childRecords, beforeResult, inserted, orderedBeforeNode) {
    var _a4;
    const { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      const context = beforeResult.pop();
      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context, orderedBeforeNode);
      }
    }
    (_a4 = super.afterInsertChild) == null ? void 0 : _a4.call(this, index, childRecords, beforeResult, inserted);
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to obtain removed
   * records initial parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @param {Boolean} isMove
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterRemoveChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [], { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          result.set(childRecord, { parentIndex: childRecord.parentIndex, orderedParentIndex: childRecord.orderedParentIndex });
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children removing. Provides it with all necessary context information collected
   * in {@link #function-beforeRemoveChild} required to undo/redo the action.
   *
   * @private
   */
  afterRemoveChild(childRecords, beforeResult, isMove) {
    var _a4;
    const { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      const context = beforeResult.pop();
      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }
    (_a4 = super.afterRemoveChild) == null ? void 0 : _a4.call(this, childRecords, beforeResult, isMove);
  }
};

// ../Core/lib/Core/data/mixin/TreeNode.js
var defaultTraverseOptions = {
  includeFilteredOutRecords: false
};
var fixTraverseOptions = (options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options
    };
  }
  return options || defaultTraverseOptions;
};
var TreeNode_default = (Target) => class TreeNode extends (Target || Base) {
  static get $name() {
    return "TreeNode";
  }
  /**
   * This static configuration option allows you to control whether an empty parent task should be converted into a
   * leaf. Enable/disable it for a whole class:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = false;
   * ```
   *
   * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object
   * with the following Boolean properties to customize the behaviour:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = {
   *     onLoad   : false,
   *     onRemove : true
   * }
   * ```
   *
   * @member {Boolean|{ onLoad : Boolean, onRemove : Boolean }} convertEmptyParentToLeaf
   * @property {Boolean} onLoad Apply the transformation on load to any parents without children (`children : []`)
   * @property {Boolean} onRemove Apply the transformation when all children have been removed from a parent
   * @default false
   * @static
   * @category Parent & children
   * */
  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }
    this._convertEmptyParentToLeaf = value;
  }
  constructor(...args) {
    super(...args);
    if (this.children) {
      this.orderedChildren = this.orderedChildren || [];
    }
  }
  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || { onLoad: false, onRemove: false };
  }
  /**
   * This is a read-only property providing access to the parent node.
   * @member {Core.data.Model} parent
   * @readonly
   * @category Parent & children
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which record id is the parent of the record.
   * @readonly
   * @field {String|Number|null} parentId
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's children array.
   * This index is set on load and gets updated automatically after row reordering, sorting, etc.
   * To save the order, need to persist the field on the server and when data is fetched to be loaded,
   * need to sort by this field.
   * @readonly
   * @field {Number} parentIndex
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's ordered children array.
   * This index is set on load and gets updated on reordering nodes in tree. Sorting and filtering
   * have no effect on it.
   * @readonly
   * @field {Number} orderedParentIndex
   * @category Tree
   */
  ingestChildren(childRecord, stores = this.stores) {
    const { inProcessChildren, constructor: MyClass } = this, store = stores == null ? void 0 : stores[0];
    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }
      return [];
    }
    if (childRecord) {
      childRecord = ArrayHelper.asArray(childRecord);
      const len = childRecord.length, result = [];
      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child.isModel ? child : store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true);
        child = store ? store.processRecord(child) : child;
        result.push(child);
      }
      if (this.children === true && store) {
        const sorter = store.createSorterFn(store.sorters);
        result.sort(sorter);
      }
      return result;
    }
  }
  /**
   * Child nodes. To allow loading children on demand, specify `children : true` in your data. Omit the field for leaf
   * tasks.
   *
   * Note, if the tree store loads data from a remote origin, make sure {@link Core/data/AjaxStore#config-readUrl}
   * is specified, and optionally {@link Core/data/AjaxStore#config-parentIdParamName} is set, otherwise
   * {@link Core/data/Store#function-loadChildren} has to be implemented.
   * @field {Boolean|Object[]|Core.data.Model[]} children
   * @readonly
   * @category Parent & children
   */
  /**
   * Array of tree nodes without any filter applied. On first filter, will take order from sorted `children`, but
   * is not thereafter kept in sorted order, so order should not be relied upon.
   * @member {Core.data.Model[]|null} unfilteredChildren
   * @category Parent & children
   * @private
   */
  /**
   * Array of children unaffected by sorting and filtering, keeps original tree structure
   * @member {Core.data.Model[]|null} orderedChildren
   * @category Parent & children
   * @private
   */
  /**
   * Called during creation to also turn any children into Models joined to the same stores as this model
   * @internal
   * @category Parent & children
   */
  processChildren(stores = this.stores) {
    const me = this, { meta } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);
    if (children) {
      const { convertEmptyParentToLeaf } = me.constructor, shouldConvert = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;
      if (shouldConvert ? children.length : Array.isArray(children)) {
        meta.isLeaf = false;
        if (me.children === true) {
          me.children = [];
        } else if (children.length === 0) {
          me.children = children;
          return;
        }
        me.insertChild(children);
      } else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      } else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }
    me.inProcessChildren = false;
  }
  /**
   * This method returns `true` if this record has all expanded ancestors and is therefore
   * eligible for inclusion in a UI.
   * @param {Core.data.Store} [store] Optional store, defaults to nodes first store
   * @readonly
   * @category Parent & children
   * @returns {Boolean}
   */
  ancestorsExpanded(store = this.firstStore) {
    const { parent } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }
  /**
   * Used by stores to assess the record's collapsed/expanded state in that store.
   * @param {Core.data.Store} store
   * @category Parent & children
   * @returns {Boolean}
   */
  isExpanded(store = this.firstStore) {
    const mapMeta = this.instanceMeta(store.id);
    if (!Object.prototype.hasOwnProperty.call(mapMeta, "collapsed")) {
      mapMeta.collapsed = !this.expanded;
    }
    return !mapMeta.collapsed;
  }
  // A read-only property. It provides the initial state upon load
  // The UI's expanded/collapsed state is in the store's meta map.
  get expanded() {
    return this.data.expanded;
  }
  /**
   * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at
   * level 1 and so on.
   * @property {Number}
   * @readonly
   * @category Parent & children
   */
  get childLevel() {
    let node = this, ret = -1;
    while (node && !node.isRoot) {
      ++ret;
      node = node.parent;
    }
    return ret;
  }
  /**
   * Is a leaf node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }
  /**
   * Returns `true` if this node is the root of the tree
   * @member {Boolean} isRoot
   * @readonly
   * @category Parent & children
   */
  /**
   * Is a parent node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isParent() {
    return !this.isLeaf;
  }
  /**
   * Returns true for parent nodes with children loaded (there might still be no children)
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }
  /**
   * Count all children (including sub-children) for a node (in its `firstStore´)
   * @member {Number}
   * @category Parent & children
   */
  get descendantCount() {
    return this.getDescendantCount();
  }
  /**
   * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)
   * @member {Number}
   * @category Parent & children
   */
  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }
  /**
   * Count visible (expanded)/all children for this node, optionally specifying for which store.
   * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.
   * @param {Core.data.Store} [store] A Store to which this node belongs
   * @returns {Number}
   * @category Parent & children
   */
  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const { children } = this;
    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }
    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }
  /**
   * Retrieve all children, not including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @category Parent & children
   */
  get allChildren() {
    return this.getAllChildren(false);
  }
  /**
   * Retrieve all children, including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @private
   * @category Parent & children
   */
  get allUnfilteredChildren() {
    return this.getAllChildren(true);
  }
  getAllChildren(unfiltered = false) {
    const { [unfiltered ? "unfilteredChildren" : "children"]: children } = this;
    if (!children || children === true) {
      return [];
    }
    return children.reduce((all, child) => {
      all.push(child);
      all.push.apply(all, unfiltered ? child.allUnfilteredChildren : child.allChildren);
      return all;
    }, []);
  }
  /**
   * Get the first child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get firstChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[0] || null;
  }
  /**
   * Get the last child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get lastChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[children.length - 1] || null;
  }
  /**
   * Get the previous sibling of this node
   * @member {Core.data.Model} previousSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Get the next sibling of this node
   * @member {Core.data.Model} nextSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Returns count of all preceding sibling nodes (including their children).
   * @property {Number}
   * @category Parent & children
   */
  get previousSiblingsTotalCount() {
    let task = this.previousSibling, count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  // This pair of accessors should never return undefined. This is required by `add task below` logic, which is trying
  // to get a task from the ordered tree, before which insert should happen. In the `addToChildren` logic there is a
  // distinction between `null` and `undefined`. `undefined` falls back to reference task in a visual tree, `null`
  // is meant to point out we should insert to the end of the ordered children list. This is really required for
  // `nextOrderedSibling`, another accessor is modified to keep behavior consistent.
  // https://github.com/bryntum/support/issues/7323
  get previousOrderedSibling() {
    var _a4, _b;
    return (_b = (_a4 = this.parent) == null ? void 0 : _a4.orderedChildren[this.orderedParentIndex - 1]) != null ? _b : null;
  }
  get nextOrderedSibling() {
    var _a4, _b;
    return (_b = (_a4 = this.parent) == null ? void 0 : _a4.orderedChildren[this.orderedParentIndex + 1]) != null ? _b : null;
  }
  get root() {
    var _a4;
    return ((_a4 = this.parent) == null ? void 0 : _a4.root) || this;
  }
  /**
   * Reading this property returns the id of the parent node, if this record is a child of a node.
   *
   * Setting this property appends this record to the record with the passed id **in the same store that this record
   * is already in**.
   *
   * Note that setting this property is **only valid if this record is already part of a tree store**.
   *
   * This is not intended for general use. This is for when a server responds to a record mutation and the server
   * decides to move a record to a new parent. If a `parentId` property is passed in the response data for a record,
   * that record will be moved.
   *
   * @property {Number|String|null}
   * @category Parent & children
   */
  get parentId() {
    return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;
  }
  set parentId(parentId) {
    const me = this, { parent } = me, newParent = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);
    if (!(newParent === parent || !parent && !newParent)) {
      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }
  static set parentIdField(parentIdField) {
    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function(parentId) {
        this.parentId = parentId;
      },
      get: function() {
        return this.parentId;
      }
    });
  }
  static get parentIdField() {
    return this._parentIdField || "parentId";
  }
  getChildren(options) {
    let result;
    if (options.includeFilteredOutRecords) {
      result = this.unfilteredChildren || this.children;
    } else if (options.useOrderedTree) {
      result = this.orderedChildren;
    } else {
      result = this.children;
    }
    return result;
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on a target node **before** iterating the child nodes.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to ignore self
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Parent & children
   */
  traverse(fn, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    if (!skipSelf) {
      fn.call(me, me);
    }
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on child nodes of a target **before** calling it on the node.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   */
  traverseBefore(fn, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
    if (!skipSelf) {
      fn.call(me, me);
    }
  }
  /**
   * Traverses child nodes recursively while fn returns true
   * @param {Function} fn
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   * @returns {Boolean}
   */
  traverseWhile(fn, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this;
    let goOn = skipSelf || fn.call(me, me) !== false;
    if (goOn) {
      const children = me.getChildren(options);
      if (children == null ? void 0 : children.length) {
        goOn = children.every((child) => child.traverseWhile(fn, false, options));
      }
    }
    return goOn;
  }
  /**
   * Bubbles up from this node, calling the specified function with each node.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   */
  bubble(fn, skipSelf = false) {
    let me = this;
    if (!skipSelf) {
      fn.call(me, me);
    }
    while (me.parent) {
      me = me.parent;
      fn.call(me, me);
    }
  }
  /**
   * Bubbles up from this node, calling the specified function with each node,
   * while the function returns true.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  bubbleWhile(fn, skipSelf = false) {
    let me = this, goOn = true;
    if (!skipSelf) {
      goOn = fn.call(me, me);
    }
    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn.call(me, me);
    }
    return goOn;
  }
  /**
   * Checks if this model contains another model as one of it's descendants
   *
   * @param {Core.data.Model|String|Number} childOrId child node or id
   * @param {Boolean} [skipSelf=false] True to ignore self in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  contains(childOrId, skipSelf = false) {
    if (childOrId && typeof childOrId === "object") {
      childOrId = childOrId.id;
    }
    return !this.traverseWhile((node) => node.id != childOrId, skipSelf);
  }
  getTopParent(all) {
    let result;
    if (all) {
      result = [];
      this.bubbleWhile((t) => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile((t) => {
        result = t;
        return t.parent && !t.parent.isRoot;
      });
    }
    return result;
  }
  /**
   * Append a child record(s) to any current children.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to append
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  appendChild(childRecord, silent = false, options = {}) {
    return this.insertChild(childRecord, null, silent, options);
  }
  /**
   * Insert a child record(s) before an existing child record.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to insert
   * @param {Core.data.Model} [before] Optional record to insert before, leave out to append to the end
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  insertChild(childRecord, before = null, silent = false, options = {}) {
    var _a4, _b, _c, _d, _e, _f, _g, _h;
    const me = this, returnArray = Array.isArray(childRecord);
    childRecord = ArrayHelper.asArray(childRecord);
    if (typeof before === "number") {
      before = (_b = (_a4 = me.children) == null ? void 0 : _a4[before]) != null ? _b : null;
    }
    if (!silent && ((_c = me.stores) == null ? void 0 : _c.every((s) => s.trigger("beforeAdd", {
      records: childRecord,
      parent: me
    }) !== false)) === false) {
      return null;
    }
    childRecord = me.ingestChildren(childRecord);
    const index = (_f = (_e = before == null ? void 0 : before.parentIndex) != null ? _e : (_d = me.children) == null ? void 0 : _d.length) != null ? _f : 0, preResult = (_g = me.beforeInsertChild) == null ? void 0 : _g.call(me, childRecord), inserted = me.internalAppendInsert(childRecord, before, silent, options);
    if (inserted.length) {
      me.convertToParent(silent);
    }
    (_h = me.afterInsertChild) == null ? void 0 : _h.call(me, index, childRecord, preResult, inserted, options.orderedBeforeNode);
    return returnArray || !inserted ? inserted : inserted[0];
  }
  /**
   * Converts a leaf node to a parent node, assigning an empty array as its children
   * @param {Boolean} [silent] Pass `true` to not trigger any event
   * @category Parent & children
   */
  convertToParent(silent = false) {
    const me = this, wasLeaf = me.isLeaf;
    me.meta.isLeaf = false;
    if (!me.children) {
      me.children = [];
    }
    if (wasLeaf && !me.root.isLoading && !silent) {
      me.signalNodeChanged({
        isLeaf: {
          value: false,
          oldValue: true
        }
      });
    }
  }
  signalNodeChanged(changes, stores = this.stores) {
    stores == null ? void 0 : stores.forEach((s) => {
      s.trigger("update", { record: this, records: [this], changes });
      s.trigger("change", { action: "update", record: this, records: [this], changes });
    });
  }
  tryInsertChild() {
    return this.insertChild(...arguments);
  }
  internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {
    const me = this, { stores, root, children } = me, { firstStore: rootStore } = root, { parentIdField } = me.constructor, parentId = me.id;
    let isNoop, start, i, newRecordsCloned, oldParentIndices, isMove;
    if (!root.isLoading && rootStore) {
      isMove = {};
      oldParentIndices = [];
      for (i = 0; i < recordsToInsert.length; i++) {
        const newRecord = recordsToInsert[i];
        isMove[newRecord.id] = newRecord.root === root;
        oldParentIndices[i] = newRecord.parentIndex;
      }
    }
    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }
    if (children) {
      const insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;
      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }
    if (isNoop) {
      return recordsToInsert;
    }
    for (i = 0; i < recordsToInsert.length; i++) {
      const newRecord = recordsToInsert[i], oldParent = newRecord.parent;
      if (rootStore && !root.isLoading) {
        newRecord.traverse((r) => {
          if (r.root === root) {
            isMove[r.id] = true;
          }
        });
      }
      const isCurrentRecordMoved = Boolean(isMove == null ? void 0 : isMove[newRecord.id]), movedWithinParent = oldParent === me && isCurrentRecordMoved;
      if ((oldParent == null ? void 0 : oldParent.removeChild(newRecord, isCurrentRecordMoved, silent, {
        isInserting: true,
        // If we're reordering siblings we should skip index update. Index will be recalculated
        // when we insert node below.
        skipIndexUpdate: movedWithinParent,
        ...options
      })) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }
        recordsToInsert.splice(i--, 1);
      } else {
        newRecord.parent = me;
        newRecord.data[parentIdField] = parentId;
        const { meta } = newRecord;
        if (meta.modified[parentIdField] === parentId && !oldParent) {
          meta.oldParentId = parentId;
        }
        if (oldParent) {
          meta.oldParentId = oldParent.id;
        }
      }
    }
    if (recordsToInsert.length) {
      if (!Array.isArray(children)) {
        me.children = [];
      }
      if (!Array.isArray(me.orderedChildren)) {
        me.orderedChildren = [];
      }
      const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);
      stores == null ? void 0 : stores.forEach((store) => {
        if (!store.isChained) {
          recordsToInsert.forEach(
            (record) => (
              // Initialize context for newly added records
              record.joinStore(store)
            )
          );
          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
          recordsToInsert.forEach((record, i2) => {
            if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {
              const toSet = {
                [parentIdField]: parentId,
                [me.getDataSource("parentIndex")]: record.parentIndex
              }, wasSet = {}, { modified, oldParentId } = record.meta, oldParentIndex = oldParentIndices[i2];
              delete record.meta.oldParentId;
              if (me.id !== oldParentId) {
                wasSet[parentIdField] = {
                  value: parentId,
                  oldValue: oldParentId
                };
              }
              if (record.parentIndex !== oldParentIndex) {
                wasSet.parentIndex = {
                  value: record.parentIndex,
                  oldValue: oldParentIndex
                };
              }
              if (modified[parentIdField] === me.id) {
                Reflect.deleteProperty(modified, parentIdField);
              } else if (!(parentIdField in modified)) {
                modified[parentIdField] = oldParentId;
              }
              if (isMove[record.id]) {
                const oldParent = store.getById(oldParentId);
                if (oldParent.isLeaf && !silent) {
                  oldParent.signalNodeChanged({
                    isLeaf: {
                      value: true,
                      oldValue: false
                    }
                  }, [store]);
                }
              }
              record.afterChange(toSet, wasSet);
            }
            record.traverse((node) => {
              if (!node.ignoreBag && !node.isLinked) {
                store.updateModifiedBagForRecord(node);
              }
            });
          });
        }
      });
    }
    return recordsToInsert;
  }
  /**
   * Remove a child record. Only direct children of this node can be removed, others are ignored.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The record(s) to remove.
   * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.
   * @param {Boolean} [silent] Pass `true` to not trigger events during remove.
   * @privateparam {Object} [options]
   * @privateparam {Object} [options.isInserting] `true` is passed when removal is part of record inserting (acted on by
   * ModelLink)
   * @returns {Core.data.Model[]} All records (including nested children) removed
   * @category Parent & children
   */
  removeChild(childRecords, isMove = false, silent = false, options = {}) {
    var _a4, _b;
    const me = this, allRemovedRecords = [], wasLeaf = me.isLeaf, {
      children,
      stores
    } = me;
    childRecords = ArrayHelper.asArray(childRecords);
    childRecords = childRecords.filter((r) => r.parent === me);
    if (!silent && stores) {
      for (const store of stores) {
        if (!store.isChained && store.trigger("beforeRemove", {
          parent: me,
          records: childRecords,
          isMove
        }) === false) {
          return false;
        }
      }
    }
    const preResult = (_a4 = me.beforeRemoveChild) == null ? void 0 : _a4.call(me, childRecords, isMove);
    for (const childRecord of childRecords) {
      const { parentIdField } = childRecord.constructor, { modified } = childRecord.meta, oldParentId = childRecord.parent ? childRecord.parent.id : null;
      if (!(parentIdField in modified) && !childRecord.isLinked) {
        modified[parentIdField] = oldParentId;
      }
      const index = me.removeFromChildren(childRecord, options);
      stores == null ? void 0 : stores.forEach((store) => {
        if (!store.isChained) {
          const { isRemoving } = store;
          store.isRemoving = true;
          allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, { isMove, silent }));
          store.isRemoving = isRemoving;
        }
      });
      if (!isMove) {
        childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        childRecord.data[parentIdField] = null;
      }
    }
    if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }
    if (me.isLeaf !== wasLeaf && !silent && !isMove) {
      me.signalNodeChanged({
        isLeaf: {
          value: true,
          oldValue: false
        }
      });
    }
    (_b = me.afterRemoveChild) == null ? void 0 : _b.call(me, childRecords, preResult, isMove);
    return allRemovedRecords;
  }
  clearParentId() {
    const me = this;
    Reflect.deleteProperty(me.data, me.parentIdField);
    Reflect.deleteProperty(me.originalData, me.parentIdField);
    if (me.meta.modified) {
      Reflect.deleteProperty(me.meta.modified, me.parentIdField);
    }
  }
  /**
   * Replaces all child nodes with the new node set.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The new child record set.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  replaceChildren(childRecords) {
    this.clearChildren();
    this.data[this.constructor.childrenField] = childRecords;
    this.processChildren();
    return this.children;
  }
  /**
   * Removes all child nodes from this node.
   * @param {Boolean} [silent=false] Pass `true` to not fire Store events during the remove.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  clearChildren(silent = false) {
    const me = this, { stores } = me, children = me.unfilteredChildren || me.children;
    me.children = [];
    me.orderedChildren = [];
    if (children && children !== true) {
      stores.forEach((store) => {
        if (!store.isChained) {
          store.onNodeRemoveChild(me, children, 0, { unfiltered: true, silent });
        }
      });
      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
    const { convertEmptyParentToLeaf } = me.constructor;
    if (convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onRemove) {
      me.meta.isLeaf = true;
    }
  }
  /**
   * Removes all records from the rootNode
   * @private
   */
  clear() {
    var _a4;
    const me = this, { stores } = me, children = (_a4 = me.unfilteredChildren || me.children) == null ? void 0 : _a4.slice();
    if (!me.isRoot || !children) {
      return;
    }
    for (const store of stores) {
      if (!store.isChained) {
        if (store.trigger("beforeRemove", {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }
    me.children.length = me.orderedChildren.length = 0;
    if (me.unfilteredChildren) {
      me.unfilteredChildren.length = 0;
    }
    stores.forEach((store) => {
      children.forEach((child) => {
        if (child.stores.includes(store)) {
          child.unjoinStore(store);
        }
        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger("removeAll");
      store.trigger("change", { action: "removeall" });
    });
  }
  updateChildrenIndices(children, indexName, silent = false) {
    let previousSibling = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i], oldValue = child[indexName];
      if (indexName === "parentIndex" || indexName === "orderedParentIndex") {
        if (oldValue === void 0 || silent) {
          child.setData(indexName, i);
        } else if (oldValue !== i) {
          child.set(indexName, i, true);
        }
      } else {
        child[indexName] = i;
      }
      if (indexName === "parentIndex") {
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  }
  addToChildren(beforeRecord, newRecords, options = {}) {
    var _a4;
    const me = this, configs = [
      [me.children, "parentIndex", beforeRecord],
      [me.unfilteredChildren, "unfilteredIndex", beforeRecord],
      [
        me.orderedChildren,
        "orderedParentIndex",
        // Distinguish null and undefined here. `null` means add to the end of the ordered tree
        (options == null ? void 0 : options.orderedBeforeNode) === void 0 ? (options == null ? void 0 : options.orderedParentIndex) !== void 0 ? me.orderedChildren[options == null ? void 0 : options.orderedParentIndex] : beforeRecord : options == null ? void 0 : options.orderedBeforeNode
      ]
    ];
    for (const config of configs) {
      const [children, indexName, beforeRecord2] = config;
      if (children) {
        let index;
        if (beforeRecord2) {
          index = children.indexOf(beforeRecord2);
          if (index === -1) {
            index = children.length;
          }
        } else {
          index = children.length;
        }
        config.push(index);
        children.splice(index, 0, ...newRecords);
        if (!((options == null ? void 0 : options.skipIndexUpdate) || ((_a4 = options == null ? void 0 : options[indexName]) == null ? void 0 : _a4.skip))) {
          me.updateChildrenIndices(children, indexName);
        }
      }
    }
    return configs[0][3];
  }
  removeFromChildren(childRecord, options) {
    var _a4;
    const configs = [
      [this.children, "parentIndex"],
      [this.unfilteredChildren, "unfilteredIndex"],
      [this.orderedChildren, "orderedParentIndex"]
    ];
    for (const config of configs) {
      const [children, indexName] = config;
      if (children) {
        const index = children.indexOf(childRecord);
        config.push(index);
        if (index > -1) {
          children.splice(index, 1);
          if (!((options == null ? void 0 : options.skipIndexUpdate) || ((_a4 = options == null ? void 0 : options[indexName]) == null ? void 0 : _a4.skip))) {
            this.updateChildrenIndices(children, indexName);
          }
        }
      }
    }
    return configs[0][2];
  }
  /**
   * Iterates orderedChildren array to apply sorting order according to `orderedParentIndex`.
   * Normally sorting is not required because order is maintained on append/insert. But is useful
   * when pasting number of records to restore their original order.
   * @param {Boolean} [deep=true] True to dive into children. False to sort own children.
   * @param {Boolean} [usePreviousOrder=false] Enable to use previous value of `orderedParentIndex`.
   * @returns {Set} Returns Set of moved nodes which require WBS update
   * @private
   */
  sortOrderedChildren(deep = true, usePreviousOrder = false) {
    const movedNodes = [];
    if (!this.isLeaf) {
      this.orderedChildren.sort((a, b) => {
        var _a4, _b;
        if (usePreviousOrder) {
          const aPrevIndex = (_a4 = a.meta.modified.orderedParentIndex) != null ? _a4 : a.orderedParentIndex, bPrevIndex = (_b = b.meta.modified.orderedParentIndex) != null ? _b : b.orderedParentIndex, result = aPrevIndex - bPrevIndex;
          if (result !== 0) {
            movedNodes.push(a);
            movedNodes.push(b);
          }
          return result;
        } else {
          return a.orderedParentIndex - b.orderedParentIndex;
        }
      });
      if (deep) {
        this.orderedChildren.forEach((child) => {
          movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));
        });
      }
      this.updateChildrenIndices(this.orderedChildren, "orderedParentIndex", true);
    }
    return new Set(movedNodes);
  }
  sortVisibleChildren(deep = true, sorterFn) {
    const me = this;
    if (!me.isLeaf) {
      me.children.sort(sorterFn);
      if (deep) {
        me.orderedChildren.forEach((child) => child.sortVisibleChildren(deep, sorterFn));
      }
      me.updateChildrenIndices(me.children, "parentIndex", true);
    }
  }
  sortUnfilteredChildren(deep = true, sorterFn) {
    const me = this;
    if (!me.isLeaf && me.unfilteredChildren) {
      me.unfilteredChildren.sort(sorterFn);
      if (deep) {
        me.orderedChildren.forEach((child) => child.sortUnfilteredChildren(deep, sorterFn));
      }
      me.updateChildrenIndices(me.unfilteredChildren, "unfilteredIndex", true);
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _a4;
    const me = this;
    if (me.unfilteredChildren) {
      me.children = me.unfilteredChildren.slice();
      me.unfilteredChildren = null;
    }
    (_a4 = super.unjoinStore) == null ? void 0 : _a4.call(this, store, isReplacing);
  }
};

// ../Core/lib/Core/data/mixin/ModelLink.js
var propertyOverrides = {
  id: 1,
  stores: 1,
  parentIndex: 1,
  parent: 1,
  previousSibling: 1,
  nextSibling: 1,
  unfilteredIndex: 1
};
var proxyConfig = {
  get(target, prop) {
    if (prop === "proxyMeta") {
      return this.proxyMeta;
    }
    if (prop === "constructor") {
      return target.constructor;
    }
    if (prop === "setData") {
      return this.setDataOverride;
    }
    if (prop === "set") {
      return this.setOverride;
    }
    if (prop === "instanceMeta") {
      return this.instanceMetaOverride;
    }
    if (propertyOverrides[prop]) {
      return this.proxyMeta.data[prop];
    }
    return Reflect.get(target, prop, this.proxyRecord);
  },
  set(target, prop, value) {
    if (propertyOverrides[prop]) {
      this.proxyMeta.data[prop] = value;
    } else {
      target[prop] = value;
    }
    return true;
  },
  // The instanceMeta has to be unique for this link instance.
  // On first reference, we create a clone of the original's instanceMeta
  instanceMetaOverride(instanceOrId) {
    const { proxyMeta } = this, id = instanceOrId.id || instanceOrId, map = proxyMeta.map || (proxyMeta.map = ObjectHelper.clone(proxyMeta.originalRecord.instanceMeta(id)));
    return map[id] || (map[id] = {});
  },
  // Override setData & set to reroute parentIndex updates
  setDataOverride(toSet, value) {
    if (toSet === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.setData(toSet, value);
    }
  },
  setOverride(field, value, ...args) {
    if (field === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.set(field, value, ...args);
    }
  }
};
var ModelLink_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    /**
     * Creates a proxy record (using native Proxy) linked to this record (the original). The proxy records shares most
     * data with the original, except for its `id` (which is always generated), and ordering fields such as
     * `parentIndex` and `parentId` etc.
     *
     * Any change to the proxy record will be reflected on the original, and vice versa. A proxy record is not meant to
     * be persisted, only the original record should be persisted. Thus, proxy records are not added to stores change
     * tracking (added, modified and removed records).
     *
     * Removing the original record removes all proxies.
     *
     * Creating a proxy record allows a Store to seemingly contain the record multiple times, something that is
     * otherwise not possible. It also allows a record to be used in both a tree store and in a flat store.
     *
     * <div class="note">Note that not all UI features support linked records</div>
     *
     * @returns {Proxy} Proxy record linked to the original record
     * @typings {typeof Proxy}
     * @category Misc
     */
    link() {
      if (this.isLinked) {
        return this.$original.link();
      }
      const me = this, useConfig = {
        ...proxyConfig,
        // Data not shared with the original record
        proxyMeta: {
          originalRecord: me,
          data: {
            id: `${me.id}_link_${StringHelper.generateUUID()}`,
            stores: []
          }
        }
      }, proxyRecord = new Proxy(me, useConfig);
      useConfig.proxyRecord = proxyRecord;
      (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);
      return proxyRecord;
    }
    /**
     * Is this record linked to another record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get isLinked() {
      var _a5;
      return Boolean((_a5 = this.proxyMeta) == null ? void 0 : _a5.originalRecord);
    }
    /**
     * Are other records linked to this record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get hasLinks() {
      return Boolean(!this.proxyMeta && this.$links.length);
    }
    // Logic to remove a link shared between removing in a flat store and a tree store
    removeLink(link, records = null, silent = false) {
      if (link.hasLinks) {
        for (const linked of link.$links.slice()) {
          if (records) {
            ArrayHelper.include(records, linked);
          } else {
            linked.remove(silent);
          }
        }
      } else if (link.isLinked) {
        ArrayHelper.remove(link.$original.$links, link);
      }
    }
    // Overrides beforeRemove in Model, to remove all linked records when original record is removed.
    beforeRemove(records) {
      this.removeLink(this, records);
    }
    // Overrides removeChild in TreeNode, to remove the original node and all linked nodes when either a linked or
    // original node is removed.
    removeChild(childRecords, isMove, silent, options) {
      if (!(options == null ? void 0 : options.isInserting)) {
        childRecords = ArrayHelper.asArray(childRecords);
        for (const child of childRecords) {
          this.removeLink(child, null, silent);
        }
      }
      return super.removeChild(childRecords, isMove, silent, options);
    }
    // Convenience getter for code keying by id that needs to work with both link and original
    get $originalId() {
      return this.$original.id;
    }
    // Convenience getter to retrieve linked records
    get $links() {
      var _a5;
      return (_a5 = this.meta.linkedRecords) != null ? _a5 : [];
    }
  }, __publicField(_a4, "$name", "ModelLink"), __publicField(_a4, "isModel", true), _a4;
};

// ../Core/lib/Core/mixin/Factoryable.js
var { defineProperty: defineProperty4 } = Reflect;
var ownerSymbol = Symbol("owner");
var typeSplitRe = /[\s,]+/;
var Factoryable_default = (Target) => class Factoryable extends (Target || Base) {
  static get $name() {
    return "Factoryable";
  }
  static get declarable() {
    return [
      /**
       * This property getter returns options that control the factory process. This property getter must be
       * defined by the class that mixes in `Factoryable` in order to initialize the factory properly.
       * ```
       *  static get factoryable() {
       *      return {
       *          defaultType : 'default'
       *      };
       *  }
       * ```
       * If there are no special options to provide, this method can return nothing (`undefined`):
       * ```
       *  static get factoryable() {
       *      // initialize the factory with all default options
       *  }
       * ```
       * @static
       * @member {Object} factoryable
       * @property {Boolean} [factoryable.caseless=true] Specify `false` to use case-sensitive type names. The
       * default is to ignore case.
       * @property {String} [factoryable.defaultType=null] The default type to create when a config object has
       * no `typeKey` property.
       * @property {Function|Function[]} [factoryable.extends] One or more classes that mix in `Factoryable` to
       * use for resolving type names when a type name is not found in this factory.
       * @property {String} [factoryable.typeKey='type'] The name of the property in a config object that holds
       * the type name.
       * @internal
       */
      "factoryable",
      /**
       * One or more additional type name aliases for this class. This can be useful for renaming and maintaining
       * a previous type name.
       * ```
       *  class Fit extends Layout {
       *      static type = 'fit';
       *
       *      static alias = 'fill';
       *  }
       * ```
       * @static
       * @member {String|String[]} alias
       * @internal
       */
      "alias",
      /**
       * The (canonical) type name for this class by which instances can be created using the static
       * {@link #function-create-static create()} method.
       * @static
       * @member {String} type
       */
      "type"
    ];
  }
  /**
   * Registers a class (`cls`) associated with the given `type`.
   * @param {String|String[]} type A string, array of strings or a comma-separated string containing the type names
   * for the specified `cls` class.
   * @param {Function} cls The class (constructor function)
   * @param {Boolean} [replace] Pass `true` to overwrite existing registered types. Otherwise, this method will throw
   * an exception if the `type` is already registered with this factory.
   * @internal
   */
  static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {
    const { factoryable } = this.initClass(), { caseless, registry: registry2 } = factoryable, types = StringHelper.split(type, typeSplitRe);
    for (let lower, name, i = 0; i < types.length; ++i) {
      name = types[i];
      lower = caseless ? name.toLowerCase() : name;
      if (!replace && lower in registry2) {
        throw new Error(`Type "${name}" already registered with ${factoryable.class.name} factory`);
      }
      registry2[name] = registry2[lower] = cls.initClass();
    }
  }
  /**
   * Returns `true` if the passed instance is of the passed type or of a derived class.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   */
  static isA(instance, type) {
    return this.isType(instance, type, true);
  }
  /**
   * Returns `true` if the passed instance is of the passed type.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   * @param {Boolean} [deep] Pass `true` to return `true` if the class is a subclass of the passed type.
   */
  static isType(instance, type, deep) {
    const { factoryable } = this, { caseless, registry: registry2 } = factoryable, typeCls = registry2[caseless ? type.toLowerCase() : type];
    if (typeCls) {
      if (deep) {
        return instance instanceof typeCls;
      }
      return instance.constructor === typeCls;
    }
    return false;
  }
  static setupAlias(cls) {
    cls.register(cls.alias, cls);
  }
  static setupFactoryable(cls, meta) {
    const superClass = meta.super.class;
    let { factoryable } = cls;
    factoryable = {
      caseless: true,
      defaultType: null,
      extends: superClass.factoryable ? [superClass] : null,
      typeKey: "type",
      ...factoryable
    };
    factoryable.class = cls;
    factoryable.registry = /* @__PURE__ */ Object.create(null);
    if (factoryable.extends && !Array.isArray(factoryable.extends)) {
      factoryable.extends = [factoryable.extends];
    }
    defineProperty4(cls, "factoryable", {
      get() {
        return factoryable;
      }
    });
  }
  static setupType(cls, meta) {
    const { type } = cls;
    cls.register(type, cls, meta.replaceType);
    defineProperty4(cls.prototype, "type", {
      value: type
    });
  }
  /**
   * Creates an instance from this factory, given the type name or a config object.
   * @param {String|Object} config The type name string or config object.
   * @param {String|Function|Object} [options] Creation options (for details see {@link #function-reconfigure-static}).
   * @returns {Object}
   */
  static create(config, options) {
    return this.reconfigure(null, config, options);
  }
  /**
   * Reconfigures an optional existing instance based on the provided config and returns the correctly configured
   * instance. This will be the `existingInstance` if the `config` does not specify a different type.
   *
   * If `config` is `null` (or simply falsy), this method will destroy the `existingInstance` (if any) and return
   * `null`.
   *
   * If there is no `existingInstance`, the config must specify a type. That is, it must be a string (the type name)
   * or an object containing a `type` property, the `defaultType` must be provided or the factory itself must have
   * a `defaultType` specified (see {@link #property-factoryable-static}).
   *
   * When an `existingInstance` is provided and a type is specified, the instance will be reconfigured via `setConfig`
   * if it is of that type. Otherwise, the `existingInstance` is destroyed (if it is owned by the `options.owner`)
   * and a new instance of the correct type is created.
   *
   * @param {Object} existingInstance The instance to reconfigure. This can be `null`.
   *
   * @param {String|Object} config The type name string or config object.
   *
   * @param {String|Function|Object} [options] Additional options to control the reconfiguration process. If this
   * value is a string or a class constructor, it treated as `options.type`. If this value is a class instance, it
   * is used as the `options.owner`. If this is a function, it is treated as `options.setup`. NOTE: functions declared
   * using the `function` keyword are equivalent to class constructors. Use an arrow function or a class method to
   * avoid this when a `setup` function is intended.
   *
   * @param {String|Function} [options.type] The default type to use if the `config` object does not specify a type.
   *
   * @param {Object} [options.owner] The owner of any created instances. If the `existingInstance` is being replaced,
   * this value determines if the instance will be destroyed.
   *
   * @param {Object} [options.defaults] A config object of default values to use when creating a new instance.
   *
   * @param {Function|String} [options.setup] A function or the name of a method (on the `options.owner`) to call
   * prior to creating a new instance. It is passed the config object that will be used to create the instance. If a
   * truthy value is returned, that value is passed to the constructor instead of the provided config object.
   *
   * @param {Function|String} [options.transform] A function or the name of a method (on the `options.owner`) to call
   * with the raw config object prior to processing and the value it returns replaces the raw value. This function is
   * used to transform strings or arrays (for example) into proper config objects.
   *
   * @param {Function|String} [options.cleanup] A function or the name of a method (on the `options.owner`) to call
   * prior to destroying the `existingInstance`. The `existingInstance` is passed as the sole argument.
   *
   * @returns {Object} The reconfigured instance (either `existingInstance` or a new instance of the desired type)
   */
  static reconfigure(existingInstance, config, options) {
    const me = this, { factoryable } = me, { typeKey } = factoryable;
    let defaultType = options, cleanup, defaults, mergeType, owner, prepared, setup, t, transform, type;
    if (options && !ObjectHelper.isClass(options)) {
      defaultType = null;
      t = typeof options;
      if (t === "function") {
        setup = options;
      } else if (t === "string") {
        defaultType = options;
      } else if (ObjectHelper.isObject(options)) {
        cleanup = options.cleanup;
        defaults = options.defaults;
        owner = options.owner;
        setup = options.setup;
        defaultType = options.type;
        transform = options.transform;
      } else {
        owner = options;
      }
    }
    if (transform) {
      config = typeof transform === "string" ? owner[transform](config) : transform(config);
    }
    type = config;
    if (typeof type === "string") {
      config = {};
    } else if (config) {
      if (config === true) {
        config = {};
      }
      if (!ObjectHelper.isObject(config)) {
        if (owner && config !== existingInstance && (existingInstance == null ? void 0 : existingInstance[ownerSymbol]) === owner) {
          typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
          existingInstance.destroy();
        }
        return config;
      }
      type = config[typeKey];
    }
    type = type && me.resolveType(type);
    if (existingInstance) {
      if (config && (!type || existingInstance.constructor === type)) {
        if (typeKey in config) {
          config = ObjectHelper.assign({}, config);
          delete config[typeKey];
        }
        existingInstance.setConfig(config);
        return existingInstance;
      }
      if (owner && existingInstance[ownerSymbol] === owner) {
        typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
        existingInstance.destroy();
      }
    }
    if (config) {
      if (defaults) {
        if (!(mergeType = type)) {
          if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {
            throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);
          }
          mergeType = me.resolveType(mergeType);
        }
        if (mergeType) {
          config = mergeType.mergeConfigs(defaults, config);
        }
      }
      if (setup) {
        prepared = typeof setup === "string" ? owner[setup](config, type, defaults) : setup(config, type, defaults);
        if (prepared === null) {
          return prepared;
        }
        config = prepared || config;
      }
      if (!type) {
        if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {
          throw new Error(`No default type defined for ${factoryable.class.name} factory`);
        }
        type = me.resolveType(type);
      }
      if (defaults && !mergeType) {
        config = type.mergeConfigs(defaults, config);
      }
      if (typeKey in config) {
        config = ObjectHelper.assign({}, config);
        delete config[typeKey];
      }
      config = new type(config);
      if (owner) {
        config[ownerSymbol] = owner;
      }
    }
    return config || null;
  }
  /**
   * This method returns the constructor of the class registered for the given type name.
   * @param {String} type The type name to look up.
   * @param {Boolean} [optional] Pass `true` to return `null` if `type` is not found instead of throwing an exception.
   * @returns {Function}
   */
  static resolveType(type, optional) {
    if (typeof type !== "string") {
      return type;
    }
    const { factoryable } = this, bases = factoryable.extends;
    let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type], i;
    for (i = 0; !result && bases && i < bases.length; ++i) {
      result = bases[i].resolveType(
        type,
        /* optional = */
        true
      );
    }
    if (!result && !optional) {
      throw new Error(`Invalid type name "${type}" passed to ${factoryable.class.name} factory`);
    }
    return result;
  }
};

// ../Core/lib/Core/data/field/DataField.js
var { getOwnPropertyDescriptor: getOwnPropertyDescriptor2 } = Reflect;
var DataField = class extends Base.mixin(Factoryable_default) {
  static get $name() {
    return "DataField";
  }
  static get type() {
    return "auto";
  }
  static get factoryable() {
    return {
      defaultType: "auto"
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * The name of the field.
       * @config {String} name
       */
      /**
       * The label text for a form item generated for this field. This is also used to create
       * a column header for a {@link #config-column} for this field.
       * @config {String} label
       */
      /**
       * A column config object for a column to display this field in a grid. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate column type can be inferred.
       *
       * This also provides default values for column configuration if a configured column definition
       * for a grid lacks a property.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * column type may be specified, for example a `type : 'number'` field may be configured
       * with
       *
       * ```javascript
       * column : 'percent'
       * ```
       * or
       * ```javascript
       * column : {
       *     type : 'percent',
       *     width : 100
       * }
       * ```
       * if it represents a percentage value and needs appropriate rendering and editing.
       * @config {String|GridColumnConfig} column
       */
      /**
       * A config object for a widget to edit this field in a form. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate input widget type can be inferred.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * widget may be specified.
       * @config {String|InputFieldConfig} editor
       * @private
       */
      /**
       * A function that compares two values and returns a value < 0 if the first is less than the second, or 0
       * if the values are equal, or a value > 0 if the first is greater than the second.
       * @config {Function}
       * @param {Core.data.Model} value1
       * @param {Core.data.Model} value2
       * @returns {Number}
       * @default
       */
      compare: null,
      /**
       * A function that compares two objects or records using the `compare` function on the properties of each
       * object based on the `name` of this field.
       * @config {Function}
       * @param {Core.data.Model} value1
       * @param {Core.data.Model} value2
       * @returns {Number}
       * @default
       * @internal
       */
      compareItems: null,
      /**
       * The property in a record's data object that contains the field's value.
       * Defaults to the field's `name`.
       * @config {String}
       */
      dataSource: null,
      /**
       * The default value to assign to this field in a record if no value is provided.
       * @config {*} defaultValue
       */
      /**
       * Setting to `true` will ensure this field is included in any update/insert request payload
       * when a Store / Project / CrudManager performs a request.
       * @config {Boolean}
       * @default
       */
      alwaysWrite: false,
      /**
       * Setting to `false` indicates that `null` is not a valid value.
       * @config {Boolean}
       * @default
       */
      nullable: true,
      /**
       * The value to return from {@link #function-print} for a `null` or `undefined` value.
       * @config {String}
       * @default
       */
      nullText: null,
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {*}
       * @default
       */
      nullValue: void 0,
      /**
       * Set to `false` to exclude this field when saving records to a server.
       * @config {Boolean}
       * @default
       */
      persist: true,
      /**
       * Set to `true` for the field's set accessor to ignore attempts to set this field.
       * @config {Boolean}
       * @default
       */
      readOnly: false,
      /**
       * By default, defined {@link Core.data.Model} fields may be used to create a grid column
       * suitable for displaying that field in a grid cell. Some fields may not be suitable for
       * features which automatically generate columns for view. These fields are created using
       * `internal : true`. Some examples are the `expanded` and `rowHeight` fields which are used
       * internally.
       * @config {Boolean}
       * @default
       */
      internal: false,
      /**
       * Set to `true` to indicate this field is calculated and cannot be edited via UI
       * @config {Boolean}
       * @internal
       * @default
       */
      calculated: false,
      useProp: null,
      /**
       * When this flag is enabled, this field will skip the equality check when store is syncing the new
       * dataset (see {@link Core.data.Store#config-syncDataOnLoad} config). This means, that even if the
       * new value in new dataset is the same as old, it will still be applied to the model. It is useful
       * in certain edge case scenarios, when the update of the field does not preserve extra context information,
       * which should be provided by other fields.
       *
       * @config {Boolean}
       * @default
       */
      bypassEqualityOnSyncDataset: false
    };
  }
  /**
   * The class that first defined this field. Derived classes that override a field do not change this property.
   * @member {Core.data.Model} definedBy
   * @private
   * @readonly
   */
  /**
   * The class that most specifically defined this field. Derived classes that override a field set this property to
   * themselves.
   * @member {Core.data.Model} owner
   * @private
   * @readonly
   */
  // NOTE: Since we create lots of instances, they have no life cycle (they are not destroyed) and are readonly after
  // creation, this class does not use configurable.
  construct(config) {
    const me = this;
    if (config) {
      me.name = config.name;
      Object.assign(me, config);
    }
    if (me.compare) {
      me.compareItems = (itemA, itemB) => me.compare(itemA == null ? void 0 : itemA[me.name], itemB == null ? void 0 : itemB[me.name]);
    }
  }
  /**
   * This method transforms a data value into the desired form for storage in the record's data object.
   *
   * ```javascript
   * export default class Task extends TaskModel {
   *    static get fields() {
   *        return [
   *            {
   *                name    : 'status',
   *                convert : (value, data) => {
   *                    if (value >= 100) {
   *                        return 'done';
   *                    }
   *                    else if (value > 0) {
   *                        return 'started';
   *                    }
   *                }
   *            }
   *        ];
   *    }
   * }
   * ```
   *
   * @method convert
   * @param {*} value The value to convert for storage in a record.
   * @param {Object} data The raw record data object
   * @returns {*} The converted value.
   */
  /**
   * This method transforms a data value into the desired form for transmitting to a server.
   * @method serialize
   * @param {*} value The value to serialize
   * @param {Core.data.Model} record The record that contains the value being serialized.
   * @returns {*} The serialized value.
   */
  /**
   * This optional method is called when setting a data value on a record.
   * @method set
   * @param {*} value The value to set
   * @param {Object} data The records future or current data object to set value to
   * @param {Core.data.Model} record The record that owns or will own the data object
   * @internal
   */
  /**
   * This optional method is called when a record using this field is created.
   * @method init
   * @param {Core.data.Model} record The record being created
   * @internal
   */
  /**
   * Create getter and setter functions for the specified field name under the specified key.
   * @internal
   */
  defineAccessor(target, force) {
    const { name, dataSource } = this;
    if (!force && name in target && target.$meta.hierarchy.some((current) => {
      var _a4;
      return ((_a4 = getOwnPropertyDescriptor2(current.prototype, name)) == null ? void 0 : _a4.enumerable) === false;
    })) {
      return;
    }
    Reflect.defineProperty(target, name, {
      configurable: true,
      // To allow removing it later
      enumerable: true,
      // no arrow functions here, need `this` to change to instance
      get: this.complexMapping ? function() {
        return this.complexGet(name, dataSource);
      } : function() {
        if (this.batching && name in this.meta.batchChanges) {
          return this.meta.batchChanges[name];
        }
        return this.data[dataSource];
      },
      // no arrow functions here, need `this` to change to instance
      set(value) {
        const field = this.$meta.fields.map[name];
        if (!(field && field.readOnly)) {
          this.set(name, value);
        }
      }
    });
  }
  /**
   * Compares two values for this field and returns `true` if they are equal, and `false` if not.
   * @param {*} first The first value to compare for equality.
   * @param {*} second The second value to compare for equality.
   * @returns {Boolean} `true` if `first` and `second` are equal.
   */
  isEqual(first, second) {
    return ObjectHelper.isEqual(first, second);
  }
  /**
   * Returns the given field value as a `String`. If `value` is `null` or `undefined`, the value specified by
   * {@link #config-nullText} is returned.
   * @param {*} value The value to convert to a string.
   * @returns {String}
   */
  print(value) {
    return value == null ? this.nullText : this.printValue(value);
  }
  /**
   * Returns the given, non-null field value as a `String`.
   * @param {*} value The value to convert to a string (will not be `null` or `undefined`).
   * @returns {String}
   * @protected
   */
  printValue(value) {
    return String(value);
  }
};
DataField._$name = "DataField";

// ../Core/lib/Core/data/field/ArrayDataField.js
var ArrayDataField = class extends DataField {
  isEqual(a, b) {
    return a === b;
  }
  getAt(record, index) {
    return record.get(this.name)[index];
  }
};
__publicField(ArrayDataField, "$name", "ArrayDataField");
__publicField(ArrayDataField, "type", "array");
ArrayDataField.initClass();
ArrayDataField._$name = "ArrayDataField";

// ../Core/lib/Core/data/field/BooleanDataField.js
var BooleanDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Boolean}
       * @default
       */
      nullValue: false
    };
  }
  isEqual(first, second) {
    if (first == null && second == null) {
      return true;
    }
    return super.isEqual(first, second);
  }
  convert(value) {
    var _a4;
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    if (((_a4 = value.toLowerCase) == null ? void 0 : _a4.call(value)) === "false") {
      return false;
    }
    return Boolean(value);
  }
};
__publicField(BooleanDataField, "$name", "BooleanDataField");
__publicField(BooleanDataField, "type", "boolean");
__publicField(BooleanDataField, "alias", "bool");
BooleanDataField.initClass();
BooleanDataField._$name = "BooleanDataField";

// ../Core/lib/Core/data/field/DateDataField.js
var DateDataField = class extends DataField {
  static get $name() {
    return "DateDataField";
  }
  static get type() {
    return "date";
  }
  static get prototypeProperties() {
    return {
      /**
       * The format of the date field.
       *
       * See {@link Core.helper.DateHelper} for details.
       * @config {String} format
       * @default DateHelper.defaultFormat
       */
      format: null
    };
  }
  convert(value) {
    if (value == null) {
      if (!this.nullable) {
        value = this.nullValue;
      }
    } else if (value === "now") {
      value = /* @__PURE__ */ new Date();
    } else if (!(value instanceof Date)) {
      value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);
      if (!value || isNaN(value)) {
        value = void 0;
      }
    }
    return value;
  }
  serialize(value) {
    if (value instanceof Date) {
      value = DateHelper.format(value, this.format || DateHelper.defaultFormat);
    }
    return value;
  }
  printValue(value) {
    return DateHelper.format(value, this.format || DateHelper.defaultFormat);
  }
};
DateDataField.initClass();
DateDataField._$name = "DateDataField";

// ../Core/lib/Core/data/field/StringDataField.js
var StringDataField = class extends DataField {
  static get $name() {
    return "StringDataField";
  }
  static get type() {
    return "string";
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {String}
       * @default
       */
      nullValue: ""
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : String(value);
  }
};
StringDataField.initClass();
StringDataField._$name = "StringDataField";

// ../Core/lib/Core/data/field/DurationUnitDataField.js
var DurationUnitDataField = class extends StringDataField {
  static get $name() {
    return "DurationUnitDataField";
  }
  static get type() {
    return "durationunit";
  }
  isEqual(first, second) {
    return DateHelper.compareUnits(first, second) === 0;
  }
};
DurationUnitDataField.initClass();
DurationUnitDataField._$name = "DurationUnitDataField";

// ../Core/lib/Core/data/field/IntegerDataField.js
var IntegerDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The `Math` method to use to ensure fractional component is removed.
       * @config {'round'|'floor'|'ceil'}
       * @default
       */
      rounding: "round"
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : Math[this.rounding](Number(value));
  }
};
__publicField(IntegerDataField, "$name", "IntegerDataField");
__publicField(IntegerDataField, "type", "integer");
__publicField(IntegerDataField, "alias", "int");
IntegerDataField.initClass();
IntegerDataField._$name = "IntegerDataField";

// ../Core/lib/Core/data/field/ModelDataField.js
var ModelDataField = class extends DataField {
  static get $name() {
    return "ModelDataField";
  }
  static get type() {
    return "model";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
  isEqual(first, second) {
    return first && second && second instanceof first.constructor && second.id == first.id;
  }
};
__publicField(ModelDataField, "configurable", {
  /**
   * Class used to contain data values in this field; should be a subclass of {@link Core.data.Model}.
   * Defining this configuration is necessary for some functionality (like filter editing) to identify the
   * type of data held by the field without data present.
   *
   * @config {Core.data.Model}
   * @typings {typeof Model}
   * @category Common
   */
  modelClass: null
});
ModelDataField.initClass();
ModelDataField._$name = "ModelDataField";

// ../Core/lib/Core/data/field/NumberDataField.js
var NumberDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The numeric precision of this field. Values are rounded to the specified number of digits. If `null`,
       * the default, no rounding is performed.
       * @config {Number}
       * @default
       */
      precision: null
    };
  }
  isEqual(first, second) {
    return isNaN(Number(first)) && isNaN(Number(second)) || super.isEqual(first, second);
  }
  convert(value) {
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    value = Number(value);
    if (isNaN(value)) {
      return;
    }
    let scale = this.precision;
    if (scale) {
      scale = 10 ** scale;
      value = Math.round(value * scale) / scale;
    } else if (scale === 0) {
      value = Math.round(value);
    }
    return value;
  }
};
__publicField(NumberDataField, "$name", "NumberDataField");
__publicField(NumberDataField, "type", "number");
__publicField(NumberDataField, "alias", "float");
NumberDataField.initClass();
NumberDataField._$name = "NumberDataField";

// ../Core/lib/Core/data/field/ObjectDataField.js
var ObjectDataField = class extends DataField {
  static get $name() {
    return "ObjectDataField";
  }
  static get type() {
    return "object";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
};
ObjectDataField.initClass();
ObjectDataField._$name = "ObjectDataField";

// ../Core/lib/Core/data/field/StoreDataField.js
var isIdAutoGenerated = (id) => typeof id === "string" && id.startsWith("_generated");
var StoreDataField = class extends DataField {
  /**
   * Store class to use when creating the store.
   *
   * ```javascript
   * class TodoStore extends Store {
   *     ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : TodoStore }
   *     ]
   * });
   * ```
   *
   * @config {Class} storeClass
   * @typings {typeof Store}
   */
  /**
   * Model class to use for the store (can also be configured as usual on the store class, this config is for
   * convenience).
   *
   * ```javascript
   * class TodoItem extends Model {
   *   ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : Store, modelClass : TodoItem }
   *     ]
   * });
   * ```
   *
   * @config {Class} modelClass
   * @typings {typeof Model}
   */
  /**
   * Optional store configuration object to apply when creating the store.
   *
   * ```javascript
   * const task = new Store({
   *     static fields = [
   *         {
   *             type       : 'store',
   *             name       : 'todoItems',
   *             storeClass : Store
   *             store      : {
   *                  syncDataOnLoad : false
   *             }
   *         }
   *     ]
   * });
   * ```
   *
   * @config {StoreConfig} store
   */
  // Initializer, called when creating a record. Sets up the store and populates it with any initial data
  init(data, record) {
    var _a4;
    const me = this, storeName = `${me.name}Store`, config = { skipStack: true, syncDataOnLoad: true };
    if (me.store) {
      ObjectHelper.assign(config, me.store);
    }
    if (me.modelClass) {
      config.modelClass = me.modelClass;
    }
    (_a4 = record[`init${StringHelper.capitalize(storeName)}`]) == null ? void 0 : _a4.call(record, config);
    if (!config.storeClass && !me.storeClass) {
      throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);
    }
    const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);
    if (me.complexMapping) {
      ObjectHelper.setPath(data, me.dataSource, store);
    } else {
      data[me.dataSource] = store;
    }
    store.verifyNoGeneratedIds = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
    store.$currentValue = me.getValue(store);
    store.ion({
      change: ({ action }) => {
        const value = me.getValue(store);
        if (!store.$isSettingStoreFieldData) {
          const oldPreserveCurrentDataset = store.$preserveCurrentDataset;
          store.$preserveCurrentDataset = me.subStore && (action === "update" || action === "remove" || action === "add");
          me.$isUpdatingRecord = true;
          record.set(me.name, value);
          me.$isUpdatingRecord = false;
          store.$preserveCurrentDataset = oldPreserveCurrentDataset;
        }
        store.$currentValue = value;
      }
    });
  }
  // Called when setting a new value to the field on a record
  set(value, data, record) {
    var _a4, _b;
    const me = this, storeName = `${me.name}Store`, { [storeName]: store } = record.meta;
    if (!store) {
      record.meta.initableValues.set(me, value);
      return false;
    }
    if (store.$isSettingStoreFieldData) {
      return;
    }
    store.$isSettingStoreFieldData = true;
    value = (_b = (_a4 = record[`process${StringHelper.capitalize(storeName)}Data`]) == null ? void 0 : _a4.call(record, value, record)) != null ? _b : value;
    if (!store.$preserveCurrentDataset) {
      store.data = value;
    }
    store.$isSettingStoreFieldData = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
  }
  serialize(value, record) {
    const store = record.meta[`${this.name}Store`];
    return this.$isUpdatingRecord ? this.getValue(store) : store.$currentValue;
  }
  // Extract persistable values, optionally including id depending on if ids are used
  getValue(store) {
    return store.allRecords.map((r) => {
      const data = r.persistableData;
      if (!store.usesId) {
        delete data.id;
      }
      return data;
    });
  }
  isEqual(a, b) {
    if (a == null && b == null) {
      return true;
    } else if (a == null && b != null || a != null && b == null) {
      return false;
    } else {
      if (a.isStore && b.isStore) {
        return ObjectHelper.isDeeplyEqual(a.$currentValue, b.$currentValue);
      } else if (a.isStore && b.isStore || !a.isStore && !b.isStore) {
        return ObjectHelper.isEqual(a, b, true);
      } else {
        const store = a.isStore ? a : b, modelClass = store.modelClass, fields = modelClass.$meta.fields.defs, storeEntries = a.isStore ? a.$currentValue : b.$currentValue, arrayEntries = a.isStore ? b : a;
        if (storeEntries.length !== arrayEntries.length) {
          return false;
        } else {
          for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            if (!field.persist) {
              continue;
            }
            for (let k = 0; k < storeEntries.length; k++) {
              const storeValue = storeEntries[k][field.dataSource];
              const arrayValue = arrayEntries[k][field.dataSource];
              if (storeValue !== void 0 && arrayValue === void 0) {
                if (field.dataSource === modelClass.idField && isIdAutoGenerated(storeValue)) {
                  continue;
                }
                if (field.defaultValue !== void 0 && ObjectHelper.isEqual(field.defaultValue, storeValue, true)) {
                  continue;
                }
              }
              if (!ObjectHelper.isEqual(storeValue, arrayValue, true)) {
                return false;
              }
            }
          }
          return true;
        }
      }
    }
  }
  // Cloned value to be able to restore it later using STM
  getOldValue(record) {
    const store = record.meta[`${this.name}Store`];
    return store ? ObjectHelper.clone(store.$currentValue) : null;
  }
  getAt(record, index) {
    const store = record.meta[`${this.name}Store`];
    return store == null ? void 0 : store.getAt(index);
  }
};
__publicField(StoreDataField, "$name", "StoreDataField");
__publicField(StoreDataField, "type", "store");
StoreDataField.initClass();
StoreDataField._$name = "StoreDataField";

// ../Core/lib/Core/data/Model.js
var nestedRe = new RegExp(/^(.*?)\.(.*)/);
var arrayRe = /(.*)\[(.*)]\.?(.*)/;
var { defineProperty: defineProperty5 } = Reflect;
var { hasOwn: hasOwn3 } = ObjectHelper;
var _undefined = void 0;
var internalProps = {
  children: 1,
  data: 1,
  meta: 1
};
var abbreviationFields = [
  "name",
  "title",
  "text",
  "label",
  "description"
];
var fieldDataTypes = {
  boolean: 1,
  number: 1,
  date: 1,
  object: 1
};
var fieldsOrder = {
  parentId: 1,
  $PhantomId: 2,
  id: 3
};
var _Model = class _Model extends Base.mixin(ModelStm_default, TreeNode_default, ModelLink_default) {
  static get $name() {
    return "Model";
  }
  static get declarable() {
    return [
      /**
       * Array of defined fields for this model class. Subclasses add new fields by implementing this static
       * getter:
       *
       * ```javascript
       * // Model defining two fields
       * class Person extends Model {
       *     static get fields() {
       *         return [
       *             { name : 'username', defaultValue : 'New person' },
       *             { name : 'birthdate', type : 'date' }
       *         ];
       *     }
       * }
       *
       * // Subclass overriding one of the fields
       * class Bot extends Person {
       *     static get fields() {
       *         return [
       *             // Default value of 'username' field is overridden, any other setting from the parents
       *             // definition is preserved
       *             { name : 'username', defaultValue : 'Bot' }
       *         ];
       *     }
       * }
       * ```
       *
       * Fields in a subclass are merged with those from the parent class, making it easy to override mappings,
       * formats etc.
       *
       * @member {Array<String|ModelFieldConfig|Core.data.field.DataField>} fields
       * @readonly
       * @static
       * @category Fields
       */
      "fields"
    ];
  }
  static get fields() {
    return [
      // The index of this item in its parent (respects filtering)
      {
        name: "parentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      // The index of this item in its parent ghost (non-sortable) children array
      {
        name: "orderedParentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      /**
       * Flag the record as read-only on the UI level, preventing the end user from manipulating it using editing
       * features such as cell editing and event dragging.
       *
       * Does not prevent altering the record programmatically, it can still be manipulated by application code.
       *
       * For more info, see the "Read-only records" section above.
       *
       * @field {Boolean} readOnly
       * @category Common
       */
      {
        name: "readOnly",
        type: "boolean"
      },
      /**
       * Start expanded or not (only valid for tree data)
       * @readonly
       * @field {Boolean} expanded
       * @category Tree
       */
      {
        name: "expanded",
        internal: true
      },
      /**
       * Only used when the store is grouped. This field references the owning group record(s), kept in a map
       * keyed by store id.
       * @internal
       * @field {Map} groupParent
       */
      {
        name: "groupParent",
        persist: false,
        internal: true
      }
    ];
  }
  /**
   * Template static getter which is supposed to be overridden to define default field values for the Model class.
   * Overrides `defaultValue` config specified by the {@link #property-fields-static} getter.
   * Returns a named object where key is a field name and value is a default value for the field.
   *
   * NOTE: This is a legacy way of defining default values, we recommend using {@link #property-fields-static} moving
   * forward.
   *
   * ```javascript
   * class Person extends Model {
   *     static get fields() {
   *         return [
   *             { name : 'username', defaultValue : 'New person' }
   *         ];
   *     }
   * }
   *
   * class Bot extends Person {
   *     static get defaults() {
   *         return {
   *             username : 'Bot' // default value of 'username' field is overridden
   *         };
   *     }
   * }
   * ```
   *
   * @member {Object} defaults
   * @static
   * @category Fields
   */
  /**
   * The data source for the id field which provides the ID of instances of this Model.
   * @property {String}
   * @category Fields
   */
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }
  static get idField() {
    return this._idField;
  }
  get id() {
    var _a4;
    return (_a4 = this._id) != null ? _a4 : this.getData("id");
  }
  set id(id) {
    this.set("id", id);
  }
  /**
   * The name of the data field which holds children of this Model when used in a tree structure
   * ```javascript
   * MyModel.childrenField = 'kids';
   * const parent = new MyModel({
   *     name : 'Dad',
   *     kids : [
   *         { name : 'Daughter' },
   *         { name : 'Son' }
   *     ]
   * });
   * ```
   * @property {String}
   * @category Fields
   */
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }
  static get childrenField() {
    if (!this._childrenField) {
      const dataField = this.fieldMap.children;
      this._childrenField = (dataField == null ? void 0 : dataField.dataSource) || "children";
    }
    return this._childrenField;
  }
  /**
   * Returns index path to this node. This is the index of each node in the node path
   * starting from the topmost parent. (only relevant when its part of a tree store).
   * @returns {Number[]} The index of each node in the path from the topmost parent to this node.
   * @category Parent & children
   * @private
   */
  get indexPath() {
    const indices = [];
    let node = this, depth = node.childLevel;
    for (node = this; node && !node.isRoot; node = node.parent) {
      indices[depth--] = node.parentIndex + 1;
    }
    return indices;
  }
  /**
   * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as
   * record.id. Will get a generated value if none is specified in records data.
   *
   * {@note}Note that generated ids are meant to be temporary (phantom ids), they should not be serialized
   * but instead replaced by the backend on commit{/@note}
   *
   * @field {String|Number} id
   * @category Common
   */
  //region Init
  /**
   * Constructs a new record from the supplied data config.
   * @param {Object} [config] Raw model config
   * @param {Core.data.Store} [store] Data store
   * @param {Object} [meta] Meta data
   * @privateparam {Boolean} [skipExpose] Skip exposing properties from data
   * @privateparam {Boolean} [forceUseRaw] Force using raw data, used by copy to not clone data twice
   * @function constructor
   * @category Lifecycle
   */
  construct(config = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {
    var _a4, _b;
    const me = this, { constructor, fieldMap } = me;
    me.meta = {
      modified: {},
      ...constructor.metaConfig,
      ...meta
    };
    if (constructor.applyConfigs) {
      const configs = {};
      if (!me.useRawData || !me.useRawData.enabled) {
        config = { ...config };
      }
      const defaultConfig = me.getDefaultConfiguration();
      if (constructor.autoExposeFields) {
        for (const key in defaultConfig) {
          if (key in config) {
            if (config[key] !== void 0) {
              configs[key] = config[key];
            }
            delete config[key];
          }
        }
      } else {
        for (const key in config) {
          if (!(key in constructor.fieldMap)) {
            if (config[key] === void 0) {
              configs[key] = defaultConfig[key];
            } else {
              configs[key] = config[key];
            }
            delete config[key];
          }
        }
      }
      super.construct(configs);
    } else {
      super.construct(null);
    }
    if (!skipExpose) {
      constructor.exposeProperties(config, rawData);
    }
    if (!hasOwn3(constructor, "idFieldProcessed")) {
      let overriddenIdField = me.meta.idField;
      if (!overriddenIdField) {
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: "id",
          dataSource: overriddenIdField,
          internal: true
        });
      }
      constructor._idField = fieldMap.id.dataSource;
      constructor.idFieldProcessed = true;
    }
    me._internalId = _Model._internalIdCounter++;
    if (!me.originalData) {
      me.originalData = config;
    }
    me.data = constructor.processData(config, false, store, me, forceUseRaw);
    me._id = fieldMap.id.complexMapping ? ObjectHelper.getPath(me.data, constructor._idField) : me.data[constructor._idField];
    ((_a4 = me.meta.initableValues) == null ? void 0 : _a4.size) && me.assignInitables();
    if (me._id == null) {
      me.setData("id", me.generateId(store));
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren((_b = ArrayHelper.asArray(store)) != null ? _b : []);
    }
    me.generation = 0;
  }
  /**
   * Set this property to `true` when adding a record on a conditional basis, that is, it is yet
   * to be confirmed as an addition.
   *
   * When this is set, the {@link #property-isPersistable} value of the record is **false**, and upon being
   * added to a Store it will *not* be eligible to be synced with the server as an added record.
   *
   * Subsequently, *clearing* this property means this record will become persistable and eligible
   * for syncing as an added record.
   * @property {Boolean}
   * @category Editing
   */
  set isCreating(isCreating) {
    var _a4;
    const me = this;
    if (Boolean(me.meta.isCreating) !== isCreating) {
      me.meta.isCreating = isCreating;
      (_a4 = me.stores) == null ? void 0 : _a4.forEach((s) => s.onIsCreatingToggle(me, isCreating));
    }
  }
  get isCreating() {
    return Boolean(this.meta.isCreating);
  }
  /**
   * Compares this Model instance to the passed instance. If they are of the same type, and all fields
   * (except, obviously, `id`) are equal, this returns `true`.
   * @param {Core.data.Model} other The record to compare this record with.
   * @returns {Boolean} `true` if the other is of the same class and has all fields equal.
   * @category Misc
   */
  equals(other) {
    if (other instanceof this.constructor) {
      for (let fields = this.$meta.fields.defs, i = 0, { length } = fields; i < length; i++) {
        const field = fields[i], { name } = field;
        if (name !== "id" && !field.isEqual(this.getValue(name), other.getValue(name))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }
  /**
   * Processes raw data, converting values and setting defaults.
   * @private
   * @param {Object} data Raw data
   * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating
   * @returns {Object} Processed data
   * @category Fields
   */
  static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {
    const { fieldMap, fieldDataSourceMap, defaultValues } = this, { useRawData = { enabled: false } } = store || {}, processed = forceUseRaw || useRawData.enabled ? data : ObjectHelper.clone(data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;
    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        const field = fieldDataSourceMap[fieldName];
        let defaultValue2 = defaultValues[fieldName];
        if (Array.isArray(defaultValue2)) {
          defaultValue2 = defaultValue2.slice();
        }
        if (field == null ? void 0 : field.complexMapping) {
          if (ObjectHelper.getPath(processed, fieldName) === _undefined) {
            ObjectHelper.setPath(processed, fieldName, defaultValue2);
          }
        } else if (processed[fieldName] === _undefined) {
          processed[fieldName] = defaultValue2;
        }
      }
    }
    if (!useRawData.disableTypeConversion && !forceUseRaw) {
      for (fieldName in fieldMap) {
        const field = fieldMap[fieldName], { name, dataSource } = field, hasSource = dataSource !== name, complex = field.complexMapping, sourceExists = hasSource && (complex ? ObjectHelper.pathExists(data, dataSource) : dataSource in data), useNameForValue = name in data && (!hasSource || !sourceExists), convert = !useRawData.disableTypeConversion && field.convert;
        if (useNameForValue || convert) {
          if (!ignoreDefaults || useNameForValue || sourceExists) {
            const value = useNameForValue ? processed[name] : complex ? ObjectHelper.getPath(processed, dataSource) : processed[dataSource], converted = convert ? field.convert(value, data, record) : value;
            if (complex) {
              ObjectHelper.setPath(processed, dataSource, converted);
            } else {
              processed[dataSource] = converted;
            }
            if (hasSource) {
              delete processed[name];
            }
          }
        }
      }
    }
    this.$meta.fields.initable.length && this.initInitables(record, processed);
    return processed;
  }
  static setupClass(meta) {
    super.setupClass(meta);
    if (!meta.fields) {
      this.setupFields(this, meta);
    }
  }
  static setupFields(cls, meta) {
    var _a4, _b, _c, _d, _e;
    const classFields = hasOwn3(cls, "fields") && cls.fields, base = meta.super.fields, fieldsInfo = meta.fields = {
      defs: (_a4 = base == null ? void 0 : base.defs.slice()) != null ? _a4 : [],
      // Set to true when an instance's data object is run through exposeProperties
      exposedData: false,
      // These objects are all keyed by field name:
      defaults: base ? { ...base.defaults } : {},
      // value=field.defaultValue
      exposed: Object.create((_b = base == null ? void 0 : base.exposed) != null ? _b : null),
      // value=true if we've done defineProperty
      ordinals: Object.create((_c = base == null ? void 0 : base.ordinals) != null ? _c : null),
      // value=index in the defs array
      map: Object.create((_d = base == null ? void 0 : base.map) != null ? _d : null),
      // value=definition object
      sources: Object.create((_e = base == null ? void 0 : base.sources) != null ? _e : null)
      // value=source definition object
    };
    if (hasOwn3(cls, "defaults")) {
      Object.assign(fieldsInfo.defaults, cls.defaults);
    }
    if (hasOwn3(cls, "idField")) {
      cls.addField({
        name: "id",
        dataSource: cls.idField,
        internal: true
      });
      fieldsInfo.exposed[cls.idField] = true;
    }
    if (classFields == null ? void 0 : classFields.length) {
      classFields.map(cls.addField, cls);
    }
    fieldsInfo.initable = fieldsInfo.defs.filter((field) => field.init);
    cls.exposeRelations();
  }
  static get defaultValues() {
    return this.$meta.fields.defaults;
  }
  /**
   * An array containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields.
   * @property {Core.data.field.DataField[]}
   * @static
   * @readonly
   * @category Fields
   */
  static get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * Same as {@link #property-allFields-static}.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * An object containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only
   * access this class's defined fields.
   * @property {Object<String,Core.data.field.DataField>}
   * @static
   * @readonly
   * @category Fields
   */
  static get fieldMap() {
    return this.$meta.fields.map;
  }
  /**
   * Same as {@link #property-fieldMap-static}.
   * @property {Object<String,Core.data.field.DataField>}
   * @readonly
   * @category Fields
   */
  get fieldMap() {
    return this.$meta.fields.map;
  }
  static get fieldDataSourceMap() {
    return this.$meta.fields.sources;
  }
  /**
   * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when
   * data is loaded first time.
   * @internal
   * @param {Object} [data] Raw data
   * @param {Boolean} [raw=true] True if data is raw (contains data sources), False if data contains field names
   * @category Fields
   */
  static exposeProperties(data, raw = true) {
    const me = this, fieldsInfo = me.$meta.fields, fieldMapProperty = raw ? "exposed" : "map";
    if (data && me.autoExposeFields && !fieldsInfo.exposedData) {
      let dataProperty, fieldDef, type;
      for (dataProperty in data) {
        if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {
          type = ObjectHelper.typeOf(data[dataProperty]);
          fieldDef = {
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          };
          if (fieldDataTypes[type]) {
            fieldDef.type = type;
          }
          me.addField(fieldDef);
        }
      }
      fieldsInfo.exposedData = true;
    }
    me.exposeRelations();
  }
  /**
   * Add a field definition in addition to those predefined in `fields`.
   * @param {String|ModelFieldConfig} fieldDef A field name or definition
   * @category Fields
   */
  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }
    if (typeof fieldDef === "string") {
      fieldDef = {
        name: fieldDef
      };
    }
    const me = this.initClass(), fieldsInfo = me.$meta.fields, { ordinals } = fieldsInfo, propertiesExposed = fieldsInfo.exposed, { name } = fieldDef, existing = fieldsInfo.map[name], dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);
    let field, key;
    if (!existing || fieldDef.type && fieldDef.type !== existing.type) {
      field = DataField.create(fieldDef);
      field.definedBy = existing ? existing.definedBy : me;
      field.ordinal = existing ? existing.ordinal : ordinals[name] = fieldsInfo.defs.length;
    } else {
      field = Object.create(existing);
      for (key in fieldDef) {
        if (key !== "type") {
          field[key] = fieldDef[key];
        }
      }
    }
    field.owner = me;
    fieldsInfo.defs[field.ordinal] = field;
    fieldsInfo.map[name] = field;
    if (!fieldsInfo.sources[dataSource]) {
      fieldsInfo.sources[dataSource] = field;
    }
    if (dataSource.includes(".")) {
      field.complexMapping = true;
    }
    if (field.complexMapping) {
      propertiesExposed[dataSource.split(".")[0]] = true;
    } else {
      propertiesExposed[dataSource] = true;
    }
    if ("defaultValue" in field) {
      fieldsInfo.defaults[dataSource] = field.defaultValue;
    }
    if (!internalProps[name]) {
      field.defineAccessor(me.prototype);
    }
    me._nonPersistableFields = null;
    me._alwaysWriteFields = null;
    return field;
  }
  /**
   * Remove a field definition by name.
   * @param {String} fieldName Field name
   * @category Fields
   */
  static removeField(fieldName) {
    const me = this.initClass(), fieldsInfo = me.$meta.fields, definition = fieldsInfo.map[fieldName], { ordinals } = fieldsInfo, index = ordinals[fieldName];
    if (definition) {
      fieldsInfo.defs.splice(index, 1);
      delete ordinals[fieldName];
      delete fieldsInfo.defaults[fieldName];
      delete fieldsInfo.exposed[fieldName];
      delete fieldsInfo.map[fieldName];
      delete fieldsInfo.sources[definition.dataSource];
      for (const name in ordinals) {
        if (ordinals[name] > index) {
          --ordinals[name];
        }
      }
      delete me.prototype[fieldName];
    }
  }
  /**
   * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it
   * to be modified later when assigning stores.
   * @internal
   * @category Relations
   */
  static exposeRelations() {
    const me = this;
    if (hasOwn3(me, "exposedRelations")) {
      return;
    }
    if (me.relations) {
      me.exposedRelations = [];
      for (const relationName in me.relations) {
        const relation = me.relations[relationName];
        relation.relationName = relationName;
        me.exposedRelations.push(relation);
        if (!Reflect.ownKeys(me.prototype).includes(relationName)) {
          defineProperty5(me.prototype, relationName, {
            enumerable: true,
            get: function() {
              return this.getForeign(relationName);
            },
            set: function(value) {
              this.setForeign(relationName, value, relation);
            }
          });
        }
      }
    }
  }
  //endregion
  //region Initable fields
  // Initializes any fields using a data type that has an init method, and caches the value to assign to that field to
  // be able to assign it after all others. That allows the initter to reference the records other data if needed
  // (baselines use that to reference the task to get default values)
  static initInitables(record, processedData) {
    const laterValues = record.meta.initableValues = /* @__PURE__ */ new Map();
    for (const field of this.$meta.fields.initable) {
      const value = ObjectHelper.getPath(processedData, field.dataSource);
      value !== void 0 && laterValues.set(field, value);
      !field.lazy && field.init(processedData, record);
    }
  }
  // Assigns values to the fields that were initialized earlier (see initInitables above)
  assignInitables() {
    const { initableValues } = this.meta;
    for (const [field, value] of initableValues) {
      if (field.set(value, this.data, this) !== false) {
        initableValues.delete(field);
      }
    }
  }
  //endregion
  //region Fields
  /**
   * Flag checked from Store when loading data that determines if fields found in first records should be exposed in
   * same way as predefined fields.
   *
   * {@note}Note that we for all but the most basic use cases recommend explicitly defining the fields.
   * Having them auto exposed can lead to unexpected behavior, if the first record is not complete (fields missing,
   * null etc).
   * {/@note}
   *
   * @property {Boolean}
   * @category Fields
   */
  static get autoExposeFields() {
    return true;
  }
  /**
   * This function forces correct field order. Correct order is parentId before id. If we process id field before
   * parentId, idMap won't be updated and changing parent node will lead to duplicated records in storage
   * @param {String} a
   * @param {String} b
   * @returns {number}
   * @private
   */
  static fieldSorter(a, b) {
    return (fieldsOrder[a] || 100) - (fieldsOrder[b] || 100);
  }
  /**
   * Convenience getter to get field definitions from class.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get fields() {
    return this.$meta.fields.defs;
  }
  /**
   * Convenience function to get the definition for a field from class.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField}
   * @category Fields
   */
  getFieldDefinition(fieldName) {
    return this.constructor.getFieldDefinition(fieldName);
  }
  getFieldDefinitionFromDataSource(dataSource) {
    return this.$meta.fields.sources[dataSource];
  }
  /**
   * Get the names of all fields in data.
   * @property {String[]}
   * @readonly
   * @category Fields
   */
  get fieldNames() {
    return Object.keys(this.data);
  }
  /**
   * Get the definition for a field by name.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField} Field definition or null if none found
   * @category Fields
   */
  static getFieldDefinition(fieldName) {
    var _a4;
    const field = this.fieldMap[fieldName];
    if (!field) {
      if (fieldName.includes("[")) {
        const [, arrayFieldName, , path] = fieldName.match(arrayRe), arrayField = arrayFieldName.includes(".") ? this.getFieldDefinition(arrayFieldName) : this.fieldMap[arrayFieldName];
        if (arrayField == null ? void 0 : arrayField.isStoreDataField) {
          return (_a4 = arrayField.modelClass) == null ? void 0 : _a4.getFieldDefinition(path);
        }
      } else if (fieldName.includes(".")) {
        const [localFieldName, path] = fieldName.split(".", 2), modelField = this.fieldMap[localFieldName];
        if ((modelField == null ? void 0 : modelField.isModelDataField) && modelField.modelClass) {
          return modelField.modelClass.getFieldDefinition(path);
        }
      }
    }
    return field;
  }
  /**
   * Returns dataSource configuration for a given field name
   * @param {String} fieldName
   * @returns {String} Field `dataSource` mapping
   * @internal
   */
  static getFieldDataSource(fieldName) {
    var _a4;
    return ((_a4 = this.getFieldDefinition(fieldName)) == null ? void 0 : _a4.dataSource) || fieldName;
  }
  /**
   * Get the data source used by specified field. Returns the fieldName if no data source specified.
   * @param {String} fieldName Field name
   * @returns {String}
   * @category Fields
   */
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    return (def == null ? void 0 : def.dataSource) || (def == null ? void 0 : def.name);
  }
  /**
   * Processes input to a field, converting to expected type.
   * @param {String} fieldName Field name
   * @param {*} value Value to process
   * @returns {*} Converted value
   * @category Fields
   */
  static processField(fieldName, value, record) {
    const field = this.fieldMap[fieldName];
    return (field == null ? void 0 : field.convert) ? field.convert(value, this.data, record) : value;
  }
  //endregion
  //region Relations
  /**
   * Initializes model relations. Called from store when adding a record.
   * @private
   * @category Relations
   */
  initRelations() {
    const me = this, relations = me.constructor.exposedRelations;
    if (!relations) {
      return;
    }
    me.stores.forEach((store) => {
      var _a4;
      if (!store.modelRelations) {
        store.initRelations();
      }
      const relatedRecords = [];
      (_a4 = store.modelRelations) == null ? void 0 : _a4.forEach((config) => {
        relatedRecords.push({ related: me.initRelation(config), config });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }
  /**
   * Initializes/updates a single relation.
   * @param config Relation config
   * @returns {Core.data.Model} Related record
   * @private
   * @category Relations
   */
  initRelation(config) {
    const me = this, foreignId = me.get(config.foreignKey), foreign = foreignId !== _undefined && typeof config.foreignStore !== "string" && config.foreignStore.getById(foreignId), relationCache = me.meta.relationCache || (me.meta.relationCache = {});
    relationCache[config.relationName] = foreign || (foreignId != null ? { id: foreignId, placeHolder: true } : null);
    return foreign;
  }
  removeRelation(config) {
    const { relationName, foreignKey, nullFieldOnRemove } = config;
    if (this.meta.relationCache[relationName]) {
      delete this.meta.relationCache[relationName];
      if (nullFieldOnRemove) {
        this.setData(foreignKey, null);
      }
    }
  }
  getForeign(name) {
    var _a4;
    return (_a4 = this.meta.relationCache) == null ? void 0 : _a4[name];
  }
  setForeign(name, value, config) {
    const id = _Model.asId(value);
    return this.set(config.foreignKey, id);
  }
  /**
   * Get a relation config by name, from the first store.
   * @param {String} name
   * @returns {Object}
   * @private
   * @category Relations
   */
  getRelationConfig(name) {
    var _a4, _b;
    return (_b = (_a4 = this.firstStore) == null ? void 0 : _a4.modelRelations) == null ? void 0 : _b.find((r) => r.foreignKey === name);
  }
  //endregion
  //region Get/set values, data handling
  flatGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return this.data[dataSource];
  }
  complexGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return ObjectHelper.getPath(this.data, dataSource);
  }
  /**
   * Get value for specified field name. You can also use the generated getters if loading through a Store.
   * If model is currently in batch operation this will return updated batch values which are not applied to Model
   * until endBatch() is called.
   * @param {String} fieldName Field name to get value from
   * @returns {*} Fields value
   * @category Fields
   */
  get(fieldName) {
    var _a4;
    if (!fieldName) {
      return;
    }
    const me = this, { fieldMap } = me, field = fieldMap[fieldName];
    if (!field) {
      if (fieldName.includes("[")) {
        const [, arrayFieldName, index, path] = fieldName.match(arrayRe);
        const arrayField = fieldMap[arrayFieldName];
        if (arrayField == null ? void 0 : arrayField.getAt) {
          me._thisIsAUsedExpression(me[arrayFieldName]);
          const subRecord = arrayField.getAt(me, index);
          if (subRecord && path) {
            if (subRecord.isModel) {
              return subRecord.getValue(path);
            }
            return subRecord[path];
          }
          return subRecord;
        }
        return null;
      }
      if (fieldName.includes(".")) {
        const [localFieldName, nestedFieldName] = fieldName.split(".", 2), localField = fieldMap[localFieldName];
        if (localField == null ? void 0 : localField.isStoreDataField) {
          return (_a4 = me[localFieldName]) == null ? void 0 : _a4.getDistinctValues(nestedFieldName);
        } else if (!ObjectHelper.hasPath(me.data, fieldName)) {
          return ObjectHelper.getPath(me, fieldName);
        }
        return me.complexGet(fieldName, fieldName);
      }
    }
    if (field == null ? void 0 : field.complexMapping) {
      return me.complexGet(fieldName, field.dataSource);
    }
    return me.flatGet(fieldName, (field == null ? void 0 : field.dataSource) || fieldName);
  }
  // Used to get field values, replaces `record[fieldName]` in internal code to allow relations etc.
  getValue(fieldName) {
    if (!fieldName) {
      return;
    }
    if (fieldName in this && !fieldName.includes(".")) {
      return this[fieldName];
    }
    return this.get(fieldName);
  }
  // Used to set field values, replacing `record[fieldName] = value` to handle dot notation
  setValue(fieldName, value) {
    if (fieldName in this) {
      this[fieldName] = value;
    } else {
      this.set(fieldName, value);
    }
  }
  /**
   * Internal function used to update a records underlying data block (record.data) while still respecting field
   * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a
   * dataSource with a different name.
   *
   * For example:
   * ```javascript
   * // startDate mapped to data.beginDate
   * { name : 'startDate', dataSource : 'beginDate' }
   *
   * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with
   * // calling set. This would then not update "beginDate":
   * record.data.startDate = xx;
   *
   * // But this would
   * record.setData('startDate', xx);
   * ```
   * @internal
   * @category Editing
   */
  setData(toSet, value) {
    var _a4, _b;
    const { data, fieldMap } = this;
    if (typeof toSet === "string") {
      const field = fieldMap[toSet], dataSource = (_a4 = field == null ? void 0 : field.dataSource) != null ? _a4 : toSet;
      if (field == null ? void 0 : field.set) {
        field.set(value, this.data, this);
      } else if (field == null ? void 0 : field.complexMapping) {
        ObjectHelper.setPath(data, dataSource, value);
      } else {
        data[dataSource] = value;
      }
      if (field === "id") {
        this._id = value;
      }
    } else {
      const keys = Object.keys(toSet);
      for (let i = 0; i < keys.length; i++) {
        const fieldName = keys[i], field = fieldMap[fieldName], dataSource = (_b = field == null ? void 0 : field.dataSource) != null ? _b : fieldName;
        if (field == null ? void 0 : field.set) {
          field.set(value, this.data, this);
        } else if (dataSource) {
          if (field == null ? void 0 : field.complexMapping) {
            ObjectHelper.setPath(data, dataSource, toSet[fieldName]);
          } else {
            data[dataSource] = toSet[fieldName];
          }
        }
      }
    }
  }
  /**
   * Returns raw data from the encapsulated data object for the passed field name
   * @param {String} fieldName The field to get data for.
   * @returns {*} The raw data value for the field.
   * @category Editing
   */
  getData(fieldName) {
    var _a4;
    const field = this.fieldMap[fieldName], dataSource = (_a4 = field == null ? void 0 : field.dataSource) != null ? _a4 : fieldName;
    if (dataSource) {
      if (field == null ? void 0 : field.complexMapping) {
        return ObjectHelper.getPath(this.data, dataSource);
      }
      return this.data[dataSource];
    }
  }
  /**
   * Silently updates record's id with no flagging the property as modified.
   * Triggers onModelChange event for changed id.
   * @param {String|Number} value id value
   * @private
   */
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this._id = value;
      this.setData("id", value);
      const data = { id: { value, oldValue } };
      this.afterChange(data, data);
    }
  }
  /**
   * Set value for the specified field. You can also use the generated setters if loading through a Store.
   *
   * Setting a single field, supplying name and value:
   *
   * ```javascript
   * record.set('name', 'Clark');
   * ```
   *
   * Setting multiple fields, supplying an object:
   *
   * ```javascript
   * record.set({
   *     name : 'Clark',
   *     city : 'Metropolis'
   * });
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent] Set to true to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [validOnly] If set to `true` it will ignore setting a `undefined` value, allowing conversion functions to invalidate a data input
   * @privateparam {Boolean} [triggerBeforeUpdate]
   * @fires Core.data.Store#event-idChange
   * @fires Core.data.Store#event-update
   * @fires Core.data.Store#event-change
   * @category Editing
   */
  set(field, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a4;
    const me = this;
    if (me.isBatchUpdating) {
      me.inBatchSet(field, value, silent || me.$silenceBatch);
      return null;
    } else {
      const wasSet = me.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate);
      (_a4 = me.afterSet) == null ? void 0 : _a4.call(me, field, value, silent, fromRelationUpdate, wasSet);
      return wasSet;
    }
  }
  fieldToKeys(field, value) {
    if (typeof field !== "string") {
      return ObjectHelper.assign({}, field);
    }
    return {
      [field]: value
    };
  }
  inBatchSet(field, value, silent) {
    var _a4;
    const me = this, {
      meta,
      constructor,
      fieldMap
    } = me, wasSet = {};
    let cmp, changed = false;
    if (typeof field !== "string") {
      Object.keys(me.fieldToKeys(field, value)).forEach((key) => {
        cmp = fieldMap[key] || ObjectHelper;
        value = constructor.processField(key, field[key], me);
        if (!cmp.isEqual(meta.batchChanges[key], value)) {
          wasSet[key] = {
            value,
            oldValue: me.get(key)
          };
          meta.batchChanges[key] = value;
          changed = true;
        }
      });
    } else {
      cmp = fieldMap[field] || ObjectHelper;
      if (!cmp.isEqual(meta.batchChanges[field], value)) {
        wasSet[field] = {
          value,
          oldValue: me.get(field)
        };
        meta.batchChanges[field] = value;
        changed = true;
      }
    }
    if (changed) {
      me.generation++;
      if (!silent) {
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        (_a4 = me.stores) == null ? void 0 : _a4.forEach(
          (store) => store.trigger("batchedUpdate", { ...event })
        );
        me.forEachLinked(
          (store, record) => store.trigger("batchedUpdate", { ...event, record, records: [record] })
        );
      }
    }
  }
  inSet(fieldNameOrObject, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a4, _b, _c, _d, _e, _f;
    const me = this, {
      data,
      meta,
      fieldMap,
      constructor
    } = me, {
      prototype: myProto,
      childrenField,
      relations
    } = constructor, wasSet = {}, toSet = me.fieldToKeys(fieldNameOrObject, value), keys = Object.keys(toSet).sort(constructor.fieldSorter), isSyncingDataOnLoad = (_a4 = me.stores) == null ? void 0 : _a4.some((store) => store.isSyncingDataOnLoad);
    let changed = false;
    if (!silent && triggerBeforeUpdate && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }
    me.inSetting = true;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === childrenField) {
        continue;
      }
      if (key.includes("[")) {
        const [, arrayFieldName, index, path] = key.match(arrayRe), field2 = me.fieldMap[arrayFieldName];
        if (field2 == null ? void 0 : field2.getAt) {
          const subRecord = (_c = field2.getAt(me, index)) != null ? _c : (_b = field2.onSubRecordMissingInSet) == null ? void 0 : _b.call(field2, me, index);
          if (subRecord == null) {
            throw new Error(`The store field '${arrayFieldName}' does not contain a record at index ${index} - can not set the data`);
          }
          if (subRecord.isModel) {
            subRecord.set(path, toSet[key]);
          } else {
            ObjectHelper.setPath(subRecord, path, toSet[key]);
          }
          continue;
        }
      }
      const complexKey = key.includes(".");
      if (relations && complexKey) {
        const [, relationName, prop] = key.match(nestedRe);
        if (relations[relationName]) {
          me[relationName].set(prop, toSet[key]);
          continue;
        }
      }
      const field = fieldMap[key], cmp = field || ObjectHelper, readOnly = field == null ? void 0 : field.readOnly, mapping = (_d = field == null ? void 0 : field.dataSource) != null ? _d : key, useProp = !skipAccessors && !field && key in myProto || (field == null ? void 0 : field.useProp), oldValue = useProp ? me[mapping] : (field == null ? void 0 : field.complexMapping) || complexKey ? ObjectHelper.getPath(data, mapping) : data[mapping], value2 = constructor.processField(key, toSet[key], me), val = toSet[key] = { value: value2 }, relation = me.getRelationConfig(key);
      if (!readOnly && (isSyncingDataOnLoad && (field == null ? void 0 : field.bypassEqualityOnSyncDataset) || !cmp.isEqual(oldValue, value2)) && (!validOnly || value2 !== void 0)) {
        me.generation++;
        val.oldValue = (_f = (_e = field == null ? void 0 : field.getOldValue) == null ? void 0 : _e.call(field, me)) != null ? _f : oldValue;
        changed = true;
        if (key in meta.modified && cmp.isEqual(meta.modified[key], value2, false, true)) {
          Reflect.deleteProperty(meta.modified, key);
          if (me.isReverting) {
            me.data[mapping] = value2;
          }
        } else if (!me.ignoreBag) {
          if (!(key in meta.modified) && !(oldValue == null && value2 == null)) {
            me.storeFieldChange(key, oldValue);
          }
          if (val.oldValue === _undefined) {
            Reflect.deleteProperty(val, "oldValue");
          }
        }
        wasSet[key] = val;
        me.applyValue(useProp, mapping, value2, skipAccessors, field);
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach((store) => store.cacheRelatedRecord(me, value2, relation.relationName, val.oldValue));
        }
      }
    }
    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    me.inSetting = false;
    return changed ? wasSet : null;
  }
  // Provided as a hook for Engine to do what needs to be done which ever way a field value is changed
  applyValue(useProp, key, value, skipAccessors, field) {
    var _a4;
    const me = this;
    if (((field == null ? void 0 : field.dataSource) || key) === me.constructor.idField) {
      me.$isPhantom = false;
      me._id = value;
    }
    if (((field == null ? void 0 : field.dataSource) || key) === me.constructor.parentIdField) {
      if (!(((_a4 = me.parent) == null ? void 0 : _a4.isRoot) && (value == null || !me.firstStore.getById(value)))) {
        (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {
          orderedParentIndex: { skip: true }
        });
      }
    } else if (useProp) {
      me[(field == null ? void 0 : field.name) || key] = value;
    } else if (field == null ? void 0 : field.set) {
      field.set(value, me.data, me);
    } else {
      let complexMapping = field == null ? void 0 : field.complexMapping;
      if (!field && key.includes(".")) {
        const nestedName = key.split(".")[0];
        field = me.constructor.fieldMap[nestedName];
        complexMapping = (field == null ? void 0 : field.complexMapping) || (field == null ? void 0 : field.type) === "object";
      }
      if (complexMapping) {
        ObjectHelper.setPath(me.data, key, value);
      } else {
        me.data[key] = value;
      }
    }
  }
  // skipAccessors argument is used in the engine override
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    if (this.stores) {
      for (const store of this.stores) {
        store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
      }
    }
    this.forEachLinked(
      (store, record) => store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors)
    );
  }
  // Run fn for each store on each linked record
  forEachLinked(fn) {
    for (const linked of this.$links) {
      for (const store of linked.stores) {
        fn(store, linked);
      }
    }
  }
  /**
   * This yields `true` if this record is eligible for syncing with the server.
   * It can yield `false` if the record is in the middle of a {@link #property-isBatchUpdating batched update},
   * or if it is a {@link #property-isCreating tentative record} yet to be confirmed as a new addition.
   * @property {Boolean}
   * @readonly
   */
  get isPersistable() {
    return !this.isBatchUpdating && !this.isCreating;
  }
  /**
   * True if this model has any uncommitted changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }
  get hasPersistableChanges() {
    return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);
  }
  /**
   * Returns `true` if this model has uncommitted changes for the provided field.
   * @param {String} fieldName Field name
   * @returns {Boolean} `true` if the field has an uncommitted change
   * @category Editing
   */
  isFieldModified(fieldName) {
    return this.isModified && fieldName in this.meta.modified;
  }
  /**
   * Returns the unmodified value of the field, as in the value it had after the last commit. If the field has not
   * been modified, the current value is returned.
   * @param {String} fieldName Field name
   * @returns {*} The unmodified value of the field, or its current value if not modified
   */
  getUnmodified(fieldName) {
    return this.isModified ? this.meta.modified[fieldName] : this.get(fieldName);
  }
  /**
   * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.
   * @param {String|Core.data.field.DataField} nameOrField Name of the field to get value for, or its field definition
   * @private
   * @category Fields
   */
  getFieldPersistentValue(nameOrField) {
    const field = typeof nameOrField === "string" ? this.getFieldDefinition(nameOrField) : nameOrField, name = (field == null ? void 0 : field.name) || nameOrField;
    let result;
    if (!field || field.persist) {
      result = this.getValue(name);
      if (field == null ? void 0 : field.serialize) {
        result = field.serialize(result, this);
      }
    }
    return result;
  }
  /**
   * Get a map of the modified fields in form of an object. The field *names* are used as the property names
   * in the returned object.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modifications() {
    const data = this.rawModifications;
    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }
    return data;
  }
  get rawModifications() {
    const me = this, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((key) => {
      const value = me.getFieldPersistentValue(key);
      if (value !== _undefined) {
        data[key] = value;
        keySet = true;
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified fields in form of an object. The field´s {@link Core.data.field.DataField#config-dataSource}
   * is used as the property name in the returned object. The record´s id is always included.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationData() {
    const data = this.rawModificationData;
    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.idField, this.id);
    }
    return data;
  }
  /**
   * Returns a map of the modified persistable fields
   * @internal
   * @property {Object}
   * @category Editing
   */
  get rawModificationData() {
    const me = this, { fieldMap } = me.constructor, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((fieldName) => {
      let field = fieldMap[fieldName], dataSource = field == null ? void 0 : field.dataSource;
      if (fieldName.includes(".")) {
        const topLevelFieldName = fieldName.match(nestedRe)[1];
        field = fieldMap[topLevelFieldName];
        dataSource = fieldName;
      }
      if (field == null ? void 0 : field.persist) {
        const value = me.getFieldPersistentValue(fieldName);
        if (value !== _undefined) {
          ObjectHelper.setPath(data, dataSource, value);
          keySet = true;
        }
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified data fields along with any {@link Core/data/field/DataField#config-alwaysWrite} fields,
   * in form of an object. The field´s *dataSource* is used as the property name in the returned object.
   * Used internally by AjaxStore / CrudManager when sending updates.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationDataToWrite() {
    const alwaysWriteFields = this.constructor.alwaysWriteFields, recordData = this.modificationData;
    alwaysWriteFields.forEach((fieldName) => {
      recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);
    });
    return recordData;
  }
  /**
   * Returns data for **all** {@link Core.data.field.DataField#config-persist persistable} fields in form of an
   * object, using dataSource if present.
   * @property {Object}
   * @internal
   * @readonly
   * @category Editing
   */
  get persistableData() {
    const me = this, data = {};
    me.fields.forEach((field) => {
      const value = me.getFieldPersistentValue(field);
      if (value !== _undefined) {
        if (field == null ? void 0 : field.complexMapping) {
          ObjectHelper.setPath(data, field.dataSource, value);
        } else {
          data[field.dataSource] = value;
        }
      }
    });
    return data;
  }
  get dataByFieldName() {
    const { data } = this;
    return this.fields.reduce((result, field) => {
      if (ObjectHelper.hasPath(data, field.dataSource)) {
        result[field.name] = data[field.dataSource];
      }
      return result;
    }, {});
  }
  /**
   * True if this models changes are currently being committed.
   * @property {Boolean}
   * @category Editing
   */
  get isCommitting() {
    return Boolean(this.meta.committing);
  }
  internalClearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {
    var _a4;
    const me = this, { meta } = me;
    if (changes) {
      for (const key in changes) {
        delete meta.modified[key];
      }
    } else {
      meta.modified = {};
    }
    const noChanges = ObjectHelper.isEmpty(meta.modified);
    meta.committing = false;
    if (removeFromStoreChanges) {
      (_a4 = me.stores) == null ? void 0 : _a4.forEach((store) => {
        noChanges && store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          noChanges && store.modified.remove(descendants);
        }
      });
    }
  }
  /**
   * Clears tracked changes, used on commit. Does not revert changes.
   * @param {Boolean} [includeDescendants] Supply `false` to not clear node descendants
   * @category Editing
   */
  clearChanges(includeDescendants) {
    var _a4;
    this.internalClearChanges(includeDescendants);
    (_a4 = this.stores) == null ? void 0 : _a4.forEach((store) => store.trigger("clearChanges", { record: this }));
  }
  storeFieldChange(key, oldValue) {
    this.meta.modified[key] = oldValue;
  }
  /**
   * Reverts changes in this back to their original values.
   * @privateparam {Boolean} [silent] Specify `true` to not trigger events.
   * @category Editing
   */
  revertChanges(silent = false) {
    this.isReverting = true;
    this.set(this.meta.modified, _undefined, silent);
    this.isReverting = false;
  }
  setByDataSource(rawChanges) {
    var _a4;
    const me = this, {
      fieldDataSourceMap
    } = me.constructor, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap), changes = {};
    for (const dataSource in rawChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource], propName = (_a4 = field == null ? void 0 : field.name) != null ? _a4 : dataSource;
      changes[propName] = rawChangesSimplePaths[dataSource];
    }
    return me.set(changes);
  }
  applyChangeset(rawChanges, phantomIdField = "$PhantomId", remote = true) {
    var _a4;
    const me = this, modelClass = me.constructor, {
      idField,
      fieldDataSourceMap
    } = modelClass, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap), ownChangesSimplePaths = ObjectHelper.pathifyKeys(me.modificationData), changes = {}, idChanged = phantomIdField in rawChanges && !(idField in rawChanges);
    if (!idChanged && phantomIdField in rawChangesSimplePaths) {
      delete rawChangesSimplePaths[phantomIdField];
    }
    for (const dataSource in rawChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource], propName = (_a4 = field == null ? void 0 : field.name) != null ? _a4 : dataSource;
      if (remote || ((field == null ? void 0 : field.name) === idField ? idChanged : rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])) {
        changes[propName] = rawChangesSimplePaths[dataSource];
      }
    }
    const wasSet = me.set(changes);
    me.internalClearChanges(false, true, remote ? null : changes);
    return wasSet ? Object.entries(wasSet).reduce((result, [field, change]) => {
      result[field] = change.value;
      return result;
    }, {}) : {};
  }
  //endregion
  //region Id
  /**
   * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.
   * @property {Number}
   * @category Identification
   */
  get internalId() {
    return this._internalId;
  }
  /**
   * Returns true if the record is new and has not been persisted (and received a proper id).
   * @property {Boolean}
   * @readonly
   * @category Identification
   */
  get isPhantom() {
    return this.id === "" || this.id == null || this.hasGeneratedId || Boolean(this.$isPhantom);
  }
  get isModel() {
    return true;
  }
  /**
   * Checks if record has a generated id.
   *
   * New records are assigned a generated id based on a UUID (starting with `_generated`), which is intended to be
   * temporary and should be replaced by the backend on commit.
   *
   * @property {Boolean}
   * @category Identification
   */
  get hasGeneratedId() {
    return typeof this.id === "string" && this.id.startsWith("_generated");
  }
  static generateId(text = this.$$name) {
    return `_generated${text}_${StringHelper.generateUUID()}`;
  }
  /**
   * Generates an id for a new record (a phantom id), based on a UUID (starting with `_generated`).
   *
   * Generated ids are intended to be temporary and should be replaced by the backend on commit.
   *
   * @category Identification
   * @returns {String}
   */
  generateId() {
    return this.constructor.generateId();
  }
  /**
   * Gets the id of specified model or model data object, or the value if passed string/number.
   * @param {Core.data.Model|String|Number} model
   * @returns {String|Number} id
   * @category Identification
   */
  static asId(model) {
    return (model == null ? void 0 : model.isModel) ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;
  }
  //endregion
  //region JSON
  /**
   * Get the records data as a json string.
   *
   * ```javascript
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonString = record.json;
   *
   * //jsonString:
   * '{"title":"Hello","children":[...]}'
   * ```
   *
   * @member {String}
   * @category JSON
   */
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Used by `JSON.stringify()` to correctly convert this record to json.
   *
   * In most cases no point in calling it directly.
   *
   * ```
   * // This will call `toJSON()`
   * const json = JSON.stringify(record);
   * ```
   *
   * If called manually, the resulting object is a clone of `record.data` + the data of any children:
   *
   * ```
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonObject = record.toJSON();
   *
   * // jsonObject:
   * {
   *     title : 'Hello',
   *     children : [
   *         ...
   *     ]
   * }
   * ```
   *
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const { children, unfilteredChildren } = this, jsonData = this.persistableData;
    if (unfilteredChildren || children) {
      jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map((c) => c.toJSON());
    }
    return jsonData;
  }
  /**
   * Represent the record as a string, by default as a JSON string. Tries to use an abbreviated version of the
   * object's data, using id + name/title/text/label/description. If no such field exists, the full data is used.
   *
   * ```javascript
   * const record = new Model({ id : 1, name : 'Steve Rogers', alias : 'Captain America' });
   * console.log(record.toString()); // logs { "id" : 1, "name" : "Steve Rogers" }
   * ```
   *
   * @returns {String}
   * @category JSON
   */
  toString() {
    const me = this, nameField = abbreviationFields.find((field) => field in me.constructor.fieldMap), data = nameField ? { [me.constructor.idField]: me.id, [nameField]: me[nameField] } : me.data;
    return StringHelper.safeJsonStringify(data);
  }
  //endregion
  //region Batch
  /**
   * True if this Model is currently batching its changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isBatchUpdating() {
    return Boolean(this.batching);
  }
  /**
   * Returns `true` if this Model currently has outstanding batched changes for the specified field name.
   * @param {String} fieldName The field name to check for batched updates on.
   * @returns {Boolean}
   * @category Editing
   */
  hasBatchedChange(fieldName) {
    var _a4, _b;
    return (_b = (_a4 = this.meta) == null ? void 0 : _a4.batchChanges) == null ? void 0 : _b[fieldName];
  }
  /**
   * Begin a batch, which stores changes and commits them when the batch ends.
   * Prevents events from being fired during batch.
   *
   * ```javascript
   * record.beginBatch();
   * record.name = 'Mr Smith';
   * record.team = 'Golden Knights';
   * record.endBatch();
   * ```
   *
   * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many
   * cases can replace using a batch:
   *
   * ```javascript
   * record.set({
   *   name : 'Mr Smith',
   *   team : 'Golden Knights'
   * });
   * ```
   * @category Editing
   * @privateparam {Boolean} silentUpdates Suppress firing the `batchUpdatedEvent`
   */
  beginBatch(silentUpdates = false) {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    if (silentUpdates) {
      me.$silenceBatch = (me.$silenceBatch || 0) + 1;
    }
    me.batching++;
  }
  /**
   * End a batch, triggering events if data has changed.
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [silent=false] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [triggerBeforeUpdate=true]
   * @category Editing
  */
  endBatch(silent = false, skipAccessors = false, triggerBeforeUpdate = true) {
    const me = this, { parentIdField } = me.constructor;
    if (!me.batching) {
      return;
    }
    me.batching--;
    me.$silenceBatch && me.$silenceBatch--;
    if (me.batching > 0) {
      return;
    }
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      let { batchChanges } = me.meta;
      me.meta.batchChanges = null;
      if (batchChanges[parentIdField]) {
        batchChanges = { ...batchChanges };
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }
      me.set(batchChanges, _undefined, silent, false, skipAccessors, void 0, triggerBeforeUpdate);
    }
  }
  /**
   * Cancels current batch operation. Any changes during the batch are discarded.
   * @category Editing
   */
  cancelBatch() {
    var _a4;
    if (this.batching) {
      const me = this, { batchChanges } = me.meta, wasSet = {};
      me.batching = null;
      me.meta.batchChanges = null;
      me.generation++;
      if (!me.$silenceBatch) {
        Object.entries(batchChanges).forEach(([key, oldValue]) => {
          wasSet[key] = {
            oldValue,
            value: me[key]
          };
        });
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        (_a4 = me.stores) == null ? void 0 : _a4.forEach(
          (store) => (
            // Cant use event directly, it will get polluted with `source` and then have that incorrect for
            // following calls
            store.trigger("batchedUpdate", { ...event })
          )
        );
        me.forEachLinked(
          (store, record) => store.trigger("batchedUpdate", { ...event, record, records: [record] })
        );
      }
      me.$silenceBatch && me.$silenceBatch--;
    }
  }
  //endregion
  //region Events
  /**
   * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.
   * @param {Object} changes Data changes
   * @returns {Boolean} returns true if data changes are accepted
   * @private
   */
  triggerBeforeUpdate(changes) {
    var _a4;
    return !((_a4 = this.stores) == null ? void 0 : _a4.some((s) => s.trigger("beforeUpdate", { record: this, changes }) === false));
  }
  //endregion
  //region Additional functionality
  /**
   * Makes a copy of this model, assigning the specified id or a generated id and also allowing you to pass field values to
   * the created copy.
   *
   * ```
   * const record = new Model({ name : 'Super model', hairColor : 'Brown' });
   * const clone = record.copy({ name : 'Super model clone' });
   * ```
   * @param {Number|String|Object} [newId] The id for the copied instance, or any field values to apply
   * (overriding the values from the source record). If no id provided, one will be auto-generated
   * @param {Boolean} [deep] True to also clone children
   * @returns {Core.data.Model} Copy of this model
   * @category Editing
   */
  copy(newId = null, deep) {
    const me = this, data = ObjectHelper.clone(me.data), idField = me.constructor.idField, useDeep = ObjectHelper.isObject(deep) ? deep.deep : deep;
    let id;
    if (newId && typeof newId === "object") {
      id = newId[idField];
      Object.assign(data, newId);
    } else {
      id = newId;
    }
    if (useDeep && me.children) {
      data.children = me.children.map((child) => child.copy(newId === false ? false : void 0, deep));
    } else {
      delete data.children;
      delete data.expanded;
    }
    if (me.$meta.fields.initable.length > 0) {
      const json = me.toJSON();
      for (const field of me.$meta.fields.initable) {
        data[field.name] = json[field.name];
      }
    }
    if (newId !== false) {
      data[idField] = id || me.generateId(me.firstStore);
    }
    const copy = new me.constructor(data, null, null, false, true);
    copy.originalInternalId = me.internalId;
    return copy;
  }
  // Copies data using the real field names to trigger setters
  copyData(fromRecord, raw, silent) {
    const propertiesAndValues = {};
    fromRecord.allFields.forEach(({ name: fieldName }) => {
      if (fieldName !== fromRecord.constructor.idField) {
        propertiesAndValues[fieldName] = raw ? fromRecord.get(fieldName) : fromRecord.getValue(fieldName);
      }
    });
    this.set(propertiesAndValues, null, silent);
  }
  /**
   * Removes this record from all stores (and in a tree structure, also from its parent if it has one).
   * @param {Boolean} [silent] Specify `true` to not trigger events. If the event is recurring, occurrences won't be
   * updated automatically.
   * @category Editing
   */
  remove(silent = false) {
    const me = this, { parent, stores } = me;
    if (parent) {
      parent.removeChild(me);
    } else if ((stores == null ? void 0 : stores.length) && !me.isSpecialRow) {
      const storesCopy = stores.slice();
      storesCopy.forEach((s) => s.remove(me, silent, false, true));
    }
  }
  // Called by stores before removing the record from the store. Returning false prevents the removal (overridden in
  // ModelLink.js)
  beforeRemove(stores, records) {
    return super.beforeRemove(stores, records);
  }
  //endregion
  //region Validation
  /**
   * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.
   * @property {Boolean}
   * @category Editing
   */
  get isValid() {
    return true;
  }
  //endregion
  //region Store
  /**
   * Get the first store that this model is assigned to.
   * @property {Core.data.Store}
   * @readonly
   * @category Misc
   */
  get firstStore() {
    var _a4;
    return (_a4 = this.stores) == null ? void 0 : _a4[0];
  }
  /**
   * Joins this record and any children to specified store, if not already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @category Misc
   */
  joinStore(store) {
    var _a4, _b;
    const me = this;
    if (!me.stores || !me.stores.includes(store)) {
      super.joinStore(store);
      store.register(me);
      if (!me.stores) {
        me.stores = [store];
      } else {
        me.stores.push(store);
      }
      if (me.unjoinedStores && me.unjoinedStores.includes(store)) {
        me.unjoinedStores.splice(me.unjoinedStores.indexOf(store), 1);
      }
      ((_a4 = me.children) == null ? void 0 : _a4.length) && me.children.forEach((child) => child.joinStore(store));
      me.constructor.exposedRelations && me.initRelations();
      if (store.tree && !me.isRoot && !((_b = store.stm) == null ? void 0 : _b.isRestoring)) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }
  /**
   * Unjoins this record and any children from specified store, if already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @param {Boolean} [isReplacing] `true` if this record is being replaced
   * @category Misc
   */
  unjoinStore(store, isReplacing = false) {
    var _a4, _b, _c;
    const me = this, { stores } = me;
    if (stores == null ? void 0 : stores.includes(store)) {
      if (!store.isDestroying) {
        store.unregister(me);
        if (!me.unjoinedStores) {
          me.unjoinedStores = [store];
        } else {
          me.unjoinedStores.push(store);
        }
      }
      (_b = (_a4 = me.unfilteredChildren || me.children) == null ? void 0 : _a4.forEach) == null ? void 0 : _b.call(_a4, (child) => child.unjoinStore(store, isReplacing));
      stores.splice(stores.indexOf(store), 1);
      (_c = super.unjoinStore) == null ? void 0 : _c.call(this, store, isReplacing);
      store.uncacheRelatedRecord(me);
    }
  }
  /**
   * Returns `true` if this record is contained in the specified store, or in any store if store param is omitted.
   * @internal
   * @param {Core.data.Store} store Store to check
   * @returns {Boolean}
   * @category Misc
   */
  isPartOfStore(store) {
    var _a4;
    if (store) {
      return store.includes(this);
    }
    return ((_a4 = this.stores) == null ? void 0 : _a4.length) > 0;
  }
  /**
   * Returns true if this record is not part of any store.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get isRemoved() {
    return !this.isPartOfStore();
  }
  //endregion
  //region Per instance meta
  /**
   * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state
   * per grid.
   * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property
   * @private
   * @category Misc
   */
  instanceMeta(instanceOrId) {
    var _a4;
    const { meta } = this, id = instanceOrId.id || instanceOrId;
    return ((_a4 = meta.map) == null ? void 0 : _a4[id]) || this.setInstanceMeta(id, {});
  }
  setInstanceMeta(instanceOrId, value) {
    const { meta } = this, id = instanceOrId.id || instanceOrId;
    if (!meta.map) {
      meta.map = {};
    }
    return meta.map[id] = value;
  }
  /**
   * When called on a group header row returns list of records in that group. Returns `undefined` otherwise.
   * @member {Core.data.Model[]|undefined} groupChildren
   * @category Grouping
   * @readonly
   */
  /**
   * Returns true for a group header record
   * @member {Boolean}
   * @category Grouping
   * @readonly
   */
  get isGroupHeader() {
    return "groupRowFor" in this.meta;
  }
  get isGroupFooter() {
    return "groupFooterFor" in this.meta;
  }
  get isSpecialRow() {
    var _a4;
    return Boolean((_a4 = this.meta) == null ? void 0 : _a4.specialRow);
  }
  get $original() {
    return this.isLinked ? this.proxyMeta.originalRecord : this;
  }
  //endregion
  static get nonPersistableFields() {
    const me = this;
    if (!me._nonPersistableFields) {
      me._nonPersistableFields = {};
      me.allFields.forEach((field) => {
        if (!field.persist || field.calculated) {
          me._nonPersistableFields[field.name] = 1;
        }
      });
    }
    return me._nonPersistableFields;
  }
  static get alwaysWriteFields() {
    const me = this;
    if (!me._alwaysWriteFields) {
      me._alwaysWriteFields = [];
      me.allFields.forEach((field) => {
        if (field.alwaysWrite) {
          me._alwaysWriteFields.push(field.name);
        }
      });
    }
    return me._alwaysWriteFields;
  }
  // Id with spaces and dots replaced by -, for safe usage as an id in DOM
  get domId() {
    return typeof this.id === "string" ? this.id.replace(/[ .]/g, "-") : this.id;
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Convert custom modelClass to string, keeping custom fields
  static toJavaScriptValue(options) {
    const { names } = this.$meta, className = names[names.length - 2], superName = names[names.length - 3];
    return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;
  }
  // Get fields current values
  getCurrentConfig(options) {
    const { data, children } = this, { defaultValues, applyConfigs } = this.constructor, result = applyConfigs ? super.getCurrentConfig(options) : {};
    if (result) {
      for (const field of this.fields) {
        if (field.persist) {
          const value = ObjectHelper.getPath(data, field.dataSource);
          if (value != null && !field.isEqual(value, defaultValues[field.name])) {
            ObjectHelper.setPath(result, field.dataSource, Base.processConfigValue(value, options));
          }
        }
      }
      if (children) {
        if (Array.isArray(children)) {
          result.children = [];
          for (const child of children) {
            result.children.push(child.getCurrentConfig(options));
          }
        } else {
          result.children = children;
        }
      }
      if (this.hasGeneratedId) {
        delete result.id;
      }
      delete result.parentId;
      delete result.parentIndex;
    }
    return result;
  }
  //endregion
};
/**
 * Override in a subclass of Model to define relations to records in other stores.
 *
 * Always defined on the "one" side, not the "many" side.
 *
 * Expects an object where keys are relation names and values are {@link #typedef-RelationConfig relation configs}.
 *
 * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It
 * will point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id
 * matching the players `teamId` field. The team record in turn, will have a field called `players` which is a
 * collection of all players in the team.
 *
 * ```javascript
 * class Player extends Model {
 *     static relations = {
 *         // Define a relation between a player and a team
 *         team : {
 *             foreignKey            : 'teamId',
 *             foreignStore          : 'teamStore',
 *             relatedCollectionName : 'players'
 *         }
 *     }
 * }
 *
 * const teamStore = new Store({
 *     data : [
 *         { id : 1, name : 'Brynas' },
 *         { id : 2, name : 'Leksand' }
 *     ]
 * });
 *
 * const playerStore = new Store({
 *     modelClass : Player,
 *     // Matches foreignStore, allowing records of playerStore to find the related store
 *     teamStore,
 *     data       : [
 *         // teamId is specified as foreignKey, will be used to match the team
 *         { id : 1, name : 'Nicklas Backstrom', teamId : 1  },
 *         { id : 2, name : 'Elias Lindholm',   teamId : 1  },
 *         { id : 3, name : 'Filip Forsberg',  teamId : 2  }
 *     ],
 * }
 *
 * playerStore.first.team.name // > Brynas
 * playerStore.last.team.name // > Leksand
 * teamStore.first.players // > [nick, elias]
 * teamStore.last.players // > [filip]
 * ```
 *
 * To access the related record from the many side, use dot notation for the field name. For example in a Grid
 * column:
 *
 * ```javascript
 * const grid = new Grid({
 *    store : playerStore,
 *    columns : [
 *        { field : 'name', text : 'Name' },
 *        { field : 'team.name', text : 'Team' }
 *    ]
 * });
 * ```
 *
 * @member {Object<String,RelationConfig>} relations
 * @static
 */
__publicField(_Model, "relations", null);
var Model = _Model;
Model._idField = "id";
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = "Model";

// ../Core/lib/Core/helper/util/Formatter.js
var hasOwn4 = Object.hasOwn || ((obj, key) => Object.prototype.hasOwnProperty.call(obj, key));
var cacheKey = null;
function setParser(me, parser) {
  Object.defineProperty(me, "parser", {
    value: parser
  });
  return parser;
}
var Default = class {
  constructor(formatter) {
    this.formatter = formatter;
  }
  format(value) {
    return this.formatter.defaultFormat(value);
  }
  parse(value, strict) {
    return this.formatter.defaultParse(value, strict);
  }
  resolvedOptions() {
    return null;
  }
};
var Formatter = class {
  static get(format) {
    if (format == null) {
      return this.NULL;
    }
    if (format instanceof this) {
      return format;
    }
    const key = typeof format === "string" ? format : JSON.stringify(format), cache = this.cache;
    let fmt = cache.get(key);
    if (!fmt) {
      cacheKey = key;
      fmt = new this(format);
      cache.set(key, fmt);
    }
    return fmt;
  }
  static get cache() {
    return hasOwn4(this, "_cache") && this._cache || (this._cache = /* @__PURE__ */ new Map());
  }
  static get NULL() {
    return hasOwn4(this, "_null") ? this._null : this._null = new this(null);
  }
  constructor(config) {
    const me = this, { standardOptions } = me.constructor;
    me.cacheKey = cacheKey;
    cacheKey = null;
    me.initialize();
    if (config === null) {
      me.formatter = new Default(me);
    } else {
      me.configure(config);
      for (const [key, value] of Object.entries(me.resolvedOptions())) {
        if (value != null && standardOptions.includes(key)) {
          me[key] = value;
        }
      }
    }
  }
  get parser() {
    return setParser(this, new this.constructor.Parser(this));
  }
  defaultFormat(value) {
    return value == null ? value : String(value);
  }
  defaultParse(value) {
    return value;
  }
  format(value) {
    return value == null ? value : this.formatter.format(value);
  }
  parse(value, strict) {
    return value == null ? value : this.parser.parse(value, strict);
  }
  parseStrict(value) {
    return this.parse(value, true);
  }
  resolvedOptions() {
    return this.formatter.resolvedOptions();
  }
};
__publicField(Formatter, "standardOptions", Object.freeze([]));
Formatter._$name = "Formatter";

// ../Core/lib/Core/helper/util/NumberFormat.js
var escapeRegExp = StringHelper.escapeRegExp;
var digitsRe2 = /[\d+-]/g;
var newFormatter = (locale4, config) => new Intl.NumberFormat(locale4 || void 0, config);
var numFormatRe = /^(?:([$])\s*)?(?:(\d+)>)?\d+(,\d+)?(?:\.((\d*)(?:#*)|[*]))?(?:\s*([%])?)?$/;
var unicodeMinus = "\u2212";
var NumberParser = class {
  constructor(formatter) {
    const me = this, locale4 = formatter.locale, numFmt = newFormatter(locale4, {
      maximumFractionDigits: 3
    }), currency = formatter.is.currency ? me._decodeStyle(locale4, {
      style: "currency",
      currency: formatter.currency,
      currencyDisplay: formatter.currencyDisplay
    }) : null, percent = formatter.is.percent ? me._decodeStyle(locale4, {
      style: "percent"
    }) : null, decimal = numFmt.format(1.2).replace(digitsRe2, "")[0], grouper = numFmt.format(1e9).replace(digitsRe2, "")[0] || "";
    Object.assign(me, { currency, decimal, formatter, grouper, percent });
    me.decimal = decimal;
    me.decimalRe = escapeRegExp(decimal, "g");
    me.grouper = grouper;
    me.stripRe = new RegExp(
      `(?:\\s+|${escapeRegExp(grouper)})` + (currency ? `|(?:${escapeRegExp(currency.text)})` : "") + (percent ? `|(?:${escapeRegExp(percent.text)})` : ""),
      "g"
    );
  }
  decimalPlaces(value) {
    value = value.replace(this.stripRe, "");
    const dot = value.indexOf(this.decimal) + 1;
    return dot && value.length - dot;
  }
  parse(value, strict) {
    if (typeof value === "string") {
      value = value.replace(this.stripRe, "").replace(this.decimalRe, ".").replace(unicodeMinus, "-");
      value = strict ? Number(value) : parseFloat(value);
      if (this.formatter.is.percent) {
        value /= 100;
      }
    }
    return value;
  }
  _decodeStyle(locale4, fmtDef) {
    const fmt = newFormatter(locale4, fmtDef), decFmt = newFormatter(locale4, Object.assign(
      fmt.resolvedOptions(),
      { style: "decimal" }
    )), zero = fmt.format(0), zeroDec = decFmt.format(0);
    return {
      suffix: zero.startsWith(zeroDec),
      text: zero.replace(zeroDec, "").trim()
    };
  }
};
var _NumberFormat = class _NumberFormat extends Formatter {
  static get $name() {
    return "NumberFormat";
  }
  initialize() {
    this._as = {
      // cacheKey : cachedInstance
    };
    this.is = {
      decimal: false,
      currency: false,
      percent: false,
      null: true,
      from: null
    };
  }
  get truncator() {
    const scale = this.maximumFractionDigits, digits = Math.min(20, scale + 1);
    return scale == null ? null : this.as({ style: "decimal", maximumFractionDigits: digits, minimumFractionDigits: digits }, "truncator");
  }
  configure(options) {
    if (typeof options !== "string") {
      Object.assign(this, options);
    } else {
      this.template = options;
    }
    const me = this, config = {}, loc = me.locale ? LocaleManager_default.locales[me.locale] : LocaleManager_default.locale, localeDefaults = loc == null ? void 0 : loc.NumberFormat, { template } = me, { standardOptions } = me.constructor;
    if (localeDefaults) {
      for (const key in localeDefaults) {
        if (me[key] == null && typeof localeDefaults[key] !== "function") {
          me[key] = localeDefaults[key];
        }
      }
    }
    if (template) {
      const match = numFormatRe.exec(template), m2 = match[2], m4 = match[4];
      me.useGrouping = !!match[3];
      me.style = match[1] ? "currency" : match[6] ? "percent" : "decimal";
      if (m2) {
        me.integer = +m2;
      }
      if (m4 === "*") {
        me.fraction = [0, 20];
      } else if (m4 != null) {
        me.fraction = [match[5].length, m4.length];
      }
    }
    me._minMax("fraction", true, true);
    me._minMax("integer", true, false);
    me._minMax("significant", false, true);
    for (const key of standardOptions) {
      if (me[key] != null) {
        config[key] = me[key];
      }
    }
    me.is.from = me.from && me.from.is;
    me.is[me.style] = !(me.is.null = false);
    me.formatter = newFormatter(me.locale, config);
  }
  /**
   * Creates a derived `NumberFormat` from this instance, with a different `style`. This is useful for processing
   * currency and percentage styles without the symbols being injected in the formatting.
   *
   * @param {String|Object} change The new style (if a string) or a set of properties to update.
   * @param {String} [cacheAs] A key by which to cache this derived formatter.
   * @returns {Core.helper.util.NumberFormat}
   */
  as(change, cacheAs = null) {
    const config = this.resolvedOptions() || { template: "9.*" }, cache = this._as;
    let ret = cacheAs && cache[cacheAs];
    if (!ret) {
      if (typeof change === "string") {
        config.style = change;
      } else {
        Object.assign(config, change);
      }
      config.from = this;
      ret = new _NumberFormat(config);
    }
    if (cacheAs) {
      cache[cacheAs] = ret;
    }
    return ret;
  }
  defaultParse(value, strict) {
    return value == null ? value : strict ? Number(value) : parseFloat(value);
  }
  /**
   * Returns the given `value` formatted in accordance with the specified locale and
   * formatting options.
   *
   * @param {Number} value
   * @returns {String}
   */
  format(value) {
    if (typeof value === "string") {
      const v = Number(value);
      value = isNaN(v) ? this.parse(value) : v;
    }
    return super.format(value);
  }
  // The parse() method is inherited but the base class implementation
  // cannot properly document the parameter and return types:
  /**
   * Returns a `Number` parsed from the given, formatted `value`, in accordance with the
   * specified locale and formatting options.
   *
   * If the `value` cannot be parsed, `NaN` is returned.
   *
   * Pass `strict` as `true` to require all text to convert. In essence, the default is
   * in line with JavaScript's `parseFloat` while `strict=true` behaves like the `Number`
   * constructor:
   *```
   *  parseFloat('1.2xx');  // = 1.2
   *  Number('1.2xx')       // = NaN
   *```
   * @method parse
   * @param {String} value
   * @param {Boolean} [strict=false]
   * @returns {Number}
   */
  /**
   * Returns a `Number` parsed from the given, formatted `value`, in accordance with the
   * specified locale and formatting options.
   *
   * If the `value` cannot be parsed, `NaN` is returned.
   *
   * This method simply passes the `value` to `parse()` and passes `true` for the second
   * argument.
   *
   * @method parseStrict
   * @param {String} value
   * @returns {Number}
   */
  /**
   * Returns the given `Number` rounded in accordance with the specified locale and
   * formatting options.
   *
   * @param {Number|String} value
   * @returns {Number}
   */
  round(value) {
    return this.parse(this.format(value));
  }
  /**
   * Returns the given `Number` truncated to the `maximumFractionDigits` in accordance
   * with the specified locale and formatting options.
   *
   * @param {Number|String} value
   * @returns {Number}
   */
  truncate(value) {
    const me = this, scale = me.maximumFractionDigits, { truncator } = me;
    let v = me.parse(value), dot;
    if (truncator) {
      v = truncator.format(v);
      dot = v.indexOf(truncator.parser.decimal);
      if (dot > -1 && v.length - dot - 1 > scale) {
        v = v.slice(0, dot + scale + 1);
      }
      v = truncator.parse(v);
    }
    return v;
  }
  resolvedOptions() {
    const options = super.resolvedOptions();
    for (const key in options) {
      if (options[key] === void 0) {
        options[key] = this[key];
      }
    }
    return options;
  }
  /**
   * Expands the provided shorthand into the "minimum*Digits" and "maximum*Digits".
   * @param {String} name
   * @param {Boolean} setMin
   * @param {Boolean} setMax
   * @private
   */
  _minMax(name, setMin, setMax) {
    const me = this, value = me[name];
    if (value != null) {
      const capName = StringHelper.capitalize(name), max = `maximum${capName}Digits`, min2 = `minimum${capName}Digits`;
      if (typeof value === "number") {
        if (setMin) {
          me[min2] = value;
        }
        if (setMax) {
          me[max] = value;
        }
      } else {
        me[min2] = value[0];
        me[max] = value[1];
      }
    }
  }
};
// This object holds only those properties that Intl.NumberFormat accepts in its
// "options" parameter. Only these options will be copied from the NumberFormat
// and passed to the Intl.NumberFormat constructor and only these will be copied
// back from its resolvedOptions:
__publicField(_NumberFormat, "standardOptions", [
  "currency",
  "currencyDisplay",
  "locale",
  "maximumFractionDigits",
  "minimumFractionDigits",
  "minimumIntegerDigits",
  "maximumSignificantDigits",
  "minimumSignificantDigits",
  "style",
  "useGrouping"
]);
var NumberFormat = _NumberFormat;
NumberFormat.Parser = NumberParser;
Object.assign(NumberFormat.prototype, {
  /**
   * The currency to use when using `style: 'currency'`. For example, `'USD'` (US dollar)
   * or `'EUR'` for the euro.
   *
   * If not provided, the {@link Core.localization.LocaleManager} default will be used.
   * @config {String}
   */
  currency: null,
  /**
   * The format in which to display the currency value when using `style: 'currency'`.
   *
   * Valid values are: `'symbol'` (the default), `'code'`, and `'name'`.
   * @config {'symbol'|'code'|'name'}
   * @default
   */
  currencyDisplay: "symbol",
  /**
   * Specifies the `minimumFractionDigits` and `maximumFractionDigits` in a compact
   * way. If this value is a `Number`, it sets both the minimum and maximum to that
   * value. If this value is an array, `[0]` sets the minimum and `[1]` sets the
   * maximum.
   * @config {Number|Number[]}
   */
  fraction: null,
  from: null,
  /**
   * An alias for `minimumIntegerDigits`.
   * @config {Number}
   */
  integer: null,
  /**
   * The name of the locale. For example, `'en-US'`. This config is the same as the
   * first argument to the `Intl.NumberFormat` constructor.
   *
   * Defaults to the browser's default locale.
   * @config {String}
   */
  locale: null,
  /**
   * The maximum number of digits following the decimal.
   *
   * This is more convenient to specify using the {@link #config-fraction} config.
   * @config {Number}
   */
  maximumFractionDigits: null,
  /**
   * The minimum number of digits following the decimal.
   *
   * This is more convenient to specify using the {@link #config-fraction} config.
   * @config {Number}
   */
  minimumFractionDigits: null,
  /**
   * The minimum number of digits preceding the decimal.
   *
   * This is more convenient to specify using the {@link #config-integer} config.
   * @config {Number}
   */
  minimumIntegerDigits: null,
  /**
   * The maximum number of significant digits.
   *
   * This is more convenient to specify using the {@link #config-significant} config.
   * @config {Number}
   */
  maximumSignificantDigits: null,
  /**
   * The minimum number of significant digits.
   *
   * This is more convenient to specify using the {@link #config-significant} config.
   * @config {Number}
   */
  minimumSignificantDigits: null,
  /**
   * Specifies the `minimumSignificantDigits` and `maximumSignificantDigits` in a compact
   * format. If this value is a `Number`, it sets only the maximum to that value. If this
   * value is an array, `[0]` sets the minimum and `[1]` sets the maximum.
   *
   * If this value (or `minimumSignificantDigits` or `minimumSignificantDigits`) is set,
   * `integer` (and `minimumIntegerDigits`) and `fraction` (and `minimumFractionDigits`
   * and `minimumFractionDigits`) are ignored.
   *
   * @config {Number|Number[]}
   */
  significant: null,
  /**
   * The formatting style.
   *
   * Valid values are: `'decimal'` (the default), `'currency'`, and `'percent'`.
   * @config {'decimal'|'currency'|'percent'}
   * @default
   */
  style: "decimal",
  /**
   * A format template consisting of the following parts:
   *```
   *  [$] [\d+:] \d+ [,\d+] [.\d* [#*] | *] [%]
   *```
   * If the template begins with a `'$'`, the formatter's `style` option is set to
   * `'currency'`. If the template ends with `'%'`, `style` is set to `'percent'`.
   * It is invalid to include both characters. When using `'$'`, the `currency` symbol
   * defaults to what is provided by the {@link Core.localization.LocaleManager}.
   *
   * To set the `minimumIntegerDigits`, the desired minimum comes before the first
   * digits in the template and is followed by a `'>'` (greater-than). For example:
   *```
   *  5>9,999.00
   *```
   * The above sets `minimumIntegerDigits` to 5.
   *
   * The `useGrouping` option is enabled if there is a `','` (comma) present and is
   * disabled otherwise.
   *
   * If there is a `'.'` (decimal) present, it may be followed by either of:
   *
   *  - Zero or more digits which may then be followed by zero or more `'#'` characters.
   *    The number of digits determines the `minimumFractionDigits`, while the total
   *    number of digits and `'#'`s determines the `maximumFractionDigits`.
   *  - A single `'*'` (asterisk) indicating any number of fractional digits (no minimum
   *    or maximum).
   *
   * @config {String}
   */
  template: null,
  /**
   * Specify `false` to disable thousands separators.
   * @config {Boolean}
   * @default
   */
  useGrouping: true
});
Formatter.number = (format, value) => NumberFormat.get(format).format(value);
LocaleManager_default.ion({
  locale: () => NumberFormat.cache.clear()
});
NumberFormat._$name = "NumberFormat";

// ../Core/lib/Core/data/Duration.js
var Duration = class _Duration {
  /**
   * Duration constructor.
   * @function constructor
   * @param {Number|String} magnitude Duration magnitude value or a duration + magnitude string ('2h', '4d')
   * @param {DurationUnit} [unit] Duration unit value
   * @category Lifecycle
   */
  constructor(magnitude, unit) {
    if (typeof magnitude === "number" || magnitude === null) {
      this._magnitude = magnitude;
      this._unit = unit;
    } else {
      if (typeof magnitude === "string") {
        Object.assign(this, DateHelper.parseDuration(magnitude));
      }
      if (typeof magnitude === "object") {
        Object.assign(this, magnitude);
      }
    }
  }
  /**
   * Get/Set numeric magnitude `value`.
   * @property {Number}
   */
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(value) {
    this._magnitude = typeof value === "number" && value;
  }
  /**
   * Get/set duration unit to use with the current magnitude value.
   * Valid values are:
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * @member {DurationUnit}
   */
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }
  get isValid() {
    return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));
  }
  /**
   * The `milliseconds` property is a read only property which returns the number of milliseconds in this Duration
   * @property {Number}
   * @readonly
   */
  get milliseconds() {
    return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;
  }
  /**
   * Returns truthy value if this Duration equals the passed value.
   * @param {Core.data.Duration} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;
  }
  /**
   * Returns a readable localized representation of this Duration (e.g. 5 days).
   * @param {Boolean} useAbbreviation Pass `true` to return an abbreviated version (e.g. 5 d)
   * @returns {String}
   */
  toString(useAbbreviation) {
    const me = this, abbreviationFn = useAbbreviation ? "getShortNameOfUnit" : "getLocalizedNameOfUnit";
    return me.isValid ? `${NumberFormat.get("9.#").format(me._magnitude)} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : "";
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.milliseconds;
  }
  diff(otherDuration) {
    return new _Duration({
      unit: this.unit,
      magnitude: DateHelper.as(this.unit, this.milliseconds - otherDuration.milliseconds)
    });
  }
};
Duration._$name = "Duration";

// ../Core/lib/Core/util/CollectionFilter.js
var nestedValueReducer = (object, path) => object == null ? void 0 : object[path];
var relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i;
var relativeDateOperators = [
  "isToday",
  "isTomorrow",
  "isYesterday",
  "isThisWeek",
  "isNextWeek",
  "isLastWeek",
  "isThisMonth",
  "isNextMonth",
  "isLastMonth",
  "isThisYear",
  "isNextYear",
  "isLastYear",
  "isYearToDate"
];
var _CollectionFilter = class _CollectionFilter extends Base.mixin(Identifiable_default) {
  static get defaultConfig() {
    return {
      /**
       * The value against which to compare the {@link #config-property} of candidate objects.
       * @config {*}
       */
      value: null,
      /**
       * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
       * @config {CollectionCompareOperator}
       */
      operator: null,
      /**
       * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
       * accepts a candidate object and returns `true` or `false`
       * @config {Function}
       * @param {*} data Data object for filtering
       * @returns {Boolean}
       */
      filterBy: null,
      /**
       * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and
       * returns the value which the filter should use to compare against its {@link #config-value}.
       * @config {Function}
       * @param {*} value
       * @returns {*}
       */
      convert: null,
      /**
       * Configure as `false` to have string comparisons case insensitive.
       * @config {Boolean}
       * @default
       */
      caseSensitive: true,
      /**
       * The `id` of this Filter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      // Type is required to process the Date value in State API. Store doesn't always know about field type to
      // process filter value, when it applies it from the state, e.g. when you don't declare model field as `date`
      // type but provide a Date instance there. When DateColumn is used to shows this field, it could add date
      // filters to the store. When store is applying state it cannot just infer type, because model doesn't
      // declare it. Only column knows. So to properly process the Date instance for the filter State API would
      // have to process the field additionally, checking model field type and column type. So it is simpler to
      // make Filter to put this information. That way when filter is instantiated by the store, it can gracefully
      // handle value processing, converting date string to the Date instance.
      // Date is the only known value type so far which requires this processing.
      type: null,
      /**
       * Setting the `internal` config on a filter means that it is a fixed part of your store's operation.
       *
       * {@link Core.data.Store#function-clearFilters} does not remove `internal` filters. If you add an
       * `internal` filter, you must explicitly remove it if it is no longer required.
       *
       * Grid features which offer column-based filtering do *not* ingest existing store filters on
       * their data field if the filter is `internal`
       * @config {Boolean}
       * @default false
       */
      internal: null,
      /**
       * When `true`, the filter will not be applied.
       * @config {Boolean}
       * @default
       */
      disabled: false
    };
  }
  static get configurable() {
    return {
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @member {String} property
       */
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @config {String}
       */
      property: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        filterBy: config
      };
    }
    if (!config.type) {
      if (DateHelper.isDate(config.value) || Array.isArray(config.value) && config.value.every(DateHelper.isDate)) {
        config.type = "date";
      } else if (config.value instanceof Duration) {
        config.type = "duration";
      }
    } else {
      if (config.type === "date" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Date(config.value);
      } else if (config.type === "duration" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Duration(config.value);
      }
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Filters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    if (!this._id) {
      if (this.internal) {
        this._id = _CollectionFilter.generateId(`b-internal-${this.property}-filter-`);
      } else {
        this._id = this.property || _CollectionFilter.generateId("b-filter-");
      }
    }
    return this._id;
  }
  set id(id) {
    this._id = id;
  }
  onChange(propertyChanged) {
    var _a4;
    const me = this;
    if (!me.isConfiguring && ((_a4 = me.owner) == null ? void 0 : _a4.onFilterChanged) && !me.owner.isConfiguring) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }
  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }
  /**
   * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
   * accepts a candidate object and returns `true` or `false`
   * @type {Function}
   * @param {*} data Data object for filtering
   * @returns {Boolean} Returns `true` for data valid for including
   */
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }
  defaultFilterBy(candidate) {
    const me = this;
    let candidateValue;
    if (candidate.isModel) {
      candidateValue = candidate.getValue(me.property);
    } else if (me._propertyItems.length > 1) {
      candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);
    } else {
      candidateValue = candidate[me.property];
    }
    return me[me.operator](me.convert(candidateValue));
  }
  updateProperty(property) {
    this._propertyItems = property.split(".");
    this.onChange("property");
  }
  /**
   * The value against which to compare the {@link #config-property} of candidate objects.
   * @type {*}
   */
  set value(value) {
    const me = this;
    me._value = value;
    if (Array.isArray(value) && ({ date: 1, duration: 1 }[me.type] || value.length > 0 && typeof value[0] === "string")) {
      me._filterValue = value.map((v) => me.convert(v));
    } else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === "string") {
      me._filterValue = value.map((s) => s == null ? void 0 : s.toLowerCase());
    } else if (!me.caseSensitive && typeof value === "string") {
      me._filterValue = value.toLowerCase();
    } else {
      me._filterValue = me.convert(value);
    }
    me.onChange("value");
  }
  get value() {
    return this._value;
  }
  get filterValue() {
    return this._filterValue;
  }
  /**
   * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
   * @type {CollectionCompareOperator}
   */
  set operator(operator) {
    this._operator = operator;
    this.onChange("operator");
  }
  get operator() {
    const me = this;
    if (me._operator) {
      return me._operator;
    }
    if (Array.isArray(me.filterValue)) {
      return "isIncludedIn";
    }
    return typeof me.filterValue === "string" ? "*" : "=";
  }
  convert(value) {
    var _a4;
    if (this.operator !== "sameTime" && !(typeof this.filterValue === "string" && value instanceof Date)) {
      if (this.operator === "sameDay") {
        value = DateHelper.clearTime(value);
      }
      value = (_a4 = value == null ? void 0 : value.valueOf()) != null ? _a4 : value;
    }
    value = !this.caseSensitive && typeof value === "string" ? value.toLowerCase() : value;
    return value;
  }
  filter(candidate) {
    return this.filterBy(candidate);
  }
  startsWith(v) {
    return String(v).startsWith(this.filterValue);
  }
  endsWith(v) {
    return String(v).endsWith(this.filterValue);
  }
  isIncludedIn(v) {
    return this.filterValue.length === 0 || this.filterValue.includes(v);
  }
  isNotIncludedIn(v) {
    return !this.isIncludedIn(v);
  }
  includes(v) {
    return this.filterValue.length === 0 || String(v).includes(this.filterValue);
  }
  doesNotInclude(v) {
    return !this.includes(v);
  }
  sameTime(v) {
    return DateHelper.isSameTime(v, this.filterValue);
  }
  sameDay(v) {
    return v === this.filterValue;
  }
  "="(v) {
    return ObjectHelper.isEqual(v, this.filterValue);
  }
  "!="(v) {
    return !ObjectHelper.isEqual(v, this.filterValue);
  }
  ">"(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue);
  }
  ">="(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "<"(v) {
    return ObjectHelper.isLessThan(v, this.filterValue);
  }
  "<="(v) {
    return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "*"(v) {
    return ObjectHelper.isPartial(v, this.filterValue);
  }
  between(v) {
    const [start, end] = this._filterValue;
    return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) && (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));
  }
  notBetween(v) {
    return !this.between(v);
  }
  empty(v) {
    return v === void 0 || v === null || String(v).length === 0;
  }
  notEmpty(v) {
    return !this.empty(v);
  }
  isToday(v) {
    return this.between(v);
  }
  isTomorrow(v) {
    return this.between(v);
  }
  isYesterday(v) {
    return this.between(v);
  }
  isThisWeek(v) {
    return this.between(v);
  }
  isNextWeek(v) {
    return this.between(v);
  }
  isLastWeek(v) {
    return this.between(v);
  }
  isThisMonth(v) {
    return this.between(v);
  }
  isNextMonth(v) {
    return this.between(v);
  }
  isLastMonth(v) {
    return this.between(v);
  }
  isThisYear(v) {
    return this.between(v);
  }
  isNextYear(v) {
    return this.between(v);
  }
  isLastYear(v) {
    return this.between(v);
  }
  isYearToDate(v) {
    return this.between(v);
  }
  isTrue(v) {
    return v === true;
  }
  isFalse(v) {
    return v === false;
  }
  // Fill in actual dates relative to now
  setRelativeDateValues() {
    this._filterValue = _CollectionFilter.getRelativeDateRange(this._operator).map((date) => date.valueOf());
  }
  static getRelativeDateRange(relativeExpr, now2 = /* @__PURE__ */ new Date()) {
    let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;
    switch (relativeExpr) {
      case "isYearToDate":
        return [DateHelper.floor(now2, "1 year"), now2];
      case "isToday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [todayStart, DateHelper.add(todayStart, 1, "day")];
      case "isYesterday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [DateHelper.add(todayStart, -1, "day"), todayStart];
      case "isTomorrow":
        tomorrowStart = DateHelper.getStartOfNextDay(now2);
        return [tomorrowStart, DateHelper.add(tomorrowStart, 1, "day")];
      case "isThisWeek":
      case "isNextWeek":
      case "isLastWeek":
      case "isThisMonth":
      case "isNextMonth":
      case "isLastMonth":
      case "isThisYear":
      case "isNextYear":
      case "isLastYear":
        parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);
        if (!parts) {
          throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);
        }
        [, which, timeUnit] = parts;
        oneTimeUnit = `1 ${timeUnit}`;
        unitStart = DateHelper.floor(now2, oneTimeUnit);
        if (which === "next") {
          unitStart = DateHelper.add(unitStart, 1, timeUnit);
        } else if (which === "last") {
          unitStart = DateHelper.add(unitStart, -1, timeUnit);
        }
        return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];
    }
  }
  /**
   * Generates a filter function based on provided collection filters.
   * @advanced
   * @param {Core.util.CollectionFilter[]|Core.util.Collection} filters Filters used for creating a filtering function
   * @returns {Function} Returns a filter function
   */
  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }
    for (const filter of filters) {
      if (filter.type === "date" && relativeDateOperators.includes(filter._operator)) {
        filter.setRelativeDateValues();
      }
    }
    return function(candidate) {
      let match = true;
      for (const filter of filters) {
        if (!filter.disabled) {
          match = filter.filter(candidate);
        }
        if (!match) {
          break;
        }
      }
      return match;
    };
  }
};
__publicField(_CollectionFilter, "$name", "CollectionFilter");
var CollectionFilter = _CollectionFilter;
CollectionFilter._$name = "CollectionFilter";

// ../Core/lib/Core/helper/IdHelper.js
var idCounts2 = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var IdHelper = class {
  /**
   * Generate a new id, using IdHelpers internal counter and a prefix
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts2[prefix] = (idCounts2[prefix] || 0) + 1);
  }
};
IdHelper._$name = "IdHelper";

// ../Core/lib/Core/util/CollectionSorter.js
var CollectionSorter = class extends Base {
  static get defaultConfig() {
    return {
      /**
       * The name of a property of collection objects which yields the value to sort by.
       * @config {String}
       */
      property: null,
      /**
       * The direction to sort in, `'ASC'` or `'DESC'`
       * @config {'ASC'|'DESC'}
       * @default
       */
      direction: "ASC",
      /**
       * A function which takes the place of using {@link #config-property} and {@link #config-direction}.
       * The function is passed two objects from the collection to compare and must return the comparison result.
       * @config {Function}
       * @param {*} first The first value to compare
       * @param {*} second The second value to compare
       * @returns {Number}  Returns `1` if first value is greater than second value, `-1` if the opposite is true or `0` if they're equal
       */
      sortFn: null,
      /**
       * When using {@link #config-property}, this may be specified as a function which takes the raw
       * property value and returns the value to actually sort by.
       * @config {Function}
       * @param {*} value
       * @returns {*}
       */
      convert: null,
      /**
       * The `id` of this Sorter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting performance. For more info on `localeCompare()`, see
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * ```javascript
       * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       */
      useLocaleSort: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        sortFn: config
      };
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId("b-sorter"));
  }
  set id(id) {
    this._id = id;
  }
  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }
  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }
  /**
   * Default sortFn used when no sortFn specified. Uses the {@link #config-property},
   * {@link #config-direction}, and {@link #config-convert}.
   * @private
  */
  defaultSortFn(lhs, rhs) {
    const me = this, { convert, property, useLocaleSort } = me, multiplier = me.direction.toLowerCase() === "desc" ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];
    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }
    if (useLocaleSort && lhs != null && rhs != null && typeof lhs === "string") {
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }
      if (typeof useLocaleSort === "string") {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }
      if (typeof useLocaleSort === "object") {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }
    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }
  static generateSortFunction(sorters, tieBreaker) {
    const items2 = sorters.isCollection ? sorters.values : sorters, n = items2.length;
    return (lhs, rhs) => {
      let comp, i;
      for (i = 0; i < n; ++i) {
        comp = items2[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }
      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
};
CollectionSorter._$name = "CollectionSorter";

// ../Core/lib/Core/util/Collection.js
var return0 = () => 0;
var reverseNumericSortFn = (a, b) => b - a;
var filteredIndicesProperty = Symbol("filteredIndicesProperty");
var emptyArray4 = Object.freeze([]);
var sortEvent = Object.freeze({
  action: "sort",
  added: emptyArray4,
  removed: emptyArray4,
  replaced: emptyArray4
});
var filterEvent = Object.freeze({
  action: "filter",
  added: emptyArray4,
  removed: emptyArray4,
  replaced: emptyArray4
});
var keyTypes = {
  string: 1,
  number: 1
};
function addItemToIndex(item, index, key, detectDuplicates) {
  if (index.unique !== false) {
    index.set(key, item);
    if (detectDuplicates) {
      index.count++;
    }
  } else {
    let set = index.get(key);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      index.set(key, set);
    }
    set.add(item);
  }
}
function removeItemFromIndex(item, index, key) {
  if (index.unique !== false) {
    index.delete(key);
  } else if (index.has(key)) {
    index.get(key).delete(item);
    if (!index.get(key).size) {
      index.delete(key);
    }
  }
}
function doRebuildIndices(values, indices, keyProps, indexCount, ignoreDetectDuplicates = false) {
  for (let i = 0; i < values.length; i++) {
    const item = values[i];
    for (let j = 0; j < indexCount; j++) {
      const keyProp = keyProps[j], key = item[keyProp], index = indices[keyProp];
      key !== void 0 && addItemToIndex(item, index, key, !ignoreDetectDuplicates && index.onDuplicate);
    }
  }
}
var Collection = class _Collection extends Base.mixin(Events_default) {
  constructor() {
    super(...arguments);
    __publicField(this, "_sortFunction", null);
    __publicField(this, "_addedValues", null);
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Specify the name of the property of added objects which provides the lookup key
       * @config {String}
       * @default
       */
      idProperty: "id",
      /**
       * Specify the names or index configs of properties which are to be indexed for fast lookup.
       *
       * Index configs use the format `{ property : string, unique : boolean }`. Unique indices stores one index
       * per entry, non-unique stores a `Set`. If left out, `unique` defaults to `true`
       *
       * @config {String[]|Object[]}
       * @property {String} property Property to index by
       * @property {Boolean} [unique=true] `true` for unique keys (~primary keys), `false` for non-unique keys
       * (~foreign keys)
       */
      extraKeys: null,
      /**
       * Automatically apply filters on item add.
       * @config {Boolean}
       * @default
       */
      autoFilter: true,
      /**
       * Automatically apply sorters on item add.
       * @config {Boolean}
       * @default
       */
      autoSort: true,
      /**
       * A {@link Core.util.CollectionSorter Sorter}, or Sorter config object, or
       * an array of these, to use to sort this Collection.
       * @config {CollectionSorterConfig[]}
       * @default
       */
      sorters: {
        $config: ["lazy"],
        value: []
      }
    };
  }
  get isCollection() {
    return true;
  }
  //endregion
  //region Init & destroy
  construct(config) {
    this.generation = 0;
    this._values = [];
    super.construct(config);
  }
  doDestroy() {
    var _a4;
    super.doDestroy();
    const me = this;
    me._values.length = 0;
    if (me.isFiltered) {
      me._filteredValues.length = 0;
      me.filters.destroy();
    }
    (_a4 = me._sorters) == null ? void 0 : _a4.destroy();
  }
  //endregion
  //region "CRUD"
  /**
   * Clears this collection.
   */
  clear() {
    const me = this, removed = me._values.slice();
    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;
      me.generation++;
      me.trigger("change", {
        action: "clear",
        removed
      });
    }
  }
  /**
   * Compares the content of this Collection with the content of the passed Collection or
   * with the passed array. Order insensitive. This returns `true` if the two objects passed
   * contain the same set of items.
   * @param {Core.util.Collection|Array} other The Collection or array to compare with.
   * @param {Function} [map] Optionally a function to convert the items into a comparable object
   * to compare. For example `item => item.id` could be used to compare the ids of the
   * constituent items.
   * @returns {Boolean} `true` if the two objects passed have the same content.
   */
  equals(other, map) {
    if (other.isCollection) {
      other = other.values;
    }
    if (other.length === this.count) {
      let { values } = this;
      if (map) {
        other = other.map(map);
        values = values.map(map);
      }
      return ArrayHelper.delta(other, values).inBoth.length === this.count;
    }
    return false;
  }
  /**
   * Replaces the internal `values` array with the passed `values`, or `filteredValues` array with the passed `filteredValues`.
   * If `filteredValues` are not passed explicitly, but storage is filtered, decides internally `values` or `filteredValues` should
   * be replaced by passed `values`.
   *
   * Note that this takes ownership of the array, and the array must not be mutated by outside code.
   *
   * This is an internal utility method, not designed for use by application code.
   *
   * @param {Object} params Values and parameters to replace
   * @param {Object[]} params.values The new `values` array
   * @param {Object[]} [params.filteredValues] The new `filteredValues` array. Applicable only when storage is filtered.
   * @param {Boolean} [params.silent=false] If true, `change` event will not be fired
   * @param {Boolean} [params.isNewDataset=false] If true, `values` is a new dataset
   * @fires change
   * @internal
   */
  replaceValues({ values, filteredValues, silent = false, isNewDataset = false }) {
    const me = this;
    let replacedValues, replacedFilteredValues;
    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);
      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      } else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }
      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;
      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
      } else if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;
    me._addedValues = void 0;
    me.generation++;
    if (!silent) {
      me.trigger("change", {
        action: "replaceValues",
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }
  set values(values) {
    this.invalidateIndices();
    this.splice(0, this._values.length, values);
  }
  /**
   * The set of values of this Collection. If this Collection {@link #property-isFiltered},
   * this yields the filtered data set.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }
  /**
   * The set of filtered values of this Collection (those matching the current filters).
   * @property {Object[]}
   * @private
   */
  get filteredValues() {
    return this._filteredValues;
  }
  /**
   * Iterator that allows you to do `for (const item of collection)`
   */
  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }
  /**
   * Executes the passed function for each item in this Collection, passing in the item,
   * ths index, and the full item array.
   * @param {Function} fn The function to execute.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.
   */
  forEach(fn, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);
  }
  /**
   * Extracts ths content of this Collection into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @returns {Object[]} An array of values extracted from this Collection.
   */
  map(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);
  }
  /**
   * Returns an accumulated value based on the passed function similar to `Array.reduce`.
   * @param {Function} fn A function, which, when passed an accumulator value and an item, returns the new accumulator value.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @param {*} [accumulator=[]] The initial value of the accumulator.
   * @returns {*} the final accumulator value.
   */
  reduce(fn, ignoreFilters = false, accumulator = []) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).reduce(fn, accumulator);
  }
  /**
   * Returns the first item in this Collection which elicits a *truthy* return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);
  }
  get first() {
    return this.values[0];
  }
  get last() {
    return this.values[this.count - 1];
  }
  /**
   * The set of all values of this Collection regardless of filters applied.
   * @readonly
   * @property {Object[]}
   */
  get allValues() {
    return this._values;
  }
  /**
   * The set of values added to this Collection since the last sort or replaceValues operation.
   * @private
   * @readonly
   * @property {Object[]}
   */
  get addedValues() {
    return this._addedValues;
  }
  /**
   * This method ensures that every item in this Collection is replaced by the matched by
   * `id` item in the other Collection.
   *
   * By default, any items in this Collection which are __not__ in the other Collection are removed.
   *
   * If the second parameter is passed as `false`, then items which are not in the other
   * Collection are not removed.
   *
   * This can be used for example when updating a selected record Collection when a new
   * Store or new store dataset arrives. The selected Collection must reference the latest
   * versions of the selected record `id`s
   * @param {Core.util.Collection} other The Collection whose items to match.
   */
  match(other, allowRemove = true) {
    const me = this, { _values } = me, toRemove = [];
    me.forEach((item) => {
      const newInstance = other.get(item.id, true);
      if (newInstance) {
        const index = me.indexOf(item, true), oldInstance = _values[index];
        _values[index] = newInstance;
        me.removeFromIndices(oldInstance);
        me.addToIndices(newInstance);
      } else if (allowRemove) {
        toRemove.push(item);
      }
    });
    if (toRemove.length) {
      me.remove(toRemove);
    }
    if (me.isFiltered) {
      me._filteredValues = me._values.filter(me.filterFunction);
    }
    return toRemove;
  }
  /**
   * Adds items to this Collection. Multiple new items may be passed.
   *
   * By default, new items are appended to the existing values.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to add.
   */
  add(...items2) {
    if (items2.length === 1) {
      this.splice(this._values.length, null, ...items2);
    } else {
      this.splice(this._values.length, null, items2);
    }
  }
  /**
   * Removes items from this Collection. Multiple items may be passed.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to remove.
   */
  remove(...items2) {
    if (items2.length === 1) {
      this.splice(0, ...items2);
    } else {
      this.splice(0, items2);
    }
  }
  /**
   * Moves an individual item, or a block of items to another location.
   * @param {Object|Object[]} items The item/items to move.
   * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`
   * is moved to the end of the Collection.
   * @returns {Number} The new index of the `item`.
   */
  move(items2, beforeItem) {
    items2 = ArrayHelper.asArray(items2);
    while (items2.length && items2[0] === beforeItem) {
      items2.shift();
    }
    if (!items2.length) {
      return;
    }
    const me = this, { _values } = me, itemIndex = me.indexOf(items2[0], true);
    if (items2.length === 1 && _values[itemIndex + 1] === beforeItem) {
      return;
    }
    me.suspendEvents();
    me.remove(items2);
    me.resumeEvents();
    const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;
    if (beforeIndex === -1) {
      throw new Error("Collection move beforeItem parameter must be present in Collection");
    }
    _values.splice(beforeIndex, 0, ...items2);
    me._indicesInvalid = 1;
    me.trigger("change", {
      action: "move",
      items: items2,
      from: itemIndex,
      to: beforeIndex
    });
    return beforeIndex;
  }
  /**
   * The core data set mutation method. Removes and adds at the same time. Analogous
   * to the `Array` `splice` method.
   *
   * Note that if items that are specified for removal are also in the `toAdd` array,
   * then those items are *not* removed then appended. They remain in the same position
   * relative to all remaining items.
   *
   * @param {Number} index Index at which to remove a block of items. Only valid if the
   * second, `toRemove` argument is a number.
   * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
   * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
   * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
   */
  splice(index = 0, toRemove, ...toAdd) {
    const me = this, idProperty = me.idProperty, values = me._values, newIds = {}, removed = [], replaced = [], oldCount = me.totalCount;
    let added, mutated;
    if ((toAdd == null ? void 0 : toAdd.length) === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    if (me.trigger("beforeSplice", { index, toRemove, toAdd }) === false) {
      return;
    }
    if (toAdd) {
      if (oldCount && toAdd.length) {
        const idIndex = me.indices[idProperty];
        added = [];
        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i], id = newItem[idProperty], existingItem = idIndex.get(id), existingIndex = existingItem ? values.indexOf(existingItem) : -1;
          newIds[id] = true;
          if (existingIndex !== -1) {
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      } else {
        added = toAdd;
      }
    }
    if (toRemove) {
      if (typeof toRemove === "number") {
        toRemove = Math.min(toRemove, values.length - index);
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = values[removeIndex][idProperty];
          if (newIds[id]) {
            index++;
            removeIndex++;
          } else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            mutated = true;
          }
        }
      } else {
        let contiguous = added.length === 0, lastIdx;
        toRemove = ArrayHelper.asArray(toRemove);
        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === "number", idx = isNumeric ? item : me.indexOf(item, true);
          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }
          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }
          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);
        if (contiguous) {
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            mutated = true;
          }
        } else {
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];
            if (removeIndex !== -1) {
              const id = values[removeIndex][idProperty];
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                mutated = true;
              }
            }
          }
        }
      }
      if (removed.length && !me._indicesInvalid) {
        removed.forEach(me.removeFromIndices, me);
      }
    }
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      mutated = true;
      if (!me._indicesInvalid) {
        added.forEach(me.addToIndices, me);
      }
      if (!me._addedValues) {
        me._addedValues = /* @__PURE__ */ new Set();
      }
      for (const value of added) {
        me._addedValues.add(value);
      }
    }
    if (removed.length && me._addedValues) {
      for (const value of removed) {
        me._addedValues.delete(value);
      }
    }
    if (replaced.length && !me._indicesInvalid) {
      replaced.forEach((rep) => {
        me.removeFromIndices(rep[0]);
        me.addToIndices(rep[1]);
      });
    }
    if (mutated || replaced.length) {
      if (me.isSorted) {
        me.onSortersChanged();
      } else if (me.isFiltered) {
        if (me.autoFilter) {
          me.onFiltersChanged({ action: "splice", oldCount: 1 });
        } else {
          me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);
        }
      }
      me.generation++;
      me.trigger("change", {
        action: "splice",
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      me.trigger("noChange", {
        index,
        toRemove,
        toAdd
      });
    }
  }
  /**
   * Change the id of an existing member by mutating its {@link #config-idProperty}.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idProperty } = me, oldId = keyTypes[typeof item] ? item : item[idProperty], member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      me.removeIndexEntry(item, idProperty, oldId);
      me.addIndexEntry(item, idProperty, newId);
      member[idProperty] = newId;
    }
  }
  /**
   * Returns the item with the passed `id`. By default, filtered are honoured, and
   * if the item with the requested `id` is filtered out, nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the second parameter as `true`.
   * @param {*} id The `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }
  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }
  /**
   * Returns the item with passed property name equal to the passed value. By default,
   * filtered are honoured, and if the item with the requested `id` is filtered out,
   * nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the third parameter as `true`.
   * @param {String} propertyName The property to test.
   * @param {*} value The value to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  getBy(propertyName, value, ignoreFilters = false) {
    return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);
  }
  /**
   * The number of items in this collection. Note that this honours filtering.
   * See {@link #property-totalCount};
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.values.length;
  }
  /**
   * The number of items in this collection regardless of filtering.
   * @property {Number}
   * @readonly
   */
  get totalCount() {
    return this._values.length;
  }
  /**
   * The property name used to extract item `id`s from added objects.
   * @member {String} idProperty
   */
  updateIdProperty(idProperty) {
    this.addIndex({ property: idProperty, unique: true });
  }
  //endregion
  //region Sorting
  /**
   * The Collection of {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @member {Core.util.Collection} sorters
   */
  changeSorters(sorters) {
    return new _Collection({
      values: ArrayHelper.asArray(sorters),
      internalListeners: {
        change: "onSortersChanged",
        thisObj: this
      }
    });
  }
  /**
   * Adds a Sorter to the Collection of Sorters which are operating on this Collection.
   *
   * A Sorter may be specified as an instantiated {@link Core.util.CollectionSorter}, or a config object for a
   * CollectionSorter of the form
   *
   *     {
   *         property  : 'age',
   *         direction : 'desc'
   *     }
   *
   * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make
   * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You
   * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.
   *
   * A Sorter may also be specified as a function which compares two objects eg:
   *
   *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age
   *
   * @param {CollectionSorterConfig} sorter A Sorter configuration object to add to the Collection
   * of Sorters operating on this Collection.
   * @returns {Core.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.
   */
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-sorters}.
   * @property {Boolean}
   * @readonly
   */
  get isSorted() {
    var _a4;
    return Boolean((_a4 = this._sorters) == null ? void 0 : _a4.count);
  }
  onSortersChanged() {
    const me = this;
    me._sortFunction = null;
    me._addedValues = null;
    me._values.sort(me.sortFunction);
    me.trigger("change", sortEvent);
  }
  /**
   * A sorter function which encapsulates the {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @property {Function}
   * @param {*} first First value to compare
   * @param {*} second Second value to compare
   * @returns {Number} Returns `1` if first value is a greater unit than second value, `-1` if the opposite is true or `0` if they're equal
   * @readonly
   */
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }
    return this._sortFunction;
  }
  //endregion
  //region Filtering
  /**
   * The Collection of {@link Core.util.CollectionFilter Filters} for this Collection.
   * @property {Core.util.Collection}
   * @readonly
   */
  get filters() {
    if (!this._filters) {
      this._filters = new _Collection({
        internalListeners: {
          change: "onFiltersChanged",
          thisObj: this
        }
      });
    }
    return this._filters;
  }
  /**
   * Adds a Filter to the Collection of Filters which are operating on this Collection.
   *
   * A Filter may be an specified as an instantiated {@link Core.util.CollectionFilter
   * CollectionFilter}, or a config object for a CollectionFilter of the form
   *
   *     {
   *         property : 'age',
   *         operator : '>=',
   *         value    : 21
   *     }
   *
   * Note that by default, a Filter *replaces* a Filter with the same `property` to make
   * it easy to change existing Filters. A Filter's `id` is its `property` by default. You
   * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.
   *
   * A Filter may also be specified as a function which filters candidate objects eg:
   *
   *     candidate => candidate.customerDetails.age >= 21
   *
   * @param {CollectionFilterConfig|Core.util.CollectionFilter} filter A Filter or Filter configuration object to add
   * to the Collection of Filters operating on this Collection.
   * @returns {Core.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.
   */
  addFilter(filter) {
    const result = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    this.filters.add(result);
    return result;
  }
  removeFilter(filter) {
    const { filters } = this;
    if (!filter.isCollectionFilter) {
      filter = filters.get(filter);
    }
    filters.remove(filter);
  }
  clearFilters() {
    this.filters.clear();
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-filters}.
   * @property {Boolean}
   * @readonly
   */
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }
  onFiltersChanged({ action, removed: gone, oldCount }) {
    const me = this, oldDataset = oldCount || action === "clear" && gone.length ? me._filteredValues : me._values;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    const {
      toAdd: added,
      toRemove: removed
    } = ArrayHelper.delta(me._filteredValues, oldDataset, true);
    me.trigger("change", { ...filterEvent, added, removed });
  }
  /**
   * A filter function which encapsulates the {@link Core.util.CollectionFilter Filters}
   * for this Collection.
   * @property {Function}
   * @param {*} value Value to compare
   * @returns {Boolean} Returns `true` for value valid for including
   * @readonly
   */
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }
    return this._filterFunction;
  }
  //endregion
  //region Indexing
  changeExtraKeys(extraKeys) {
    const keys = ArrayHelper.asArray(extraKeys);
    return keys.map((config) => {
      if (typeof config === "string") {
        return { property: config, unique: true };
      }
      return config;
    });
  }
  updateExtraKeys(extraKeys) {
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }
  /**
   * Adds a lookup index for the passed property name or index config. The index is built lazily when an index is
   * searched
   * @internal
   * @param {Object} indexConfig An index config
   * @param {String} indexConfig.property The property name to add an index for
   * @param {Boolean} [indexConfig.unique] Specify `false` to allow multiple entries of the same index, turning
   *   entries into sets
   * @param {Object} [indexConfig.dependentOn] The properties that make the key
   */
  addIndex(indexConfig) {
    const me = this;
    if (indexConfig) {
      (me._indices || (me._indices = {}))[indexConfig.property] = /* @__PURE__ */ new Map();
      Object.assign(me._indices[indexConfig.property], indexConfig);
      me.invalidateIndices();
      if (indexConfig.dependentOn) {
        me.hasCompositeIndex = true;
      }
    }
  }
  /**
   * Return the index of the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account and this returns the index in the filtered dataset if present. To
   * bypass this, pass the third parameter as `true`.
   *
   * Only useful for indices configured with `unique: true`.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Number} The index of the item or `-1` if not found for unique indices
   */
  findIndex(propertyName, value, ignoreFilters = false) {
    const item = this.findItem(propertyName, value, ignoreFilters);
    if (!item) {
      return -1;
    }
    const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;
    return values.indexOf(item);
  }
  /**
   * Return the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account. To bypass this, pass the third parameter as `true`.
   *
   * For indices configured with `unique: false`, a Set of items will be returned.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Object|Set} The found item or Set of items or null
   */
  findItem(propertyName, value, ignoreFilters = false) {
    var _a4;
    const me = this, { isFiltered } = me, index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];
    if (index) {
      const item = (_a4 = index.get(value)) != null ? _a4 : typeof value === "string" && value.length && !isNaN(value) && index.get(Number(value)) || null;
      if (item != null) {
        return item;
      }
    } else {
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values, count = values.length;
      for (let i = 0; i < count; i++) {
        const item = values[i];
        if (item[propertyName] == value) {
          return item;
        }
      }
    }
    return null;
  }
  removeIndex(propertyName) {
    delete this._indices[propertyName];
    this.hasCompositeIndex = Object.values(this.indices).some((index) => index.dependentOn);
  }
  /**
   * Returns the index of the item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added, but is currently filtered out of
   * visibility, `-1` will be returned.
   *
   * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Number} The index of the item, or `-1` if not found.
   */
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added,
   * but is currently filtered out of visibility, `false` will be returned.
   *
   * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item, ignoreFilters = false) {
    if (Array.isArray(item)) {
      return item.some((item2) => this.includes(item2));
    }
    return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));
  }
  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }
  invalidateIndices() {
    this._indicesInvalid = true;
  }
  /**
   * Called when the Collection is mutated and the indices have been flagged as invalid.
   *
   * Rebuilds the indices object to allow lookup by keys.
   * @internal
   */
  rebuildIndices() {
    const me = this, isFiltered = me.isFiltered, indices = me._indices || (me._indices = {}), keyProps = Object.keys(indices), indexCount = keyProps.length, values = me._values;
    let detectDuplicates = false, filteredIndices;
    if (isFiltered) {
      filteredIndices = indices[filteredIndicesProperty] = {};
    }
    for (let i = 0; i < indexCount; i++) {
      const index = indices[keyProps[i]];
      index.clear();
      if (index.onDuplicate) {
        index.count = 0;
        detectDuplicates = true;
      }
      if (isFiltered) {
        let filteredIndex = filteredIndices[keyProps[i]];
        if (filteredIndex) {
          filteredIndex.clear();
        } else {
          filteredIndex = filteredIndices[keyProps[i]] = /* @__PURE__ */ new Map();
          filteredIndex.unique = index.unique;
        }
      }
    }
    doRebuildIndices(values, indices, keyProps, indexCount);
    if (detectDuplicates) {
      for (let i = 0; i < indexCount; i++) {
        const index = indices[keyProps[i]];
        if (index.onDuplicate && index.count > index.size) {
          const checked = /* @__PURE__ */ new Set();
          for (let j = 0; j < values.length; j++) {
            const item = values[j], key = item[keyProps[i]];
            if (checked.has(key)) {
              index.onDuplicate(item, key, index);
            }
            checked.add(key);
          }
        }
      }
    }
    if (isFiltered) {
      doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount, true);
    }
    me._indicesInvalid = false;
  }
  // Returns an array with [indices] or [indices, filteredIndices] if filtering is used
  getIndices(propertyName) {
    const indices = [this.indices[propertyName]];
    if (this.isFiltered) {
      indices.push(this.indices[filteredIndicesProperty][propertyName]);
    }
    return indices;
  }
  /**
   * Add an item to all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  addToIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.addIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an item from all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  removeFromIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.removeIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an entry from an index, and if filtering is used also from the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} oldValue Value to remove
   * @private
   */
  removeIndexEntry(item, propertyName, oldValue) {
    this.getIndices(propertyName).forEach((index) => removeItemFromIndex(item, index, oldValue));
  }
  /**
   * Add a new entry to an index, and if filtering is used also to the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} value Value to store
   * @private
   */
  addIndexEntry(item, propertyName, value) {
    this.getIndices(propertyName).forEach((index) => addItemToIndex(item, index, value));
  }
  /**
   * Call externally to update indices on item mutation (from Store)
   * @param {*} item Item already available in the Collection
   * @param {Object} wasSet Uses the `wasSet` format from Store, `{ field : { oldValue, newValue } }`
   * @internal
   */
  onItemMutation(item, wasSet) {
    const me = this;
    if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {
      Object.keys(wasSet).forEach((propertyName) => {
        var _a4;
        const indexConfig = me.indices[propertyName];
        if (indexConfig) {
          const { value, oldValue } = wasSet[propertyName];
          me.removeIndexEntry(item, propertyName, oldValue);
          me.addIndexEntry(item, propertyName, value);
        }
        if (me.hasCompositeIndex) {
          const dependentIndex = Object.values(me.indices).find((index) => {
            var _a5;
            return (_a5 = index.dependentOn) == null ? void 0 : _a5[propertyName];
          });
          if (dependentIndex) {
            const keysAndOldValues = {};
            for (const o in dependentIndex.dependentOn) {
              keysAndOldValues[o] = ((_a4 = wasSet[o]) == null ? void 0 : _a4.oldValue) || item[o];
            }
            const oldIndex = item.buildIndexKey(keysAndOldValues);
            me.removeIndexEntry(item, dependentIndex.property, oldIndex);
            me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);
          }
        }
      });
    }
  }
  //endregion
};
Collection._$name = "Collection";

// ../Core/lib/Core/util/Bag.js
var nonPrimitives = /* @__PURE__ */ new WeakMap();
var safeIndexKey = (value) => {
  if (value && typeof value === "object") {
    let substitute = nonPrimitives.get(value);
    if (substitute === void 0) {
      substitute = Symbol("bscik");
      nonPrimitives.set(value, substitute);
    }
    value = substitute;
  }
  return value;
};
var Bag = class {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = /* @__PURE__ */ new Set();
    me.idMap = {};
    me.idProperty = "id";
    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }
  }
  /**
   * Returns the item with the passed `id`.
   *
   * @param {*} id The `id` to find.
   * @returns {Object} The found item, or `undefined`.
   */
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }
  /**
   * The number of items in this Bag.
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.items.size;
  }
  /**
   * Adds the passed item(s) to this Bag. Existing items with the same ID
   * will be replaced.
   * @param {Object|Object[]} toAdd Item(s) to add.
   */
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    const me = this, {
      items: items2,
      idMap,
      idProperty
    } = me, len = toAdd.length;
    for (let i = 0; i < len; i++) {
      const item = toAdd[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem == null) {
        idMap[key] = item;
        items2.add(item);
        me.generation++;
      } else if (existingItem !== item) {
        idMap[key] = item;
        items2.delete(existingItem);
        items2.add(item);
      }
    }
  }
  /**
   * Returns `nth` item in this Bag.
   * @param {Number} nth The index of the matching item. Negative numbers index for the last item. For example, -1
   * returns the last item, -2 the 2nd to last item etc.
   * @returns {Object} The matched item, or `undefined`.
   */
  at(nth) {
    let item, ret;
    if (nth < 0) {
      nth += this.count;
    }
    for (item of this.items) {
      if (!nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Removes the passed item(s) from this Bag.
   * @param {Object|Object[]} toRemove Item(s) to remove.
   */
  remove(toRemove) {
    toRemove = ArrayHelper.asArray(toRemove);
    const { items: items2, idMap, idProperty } = this, len = toRemove.length;
    for (let i = 0; i < len; i++) {
      const item = toRemove[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem != null) {
        items2.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }
  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }
  /**
   * Returns the number of items in this Bag which elicits a truthy return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @returns {Number} The number of matched items.
   */
  countOf(fn) {
    let ret = 0, item;
    for (item of this.items) {
      if (fn(item)) {
        ++ret;
      }
    }
    return ret;
  }
  /**
   * Change the id of an existing member by mutating its idProperty.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idMap, idProperty } = me, oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }
  /**
   * Extracts the matching items from this Bag into an array based upon the passed value filter function.
   * @param {Function} fn A function, which, when passed an item, returns a `true` to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  filter(fn, thisObj) {
    const { items: items2 } = this, result = [];
    let i = 0;
    items2.forEach((item) => {
      if (fn.call(thisObj, item, i++, items2)) {
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }
  /**
   * Extracts the content of this Bag into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  map(fn, thisObj) {
    const { items: items2 } = this, result = new Array(items2.size);
    let i = 0;
    items2.forEach((item) => {
      result[i] = fn.call(thisObj, item, i++, items2);
    });
    return result;
  }
  /**
   * Executes the passed function for each item in this Bag, passing in the item.
   * @param {Function} fn The function to execute.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   */
  forEach(fn, thisObj) {
    return this.items.forEach(fn, thisObj);
  }
  /**
   * Returns `nth` item in this Bag which elicits a truthy return value from the provided matcher function `fn`.
   * @param {Function} fn A function which, when passed an item, returns `true` to select the item as a match.
   * @param {Number} [nth=0] The index of the matching item. By default, 0 returns the first item that matches
   * according to `fn`. Negative numbers index for the last item. For example, -1 returns the last matching item,
   * -2 the 2nd to last matching item etc..
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn, nth = 0) {
    let item, ret;
    if (nth < 0) {
      nth += this.countOf(fn);
    }
    for (item of this.items) {
      if (fn(item) && !nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Iterator that allows you to do for (let item of bag)
   */
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  indexOf(item, matchFn) {
    let index = -1, it;
    for (it of this.items) {
      if (!matchFn || matchFn(it)) {
        ++index;
        if (it === item) {
          return index;
        }
      }
    }
    return -1;
  }
  /**
   * The set of values of this Bag.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return [...this.items];
  }
  set values(values) {
    values = ArrayHelper.asArray(values);
    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }
  /**
   * Sort the values of this Bag using the passed comparison function.
   *
   * Setting this property replaces the data set.
   * @param {Function} fn Comparison function which returns -ve, 0, or +ve
   */
  sort(fn) {
    this.values = this.values.sort(fn);
  }
  some(fn, thisObj) {
    return this.values.some(fn, thisObj);
  }
};
Bag._$name = "Bag";

// ../Core/lib/Core/data/StoreBag.js
var StoreBag = class extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    return super.add(...toAdd.filter((record) => record.isPersistable));
  }
};
StoreBag._$name = "StoreBag";

// ../Core/lib/Core/data/mixin/StoreCRUD.js
var StoreCRUD_default = (Target) => class StoreCRUD extends (Target || Base) {
  static get $name() {
    return "StoreCRUD";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Commit changes automatically
       * @config {Boolean}
       * @default
       * @category Common
       */
      autoCommit: false
    };
  }
  static get properties() {
    return {
      isRemoving: false,
      suspendCount: 0
    };
  }
  //endregion
  //region Events
  /**
   * Fired after removing all records
   * @event removeAll
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before committing changes. Return false from handler to abort commit
   * @event beforeCommit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired after committing changes
   * @event commit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.
   * Also fired when removing a child record in a tree store using {@link Core.data.mixin.TreeNode#function-removeChild}.
   * The remove may be vetoed by returning `false` from a handler.
   * @event beforeRemove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be removed.
   * @param {Core.data.Model} parent The record from which children are being removed when using a tree store. Only
   * provided when removing a single node.
   * @param {Boolean} isMove This flag is `true` if the child node is being removed by
   * {@link Core.data.mixin.TreeNode#function-appendChild appendChild} to be moved
   * _within the same tree_.
   * @param {Boolean} removingAll This flag is `true` if the operation is removing the store's entire data set.
   * @preventable
   */
  /**
   * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree
   * store, also fired by {@link Core.data.mixin.TreeNode#function-appendChild} and
   * {@link Core.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`
   * from a handler.
   * @event beforeAdd
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be added
   * @param {Core.data.Model} parent The parent node when using a tree store
   * @preventable
   */
  /**
   * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the
   * event. If it was inserted, event contains `index`
   * @event add
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is
   * added, all new records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to an {@link Core/data/mixin/TreeNode#function-appendChild}
   * call, this is the parent node added to.
   * @param {Number} [index] Insertion point in the store's {@link Core.data.Store#config-storage Collection}.
   * @param {Number} [oldIndex] Not used for tree stores. The index of the first record moved.
   * @param {Boolean} [isChild] Flag which is set to true if the records are added to a parent record
   * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent
   * @param {Object} [isMove] An object keyed by the ids of the records which were moved from another
   * position in the store, or from another parent node in the store. The ids of moved records will be
   * property names with a value `true`.
   */
  /**
   * Fired when one or more records are removed
   * @event remove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Array of removed records. In case of tree store, if branch is removed, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat array of all removed records. In case of tree store, if branch is
   * removed, all removed records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to a {@link Core.data.mixin.TreeNode#function-removeChild removeChild}
   * call, this is the parent node removed from. Only applicable when removing a single tree node.
   * @param {Number} [index] Visible index at which record was removed. In case the record was removed from a collapsed
   * branch, -1 is returned. For tree store, this is only provided when removing a single node.
   * @param {Boolean} [isChild] Flag which is set to true if the record was removed from a parent record
   * @param {Boolean} [isCollapse] Flag which is set to true if records were removed from the store by collapsing parent
   * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.
   */
  /**
   * Fired when Data in the store was changed. See {@link Core/data/Store#event-change} event for the details.
   * @event change
   * @param {Core.data.Store} source This Store
   * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action
   * Name of action which triggered the change. May be one of the options listed above
   * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)
   * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`
   * @param {Object} changes Passed for the `'update'` action, info on which record fields changed
   */
  /**
   * Data in the store has completely changed, such as by a filter, or sort or load operation.
   * @event refresh
   * @param {Core.data.Store} source This Store.
   * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
   * @param {'dataset'|'sort'|'clearchanges'|'filter'|'create'|'update'|'delete'|'group'} action Name of
   * action which triggered the change. May be one of the options listed above.
   */
  //endregion
  //region Add, insert & remove
  /**
   * Removes a record from this store. Fires a single {@link #event-remove} event passing the removed records.
   * @param {String|String[]|Number|Number[]|Core.data.Model|Core.data.Model[]} records Record/array of records (or record ids) to remove
   * @param {Boolean} [silent] Specify `true` to suppress events/autoCommit
   * @returns {Core.data.Model[]} Removed records
   * @fires beforeRemove
   * @fires remove
   * @fires change
   * @category CRUD
   */
  remove(records, silent = false) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records).reduce((result, r) => {
      r = me.getById(r);
      if (r) {
        result.push(r);
      }
      return result;
    }, []);
    if (records.length === 0) {
      return records;
    }
    if (!me.tree && !silent && me.trigger("beforeRemove", { records }) === false) {
      return [];
    }
    me.isRemoving = true;
    if (me.isGrouped) {
      const oldCount = storage.count, recordsInCollapsedGroups = [], changedGroupParents = /* @__PURE__ */ new Set();
      for (const rec of records) {
        const groupParent = rec.groupParent.get(me.id);
        if (groupParent.meta.collapsed) {
          recordsInCollapsedGroups.push(rec);
        }
        ArrayHelper.remove(groupParent.groupChildren, rec);
        ArrayHelper.remove(groupParent.unfilteredGroupChildren, rec);
        groupParent.meta.childCount--;
        changedGroupParents.add(groupParent);
      }
      for (const groupParent of changedGroupParents) {
        if (groupParent.groupChildren.length > 0) {
          me.onModelChange(groupParent, {}, {});
        }
      }
      if (recordsInCollapsedGroups.length) {
        storage.trigger("change", {
          action: "splice",
          removed: recordsInCollapsedGroups,
          added: [],
          replaced: [],
          oldCount
        });
      }
    } else if (me.tree) {
      const allRemovedRecords = [], removingMultiple = records.length > 1, firstRemoved = records[0], index = removingMultiple ? void 0 : storage.indexOf(firstRemoved), removeChildArgs = records.reduce((result, child) => {
        const { parent } = child;
        if (parent) {
          if (!result[parent.id]) {
            result[parent.id] = [parent, []];
          }
          result[parent.id][1].push(child);
        }
        return result;
      }, {}), removals = Array.from(Object.values(removeChildArgs));
      if (!silent && me.trigger("beforeRemove", { records, isMove: false, parent: removingMultiple ? void 0 : firstRemoved.parent }) === false) {
        me.isRemoving = false;
        return [];
      }
      me.suspendAutoCommit();
      removals.sort((a, b) => b[0].childLevel - a[0].childLevel);
      for (const [parent, children] of removals) {
        allRemovedRecords.push(...parent.removeChild(children, false, true));
      }
      if (!silent) {
        me.trigger("remove", {
          // parent is only relevant when removing single node
          parent: removingMultiple ? void 0 : firstRemoved.parent,
          index,
          isChild: true,
          allRecords: allRemovedRecords,
          isMove: false,
          records
        });
        me.trigger("change", {
          action: "remove",
          records
        });
      }
      me.resumeAutoCommit();
      me.isRemoving = false;
      return records;
    }
    if (records.length === 0) {
      me.isRemoving = false;
      return records;
    }
    for (const record of records) {
      record.beforeRemove(records);
    }
    if (silent) {
      me.suspendEvents();
    }
    storage.remove(records);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    me.isRemoving = false;
    return records;
  }
  /**
   * Clears store data. Used by removeAll, separate function for using with chained stores.
   * @private
   * @category CRUD
   */
  clear(isLoading = false) {
    var _a4, _b;
    const me = this, { storage } = me;
    if (me.storage.totalCount || ((_b = (_a4 = me.rootNode) == null ? void 0 : _a4.unfilteredChildren) == null ? void 0 : _b.length)) {
      if (!isLoading && me.trigger("beforeRemove", { records: storage.allValues, removingAll: true }) === false) {
        return null;
      }
      if (me.rootNode) {
        if (!me.isChained) {
          me.rootNode.clearChildren(isLoading);
        }
      } else if (isLoading) {
        const allRecords = me.registeredRecords;
        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unjoinStore(me);
          }
        }
      }
      if (isLoading) {
        me.removed.clear();
        storage.suspendEvents();
      }
      storage.clear();
      if (isLoading) {
        storage.resumeEvents();
      }
      me.added.clear();
      me.modified.clear();
    }
  }
  /**
   * Removes all records from the store.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`
   * @fires beforeRemove
   * @fires removeAll
   * @fires change
   * @category CRUD
   */
  removeAll(silent = false) {
    const me = this, storage = me.storage;
    let result;
    me.isRemoving = true;
    if (silent) {
      storage.suspendEvents();
      const allRecords = me.registeredRecords;
      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];
        if (rec && !rec.isDestroyed && !rec.isRoot) {
          rec.unjoinStore(me);
        }
      }
    }
    if (me.tree) {
      result = me.rootNode.clear() !== false;
    } else {
      result = me.clear() !== null;
    }
    if (silent) {
      storage.resumeEvents();
    }
    me.isRemoving = false;
    return result;
  }
  /**
   * Add records to store.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Added records
   * @fires add
   * @fires change
   * @category CRUD
   */
  add(records, silent = false, options = {}) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records);
    if (!(records == null ? void 0 : records.length)) {
      return;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      const parentIdMap = /* @__PURE__ */ new Map(), parentIndexField = me.modelClass.getFieldDataSource("parentIndex"), { parentIdField } = me.modelClass, added2 = [];
      records.forEach((node) => {
        const parentId = node[parentIdField];
        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, { append: [], insert: [] });
        }
        const entry = parentIdMap.get(parentId);
        if (!node.isModel && parentIndexField in node) {
          entry.insert.push(node);
        } else {
          entry.append.push(node);
        }
      });
      parentIdMap.forEach(({ append, insert }, parentId) => {
        const parentNode = parentId == null ? me.rootNode : me.getById(parentId);
        if (!parentNode) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }
        if (append.length) {
          added2.push(...parentNode.appendChild(append, silent, options));
        }
        if (insert.length) {
          for (const toInsert of insert) {
            added2.push(parentNode.insertChild(toInsert, toInsert[parentIndexField], silent, options));
          }
        }
      });
      if (me.isFiltered && me.reapplyFilterOnAdd) {
        me.filter({
          silent: true
        });
      }
      if (me.reapplySortersOnAdd && !me.isSyncingDataOnLoad) {
        me.sort();
      }
      return added2;
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      return me.rootNode.appendChild(records);
    }
    const added = me.processRecords(records);
    if (silent) {
      me.suspendEvents();
    }
    me.addingClean = options.clean;
    storage.add(added);
    me.addingClean = false;
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  processRecords(records, onRecordCreated) {
    return records.map((data) => {
      const record = this.processRecord(data.isModel ? data : this.createRecord(data));
      onRecordCreated == null ? void 0 : onRecordCreated.call(this, record);
      return record;
    });
  }
  /**
   * Insert records into the store.
   * @param {Number} index Index to insert at
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to insert to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Inserted records
   * @fires add
   * @fires change
   * @category CRUD
   */
  insert(index, records, silent = false) {
    var _a4;
    const me = this, storage = me.storage, insertBefore = me.getAt(index), _records = storage.values, removeIndices = [];
    records = ArrayHelper.asArray(records);
    if (me.tree) {
      const root = me.rootNode;
      return root.insertChild(records, (_a4 = root.children) == null ? void 0 : _a4[index], silent);
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    let isNoop, start, i;
    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }
    if (isNoop) {
      return null;
    }
    const added = me.processRecords(records, (record) => {
      const removedAtIndex = storage.indexOf(record);
      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }
      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore)
          index--;
        removeIndices.push(removedAtIndex);
      }
      record.meta.previousIndex = removedAtIndex;
    });
    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();
    if (silent) {
      me.suspendEvents();
    }
    storage.splice(index, 0, ...added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  /**
   * Moves a record, or block of records to another location.
   * @param {Core.data.Model|Core.data.Model[]} records The record(s) to move.
   * @param {Core.data.Model} beforeRecord the record to insert the first record(s) before.
   * @fires change
   * @category CRUD
   */
  move(records, beforeRecord) {
    if (this.isTree) {
      beforeRecord.parent.insertChild(records, beforeRecord);
    } else {
      this.storage.move(records, beforeRecord);
    }
  }
  //endregion
  //region Update multiple
  setMultiple(filterFn, field, value) {
    const me = this, records = [], changes = [];
    me.suspendFilterOnUpdate();
    me.forEach((r) => {
      if (filterFn(r)) {
        changes.push(r.set(field, value, true));
        records.push(r);
      }
    });
    me.trigger("updateMultiple", { records, all: me.records.length === records.length });
    me.trigger("change", { action: "updatemultiple", records, all: me.records.length === records.length });
    me.resumeFilterOnUpdate();
  }
  setAll(field, value) {
    const me = this, changes = [];
    me.suspendFilterOnUpdate();
    me.forEach((r) => {
      changes.push(r.set(field, value, true));
    });
    me.trigger("updateMultiple", { records: me.records, all: true });
    me.trigger("change", { action: "updatemultiple", records: me.records, all: true });
    me.resumeFilterOnUpdate();
  }
  //endregion
  //region Commit
  /**
   * Accepts all changes, resets the modification tracking:
   * * Clears change tracking for all records
   * * Clears added
   * * Clears modified
   * * Clears removed
   * Leaves the store in an "unmodified" state.
   * @internal
   */
  acceptChanges() {
    const me = this;
    me.added.forEach((r) => r.internalClearChanges(true, false));
    me.modified.forEach((r) => r.internalClearChanges(true, false));
    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }
  /**
   * Commits changes, per default only returns changes and resets tracking.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Object} Changes, see {@link #property-changes}
   * @fires beforeCommit
   * @fires commit
   * @category CRUD
   */
  commit(silent = false) {
    const { changes } = this;
    if (!silent && this.trigger("beforeCommit", { changes }) === false) {
      return false;
    }
    this.acceptChanges();
    if (!silent) {
      this.trigger("commit", { changes });
    }
    return changes;
  }
  /**
   * Reverts all changes in the store (adds removed records back, and removes newly added records).
   * @fires change
   * @fires refresh
   * @category CRUD
   */
  revertChanges() {
    const me = this, { changes } = me;
    if (changes) {
      const event = { action: "clearchanges", changes };
      me.add(me.removed.values, true);
      me.remove(me.added.values, true);
      me.modified.forEach((r) => r.revertChanges(true));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
      me.trigger("change", event);
      me.trigger("refresh", event);
    }
  }
  /**
   * Get uncommitted changes as an object of added/modified/removed arrays of records.
   *
   * ```javascript
   * // Format:
   * {
   *      added: [], // array of Core.data.Model
   *      modified: [], // array of Core.data.Model
   *      removed: [] // array of Core.data.Model
   * }
   * ```
   *
   * @member {Object} changes
   * @property {Core.data.Model[]} changes.added Records that have been added
   * @property {Core.data.Model[]} changes.modified Records that have changes to persistable fields
   * @property {Core.data.Model[]} changes.removed Records that have been removed
   * @readonly
   * @category Records
   */
  get changes() {
    const me = this, modified = me.modified.values.filter((r) => r.rawModifications);
    return me.added.count || modified.length || me.removed.count ? {
      // Slicing to have changes intact when triggering commit
      added: me.added.values.slice(),
      modified,
      removed: me.removed.values.slice()
    } : null;
  }
  /**
   * Boolean flag, indicating whether the store has any data changes (its {@link #property-changes} accessor
   * returns non-empty object). Cheaper than {@link #property-changes} accessor itself, because it
   * does not clone some internal data structures.
   *
   * @property {Boolean}
   * @readonly
   * @category Records
   */
  get hasChanges() {
    return Boolean(this.added.count || this.removed.count || this.modified.values.some((r) => r.rawModifications));
  }
  /**
   * Setting autoCommit to true automatically commits changes to records.
   * @property {Boolean}
   * @category Records
   */
  get autoCommit() {
    return this._autoCommit;
  }
  set autoCommit(auto) {
    this._autoCommit = auto;
    if (auto && this.hasChanges) {
      this.commit();
    }
  }
  /**
   * Suspends automatic commits upon store changes. Can be called multiple times (it uses an internal counter).
   * @category Records
   */
  suspendAutoCommit() {
    this.suspendCount++;
  }
  /**
   * Resumes automatic commits upon store changes. Will trigger commit if the internal counter is 0.
   * @category Records
   */
  resumeAutoCommit(doCommit = true) {
    this.suspendCount--;
    if (this.autoCommit && doCommit) {
      this.doAutoCommit();
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit();
    }
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChanges.js
var StoreChanges_default = (Target) => class StoreChanges extends (Target || Base) {
  static get $name() {
    return "StoreChanges";
  }
  static get configurable() {
    return {
      /**
       * Specifies target to filter and sort after applying changeset:
       * * `'changes'` - apply sort and filter to changeset only (see more below)
       * * `'none'` - do not apply sort and filter
       *
       * ### `changes` behavior
       * If the store has filters in effect when the changeset is applied, the following rules will determine how the
       * filtered values are affected:
       * - Among added records, only those that match the filter will be included in the filtered set
       * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
       *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
       *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
       *   re-applied.
       *
       * @default
       * @prp {'changes'|'none'}
       * @category Advanced
       */
      applyChangesetFilterSortTarget: "changes"
    };
  }
  /**
   * Applies changes from another store to this store. Useful if cloning records in one store to display in a
   * grid in a popup etc. to reflect back changes.
   * @param {Core.data.Store} otherStore
   * @category CRUD
   */
  applyChangesFromStore(otherStore) {
    const me = this, { changes } = otherStore;
    if (!changes) {
      return;
    }
    if (changes.added) {
      me.add(changes.added);
    }
    if (changes.removed) {
      me.remove(changes.removed.map((r) => r.id));
    }
    if (changes.modified) {
      changes.modified.forEach((record) => {
        const localRecord = me.getById(record.id);
        localRecord == null ? void 0 : localRecord.set(record.modifications);
      });
    }
  }
  /**
   * Applies a set of changes (presumable from a backend) expressed as an object matching the format outputted by the
   * {@link Core/data/Store#property-changes} property: `{ added : [], modified/updated : [], removed : [] }`
   *
   * `added` is expected to be an array of raw data objects consumable by the stores model class for records to add to
   * the store (see example snippet below).
   *
   * `modified` (or `updated` for compatibility with Schedulers CrudManager) is expected to have the same format as
   * `added`, but should always include the `id` of the record to update.
   *
   * Records that have been created locally and gets assigned a proper id by the backend are expected to also pass a
   * `phantomId` field (name of the field is configurable using the `phantomIdField` arg, more info on phantom ids
   * below), to match it with the current id of a local record (`id` will contain the new id).
   *
   * Note that it is also possible to pass this `phantomId` -> `id` mapping in the `added` array. When encountering a
   * record in that array that already exists in the local store, it will be treated the same was as a record in the
   * `modified` array.
   *
   * `removed` is expected to be an array of objects with the `{ id : xx }` shape. Any matches on an id in the store
   * will be removed, those and any non matches will also be cleared from the change tracking of the store.
   *
   * If the store has filters in effect when the changeset is applied, the following rules will determine how the
   * filtered values are affected:
   * - Among added records, only those that match the filter will be included in the filtered set
   * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
   *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
   *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
   *   re-applied.
   *
   * As an example, consider a store with the following initial state and some operations performed on it:
   *
   * ```javascript
   * // Load some data into the store
   * store.data = [
   *     { id : 1, name : 'Minerva' },
   *     { id : 2, name : 'Mars' },
   *     { id : 3, name : 'Jupiter' }
   * ];
   * // Add a new record. It gets assigned a generated id,
   * // for example 'generated56'
   * store.add({ name : 'Artemis' });
   * // Remove Jupiter
   * store.remove(3);
   * ```
   *
   * After syncing those operations to a custom backend (however you chose to solve it in your application) we might
   * get the following response (see "Transforming a response to the correct format" below if your backend responds
   * in another format):
   *
   * ```javascript
   * const serverResponse = {
   *     added : [
   *         // Added by the backend, will be added locally
   *         { id : 5, name : 'Demeter' }
   *     ],
   *
   *     updated : [
   *         // Will change the name of Minerva -> Athena
   *         { id : 1, name : 'Athena' },
   *         // Will set proper id 4 for Artemis
   *         { $PhantomId : 'generated56', id : 4 }
   *     ],
   *
   *     removed : [
   *         // Confirmed remove of Jupiter
   *         { id : 3 },
   *         // Removed by the backend, Mars will be removed locally
   *         { id : 2 }
   *     ]
   * };
   * ```
   *
   * If that response is then passed to this function:
   *
   * ```javascript
   * store.applyChangeSet(serverResponse);
   * ```
   *
   * The end result will be the following data in the store:
   *
   * ```javascript
   * [
   *     { id : 1, name : 'Athena' }, // Changed name
   *     { id : 4, name : 'Artemis' }, // Got a proper id
   *     { id : 5, name : 'Demeter' } // Added by the backend
   * ]
   * ```
   *
   * ### Phantom ids
   *
   * When a record is created locally, it is always assigned a generated id. That id is called a phantom id (note that
   * it is assigned to the normal id field). When passing the new record to the backend, the id is sent with it. When
   * the backend inserts the record into the database, it (normally) gets a proper id assigned. That id then needs to
   * be passed back in the response, to update the local record with the correct id. Making sure that future updates
   * match the correct row in the database.
   *
   * For example a newly created record should be passed similar to this to the backend (pseudo format, up to the
   * application/backend to decide):
   *
   * ```json
   * {
   *     "added" : {
   *         "id" : "generated79",
   *         "name" : "Hercules",
   *         ...
   *     }
   * }
   * ```
   *
   * For the backend response to be applicable for this function, it should then respond with:
   *
   * ```json
   * {
   *     "updated" : {
   *         {
   *             "$PhantomId" : "generated79",
   *             "id" : 465
   *         }
   *     }
   * }
   * ```
   *
   * (Or, as stated above, it can also be passed in the "added" array. Which ever suits your backend best).
   *
   * This function will then change the id of the local record using the phantom id `generated79` to `465`.
   *
   * ### Transforming a response to the correct format
   *
   * This function optionally accepts a `transformFn`, a function that will be called with the `changes`. It is
   * expected to return a changeset in the format described above (`{ added : [], updated : [], removed : [] }`),
   * which then will be used to apply the changes.
   *
   * Consider the following "non standard" (made up) changeset:
   *
   * ```javascript
   * const changes = {
   *     // Database ids for records previously added locally
   *     assignedIds : {
   *         'phantom1' : 10,
   *         'phantom2' : 15
   *     },
   *     // Ids records removed by the backend
   *     removed : [11, 27],
   *     // Modified records, keyed by id
   *     altered : {
   *         12 : { name : 'Changed' }
   *     },
   *     // New records, keyed by id
   *     inserted : {
   *         20  : { name : 'New' }
   *     }
   * }
   * ```
   *
   * Since it does not match the expected format it has to be transformed:
   *
   * ```javascript
   * store.applyChangeset(changes, ({ assignedIds, inserted, altered, removed }) => ({
   *    // Convert inserted to [{ id : 20, name : 'New' }]
   *    added : Object.entries(inserted).map(([id, data] => ({ id, ...data }),
   *    updated : [
   *        // Convert assignedIds to [{ $PhantomId : 'phantom1', id : 10 }, ...]
   *       ...Object.entries(assignedIds).map(([phantomId, id])) => ({ $PhantomId : phantomId, id }),
   *       // Convert altered to [{ id : 12, name : 'Changed' }]
   *       ...Object.entries(modified).map(([id, data] => ({ id, ...data })
   *    ],
   *    // Convert removed to [{ id : 11 }, ...]
   *    removed : removed.map(id => ({ id }))
   * }));
   * ```
   *
   * The transform function above would output:
   *
   * ```javascript
   * {
   *     added : [
   *         {  id : 20, name : 'New' }
   *     ],
   *     updated : [
   *         { $PhantomId : 'phantom1', id : 10 },
   *         { $PhantomId : 'phantom2', id : 15 },
   *         {  id : 12, name : 'Changed' }
   *     ],
   *     removed : [
   *        { id : 11 },
   *        { id : 12 }
   *     ]
   * }
   * ```
   *
   * And that format can then be applied.
   *
   * @param {Object} changes Changeset to apply to the store, see specification above
   * @param {Function} [transformFn] Optional function used to preprocess a changeset in a different format,
   * should return an object with the format expected by this function (see above)
   * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a proper id
   * instead of a phantom id (see above)
   * @privateparam {Boolean} [remote] Set to true to indicate changes are from the remote source. Remote changes have
   * precedence over local.
   * @privateparam {Boolean} [logChanges] Used by CrudManager to be able to revert specific changes later
   * @category CRUD
   */
  applyChangeset(changes, transformFn = null, phantomIdField = "$PhantomId", remote = true, logChanges = false) {
    var _a4, _b, _c, _d, _e;
    const me = this, { added, updated, modified, removed } = (_a4 = transformFn == null ? void 0 : transformFn(changes, me)) != null ? _a4 : changes, altered = (_b = updated != null ? updated : modified) != null ? _b : [], idDataSource = me.modelClass.getFieldDataSource("id"), parentIdDataSource = me.modelClass.getFieldDataSource("parentId"), log = logChanges ? /* @__PURE__ */ new Map() : null, allAdded = [], allAltered = [];
    let rootUpdated = false, modifiedParents = [];
    me.trigger("startApplyChangeset");
    me._groupVisibleRecordIds = [];
    me.isGrouped && me.forEach((record) => {
      me._groupVisibleRecordIds.push(record.id);
    });
    if ((added == null ? void 0 : added.length) > 0) {
      const toUpdate = [], toAdd = [];
      for (const data of added) {
        if (me.getById(data[phantomIdField]) || me.getById(ObjectHelper.getPath(data, idDataSource))) {
          toUpdate.push(data);
        } else {
          toAdd.push(data);
        }
      }
      altered.unshift.apply(altered, toUpdate);
      const prevReapplySortersOnAdd = me.reapplySortersOnAdd;
      me.reapplySortersOnAdd = false;
      const addedRecords = (_c = me.add(toAdd, false, { orderedParentIndex: { skip: true }, clean: remote })) != null ? _c : [];
      allAdded.push(...addedRecords);
      me.reapplySortersOnAdd = prevReapplySortersOnAdd;
      if (me.tree) {
        for (const record of addedRecords) {
          const { parent } = record;
          if (parent.isRoot) {
            rootUpdated = true;
            modifiedParents = [parent];
            break;
          }
          if (!parent.isRoot && modifiedParents.every((r) => !r.contains(parent))) {
            modifiedParents.push(parent);
          }
        }
      }
      for (const record of addedRecords) {
        log == null ? void 0 : log.set(record.id, record.data);
        record.internalClearChanges();
      }
    }
    if ((altered == null ? void 0 : altered.length) > 0) {
      for (const data of altered) {
        const phantomId = data[phantomIdField], id = ObjectHelper.getPath(data, idDataSource), parentId = ObjectHelper.getPath(data, parentIdDataSource), record = (_d = me.getById(phantomId)) != null ? _d : me.getById(id);
        if (record) {
          const newParentWasLeaf = parentId != null ? (_e = me.getById(parentId)) == null ? void 0 : _e.isLeaf : false;
          const changes2 = record.applyChangeset(data, phantomIdField, remote);
          if (newParentWasLeaf) {
            me.toggleCollapse(record.parent, false);
          }
          if (me.tree && !rootUpdated && modifiedParents.every((r) => !r.contains(record))) {
            if (record.parent.isRoot) {
              rootUpdated = true;
              modifiedParents = [record.parent];
            } else {
              modifiedParents.push(record.parent);
            }
          }
          log == null ? void 0 : log.set(id, changes2);
          allAltered.push(record);
        }
      }
    }
    if ((removed == null ? void 0 : removed.length) > 0) {
      me.applyRemovals(removed);
    }
    if (me.applyChangesetFilterSortTarget === "changes") {
      const parentsModifiedByFilter = me.filterChangeset(allAdded, allAltered);
      modifiedParents.push(...parentsModifiedByFilter);
    }
    me.afterChangesetApplied(modifiedParents);
    if (me.tree && me.isSorted && me.reapplySortersOnAdd && ((added == null ? void 0 : added.length) || (altered == null ? void 0 : altered.length))) {
      const refreshed = /* @__PURE__ */ new Set();
      modifiedParents.forEach((record) => {
        if (refreshed.has(record)) {
          return;
        }
        refreshed.add(record);
        record.sortVisibleChildren(false, me.sorterFn);
        record.sortUnfilteredChildren(false, me.sorterFn);
      });
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
      me.afterPerformSort(false);
    }
    me._groupVisibleRecordIds = null;
    me.trigger("endApplyChangeset");
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    const visited = /* @__PURE__ */ new Set();
    modifiedParents.forEach((parent) => {
      if (visited.has(parent)) {
        return;
      }
      parent.traverse((record) => {
        if (visited.has(record)) {
          return;
        }
        visited.add(record);
        record.sortOrderedChildren(false, false);
        if (record.children) {
          record.updateChildrenIndices(record.children, "parentIndex", true);
        }
        if (record.unfilteredChildren) {
          record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
        }
      });
    });
  }
  // Apply removals, removing records and updating the `removed` bag to match.
  //
  // Accepts an array of objects containing an `id` property. Records in the store matching an entry in the array
  // will be removed from the store and the `removed` bag. Unmatched entries will be removed from the `removed` bag.
  applyRemovals(removals) {
    const me = this, { removed: removedStash } = me, idDataSource = me.modelClass.idField, toRemove = [];
    for (const removedEntry of removals) {
      const id = ObjectHelper.getPath(removedEntry, idDataSource);
      if (removedStash.includes(id)) {
        const record = removedStash.get(id);
        record.internalClearChanges(false, true, null);
        record.$isPhantom = true;
        removedStash.remove(id);
      } else {
        toRemove.push(id);
      }
    }
    if (me.tree) {
      const modifiedParents = toRemove.reduce((parents, id) => {
        var _a4;
        if (me.getById(id)) {
          parents.add((_a4 = me.getById(id).parentNode) != null ? _a4 : me.rootNode);
        }
        return parents;
      }, /* @__PURE__ */ new Set());
      modifiedParents.forEach((parent) => parent.sortOrderedChildren(false, false));
    }
    me.remove(toRemove);
    for (const record of toRemove) {
      removedStash.remove(record);
    }
  }
  /**
   * Filters records that have been added/updated as part of a changeset. The `added` and `updated` parameters
   * are arrays of values that have already been added/updated in the Collection's values. This method brings
   * the Collection's `_filteredValues` in sync without performing a full sort or filter, using the following rules:
   *
   * - Added records that do not match the filter are removed from _filteredValues
   *
   * - Updated records that now match the filter are inserted at the correct position in _filteredValues
   *   if they were not formerly included
   *
   * - Updated records that formerly matched the filter, but now do not, are NOT removed from _filteredValues
   *
   * If the collection is sorted, either on its own or via a sort applied at the store level, that sort order is
   * respected when adding items to _filteredValues. If not, items are inserted in the same order they occur in
   * _values.
   *
   * @param {Object[]} added An array of unique values that were added as part of the changeset.
   * @param {Object[]} updated An array of unique values that were updated as part of the changeset.
   * @returns {Object[]} Any records that were added or removed from view, or whose children were modified.
   * @private
   */
  filterChangeset(added, updated) {
    const me = this, {
      isFiltered,
      tree,
      isGrouped,
      filtersFunction
    } = me, storeSortFunction = me.isSorted ? me.createSorterFn(me.sorters) : void 0, {
      allValues,
      addedValues,
      isSorted
    } = me.storage, sorter = storeSortFunction != null || isSorted ? storeSortFunction != null ? storeSortFunction : me.storage.sortFunction : null, modifiedParents = /* @__PURE__ */ new Set();
    if (!isFiltered) {
      return [];
    }
    let trigger = false, groupers;
    if (isGrouped) {
      groupers = me.groupers;
      me.clearGroupers(true);
    }
    if (tree) {
      const nodesToInclude = new Set(updated.filter(filtersFunction));
      for (const matchingAdd of added.filter(filtersFunction)) {
        nodesToInclude.add(matchingAdd);
      }
      nodesToInclude.forEach((node) => node.bubble((ancestor) => nodesToInclude.add(ancestor)));
      nodesToInclude.delete(me.rootNode);
      const nodesToIncludeByParent = ArrayHelper.groupByIndexed(
        // filter out the nodes that are already included to `children`
        Array.from(nodesToInclude).filter((child) => {
          var _a4, _b;
          return !((_b = (_a4 = child.parent) == null ? void 0 : _a4.children) == null ? void 0 : _b.includes(child));
        }),
        (r) => r.parent
      );
      for (const [parent, siblingsToInclude] of nodesToIncludeByParent) {
        if (parent.unfilteredChildren) {
          parent.children.push(...siblingsToInclude);
          modifiedParents.add(parent);
          me.traverseFilter(parent, false, siblingsToInclude);
        }
      }
    } else if (sorter && !isGrouped) {
      const { filteredValues } = me.storage, sortedLength = addedValues ? filteredValues.findLastIndex((value) => !addedValues.has(value)) + 1 : filteredValues.length, sorted = filteredValues.slice(0, sortedLength), updatedMatches = new Set(updated.filter(filtersFunction));
      for (const value of filteredValues) {
        if (updatedMatches.has(value)) {
          updatedMatches.delete(value);
        }
      }
      for (const newMatch of updatedMatches) {
        sorted.push(newMatch);
      }
      sorted.sort(sorter);
      filteredValues.splice(0, sortedLength, ...sorted);
      trigger = true;
    } else {
      const updatedMatches = updated.filter((item) => filtersFunction(item) && !me.storage.includes(item));
      if (updatedMatches.length > 0) {
        me.includeInSubset(allValues, me.storage.filteredValues, updatedMatches);
        trigger = true;
      }
    }
    const nonMatchingAdds = new Set(added.filter((value) => !filtersFunction(value)));
    if (nonMatchingAdds.size > 0) {
      if (tree) {
        for (const addedChild of nonMatchingAdds) {
          ArrayHelper.remove(addedChild.parent.children, addedChild);
          modifiedParents.add(addedChild.parent);
        }
      } else {
        ArrayHelper.remove(me.storage.filteredValues, nonMatchingAdds);
      }
      trigger = true;
    }
    if (groupers) {
      me.group(groupers[0], null, false, true, true);
      trigger = true;
    }
    if (tree && modifiedParents.size > 0) {
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
    } else if (trigger) {
      me._idMap = null;
      me.trigger("refresh");
    }
    return [...modifiedParents];
  }
  /**
   * Given an array `all`, an array `subset` that is a subset of `all` in the same order, and another array
   * `toInclude` that is a different subset of `all` disjoint with `subset`, add each item from `toInclude`
   * to `subset`, in an order matching the order in `all`. The order of `subset` must match the order of `all`.
   * The order of `toInclude` is unimportant.
   *
   * Modifies `subset` in-place.
   *
   * @param {Array} all An array of unique items (e.g. records)
   * @param {Array} subset An array containing a subset of the items in `all` (same order as `all`)
   * @param {Array} toInclude An array or items from `all` that should be included in `subset` (unordered)
   * @returns {Array} The subset modified in-place.
   * @private
   */
  includeInSubset(all, subset, toInclude) {
    const toIncludeSet = new Set(toInclude);
    let subsetIndex = 0, allIndex = 0, done = toIncludeSet.size === 0;
    while (allIndex < all.length && !done) {
      const subsetItem = subset[subsetIndex];
      let allItem = all[allIndex];
      while (subsetItem !== allItem) {
        if (toIncludeSet.has(allItem)) {
          subset.splice(subsetIndex, 0, allItem);
          subsetIndex++;
          toIncludeSet.delete(allItem);
          done = toIncludeSet.size === 0;
        }
        allItem = all[++allIndex];
      }
      if (toIncludeSet.has(subsetItem)) {
        toIncludeSet.delete(subsetItem);
      }
      if (subsetIndex < subset.length) {
        subsetIndex++;
      }
    }
    return subset;
  }
};

// ../Core/lib/Core/data/mixin/StoreFilter.js
var StoreFilter_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static get $name() {
      return "StoreFilter";
    }
    //region Config
    static get defaultConfig() {
      return {
        /**
         * Specify one or more {@link Core/util/CollectionFilter} config objects to apply initially.
         *
         * For example:
         *
         * ```javascript
         *  // Configure the store to filter in clients over the age of 30
         *  new Store({
         *      ...,
         *      filters : [{
         *          property : 'age',
         *          value    : 30,
         *          operator : '>'
         *      }],
         *      ...
         *  })
         * ```
         *
         * or:
         *
         * ```javascript
         *  // Configure the store to filter based on a complex operation
         *  new Store({
         *      ...,
         *      filters : [{
         *          filterBy(record) {
         *              // Return true or false for filtering in or out
         *              return shouldClientBeVisible(record);
         *          }
         *      }],
         *      ...
         *  })
         * ```
         *
         * @config {CollectionFilterConfig|CollectionFilterConfig[]}
         * @category Filtering
         */
        filters: null,
        /**
         * Specify true to reapply filters when a record is added to the store.
         * @config {Boolean}
         * @default
         * @category Filtering
         */
        reapplyFilterOnAdd: false,
        /**
         * Specify true to reapply filters when a record is updated in the store.
         * @config {Boolean}
         * @default
         * @category Filtering
         */
        reapplyFilterOnUpdate: false
      };
    }
    //endregion
    //region Events
    /**
     * Fired after applying filters to the store
     * @event filter
     * @param {Core.data.Store} source This Store
     * @param {Core.util.Collection} filters Filters used by this Store
     * @param {Core.data.Model[]} removed The records which were filtered out by the action.
     * @param {Core.data.Model[]} added The records which were filtered back in by the action.
     * @param {Core.data.Model[]} records Filtered records
     */
    //endregion
    //region Properties
    set reapplyFilterOnAdd(enable) {
      this.storage.autoFilter = enable;
    }
    get reapplyFilterOnAdd() {
      return this.storage.autoFilter;
    }
    /**
     * Currently applied filters. A collection of {@link Core.util.CollectionFilter} instances.
     * @type {Core.util.Collection}
     * @readonly
     * @category Sort, group & filter
     */
    set filters(filters) {
      const me = this, collection = me.filters;
      collection.clear();
      me._filtersFunction = null;
      if (filters) {
        if (filters.constructor.name === "Object") {
          for (const f of Object.entries(filters)) {
            if (f[0] === "filterBy" && typeof f[1] === "function") {
              collection.add(new CollectionFilter({
                filterBy: f[1]
              }));
            } else {
              collection.add(new CollectionFilter(f[1].constructor.name === "Object" ? Object.assign({
                property: f[0]
              }, f[1]) : {
                property: f[0],
                value: f[1]
              }));
            }
          }
        } else if (Array.isArray(filters)) {
          collection.add(...filters.map((filterConfig) => {
            if (filterConfig instanceof CollectionFilter) {
              return filterConfig;
            }
            return new CollectionFilter(filterConfig);
          }));
        } else if (filters.isCollection) {
          collection.add(...filters.values);
        } else {
          collection.add(new CollectionFilter({
            filterBy: filters
          }));
        }
        collection.forEach((item) => item.owner = me);
      }
    }
    get filters() {
      return this._filters || (this._filters = new Collection({ extraKeys: ["property"] }));
    }
    set filtersFunction(filtersFunction) {
      this._filtersFunction = filtersFunction;
    }
    get filtersFunction() {
      const me = this, { filters, isGrouped } = me;
      if (!me._filtersFunction) {
        if (filters.count) {
          const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);
          me._filtersFunction = (candidate) => {
            if (isGrouped && candidate.isSpecialRow) {
              return candidate.groupChildren.some(generatedFilterFunction);
            }
            return generatedFilterFunction(candidate);
          };
        } else {
          me._filtersFunction = FunctionHelper.returnTrue;
        }
      }
      return me._filtersFunction;
    }
    /**
     * Check if store is filtered
     * @property {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isFiltered() {
      return this.filters.values.some((filter) => !filter.disabled);
    }
    isFilteredOut(record) {
      return this.isFiltered && !this.filtersFunction(record);
    }
    //endregion
    traverseFilter(record, deep = true, forceInclusionSet = void 0) {
      const me = this, { filtersFunction } = me, hitsCurrent = !record.isRoot && filtersFunction(record), children = record.unfilteredChildren || record.children;
      if (!children || !children.length) {
        return hitsCurrent;
      }
      if (!record.unfilteredChildren) {
        record.unfilteredChildren = record.children.slice();
      }
      record.children = record.unfilteredChildren.filter(
        (r) => deep ? me.traverseFilter(r, deep) : filtersFunction(r) || (forceInclusionSet == null ? void 0 : forceInclusionSet.has(r))
      );
      if (me.isSorted) {
        record.children.sort(me.sorterFn);
      }
      record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
      record.updateChildrenIndices(record.children, "parentIndex", true);
      return hitsCurrent || Boolean(record.children.length);
    }
    traverseClearFilter(record) {
      const me = this;
      if (record.unfilteredChildren) {
        record.children = record.orderedChildren.slice();
        record.unfilteredChildren = null;
      }
      if (record.children) {
        if (me.isSorted) {
          record.children.sort(me.sorterFn);
        }
        record.children.forEach((r) => me.traverseClearFilter(r));
        record.updateChildrenIndices(record.children, "parentIndex", true);
      }
    }
    get latestFilterField() {
      return this.filters.last ? this.filters.last.property : null;
    }
    /**
     * Adds a single filter to the {@link #config-filters} collection. By default, filters are reevaluated
     * and a Store change event fired.
     *
     * If the `silent` parameter is passed as `true`, multiple filters can be added without causing data changes.
     *
     * When the filters are as required, call {@link #function-filter} with no parameters
     * to apply the filters to the store.
     *
     * @param {CollectionFilterConfig|Function} newFilter A {@link Core.util.CollectionFilter filter} config,
     * or a function to use for filtering.
     * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
     * adding multiple filters.
     * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
     * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    addFilter(filter, silent = false) {
      const me = this;
      filter = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
      filter.owner = me;
      me.filters.add(filter);
      if (!silent) {
        if (me.remoteFilter) {
          return me.filter().then(() => filter);
        } else {
          me.filter();
        }
      }
      return filter;
    }
    /**
     * Filters the store by **adding** the specified filter(s) to the existing filters collection applied to this Store.
     * If a filter has an {@link Core.util.CollectionFilter#config-id id} specified,
     * or a {@link Core.util.CollectionFilter#config-property property} specified,
     * it will search for corresponding filter(s) in the existing filters first and replace it with a new filter.
     * **It will not remove other filters applied to the store!**
     *
     * To **add** a new filter:
     *
     * ```javascript
     * // Filter using simple object
     * store.filter({
     *     property : 'age',
     *     operator : '>',
     *     value    : 90
     * });
     *
     * // Filter using function
     * store.filter(r => r.age < 90);
     *
     * // Filter using a named filter as a function
     * store.filter({
     *     id : 'my-filter',
     *     filterBy : record => record.score > 10
     * });
     * ```
     *
     * To **remove** a specific filter, but keep other filters applied
     *
     * ```javascript
     * // Remove by filter `id` or `property`. Filter `id` defaults to the `property` name.
     * store.removeFilter('age');
     * store.removeFilter('my-filter');
     * ```
     *
     * To **replace** all existing filters with a new filter
     *
     * ```javascript
     * // Remove all filters and filter using simple object
     * store.filter({
     *     filters : {
     *         property : 'age',
     *         operator : '<',
     *         value    : 90
     *     },
     *     replace : true
     * });
     *
     * // Remove all filters and filter using function
     * store.filter({
     *     filters : r => r.age > 90,
     *     replace : true
     * });
     *
     * // Remove all filters and filter using a named filter as a function
     * store.filter({
     *     filters : {
     *         id : 'my-filter',
     *         filterBy : record => record.score > 10
     *     },
     *     replace : true
     * });
     * ```
     *
     * Basically filters replacing is an equivalent of having two sequenced calls:
     * {@link #function-clearFilters clearFilters} and {@link #function-filter filter}.
     *
     * Call without arguments to reapply filters.
     *
     * ```javascript
     * // Re-filter the store
     * store.filter();
     * ```
     *
     * @param {Object|CollectionFilterConfig|CollectionFilterConfig[]|Function} newFilters
     *        A {@link Core.util.CollectionFilter filter} config,
     *        or an array of {@link Core.util.CollectionFilter filter} configs,
     *        or a function to use for filtering,
     *        or a special object like: ```{ replace : true, filters : newFilters }```
     * @param {Boolean} [newFilters.replace]
     *        A flag, indicating whether or not the previous filters should be removed.
     * @param {Boolean} [newFilters.silent]
     *        Set as true to not fire events. UI will not be informed about the changes.
     * @param {CollectionFilterConfig|CollectionFilterConfig[]|Function} [newFilters.filters]
     *        If `newFilters` is an object and `replace` property is defined in the `newFilters`,
     *        it means that special object is used and real filter configuration must be nested down to this `filters` property.
     *        It can be:
     *        A {@link Core.util.CollectionFilter filter} config,
     *        or an array of {@link Core.util.CollectionFilter filter} configs,
     *        or a function to use for filtering.
     * @fires filter
     * @fires Core.data.Store#event-change
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns Promise
     * which is resolved after data is loaded from remote server, otherwise it returns null value
     * @async
     * @category Sort, group & filter
     */
    filter(newFilters) {
      const me = this;
      let silent = false, internal;
      if (newFilters) {
        let fieldType = typeof newFilters;
        if (fieldType === "object") {
          if ("silent" in newFilters || "replace" in newFilters || newFilters.filters) {
            silent = newFilters.silent;
            if (newFilters.replace) {
              me.clearFilters(newFilters.filters.length === 0);
            }
            internal = newFilters.internal;
            newFilters = newFilters.filters;
            fieldType = typeof newFilters;
          }
        }
        if (newFilters) {
          const wasFiltered = me.isFiltered;
          me.isConfiguring = true;
          if (Array.isArray(newFilters)) {
            newFilters.forEach((f) => me.addFilter(f, true), me);
          } else if (fieldType === "function") {
            const filter = new CollectionFilter(newFilters);
            filter.internal = internal;
            me.addFilter(filter, true);
          } else if (fieldType === "string") {
            me.addFilter({
              property: newFilters,
              value: arguments[1]
            }, true);
          } else {
            me.addFilter(newFilters, true);
          }
          me.isConfiguring = false;
          if (!me.isFiltered && !wasFiltered) {
            return null;
          }
        }
      }
      me.filtersFunction = null;
      const result = me.performFilter(silent);
      me._idMap = null;
      return result;
    }
    suspendFilterOnUpdate() {
      this.filterBatching++;
    }
    resumeFilterOnUpdate(silent) {
      this.filterBatching--;
      if (this.filterBatching < 0) {
        throw new Error("No matching `startFilterBatching` call");
      }
      if (this.filterBatching === 0 && this.needsFiltering) {
        this.needsFiltering = false;
        this.performFilter(silent);
      }
    }
    /**
     * Perform filtering according to the {@link #property-filters} Collection.
     * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
     * must not be overridden.
     * @private
     */
    performFilter(silent) {
      const me = this;
      if (me.filterBatching > 0) {
        me.needsFiltering = true;
        return;
      }
      const { storage, filters, rootNode } = me, oldCount = me.count;
      me.trigger("beforeFilter", { filters });
      let added, removed;
      if (me.tree) {
        const oldDataset = storage.values;
        if (me.isFiltered) {
          me.traverseFilter(rootNode);
        } else {
          me.traverseClearFilter(rootNode);
        }
        const newDataset = me.collectDescendants(rootNode).visible;
        storage.replaceValues({
          values: newDataset,
          silent: true
        });
        const delta = ArrayHelper.delta(newDataset, oldDataset, true);
        added = delta.toAdd;
        removed = delta.toRemove;
      } else {
        storage.ion({
          change({ removed: r, added: a }) {
            removed = r;
            added = a;
          },
          once: true
        });
        if (me.isFiltered) {
          me.isGrouped && me.includeCollapsed();
          storage.addFilter({
            id: "primary-filter",
            filterBy: me.filtersFunction
          });
          me.isGrouped && me.excludeCollapsed();
        } else {
          storage.filters.clear();
        }
      }
      me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {
        action: "filter",
        filters,
        oldCount,
        added,
        removed,
        records: me.storage.values
      });
    }
    afterPerformFilter(event) {
      this.resetRelationCache();
      if (event) {
        this.triggerFilterEvent(event);
      }
    }
    // Used from filter() and StoreCRUD when reapplying filters
    triggerFilterEvent(event) {
      this.trigger("filter", event);
      if (!this.remoteFilter) {
        this.trigger("refresh", event);
        this.trigger("change", event);
      }
    }
    /**
     * *Adds* a function used to filter the store. Alias for calling `filter(fn)`. Return `true` from the function to
     * include record in filtered set
     *
     * ```javascript
     * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));
     * ```
     *
     * @param {Function} fn Function used to test records
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    filterBy(fn) {
      return this.filter(fn);
    }
    /**
     * Removes the passed filter, or the filter by the passed ID from the {@link #config-filters} collection.
     * By default, filters are reevaluated and a Store change event fired.
     *
     * If the `silent` parameter is passed as `true`, multiple filters can be removed without causing data changes.
     *
     * When the filters are as required, call {@link #function-filter} with no parameters
     * to apply the filters to the store.
     *
     * ```javascript
     * // Only view top priority events
     * myEventStore.filter({
     *     id       : 'priorityFilter',
     *     property : 'priority',
     *     value    : 1,
     *     operator : '='
     * });
     *
     * // That individual filter can be removed like this
     * myEventStore.removeFilter('priorityFilter');
     *
     * // Add named filter as a function
     * store.filter({
     *     id : 'my filter',
     *     filterBy : record => record.score > 10
     * });
     *
     * // Remove named filter function
     * store.removeFilter('my filter');
     * ```
     *
     * @param {String|Core.util.CollectionFilter} idOrInstance Filter to remove, or ID of the filter to remove. By default,
     * filters are reevaluated and a change event fired.
     * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
     * removing multiple filters.
     * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
     * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    removeFilter(idOrInstance, silent = false) {
      const me = this, filter = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);
      if (filter) {
        me.filters.remove(filter);
        me._filtersFunction = null;
        if (!silent) {
          if (me.remoteFilter) {
            return me.filter().then(() => filter);
          } else {
            me.filter();
          }
        }
        return filter;
      }
    }
    /**
     * Removes all filters from the store.
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    clearFilters(apply = true) {
      this.filters.remove(this.filters.values.filter((f) => !f.internal));
      if (apply) {
        return this.filter();
      }
    }
    convertFilterToString(field) {
      const filter = this.filters.getBy("property", field);
      return filter && !filter.filterBy ? String(filter) : "";
    }
    doDestroy() {
      var _a5;
      (_a5 = this._filters) == null ? void 0 : _a5.destroy();
      super.doDestroy();
    }
  }, __publicField(_a4, "properties", {
    filterBatching: 0,
    needsFiltering: false
  }), _a4;
};

// ../Core/lib/Core/data/mixin/StoreGroup.js
var resortActions = {
  add: 1,
  replace: 1
};
var defaultGroupSortFn = ({ _groupValue: lhs }, { _groupValue: rhs }) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
var arrayAt = (array, index) => array[index < 0 ? array.length + index : index];
var StoreGroup_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static get properties() {
      return {
        collapsedGroups: /* @__PURE__ */ new Set()
      };
    }
    //endregion
    //region Init
    construct(config) {
      super.construct(config);
      this.ion({ change: "onDataChanged", thisObj: this });
    }
    get GroupRow() {
      var _a5;
      return this._GroupRowClass || (this._GroupRowClass = (_a5 = class extends this.modelClass {
        get isCollapsed() {
          return this.meta.collapsed;
        }
      }, __publicField(_a5, "isSpecialRow", true), // The calculated group value for this group header/footer.
      __publicField(_a5, "fields", [{
        name: "_groupValue"
      }]), _a5));
    }
    updateGroupers(groupers) {
      this.setGroupers(groupers);
    }
    /**
     * Set groupers.
     * @param {Grouper[]} groupers Array of groupers to apply to store
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns
     * `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    setGroupers(groupers, options = null) {
      const me = this, { storage } = me;
      let result;
      if (groupers == null ? void 0 : groupers.length) {
        me._groupers = groupers.map((g) => me.createGrouper(g));
      } else if (me.groupers) {
        delete me._groupers;
        me.includeCollapsed();
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage._values),
          filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
          silent: true
        });
        result = me.group(null, null, null, false, options == null ? void 0 : options.silent);
      }
      me._idMap = null;
      return result;
    }
    createGrouper(grouper) {
      if (!grouper || grouper.isGrouper) {
        return grouper;
      }
      if (typeof grouper === "string") {
        grouper = {
          field: grouper
        };
      }
      const { field } = grouper, dotPos = field == null ? void 0 : field.indexOf("."), complexMapping = dotPos > 0, path = field == null ? void 0 : field.split("."), rootFieldName = complexMapping ? path[0] : field, leafFieldName = complexMapping ? arrayAt(path, -1) : field, fieldPath = complexMapping ? field.slice(dotPos + 1) : field;
      return {
        isGrouper: true,
        ...grouper,
        complexMapping,
        rootFieldName,
        leafFieldName,
        fieldPath
      };
    }
    get unfilteredGroupRecords() {
      var _a5;
      const me = this;
      if (me.isGrouped) {
        const { generation } = me.storage;
        if (((_a5 = me._unfilteredGroupRecords) == null ? void 0 : _a5.generation) !== generation) {
          me._unfilteredGroupRecords = me.storage.allValues.filter((r) => r.isSpecialRow);
          me._unfilteredGroupRecords.generation = generation;
        }
      }
      return me._unfilteredGroupRecords || [];
    }
    /**
     * Returns group header record for the passed record or last group header in the store
     * @param {Core.data.Model} [targetRecord]
     * @param {Boolean} [ignoreFilter] Pass true to search in the complete collection
     * @returns {Core.data.Model}
     * @internal
     */
    getGroupHeaderForRecord(targetRecord, ignoreFilter = false) {
      if (this.isGrouped) {
        return targetRecord ? targetRecord.meta.groupRowFor ? targetRecord : targetRecord.groupParent.get(this.id) : this.groupRecords.last;
      }
    }
    // Temporarily include records from collapsed groups, for example prior to filtering
    includeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.expand(this.getById(groupId), false);
      }
    }
    // Exclude records in collapsed groups, intended to be used after a call to includeCollapsed()
    excludeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.collapse(this.getById(groupId));
      }
    }
    onDataChange({ source: storage, action, removed }) {
      var _a5;
      const me = this, { groupers } = me;
      if (groupers) {
        if (groupers.length) {
          if (action === "splice" && (removed == null ? void 0 : removed.length) || action === "move") {
            storage.replaceValues({
              ...me.prepareGroupRecords(),
              silent: true
            });
          }
        } else {
          storage.replaceValues({
            values: me.removeHeadersAndFooters(storage._values),
            filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
            silent: true
          });
        }
      }
      (_a5 = super.onDataChange) == null ? void 0 : _a5.call(this, ...arguments);
    }
    move(records, beforeRecord) {
      const me = this;
      if (me.isGrouped && !me.tree) {
        let prevRecord = beforeRecord;
        if (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow) {
          prevRecord = me.getPrev(beforeRecord, false, false);
          if (!prevRecord) {
            return;
          }
        }
        const targetGroupHeader = me.getGroupHeaderForRecord(prevRecord), groupField = me.groupers[0].field, newGroupValue = targetGroupHeader.meta.groupRowFor, { reapplyFilterOnUpdate } = me;
        me.reapplyFilterOnUpdate = false;
        me.beginBatch();
        records.forEach((record) => record.setValue(groupField, newGroupValue));
        me.endBatch();
        me.reapplyFilterOnUpdate = reapplyFilterOnUpdate;
        if (me.isFiltered && (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow)) {
          const { unfilteredGroupRecords } = me, index = unfilteredGroupRecords.indexOf(targetGroupHeader);
          beforeRecord = unfilteredGroupRecords[index + 1];
        }
      }
      super.move(records, beforeRecord);
    }
    // private function that collapses on the data level
    collapse(groupRecord) {
      if (groupRecord && !groupRecord.meta.collapsed) {
        this.excludeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = true;
        this.collapsedGroups.add(groupRecord.id);
        this.trigger("toggleGroup", { groupRecord, collapse: true });
        return true;
      }
      return false;
    }
    // private function that expands on the data level
    expand(groupRecord, updateMap = true) {
      if (groupRecord == null ? void 0 : groupRecord.meta.collapsed) {
        this.includeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = false;
        updateMap && this.collapsedGroups.delete(groupRecord.id);
        updateMap && this.trigger("toggleGroup", { groupRecord, collapse: false });
        return true;
      }
      return false;
    }
    removeHeadersAndFooters(records) {
      return records.filter((r) => {
        var _a5;
        if (r.unfilteredGroupChildren) {
          r.groupChildren.length = r.unfilteredGroupChildren.length = r.meta.childCount = 0;
        }
        if (r.isSpecialRow || r.isLinked && ((_a5 = r.groupParent) == null ? void 0 : _a5.get(this.id))) {
          this.unregister(r);
          return false;
        }
        return true;
      });
    }
    prepareGroupRecords() {
      var _a5;
      const me = this, {
        GroupRow,
        isFiltered,
        reapplyFilterOnUpdate,
        groupRecords
      } = me, grouper = me.groupers[0], multiplier = grouper.ascending !== false ? 1 : -1, {
        field,
        fn: groupSortFn = defaultGroupSortFn,
        leafFieldName
      } = grouper, byFn = typeof field === "function", groupingById = field === me.modelClass.idField, newGroupRecords = new Collection(), visibleRecordsIds = me._groupVisibleRecordIds || [], isVisible2 = (record) => {
        const matchesFilter = !isFiltered || me.filtersFunction(record);
        return reapplyFilterOnUpdate ? matchesFilter : matchesFilter || visibleRecordsIds.includes(record.id);
      }, collapseAll = Boolean(me.startGroupsCollapsed && !(groupRecords == null ? void 0 : groupRecords.count));
      groupRecords == null ? void 0 : groupRecords.forEach((groupRec) => {
        if (groupRec.isCollapsed) {
          me.includeGroupRecords(groupRec);
        }
      });
      const records = me.removeHeadersAndFooters(me.storage._values);
      if (me.sorters.length) {
        records.sort(me.sorterFn);
      }
      if (isFiltered) {
        me.filtersFunction = null;
      }
      records.forEach((rec) => {
        const original = rec, v = byFn ? field(rec) : rec.getValue(field), groupValues = ArrayHelper.asArray(v == void 0 ? "!!novalue!!" : v), multiValue = Array.isArray(groupValues), emptyArray13 = multiValue && !groupValues.length, length = emptyArray13 ? 1 : groupValues.length;
        for (let i = 0; i < length; i++) {
          const groupValue = emptyArray13 ? [] : groupValues[i], id = `group-header-${typeof groupValue === "number" ? groupValue : StringHelper.createId(groupValue)}`;
          let groupRec = newGroupRecords.get(id);
          if (!groupRec) {
            groupRec = (groupRecords == null ? void 0 : groupRecords.get(id)) || new GroupRow({
              [me.modelClass.idField]: id,
              [groupingById ? "" : leafFieldName]: groupValue,
              _groupValue: groupValue
            }, me, {
              collapsed: collapseAll,
              specialRow: true,
              groupRowFor: groupValue,
              groupField: leafFieldName,
              emptyArray: emptyArray13
            });
            newGroupRecords.add(groupRec);
            groupRec.meta.childCount = 0;
            groupRec.groupChildren = [];
            groupRec.unfilteredGroupChildren = [];
            groupRec.stores = [me];
          }
          me.register(groupRec);
          if (i > 0) {
            const links = original.groupLinks || (original.groupLinks = []);
            rec = links[groupValue] || (links[groupValue] = original.link());
            rec.stores = [me];
            me.register(rec);
          }
          if (!rec.groupParent) {
            rec.setData("groupParent", /* @__PURE__ */ new Map());
          }
          rec.groupParent.set(me.id, groupRec);
          if (isVisible2(rec)) {
            groupRec.groupChildren.push(rec);
            groupRec.meta.childCount++;
          }
          groupRec.unfilteredGroupChildren.push(rec);
        }
      });
      newGroupRecords._values.sort((lhs, rhs) => groupSortFn(lhs, rhs) * multiplier);
      if (me.useGroupFooters) {
        for (let index = 0, length = newGroupRecords.count; index < length; index++) {
          const groupRec = newGroupRecords.values[index], val = groupRec.meta.groupRowFor, id = `group-footer-${typeof val === "number" ? val : StringHelper.createId(val)}`, footer = me.getById(id) || new GroupRow({
            [me.modelClass.idField]: id,
            [groupingById ? "" : leafFieldName]: val,
            _groupValue: val
          }, me, {
            specialRow: true,
            groupFooterFor: val,
            groupRecord: groupRec
          });
          footer.stores = [me];
          me.register(footer);
          footer.groupChildren = groupRec.groupChildren;
          newGroupRecords.splice(++index, 0, footer);
          length++;
          groupRec.groupChildren.push(footer);
          groupRec.unfilteredGroupChildren.push(footer);
          groupRec.meta.childCount++;
        }
      }
      me._idMap = null;
      const result = {
        values: newGroupRecords.reduce((result2, groupRec) => {
          if (!groupRec.isGroupFooter) {
            result2.push(groupRec);
            if (!groupRec.meta.collapsed) {
              result2.push(...groupRec.unfilteredGroupChildren);
            }
          }
          return result2;
        }, false, [])
      };
      if (isFiltered) {
        result.filteredValues = result.values.filter(isVisible2);
      }
      (_a5 = me.groupRecords) == null ? void 0 : _a5.forEach((oldGroupRec) => {
        if (!newGroupRecords.includes(oldGroupRec)) {
          oldGroupRec.destroy();
        }
      });
      me.groupRecords = newGroupRecords;
      return result;
    }
    //endregion
    //region Group and ungroup
    /**
     * Is store currently grouped?
     * @property {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isGrouped() {
      var _a5;
      return Boolean((_a5 = this.groupers) == null ? void 0 : _a5.length);
    }
    /**
     * Group records, either by replacing current sorters or by adding to them.
     * A grouper can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
     * normal sorting routine. Grouped store **must** always be sorted by the same field.
     *
     * ```javascript
     * // simple grouper
     * store.group('city');
     *
     * // grouper as object, descending order
     * store.group({ field : 'city', ascending : false });
     *
     * // using custom sorting function
     * store.group({
     *     field : 'city',
     *     fn : (recordA, recordB) => {
     *         // apply custom logic, for example:
     *         return recordA.city.length < recordB.city.length ? -1 : 1;
     *     }
     * });
     * ```
     *
     * @param {String|Object} field Field to group by.
     * Can also be a config containing a field to group by and a custom sorting function called `fn`.
     * @param {String} field.field Field to group by
     * @param {Function} field.fn Custom sorting function
     * @param {Boolean} field.ascending  Sort order of the group titles
     * @param {Boolean} [ascending] Sort order of the group titles
     * @param {Boolean} [add] Add a grouper (true) or use only this grouper (false)
     * @param {Boolean} [performSort] Trigger sort directly, which does the actual grouping
     * @param {Boolean} [silent] Set as true to not fire events
     * @category Sort, group & filter
     * @fires group
     * @fires Core.data.Store#event-refresh
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     */
    group(field, ascending2, add = false, performSort = true, silent = false) {
      var _a5, _b;
      const me = this, grouper = me.createGrouper(field);
      let newGrouper;
      if (add) {
        me.groupers.push(grouper);
      } else if (field) {
        if (ascending2 == null && !("ascending" in grouper)) {
          grouper.ascending = grouper.fn && ((_a5 = me.groupInfo) == null ? void 0 : _a5.field) === grouper.field && ((_b = me.groupInfo) == null ? void 0 : _b.fn) === grouper.fn ? !me.groupInfo.ascending : true;
        }
        me.groupInfo = newGrouper = grouper;
        me.groupers = [me.groupInfo];
      }
      if (newGrouper) {
        const { prototype: prototype2 } = me.modelClass;
        if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype2, field)) {
          Object.defineProperty(prototype2, field, {
            get() {
              return ObjectHelper.getPath(this, field);
            }
          });
        }
      }
      if (performSort !== false) {
        if (me.remoteSort && !me.isRemoteDataLoading) {
          return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));
        } else {
          me.sort(null, null, false, true);
        }
      }
      me.onAfterGrouping(silent);
    }
    onAfterGrouping(silent) {
      if (silent) {
        return;
      }
      const me = this, groupers = me.groupers || [];
      me.trigger("group", { isGrouped: me.isGrouped, groupers, records: me.storage.values });
      me.trigger("refresh", { action: "group", isGrouped: me.isGrouped, groupers, records: me.storage.values });
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Add a grouping level (a grouper).
     * @param {String} field Field to group by
     * @param {Boolean} ascending Group direction
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    addGrouper(field, ascending2 = true) {
      return this.group(field, ascending2, true);
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Removes a grouping level (a grouper)
     * @param {String} field Grouper to remove
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    removeGrouper(field) {
      const me = this, { groupers } = me;
      if (!groupers) {
        return;
      }
      const index = groupers.findIndex((grouper) => grouper.field === field);
      if (index > -1) {
        groupers.splice(index, 1);
        if (!groupers.length) {
          return me.clearGroupers();
        } else {
          return me.group();
        }
      }
    }
    /**
     * Removes all groupers, turning store grouping off.
     * @privateparam {Boolean} [silent=false] Pass true to suppress events.
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    clearGroupers(silent = false) {
      return this.setGroupers(null, { silent });
    }
    //endregion
    //region Get and check
    /**
     * Check if a record belongs to a certain group (only for the first grouping level)
     * @param {Core.data.Model} record The Record
     * @param {*} groupValue The group value
     * @returns {Boolean} True if the record belongs to the group, otherwise false
     * @category Sort, group & filter
     */
    isRecordInGroup(record, groupValue) {
      var _a5;
      if (!this.isGrouped) {
        return null;
      }
      const groupField = (_a5 = this.groupers[0]) == null ? void 0 : _a5.field;
      return record.getValue(groupField) === groupValue && !record.isSpecialRow;
    }
    isInCollapsedGroup(record) {
      const parentGroupRec = record.groupParent.get(this.id);
      return parentGroupRec == null ? void 0 : parentGroupRec.meta.collapsed;
    }
    /**
     * Returns all records in the group with specified groupValue.
     * @param {*} groupValue
     * @returns {Core.data.Model[]} Records in specified group or null if store not grouped
     * @category Sort, group & filter
     */
    getGroupRecords(groupValue) {
      if (!this.isGrouped) {
        return null;
      }
      return this.storage.values.filter((record) => this.isRecordInGroup(record, groupValue));
    }
    /**
     * Get all group titles.
     * @returns {String[]} Group titles
     * @category Sort, group & filter
     */
    getGroupTitles() {
      if (!this.isGrouped) {
        return null;
      }
      return this.getDistinctValues(this.groupers[0].field);
    }
    //endregion
    onDataChanged({ changes, action }) {
      if (this.isGrouped && // If an action flagged as requiring resort is performed...
      (!changes && resortActions[action] || // ...or if the group field has changes...
      changes && this.groupers.some((grouper) => grouper.rootFieldName in changes))) {
        this.sort();
      }
    }
    /**
     * Adds or removes records in a group from storage. Used when expanding/collapsing groups.
     * @private
     * @param {Core.data.Model} groupRecord Group which records should be added or removed
     * @param {Boolean} include Include (true) or exclude (false) records
     * @category Grouping
     */
    internalIncludeExcludeGroupRecords(groupRecord, include) {
      const me = this, index = me.indexOf(groupRecord), allIndex = me.allIndexOf(groupRecord), { id: mapId, storage } = me, {
        _filteredValues,
        _values
      } = storage, {
        meta,
        groupChildren,
        unfilteredGroupChildren
      } = groupRecord;
      if (allIndex === -1 || meta.collapsed && !include || !meta.collapsed && include) {
        return;
      }
      unfilteredGroupChildren.forEach(
        (child) => child.instanceMeta(mapId).hiddenByCollapse = !include
      );
      if (include) {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, 0, ...groupChildren.filter((r) => !me.isAvailable(r.id)));
        }
        storage._values.splice(allIndex + 1, 0, ...unfilteredGroupChildren.filter((r) => !me.isAvailable(r.id)));
      } else {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, groupChildren.length);
        }
        _values.splice(allIndex + 1, unfilteredGroupChildren.length);
      }
      storage._indicesInvalid = true;
      me._idMap = null;
    }
    /**
     * Removes records in a group from storage. Used when collapsing a group.
     * @private
     * @param groupRecord Group which records should be removed
     * @category Grouping
     */
    excludeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, false);
    }
    /**
     * Adds records in a group to storage. Used when expanding a group.
     * @private
     * @param groupRecord Group which records should be added
     * @category Grouping
     */
    includeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, true);
    }
    /**
     * Collects all group headers + children, whether expanded or not
     * @private
     * @param {Boolean} allRecords True to include filtered out records
     * @param {Boolean} includeHeaders True to also include group headers
     * @returns {Core.data.Model[]}
     */
    collectGroupRecords(allRecords, includeHeaders = true) {
      const records = allRecords ? this.storage.allValues : this.storage.values;
      return records.reduce((records2, record) => {
        if (record.isSpecialRow) {
          if (includeHeaders && !record.isGroupFooter) {
            records2.push(record);
          }
          if (record.isGroupHeader) {
            records2.push.apply(records2, allRecords ? record.unfilteredGroupChildren : record.groupChildren);
          }
        }
        return records2;
      }, []);
    }
  }, __publicField(_a4, "$name", "StoreGroup"), //region Config
  __publicField(_a4, "configurable", {
    /**
     * Currently used groupers.
     * To set groupers when remote sorting is enabled by {@link Core/data/AjaxStore#config-sortParamName} you should
     * use {@link #function-setGroupers} instead to be able to wait for the operation to finish.
     * @member {Grouper[]} groupers
     * @category Sort, group & filter
     */
    /**
     * Initial groupers, specify to have store grouped automatically after initially setting data
     * @config {Grouper[]}
     * @category Common
     */
    groupers: null,
    useGroupFooters: false,
    /**
     * To have all groups __initially loaded__ start collapsed, configure this as `true`.
     *
     * Note that this only affects the initial load of the store. Subsequent reloads maintain
     * current group state where possible.
     * @config {Boolean}
     * @default false
     * @category Advanced
     */
    startGroupsCollapsed: null
  }), _a4;
};

// ../Core/lib/Core/data/mixin/StoreProxy.js
var StoreProxy_default = (Target) => class StoreProxy extends (Target || Base) {
  static get configurable() {
    return {
      /**
       * Allow object like interaction with the Store. For example:
       *
       * ```javascript
       * const store = new Store({
       *    objectify : true,
       *    data      : [
       *        { id : 'batman', name : 'Bruce' }
       *    ]
       * });
       *
       * // retrieve using id as property
       * const record = store.batman;
       *
       * // add as property
       * store.superman = { name : 'Clark' };
       *
       * // delete to remove
       * delete store.batman;
       * ``
       *
       * @config {Boolean}
       * @default false
       */
      objectify: null
    };
  }
  initProxy() {
    if (!globalThis.Proxy) {
      throw new Error("Proxy not supported");
    }
    const proxy = new Proxy(this, {
      // Support getting records using `store[id/index]
      get(target, property) {
        if (property in target) {
          return target[property];
        }
        if (property === "$store") {
          return target;
        }
        let record = target.getById(property);
        if (!record && !isNaN(parseInt(property))) {
          record = target.getAt(parseInt(property));
        }
        return record;
      },
      // Support adding/replacing records using `store.id = { ...data }`
      set(target, property, value) {
        if (property in target || target.isDestroying || property === "_triggered") {
          target[property] = value;
        } else {
          target.add({ [target.modelClass.idField]: property, ...value });
        }
        return true;
      },
      // Support deleting records using `delete store.id`
      deleteProperty(target, property) {
        if (target.isDestroying) {
          delete target[property];
          return true;
        }
        return Boolean(target.remove(property).length);
      },
      // Support `id in store`
      has(target, property) {
        if (property in target) {
          return true;
        }
        if (property.startsWith("{") && property.endsWith("}")) {
          const data = StringHelper.safeJsonParse(property);
          property = data == null ? void 0 : data.id;
        }
        return target.includes(property);
      }
    });
    return proxy;
  }
};

// ../Core/lib/Core/data/mixin/StoreRelation.js
var StoreRelation_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    //region Init
    /**
     * Initialized relations, called from constructor
     * @private
     */
    initRelations(reset) {
      const me = this, relations = me.modelClass.exposedRelations;
      if (reset && me.modelRelations) {
        me.modelRelations.forEach((relation) => {
          var _a5;
          return (_a5 = relation.storeDetacher) == null ? void 0 : _a5.call(relation);
        });
      }
      if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && !me.isChained) {
        me.modelRelations = [];
        relations == null ? void 0 : relations.forEach((modelRelationConfig) => {
          const config = { ...modelRelationConfig }, {
            foreignStore,
            relationName,
            relatedCollectionName
          } = config, relatedStore = typeof foreignStore === "string" ? me[foreignStore] : foreignStore;
          config.dependentStore = me;
          me.modelRelations.push(config);
          if (relatedStore) {
            config.foreignStoreProperty = config.foreignStore;
            config.foreignStore = relatedStore;
            const dependentStoreConfigs = relatedStore.dependentStoreConfigs;
            if (dependentStoreConfigs.has(me)) {
              const dependentConfigs = dependentStoreConfigs.get(me);
              if (reset) {
                const existingConfig = dependentConfigs.find((c) => c.relationName === relationName);
                if (existingConfig) {
                  ArrayHelper.remove(dependentConfigs, existingConfig);
                }
              }
              dependentConfigs.push(config);
            } else {
              dependentStoreConfigs.set(me, [config]);
            }
            if (relatedCollectionName) {
              relatedStore.initRelationCollection(config, me);
            }
            if (relatedStore.count > 0) {
              relatedStore.updateDependentStores("dataset", relatedStore.records);
            }
          }
        });
      }
    }
    /**
     * Called from other end of a relation when this store should hold a collection of related records.
     * @private
     * @param config
     * @param collectionStore
     */
    initRelationCollection(config, collectionStore) {
      const me = this, name = config.relatedCollectionName, collectionStores = me.collectionStores || (me.collectionStores = {});
      collectionStores[name] = {
        store: collectionStore,
        config
      };
      if (!me[name + "Store"]) {
        me[name + "Store"] = collectionStore;
      }
      if (me.count > 0) {
        me.initModelRelationCollection(name, me.allRecords);
      }
    }
    initModelRelationCollection(name, records) {
      const me = this;
      records.forEach((record) => {
        record.traverse((node) => {
          const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;
          Object.defineProperty(node, useName, {
            enumerable: true,
            configurable: true,
            get: function() {
              return me.getCollection(this, name);
            },
            set: function(value) {
              return me.setCollection(this, name, value);
            }
          });
        });
      });
    }
    /**
     * Updates relationCache for all records.
     * @private
     */
    resetRelationCache() {
      this.relationCache = {};
      this.forEach((record) => record.initRelations());
    }
    /**
     * Caches related records from related store on the local store.
     * @private
     * @param record Local record
     * @param relations Relations to related store
     */
    updateRecordRelationCache(record, relations) {
      relations == null ? void 0 : relations.forEach((relation) => {
        const { config } = relation, foreignId = relation.related ? relation.related.id : record.getValue(config.foreignKey);
        foreignId !== void 0 && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);
      });
    }
    //endregion
    //region Getters
    /**
     * Returns records the relation cache. Same result as if retrieving the collection on the dependent store, but
     * without the need of accessing that store.
     * @internal
     * @param {String} name
     * @param {Core.data.Model|String|Number} recordOrId
     * @returns {Array}
     */
    getRelationCollection(name, recordOrId) {
      var _a5;
      const id = Model.asId(recordOrId);
      return ((_a5 = this.relationCache[name]) == null ? void 0 : _a5[id]) || [];
    }
    /**
     * Returns records from a collection of related records. Not to be called directly, called from Model getter.
     * @private
     * @param {Core.data.Model} record
     * @param {String} name
     * @returns {Array}
     */
    getCollection(record, name) {
      var _a5;
      const { config, store } = this.collectionStores[name];
      return ((_a5 = store.relationCache[config.relationName]) == null ? void 0 : _a5[record.id]) || [];
    }
    /**
     * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called
     * directly, called from Model setter.
     * @private
     */
    setCollection(model, name, records) {
      const { config, store } = this.collectionStores[name], relationCache = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}), old = (relationCache[model.id] || []).slice(), added = [], removed = [];
      store.suspendEvents();
      old.forEach((record) => {
        if (!records.includes(record)) {
          record[config.foreignKey] = null;
          store.remove(record);
          removed.push(record);
        }
      });
      records.forEach((record) => {
        if (record.isModel instanceof Model) {
          if (!record.stores.includes(store)) {
            store.add(record);
            added.push(record);
          }
        } else {
          [record] = store.add(record);
          added.push(record);
        }
        record[config.foreignKey] = model.id;
      });
      store.resumeEvents();
      if (removed.length) {
        store.trigger("remove", { records: removed });
        store.trigger("change", { action: "remove", records: removed });
      }
      if (added.length) {
        store.trigger("add", { records: added });
        store.trigger("change", { action: "add", records: added });
      }
    }
    //endregion
    //region Caching
    /**
     * Adds a record to relation cache, optionally removing it if already there.
     * @private
     * @param record
     * @param id
     * @param name
     * @param uncacheId
     */
    cacheRelatedRecord(record, id, name, uncacheId = null) {
      const me = this, cache = me.relationCache[name] || (me.relationCache[name] = {});
      if (uncacheId !== null) {
        me.uncacheRelatedRecord(record, name, uncacheId);
      }
      if (id != null) {
        ArrayHelper.include(cache[id] || (cache[id] = []), record);
      }
    }
    /**
     * Removes a record from relation cache, for a specific relation (specify relation name and id) or for all relations
     * @private
     * @param record Record to remove from cache
     * @param name Optional, relation name
     * @param id Optional, id
     */
    uncacheRelatedRecord(record, name = null, id = null) {
      const me = this;
      function remove(relationName, relatedId) {
        const cache = me.relationCache[relationName], oldCache = cache == null ? void 0 : cache[relatedId];
        if (oldCache) {
          const uncacheIndex = oldCache.indexOf(record);
          uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);
          if (oldCache.length === 0) {
            delete cache[relatedId];
          }
        }
      }
      if (id != null) {
        remove(name, id);
      } else {
        if (record.meta.relationCache) {
          Object.entries(record.meta.relationCache).forEach(
            ([relationName, relatedRecord]) => remove(relationName, relatedRecord == null ? void 0 : relatedRecord.id)
          );
        }
      }
    }
    /**
     * Updates related stores when store is cleared, a record is removed or added.
     * @private
     * @param {String} action
     * @param {Core.data.Model[]} records
     */
    updateDependentStores(action, records, silent) {
      var _a5;
      const me = this;
      me.dependentStoreConfigs.forEach((configs) => {
        configs.forEach((config) => {
          const {
            dependentStore,
            relatedCollectionName,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName];
          if (action === "dataset") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
            dependentStore.forEach((record) => {
              const foreign = record.initRelation(config);
              foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);
            });
          } else if (action === "removeall") {
            dependentStore.forEach((record) => record.removeRelation(config));
            delete dependentStore.relationCache[relationName];
            return;
          } else if (action === "replace") {
            records = records.map((r) => r[1]);
          }
          if (action === "add" || action === "replace") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
          }
          if (action !== "dataset") {
            records.forEach((record) => {
              const dependentRecords = cache == null ? void 0 : cache[record.id];
              switch (action) {
                case "remove":
                  if (dependentRecords) {
                    dependentRecords.forEach((dependentRecord) => dependentRecord.removeRelation(config));
                  }
                  break;
                case "add":
                case "replace":
                  dependentStore.forEach((dependentRecord) => {
                    if (dependentRecord.getValue(foreignKey) == record.id) {
                      dependentRecord.initRelation(config);
                      dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);
                    }
                  });
                  break;
              }
              if (!silent && (dependentRecords == null ? void 0 : dependentRecords.length) && config.propagateRecordChanges) {
                dependentRecords.forEach(
                  (dependentRecord) => me.notifyRelatedStore(dependentStore, dependentRecord, config.relationName, record)
                );
              }
            });
          }
        });
      });
      if (action !== "dataset" && (records == null ? void 0 : records.length)) {
        (_a5 = me.modelRelations) == null ? void 0 : _a5.forEach((relation) => {
          if (relation.propagateRecordChanges) {
            records.forEach((record) => {
              var _a6;
              const relatedRecord = record[relation.relationName];
              (_a6 = relatedRecord == null ? void 0 : relatedRecord.stores) == null ? void 0 : _a6.forEach((store) => {
                me.notifyRelatedStore(store, relatedRecord, relation.relatedCollectionName, record);
              });
            });
          }
        });
      }
    }
    notifyRelatedStore(store, relatedRecord, relationName, { meta }) {
      if (this.isChained || store.isChained) {
        return;
      }
      let { _ignoreRelationUpdate } = meta, isInitiator = false;
      if (!(_ignoreRelationUpdate == null ? void 0 : _ignoreRelationUpdate.size)) {
        meta._ignoreRelationUpdate = _ignoreRelationUpdate = /* @__PURE__ */ new Set();
        isInitiator = true;
      }
      if (!_ignoreRelationUpdate.has(store)) {
        _ignoreRelationUpdate.add(this).add(store);
        relatedRecord.meta._ignoreRelationUpdate = _ignoreRelationUpdate;
        store.onModelChange(relatedRecord, { [relationName]: relatedRecord[relationName] }, { [relationName]: relatedRecord[relationName] }, false, true);
        if (isInitiator) {
          _ignoreRelationUpdate.clear();
        }
      }
    }
    /**
     * Updates relation cache and foreign key value when a related objects id is changed.
     * @private
     */
    updateDependentRecordIds(oldValue, value) {
      var _a5;
      (_a5 = this.dependentStoreConfigs) == null ? void 0 : _a5.forEach((configs) => {
        configs.forEach((config) => {
          var _a6;
          const {
            dependentStore,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName], localRecords = (_a6 = cache == null ? void 0 : cache[oldValue]) == null ? void 0 : _a6.slice();
          localRecords == null ? void 0 : localRecords.forEach((localRecord) => {
            dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);
            localRecord.meta._ignoreRelatedIdUpdate = true;
            localRecord.set(foreignKey, value, false, true);
            delete localRecord.meta._ignoreRelatedIdUpdate;
          });
        });
      });
    }
    //endregion
  }, __publicField(_a4, "$name", "StoreRelation"), _a4;
};

// ../Core/lib/Core/data/mixin/StoreSum.js
var StoreSum_default = (Target) => class StoreSum extends (Target || Base) {
  static get $name() {
    return "StoreSum";
  }
  /**
   * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records
   * in store
   * @param {String} field Field to summarize by
   * @param {Core.data.Model[]} records Records to summarize, uses all records if unspecified.
   * @returns {Number}
   * @category Sum
   */
  sum(field, records = this.storage.values) {
    if (!records) {
      return 0;
    }
    return records.reduce((sum, record) => {
      if (record.isSpecialRow) {
        return sum;
      }
      const v = Number(record.getValue(field));
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }
  /**
   * Returns min value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find min value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  min(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((min2, record) => {
      const fieldValue = record.getValue(field), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && (fieldValue < min2 || min2 == null)) {
        min2 = fieldValue;
      }
      return min2;
    }, records[0].getValue(field));
  }
  /**
   * Returns max value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find max value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  max(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((max, record) => {
      const fieldValue = record.getValue(field), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && (fieldValue > max || max == null)) {
        max = fieldValue;
      }
      return max;
    }, records[0].getValue(field));
  }
  /**
   * Returns the average value for the specified field. Defaults to look through all records in store
   * @param {String} field Field to calculate average value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number}
   * @category Sum
   */
  average(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    let count = 0;
    const sum = records.reduce((sum2, record) => {
      if (record.isSpecialRow) {
        return sum2;
      }
      const v = parseFloat(record.getValue(field));
      if (!isNaN(v)) {
        count++;
        return sum2 + v;
      } else {
        return sum2;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }
  /**
   * Returns sum by adding value of specified field for records in the group with the specified groupValue.
   * @param {*} groupValue The group to summarize
   * @param {String} field Field to summarize by
   * @returns {Number} Sum or null if store not grouped
   * @category Sum
   */
  groupSum(groupValue, field) {
    return this.sum(field, this.getGroupRecords(groupValue));
  }
};

// ../Core/lib/Core/data/mixin/StoreSearch.js
var findInString = (value, text) => String(value).toLowerCase().includes(text);
var matchFns = {
  string: findInString,
  number: findInString,
  boolean: findInString,
  date: (value, text) => {
    if (value instanceof Date && text instanceof Date) {
      return value - text === 0;
    }
    return String(value.getMonth() + 1).includes(text) || String(value.getDate()).includes(text) || String(value.getFullYear()).includes(text);
  },
  object: (value, text) => value === text,
  // typeof null === object
  undefined: (value, text) => value === text
};
var StoreSearch_default = (Target) => class StoreSearch extends (Target || Base) {
  static get $name() {
    return "StoreSearch";
  }
  //region Search (multiple hits)
  /**
   * Find all hits matching the specified input
   * @param {String} text Value to search for
   * @param {String[]} fields Fields to search value in
   * @param {Function[]} [formatters] An array of field formatting functions to format the found value
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  search(text, fields = null, formatters, searchAllRecords) {
    const records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords), len = records.length, found = [];
    if (text == null) {
      return [];
    }
    if (typeof text === "string") {
      text = text.toLowerCase();
    }
    let i, j, record, value, valueType, comparison;
    for (i = 0; i < len; i++) {
      record = records[i];
      j = 0;
      for (const key of fields || record.fieldNames) {
        value = record.getValue(key);
        valueType = value instanceof Date ? "date" : typeof value;
        const formatter = formatters == null ? void 0 : formatters[j];
        if (formatter) {
          value = formatter(value);
          valueType = "string";
        }
        comparison = matchFns[valueType];
        if (value && (comparison == null ? void 0 : comparison(value, text))) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
        j++;
      }
    }
    return found;
  }
  /**
   * Find occurrences of the specified `value` in the specified `field` on all records in the store
   * @param {String} field The record field to search in
   * @param {*} value Value to search for
   * @param {Boolean} distinct True to only return distinct matches, no duplicates
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  findByField(field, value, distinct2 = false, searchAllRecords = false) {
    const records = this.getAllDataRecords(searchAllRecords), len = records.length, usedValues = /* @__PURE__ */ new Set(), found = [];
    let i, record, fieldValue;
    if (value != null) {
      value = String(value).toLowerCase();
    }
    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record.getValue(field);
      if (!distinct2 || !usedValues.has(fieldValue)) {
        const type = fieldValue instanceof Date ? "date" : typeof fieldValue, matchFn = matchFns[type];
        if (value == null && fieldValue === value || value === "" && fieldValue === "" || value && matchFn(fieldValue, value)) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
          if (distinct2) {
            usedValues.add(fieldValue);
          }
        }
      }
    }
    return found;
  }
  //endregion
  //region Find (single hit)
  /**
   * Finds the first record for which the specified function returns true
   * @param {Function} fn Comparison function, called with record as parameter
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   *
   * ```javascript
   * store.find(record => record.color === 'blue');
   * ```
   *
   * @category Search
   */
  find(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).find(fn);
  }
  /**
   * Finds the first record for which the specified field has the specified value
   * @param {String} fieldName Field name
   * @param {*} value Value to find
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   * @category Search
   */
  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = (r) => ObjectHelper.isEqual(r[fieldName], value);
    if (this.isTree) {
      return this.query(matchFn, searchAllRecords)[0];
    }
    return this.getAllDataRecords(searchAllRecords).find(matchFn);
  }
  /**
   * Searches the Store records using the passed function.
   * @param {Function} fn A function that is called for each record. Return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model[]} An array of the matching Records
   * @category Search
   */
  query(fn, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse((node) => {
        if (fn(node)) {
          matches.push(node);
        }
      }, void 0, void 0, searchAllRecords);
      return matches;
    }
    return this.getAllDataRecords(searchAllRecords).filter(fn);
  }
  //endregion
  //region Others
  /**
   * Returns true if the supplied function returns true for any record in the store
   * @param {Function} fn A function that should return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Boolean}
   *
   * ```javascript
   * store.some(record => record.age > 95); // true if any record has age > 95
   * ```
   *
   * @category Search
   */
  some(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).some(fn);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreSort.js
var StoreSort_default = (Target) => class StoreSort extends (Target || Base) {
  static get $name() {
    return "StoreSort";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting
       * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * Examples:
       *
       * ```javascript
       * const store = new Store({
       *     // Swedish sorting
       *     useLocaleSort : 'sv-SE'
       * });
       *
       * const store = new Store({
       *     // Swedish sorting with custom casing order
       *     useLocaleSort : {
       *         locale    : 'sv-SE',
       *         caseFirst : 'upper'
       *     }
       * });
       * ```
       *
       * Can also be configured on a per-sorter basis:
       *
       * ```javascript
       * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       * @category Advanced
       */
      useLocaleSort: null
    };
  }
  static get configurable() {
    return {
      /**
       * Initial sorters, format is:
       * ```javascript
       * { sorters : [{ field: 'name', ascending: false }, ...] }
       * // or
       * { sorters : ['name', ...] }
       * ```
       * @config {Sorter[]|String[]}
       * @category Common
       */
      sorters: [],
      /**
       * Specify true to sort this store after records are added.
       * @config {Boolean}
       * @default
       * @category Sorting
       */
      reapplySortersOnAdd: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired before sorting
   * @event beforeSort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Records to sort
   */
  /**
   * Fired after sorting
   * @event sort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Sorted records
   */
  //endregion
  //region Properties
  /**
   * Currently applied sorters
   * @member {Sorter[]} sorters
   * @readonly
   * @category Sort, group & filter
   */
  /**
   * Is store sorted?
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }
  // Keeping for now in case it is useful elsewhere in the future
  // /**
  //  * Determines if the store is sorted as specified by its sorters. Only applicable for local sorting.
  //  * Note that this is an expensive operation that iterates all records.
  //  * @member {Boolean}
  //  * @internal
  //  */
  // get isInOrder() {
  //     if (!this.isSorted || this.remoteSort) {
  //         return false;
  //     }
  //
  //     const { sorterFn } = this;
  //
  //     let inOrder = true;
  //
  //     this.traverse(record => {
  //         const { previousSibling } = record;
  //         if (previousSibling) {
  //             if (sorterFn(previousSibling, record) > 0) {
  //                 inOrder = false;
  //                 return false;
  //             }
  //         }
  //     });
  //
  //     return inOrder;
  // }
  changeSorters(sorters) {
    return sorters.map((sorter) => this.normalizeSorterConfig(sorter, true));
  }
  updateReapplySortersOnAdd(enable) {
    this.storage.autoSort = enable;
  }
  //endregion
  //region Add & remove sorters
  /**
   * Sort records, either by replacing current sorters or by adding to them.
   * A sorter can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
   * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
   * normal sorting routine.
   *
   * ```javascript
   * // single sorter
   * store.sort('age');
   *
   * // single sorter as object, descending order
   * store.sort({ field : 'age', ascending : false });
   *
   * // multiple sorters
   * store.sort(['age', 'name']);
   *
   * // using custom sorting function
   * store.sort((recordA, recordB) => {
   *     // apply custom logic, for example:
   *     return recordA.name.length < recordB.name.length ? -1 : 1;
   * });
   *
   * // using locale specific sort (slow)
   * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
   * ```
   *
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by.
   * Can also be an array of {@link Core.util.CollectionSorter sorter} config objects, or a sorting function, or a
   * {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order.
   * Applicable when the `field` is a string (if not specified and already sorted by the field, reverts direction),
   * or an object and `ascending` property is not specified for the object. `true` by default.
   * Not applicable when `field` is a function. `ascending` is always `true` in this case.
   * @param {Boolean} [add] If `true`, adds a sorter to the sorters collection.
   * Not applicable when `field` is an array. In this case always replaces active sorters.
   * @param {Boolean} [silent] Set as true to not fire events. UI will not be informed about the changes.
   * @category Sort, group & filter
   * @fires beforeSort
   * @fires sort
   * @fires Core.data.Store#event-refresh
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   */
  sort(field, ascending2, add = false, silent = false) {
    const me = this, records = me.allRecords, currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null, curSort;
    if (field) {
      if (Array.isArray(field)) {
        me.sorters = field.map((sorter) => me.normalizeSorterConfig(sorter, typeof sorter === "string" ? true : ascending2));
      } else {
        const sorter = me.normalizeSorterConfig(field, ascending2);
        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);
          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }
    if (!silent && me.trigger("beforeSort", { sorters: me.sorters, records, currentSorters }) === false) {
      me.sorters = currentSorters;
      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }
      return null;
    }
    return me.performSort(silent);
  }
  normalizeSorterConfig(field, ascending2) {
    var _a4, _b, _c;
    const me = this, sorter = { ascending: ascending2 };
    if (typeof field === "object") {
      ObjectHelper.assign(sorter, field);
      if (field.fn) {
        delete sorter.fn;
        sorter.sortFn = field.fn;
      }
      sorter.ascending = (_a4 = field.ascending) != null ? _a4 : ascending2;
    } else if (typeof field === "function") {
      sorter.sortFn = field;
    } else {
      sorter.field = field;
    }
    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }
    if (sorter.sortFn == null) {
      const compareItems = (_c = (_b = me.modelClass) == null ? void 0 : _b.$meta.fields.map[sorter.field]) == null ? void 0 : _c.compareItems;
      if (compareItems) {
        sorter.sortFn = compareItems;
      }
    }
    return sorter;
  }
  getCurrentSorterByField(field) {
    return typeof field === "string" && this.sorters.find((s) => s.field === field) || null;
  }
  /**
   * Add a sorting level (a sorter).
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by. Can also be an array of sorters, or a sorting
   * function, or a {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order (used only if field specified as string)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addSorter(field, ascending2 = true) {
    return this.sort(field, ascending2, true);
  }
  /**
   * Remove a sorting level (a sorter)
   * @param {String|Function} field Stop sorting by this field (or sorter function)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeSorter(field) {
    const sorterIndex = this.sorters.findIndex((sorter) => sorter.field === field || sorter.sortFn === field);
    if (sorterIndex > -1) {
      this.sorters.splice(sorterIndex, 1);
      return this.sort();
    }
  }
  /**
   * Removes all sorters, turning store sorting off.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearSorters(silent = false) {
    if (this.sorters.length) {
      this.sorters.length = 0;
      return this.sort(void 0, void 0, void 0, silent);
    }
  }
  //region
  //region Sorting logic
  /**
   * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.
   * @param {Sorter[]} sorters An array of sorter config objects
   * @returns {Function}
   * @category Sort, group & filter
   */
  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {
      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i], { field, ascending: ascending2 = true, useLocaleSort = storeLocaleSort } = sorter, fn = sorter.fn || sorter.sortFn, direction = ascending2 ? 1 : -1;
        if (fn) {
          const val = fn.call(sorter, lhs, rhs);
          if (val === 0) {
            continue;
          }
          if (val !== null) {
            return val * direction;
          }
        }
        const lhsValue = lhs.isModel ? lhs.getValue(field) : lhs[field], rhsValue = rhs.isModel ? rhs.getValue(field) : rhs[field];
        if (lhsValue === rhsValue) {
          continue;
        }
        if (lhsValue == null) {
          return -direction;
        }
        if (rhsValue == null) {
          return direction;
        }
        if (useLocaleSort && typeof lhsValue === "string") {
          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }
          if (typeof useLocaleSort === "string") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }
          if (typeof useLocaleSort === "object") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }
        if (lhsValue > rhsValue) {
          return direction;
        }
        if (lhsValue < rhsValue) {
          return -direction;
        }
      }
      return 0;
    };
  }
  /**
   * The sorter function for sorting records in the store.
   * @member {Function}
   * @internal
   * @readonly
   */
  get sorterFn() {
    return this.createSorterFn(this.remoteSort ? [{ field: "_remoteSortIndex" }] : this.sorters);
  }
  /**
   * Perform sorting according to the {@link #config-sorters} configured.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @async
   * @private
   * @category Sort, group & filter
   */
  performSort(silent) {
    const me = this, { rootNode, storage, sorterFn: sorter } = me;
    if (me.tree) {
      !me.isChained && rootNode.traverse((node) => {
        if (node.isLoaded && node.isParent) {
          node.children.sort(sorter);
          node.updateChildrenIndices(node.children, "parentIndex", true);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else if (me.isGrouped) {
      storage.replaceValues({
        ...me.prepareGroupRecords(),
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }
    me.afterPerformSort(silent || me.isRemoteDataLoading);
  }
  afterPerformSort(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me._idMap = null;
    const event = {
      action: "sort",
      sorters: me.sorters,
      records: me.allRecords
    };
    me.trigger("sort", event);
    me.trigger("refresh", event);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChained.js
var returnTrue = () => true;
var StoreChained_default = (Target) => class StoreChained extends (Target || Base) {
  static get $name() {
    return "StoreChained";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Function used to filter records in the masterStore into a chained store. If not provided,
       * all records from the masterStore will be included in the chained store.
       * Return `true` to include the passed record, or a `false` to exclude it.
       * @config {Function}
       * @param {Core.data.Model} record
       * @returns {Boolean}
       * @category Chained store
       */
      chainedFilterFn: null,
      /**
       * Array of field names that should trigger filtering of chained store when the fields are updated.
       * @config {String[]}
       * @category Chained store
       */
      chainedFields: null,
      /**
       * Master store that a chained store gets its records from.
       * @config {Core.data.Store}
       * @category Chained store
       */
      masterStore: null,
      /**
       * Method names calls to which should be relayed to master store.
       * @config {String[]}
       * @category Chained store
       */
      doRelayToMaster: ["add", "remove", "insert"],
      /**
       * Method names calls to which shouldn't be relayed to master store.
       * @config {String}
       * @category Chained store
       */
      dontRelayToMaster: [],
      /**
       * If true, collapsed records in original tree will be excluded from the chained store.
       * @config {Boolean}
       * @category Chained store
       */
      excludeCollapsedRecords: true,
      /**
       * If `true`, chained stores will be sorted when the master store is sorted. Note that this replaces
       * any existing sorters defined on the chained store.
       * @config {Boolean}
       * @category Chained store
       */
      syncSort: true,
      chainSuspended: 0
    };
  }
  // All props should be predefined to work properly with objectified stores
  static get properties() {
    return {
      chainedStores: null
    };
  }
  //endregion
  construct(config) {
    super.construct(config);
    const me = this, { masterStore } = me;
    if (masterStore) {
      me.methodNamesToRelay.forEach((fnName) => me[fnName] = (...params) => me.relayToMaster(fnName, params));
      me.removeAll = (...params) => {
        masterStore.remove(me.getRange(), ...params);
      };
      masterStore.ion({
        // HACK to have chained stores react early in a async events scenario (with engine). Could be turned
        // into a config, but this way one does not have to think about it
        changePreCommit: me.onMasterDataChangedPreCommit,
        change: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });
      if (me.syncSort) {
        masterStore.ion({
          sort: () => me.sort(masterStore.sorters),
          thisObj: me
        });
      }
      if (!masterStore.chainedStores) {
        masterStore.chainedStores = [];
      }
      masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }
  //region Properties
  // For accessing the full set of records, whether chained or not
  get $master() {
    return this.masterStore || this;
  }
  /**
   * Is this a chained store?
   * @property {Boolean}
   * @readonly
   * @category Advanced
   */
  get isChained() {
    return Boolean(this.masterStore);
  }
  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }
  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue;
  }
  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster), dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter((name) => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }
  //endregion
  //region Internal
  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach((store) => store.fillFromMaster());
    }
  }
  /**
   * Updates records available in a chained store by filtering the master store records using
   * {@link #config-chainedFilterFn}
   * @category Chained store
   */
  fillFromMaster() {
    const me = this, { masterStore, isTree } = me;
    let records = [];
    if (!me.isChained) {
      throw new Error("fillFromMaster only allowed on chained store");
    }
    if (me.isChainSuspended) {
      return;
    }
    if (masterStore.isGrouped && masterStore.isFiltered) {
      masterStore.forEach((r) => records.push(r), masterStore, { includeFilteredOutRecords: true, includeCollapsedGroupRecords: true });
    } else {
      records = masterStore.allRecords.filter((r) => !r.isSpecialRow && me.chainedFilterFn(r));
    }
    if (isTree) {
      me.idRegister = {};
      me.internalIdRegister = {};
      records.forEach((r) => {
        if (r.stores.includes(me)) {
          me.register(r);
        } else {
          r.joinStore(me);
        }
      });
      if (me.excludeCollapsedRecords) {
        const children = me.getChildren(me.rootNode);
        records = me.doIncludeExclude(children, true);
      }
    }
    me.isFillingFromMaster = true;
    me.data = records;
    me.isFillingFromMaster = false;
  }
  /**
   * Commits changes back to master.
   * - the records deleted from chained store and present in master will be deleted from master
   * - the records added to chained store and missing in master will added to master
   * Internally calls {Store#function-commit commit()}.
   * @returns {Object} Changes, see Store#changes
   * @internal
   */
  commitToMaster() {
    const me = this, master = me.masterStore;
    if (!me.isChained) {
      throw new Error("commitToMaster only allowed on chained store");
    }
    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }
  /**
   * Relays some function calls to the master store
   * @private
   */
  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }
  // HACK, when used with engine the chained store will catch events early (sync) and prevent late (async) listeners
  onMasterDataChangedPreCommit(event) {
    this.onMasterDataChanged(event);
    this.$masterEventhandled = true;
  }
  /**
   * Handles changes in master stores data. Updates the chained store accordingly
   * @private
   */
  onMasterDataChanged({ action, changes, $handled, isMove }) {
    var _a4;
    if (this.$masterEventhandled) {
      this.$masterEventhandled = false;
      return;
    }
    if (isMove && action === "remove") {
      return;
    }
    if (action !== "update" || ((_a4 = this.chainedFields) == null ? void 0 : _a4.some((field) => field in changes))) {
      this.fillFromMaster();
    }
  }
  //endregion
  //region public API
  /**
   * Creates a chained store, a new Store instance that contains a subset of the records from current store.
   * Which records is determined by a filtering function, which is reapplied when data in the base store changes.
   *
   * ```javascript
   * const oldies = store.makeChained(record => record.age > 50);
   * // or use a simple query
   * const ages = store.makeChained(() => store.allRecords.distinct('age')));
   * ```
   *
   * If this store is a {@link Core.data.mixin.StoreTree#property-isTree tree} store, then the resulting chained store
   * will be a tree store sharing the same root node, but only child nodes which pass the `chainedFilterFn` will be
   * considered when iterating the tree through the methods such as
   * {@link Core.data.Store#function-traverse} or {@link Core.data.Store#function-forEach}.
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  makeChained(chainedFilterFn = returnTrue, chainedFields, config) {
    if (this.isChained) {
      const newChainedFilterFn = chainedFilterFn;
      chainedFilterFn = (r) => newChainedFilterFn(r) && this.chainedFilterFn(r);
    }
    return new ((config == null ? void 0 : config.storeClass) || this.constructor)({
      // Don't copy the legacy storeId, see Store#construct
      storeId: void 0,
      id: `${this.id}-chained-${StringHelper.generateUUID()}`,
      // Make sure we don't share instanceMeta with the master store
      ...config || {},
      tree: false,
      autoTree: false,
      // If someone ever chains a chained store, chain master instead
      masterStore: this.$master,
      modelClass: this.modelClass,
      // Chained store should never use syncDataOnLoad, that will create an infinite loop when they determine
      // that a record is added and then add it to master, repopulating this store and round we go
      syncDataOnLoad: false,
      chainedFilterFn,
      chainedFields
    });
  }
  /**
   * Alias for {@link Core.data.Store#function-makeChained}
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  chain() {
    return this.makeChained(...arguments);
  }
  //endregion
  doDestroy() {
    var _a4;
    (_a4 = this.chainedStores) == null ? void 0 : _a4.forEach((chainedStore) => chainedStore.destroy());
    super.doDestroy();
  }
  suspendChain() {
    this.chainSuspended++;
  }
  resumeChain(refill = false) {
    if (this.chainSuspended && !--this.chainSuspended && refill) {
      this.fillFromMaster();
    }
  }
  get isChainSuspended() {
    return this.chainSuspended > 0;
  }
};

// ../Core/lib/Core/data/mixin/StoreState.js
var StoreState_default = (Target) => class StoreState extends (Target || Base) {
  static get $name() {
    return "StoreState";
  }
  /**
   * Get store state. Used by State-plugin to serialize state
   * @private
   * @returns {{ sorters, groupers }}
   */
  getState() {
    const { sorters, groupers, filters } = this, state = {};
    if (sorters == null ? void 0 : sorters.length) {
      state.sorters = sorters.map((sorter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));
        delete clone.fn;
        delete clone.sortFn;
        return clone;
      });
    }
    if (groupers == null ? void 0 : groupers.length) {
      state.groupers = groupers.map((grouper) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));
        delete clone.fn;
        return clone;
      });
      state.collapsedGroups = [...this.collapsedGroups];
    }
    if (filters == null ? void 0 : filters.values.length) {
      state.filters = filters.values.map((filter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter.config));
        clone.value = filter.value;
        if (clone.caseSensitive) {
          delete clone.caseSensitive;
        }
        return clone;
      });
    }
    return state;
  }
  /**
   * Apply store state. Used by State-plugin to restore a previously serialized state
   * @private
   * @param {{ sorters, groupers }} state
   */
  applyState(state) {
    var _a4;
    const me = this, {
      sorters = [],
      groupers = [],
      filters = []
    } = state, {
      sortParamName,
      filterParamName
    } = me;
    me.sorters = sorters.filter((sorter) => sorter.field || sorter.sortFn && !sortParamName);
    me.groupers = groupers.slice();
    me.sort();
    (_a4 = state.collapsedGroups) == null ? void 0 : _a4.forEach((id) => {
      const record = me.getById(id);
      if (record) {
        me.collapse(record, true);
      }
    });
    me.filters = filters.filter((filter) => filter.property || filter.filterBy && !filterParamName);
    me.filter();
  }
};

// ../Core/lib/Core/data/Wbs.js
var zeroPad = (v) => String(v).padStart(6, "0");
var Wbs = class _Wbs {
  /**
   * Wbs constructor.
   * @param {String|Number} value The value of WBS
   */
  constructor(value) {
    this.value = value;
    this._padded = null;
  }
  /**
   * The WBS value
   * @readonly
   * @member {String} value
   */
  set value(value) {
    this._value = String(value != null ? value : "");
  }
  get value() {
    return this._value;
  }
  /**
   * Returns a `Wbs` instance given a `value`. If the `value` is already a `Wbs` object, it is returned. Otherwise,
   * a new `Wbs` is created. If `value` is `null` or `undefined`, that value is returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Core.data.Wbs}
   */
  static from(value) {
    return value == null ? value : value instanceof _Wbs ? value : new _Wbs(value);
  }
  /**
   * Returns a WBS code where each component is 0-padded on the left to 6 digits. That is "1.2" is padded to be
   * "000001.000002". These values can be compared for proper semantic order (e.g., Wbs.pad('1.2') < Wbs.pad('1.10')).
   * @param {String|Number|Core.data.Wbs} value
   * @returns {String}
   * @private
   */
  static pad(value) {
    return value instanceof _Wbs ? value.valueOf() : _Wbs.split(value).map(zeroPad).join(".");
  }
  /**
   * Returns an array of digits from a given WBS code `value`. If the value cannot be converted, an empty array is
   * returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Number[]}
   * @private
   */
  static split(value) {
    let i, ret;
    if (value || value === 0) {
      switch (typeof value) {
        case "object":
          value = String(value);
        case "string":
          ret = value.split(".");
          for (i = ret.length; i-- > 0; ) {
            ret[i] = parseInt(ret[i], 10);
          }
          break;
        case "number":
          ret = [value];
          break;
      }
    }
    return ret || [];
  }
  /**
   * Compares two WBS values, returning 0 if equal, -1 if `lhs` is less than `rhs, or 1 if `lhs` is greater than `rhs`.
   * @param {String|Core.data.Wbs} lhs
   * @param {String|Core.data.Wbs} rhs
   * @returns {Number}
   */
  static compare(lhs, rhs) {
    if (lhs === rhs) {
      return 0;
    }
    if (!lhs || !rhs) {
      return lhs ? 1 : rhs ? -1 : 0;
    }
    lhs = _Wbs.pad(lhs);
    rhs = _Wbs.pad(rhs);
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  }
  /**
   * Appends a sub-level WBS value to this WBS code and returns a `Wbs` instance for it.
   * @param {String|Number} value
   * @returns {Core.data.Wbs}
   */
  append(value) {
    const s = this.value;
    return _Wbs.from(s ? `${s}.${value}` : value);
  }
  /**
   * Returns truthy value if this Wbs equals the passed value.
   * @param {String|Core.data.Wbs} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return !_Wbs.compare(this, value);
  }
  /**
   * Compares this WBS value with a specified pattern, returning `true` if they match. If the `pattern` is simply a
   * sequence of digits and decimal points (e.g., "1.2"), it is a match if it is a substring of this WBS code (e.g.,
   * "3.1.2.4"). If the `pattern` starts with `*` (e.g., "*.1.2"), it is a match if this WBS code ends with the text
   * following the `*` (e.g., "4.3.1.2"). If the `pattern` ends with `*`, it is a match if this WBS code starts with
   * the text up to the `*`.
   *
   * Some examples:
   * ```
   *  console.log(Wbs.from('1.2.3.4').match('2.3'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('*.4'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('1.2.*'));
   *  > true
   *
   *  console.log(Wbs.from('1.2.3.4').match('2.4'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('*.3'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('2.*'));
   *  > false
   * ```
   * @param {String} pattern A partial WBS code (e.g., "1.2"), optionally starting or ending with `*`.
   * @returns {Boolean}
   */
  match(pattern) {
    let ret = false;
    if (pattern) {
      const wbs = this.value, globLeft = pattern[0] === "*", globRight = pattern.endsWith("*"), n = pattern.length;
      if (globLeft === globRight) {
        ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;
      } else if (globLeft) {
        ret = wbs.endsWith(pattern.substr(1));
      } else {
        ret = wbs.startsWith(pattern.substr(0, n - 1));
      }
    }
    return ret;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    var _a4;
    return (_a4 = this._padded) != null ? _a4 : this._padded = _Wbs.pad(this.value);
  }
};
Wbs._$name = "Wbs";

// ../Core/lib/Core/data/mixin/StoreTree.js
var emptyArray5 = Object.freeze([]);
var StopBranch = Symbol("StopBranch");
var nullKeyUUID = StringHelper.generateUUID();
var StoreTree_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    get StopBranch() {
      return StopBranch;
    }
    //region Getters
    /**
     * True if this Store is configured to handle tree data (with `tree : true`) or if this is a
     * {@link Core.data.Store#function-makeChained chained store} and the master store is a tree store.
     * @property {Boolean}
     * @readonly
     * @category Tree
     */
    get isTree() {
      return this.tree || this.masterStore && this.masterStore.tree;
    }
    /**
     * Returns all leaf records in a tree store
     * @property {Core.data.Model[]}
     * @category Tree
     */
    get leaves() {
      const me = this, result = [];
      if (me.isTree) {
        me.traverse((record) => {
          if (record.isLeaf) {
            result.push(record);
          }
        });
        return result;
      } else {
        me.allRecords.forEach((r) => {
          if (r.isLeaf) {
            result.push(r);
          }
          r.traverse((record) => {
            if (record.isLeaf) {
              result.push(record);
            }
          }, true);
        });
      }
      return result;
    }
    //endregion
    //region Children
    /**
     * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,
     * either use AjaxStore which implements it, create your own subclass with an implementation or listen for
     * `toggleNode` and insert records when you have them available.
     * @param {Core.data.Model} parentRecord
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     * vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler, or if an {@link Core.data.AjaxStore#event-exception} is detected.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link Core.data.AjaxStore#event-exception} event if an exception occurred,
     * or `false` if the load was vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler.
     * @category Tree
     */
    async loadChildren(parentRecord) {
    }
    /**
     * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.
     * @internal
     * @param {Core.data.mixin.TreeNode} parent
     * @param {Core.data.mixin.TreeNode[]} children
     * @param {Number} index
     * @param {Object} [isMove]
     * @param {Boolean} [silent]
     * @fires add
     * @fires Core.data.Store#event-change
     * @category Tree
     */
    onNodeAddChild(parent, children, index, isMove, silent = false) {
      var _a5;
      const me = this, isRootLoad = parent === me.rootNode && parent.isLoading, { storage } = me, { previousSibling } = children[0];
      let storeInsertionPoint;
      const { visible: toAddToUI, all: toAdd } = me.collectDescendants(children, void 0, void 0, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
        applyFilter: me.isFiltered && me.reapplyFilterOnAdd
      });
      if (!isRootLoad && toAdd.length) {
        for (const record of toAdd) {
          if (!me.modified.includes(record) && !isMove[record.id]) {
            if (me.removed.includes(record)) {
              me.removed.remove(record);
            } else if (!record.isLinked) {
              me.added.add(record);
            }
          }
        }
      }
      if (isRootLoad && me.rootVisible) {
        toAddToUI.unshift(parent);
        toAdd.unshift(parent);
      }
      if (toAddToUI.length) {
        if (index === 0 || !previousSibling) {
          storeInsertionPoint = storage.indexOf(parent);
        } else {
          storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
        }
        storage.suspendEvents();
        me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
        storage.resumeEvents();
        me._idMap = null;
      } else {
        me._allRecords = null;
      }
      me.updateDependentStores("add", children);
      if (isRootLoad && toAddToUI.length) {
        if (me.sorters.length) {
          me.sort(null, null, false, true);
        }
        (_a5 = me.afterLoadData) == null ? void 0 : _a5.call(me);
        if (!silent) {
          const event = { action: "dataset", data: me._data, records: toAddToUI };
          me.trigger("refresh", event);
          me.trigger("change", event);
        }
      } else if (!silent) {
        const event = { action: "add", parent, isChild: true, isMove, records: children, allRecords: toAdd, index: storeInsertionPoint };
        me.trigger("add", event);
        me.trigger("change", event);
        if (isMove && Object.values(isMove).some((wasMoved) => wasMoved)) {
          const event2 = {
            newParent: parent,
            records: children.filter((record) => isMove[record.id]),
            oldParents: children.map((child) => {
              return me.getById(child.meta.oldParentId);
            })
          };
          me.trigger("move", event2);
        }
      }
    }
    onNodeRemoveChild(parent, children, index, flags = { isMove: false, silent: false, unfiltered: false }) {
      const me = this, { storage } = me, toRemoveFromUI = [], toRemove = [], { isMove, silent, unfiltered } = flags, removeUnfiltered = unfiltered && me.isFiltered, childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
      me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, { inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)), unfiltered: removeUnfiltered });
      if (!isMove) {
        for (const record of children) {
          record.unjoinStore(me);
        }
        for (const record of toRemove) {
          if (record.stores.includes(me)) {
            record.unjoinStore(me);
          }
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(toRemove);
      }
      if (toRemoveFromUI.length) {
        index = storage.indexOf(toRemoveFromUI[0]);
        if (index > -1) {
          storage.suspendEvents();
          storage.splice(index, toRemoveFromUI.length);
          storage.resumeEvents();
          me._idMap = null;
        }
      } else {
        index = -1;
        me._allRecords = null;
      }
      if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {
        const event = {
          action: "remove",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toRemove,
          index
        };
        me.trigger("remove", event);
        me.trigger("change", event);
      }
      return toRemove;
    }
    // IMPORTANT when using `applyFilter` option, should use the return value of this function
    // instead of relying on arguments mutation
    collectDescendants(node, visible = [], all = [], flags = {}) {
      var _a5;
      const me = this, { inCollapsedBranch = false, unfiltered = false, applyFilter = false } = flags, children = Array.isArray(node) ? node : (_a5 = me.getChildren(node, unfiltered)) != null ? _a5 : [];
      if (applyFilter) {
        return {
          visible: !inCollapsedBranch && children.flatMap((child) => me.collectVisibleNodeDescendantsFiltered(child)),
          all: children.flatMap((child) => child.allChildren)
        };
      } else {
        for (let i = 0, len = children.length, child; i < len; i++) {
          child = children[i];
          if (!inCollapsedBranch) {
            visible.push(child);
          }
          all.push(child);
          me.collectDescendants(child, visible, all, {
            inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
            unfiltered
          });
        }
        return { visible, all };
      }
    }
    collectVisibleNodeDescendantsFiltered(node) {
      const children = node.unfilteredChildren || node.children;
      if (!children || children.length === 0 || !node.isLeaf && !node.isExpanded(this)) {
        return this.filtersFunction(node) ? [node] : [];
      }
      const filteredChildren = children.flatMap((child) => this.collectVisibleNodeDescendantsFiltered(child));
      return filteredChildren.length || this.filtersFunction(node) ? [node, ...filteredChildren] : [];
    }
    /**
     * Returns the children of the passed branch node which this store owns. By default, this
     * is the entire `children` array.
     *
     * **If this store {@link Core.data.mixin.StoreChained#property-isChained isChained}**, then
     * this returns only the subset of children which are filtered into this store by the
     * {@link Core.data.mixin.StoreChained#config-chainedFilterFn chainedFilterFn}.
     * @param {Core.data.Model} parent The node to return the children of.
     * @returns {Core.data.Model[]}
     * @category Tree
     */
    getChildren(parent, unfiltered = false) {
      const me = this, children = (unfiltered || me.isChained) && parent.unfilteredChildren || parent.children;
      return !(children == null ? void 0 : children.length) ? emptyArray5 : me.isChained ? children.filter(me.chainedFilterFn).sort(me.sorterFn) : children;
    }
    /**
     * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing
     * nodes.
     * @private
     * @param parent Parent record
     * @param include Include (true) or exclude (false)
     * @category Tree
     */
    internalToggleTreeSubRecords(parent, include) {
      const me = this, { storage } = me, index = storage.indexOf(parent), children = me.doIncludeExclude(me.getChildren(parent), include);
      if (me.isFiltered && include && parent.unfilteredChildren) {
        me.updateChildrenHiddenState(parent);
      }
      if (children.length && index !== false) {
        storage.suspendEvents();
        if (include) {
          storage.splice(index + 1, 0, ...children);
          const event = { action: "add", isExpand: true, parent, records: children, index: index + 1 };
          me.trigger("add", event);
          me.trigger("change", event);
        } else {
          storage.splice(index + 1, children.length);
          const event = { action: "remove", isCollapse: true, parent, records: children, index: index + 1 };
          me.trigger("remove", event);
          me.trigger("change", event);
        }
        storage.resumeEvents();
        me._idMap = null;
      }
    }
    // Updates the hidden flag of its children while store is filtered
    updateChildrenHiddenState(parentRecord) {
      var _a5;
      (_a5 = parentRecord.unfilteredChildren) == null ? void 0 : _a5.forEach((child) => {
        child.instanceMeta(this.id).hidden = false;
        if (!child.isLeaf) {
          this.updateChildrenHiddenState(child);
        }
      });
    }
    doIncludeExclude(children, include, result = []) {
      const me = this, childCount = (children == null ? void 0 : children.length) || 0;
      for (let i = 0; i < childCount; i++) {
        const child = children[i];
        if (!me.isChained || me.chainedFilterFn(child)) {
          const mapMeta = child.instanceMeta(me.id);
          if (include || !mapMeta.hidden) {
            result.push(child);
          }
          mapMeta.hidden = !include;
          if (child.isExpanded(me)) {
            me.doIncludeExclude(me.getChildren(child), include, result);
          }
        }
      }
      return result;
    }
    /**
     * Collapse an expanded record or expand a collapsed. Optionally forcing a certain state.
     * @param {String|Number|Core.data.Model} idOrRecord Record (the record itself) or id of a record to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @category Tree
     */
    async toggleCollapse(idOrRecord, collapse) {
      const me = this, record = me.getById(idOrRecord), meta = record.instanceMeta(me);
      if (collapse === void 0) {
        collapse = !meta.collapsed;
      }
      if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
        me.trigger("beforeToggleNode", { record, collapse });
        meta.collapsed = collapse;
        if (meta.collapsed) {
          me.onNodeCollapse(record);
          return true;
        } else {
          me.onNodeExpand(record);
          let success2 = true;
          if (!record.isLoaded) {
            meta.isLoadingChildren = true;
            try {
              await me.loadChildren(record);
            } catch (exception) {
              meta.collapsed = true;
              success2 = false;
              me.trigger("loadChildrenException", { record, exception });
            } finally {
              meta.isLoadingChildren = false;
            }
          }
          return success2;
        }
      }
    }
    /**
     * Remove all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeCollapse(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, false);
      }
    }
    /**
     * Add all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeExpand(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, true);
      }
    }
    //endregion
    //region Transform flat data
    /**
     * Transforms flat data containing parent ids into tree data
     * @param {Object[]} data Flat raw data
     * @returns {Object[]} Tree data
     * @private
     */
    transformToTree(data) {
      const { parentIdField, idField, childrenField } = this.modelClass, indexById = /* @__PURE__ */ new Map(), parentIds = /* @__PURE__ */ new Set(), transformed = [];
      for (const node of data) {
        const id = node[idField];
        if (id != null) {
          indexById.set(id, node);
        }
      }
      const cloneParent = (node) => {
        const clone = Object.assign({}, node);
        clone[childrenField] = [];
        indexById.set(clone[idField], clone);
        parentIds.add(node[idField]);
        return clone;
      };
      for (let node of data) {
        const nodeId = node[idField];
        if (parentIds.has(nodeId)) {
          node = indexById.get(nodeId);
        } else {
          node = cloneParent(node);
        }
        const parentId = node[parentIdField];
        if (parentId != null) {
          let parent = indexById.get(parentId);
          if (parent) {
            if (!parent[childrenField]) {
              parent = cloneParent(parent);
            }
            parent[childrenField].push(node);
          }
        } else {
          if (node[childrenField]) {
            transformed.push(node);
          } else if (node[idField] != null) {
            transformed.push(cloneParent(node));
          } else {
            transformed.push(node);
          }
        }
      }
      indexById.forEach((parent) => {
        var _a5, _b;
        (_b = (_a5 = parent[childrenField]).sort) == null ? void 0 : _b.call(_a5, (child1, child2) => child1.parentIndex - child2.parentIndex);
      });
      return transformed;
    }
    /**
     * Transforms data into a tree with parent levels based on supplied fields.
     *
     * ```javascript
     * const newRoot = store.treeify(['name', r => r.age % 10]);
     * ```
     *
     * Generated parent records are indicated with `generatedParent` and `key` properties. The first one is set to
     * `true` and the latter one has a value for the group the parent represents.
     *
     * @param {Array<String|Function>} fields The field names, or a function to call to extract a value to create parent
     * nodes for records with the same value.
     * @param {Function} [parentTransform] A function which is called to allow the caller to transform the raw data
     * object of any newly created parent nodes.
     * @param {Boolean} [convertParents] Pass `true` to convert raw new parent data objects to this Store's
     * {@link Core.data.Store#config-modelClass}.
     * @returns {Core.data.Model} New root node
     * @internal
     */
    treeify(fields, parentTransform, convertParents = false) {
      const { length } = fields, parents = [], orphans = [], newRoot = {};
      let i, lastParents;
      for (i = 0; i < length; i++) {
        let field = fields[i];
        field = field.field || field;
        if (!fields[i].call) {
          fields[i] = (n) => n[field];
          fields[i].fieldName = field;
        }
        parents[i] = /* @__PURE__ */ new Map();
      }
      this.rootNode.traverse((n) => {
        lastParents = [];
        if (n.isLeaf) {
          for (i = 0; i < length; i++) {
            const nodeMap = parents[i], fieldValue = fields[i](n), key = fieldValue === "" ? nullKeyUUID : fieldValue, keys = ArrayHelper.asArray(key) || [nullKeyUUID], newParents = [];
            if (keys[0] === StopBranch) {
              break;
            }
            const lastParentsToIterate = lastParents.length > 0 ? lastParents : [null];
            lastParentsToIterate.forEach((lastParent) => {
              var _a5;
              for (let j = 0, { length: length2 } = keys; j < length2; j++) {
                const key2 = keys[j], path = `${((_a5 = lastParent == null ? void 0 : lastParent.path) != null ? _a5 : "") + ((key2 == null ? void 0 : key2.isModel) ? key2.id : key2)}/`, id = StringHelper.makeValidDomId(`generated_${path}`, "_"), field = fields[i].fieldName, parent = nodeMap.get(id) || nodeMap.set(id, {
                  id,
                  key: keys[j] === nullKeyUUID ? "" : key2,
                  path,
                  expanded: true,
                  readOnly: true,
                  children: [],
                  generatedParent: true,
                  field,
                  firstGroupChild: n
                }).get(id);
                newParents.push(parent);
                if (lastParent && !lastParent.children.includes(parent)) {
                  lastParent.children.push(parent);
                }
              }
            });
            lastParents = newParents;
          }
          if (lastParents.length) {
            lastParents.forEach((lastParent, j) => lastParent.children.push(j ? n.link() : n));
          } else {
            orphans.push(n);
          }
        }
      }, true);
      if (parentTransform || convertParents) {
        parents.forEach((p) => p.forEach((p2, id, map) => {
          parentTransform == null ? void 0 : parentTransform(p2);
          if (convertParents) {
            p2 = this.createRecord(p2);
            map.set(id, p2);
          }
        }));
      }
      newRoot.children = [...parents[0].values(), ...orphans];
      const sort = (n) => {
        if (n.children) {
          n.children.sort((lhs, rhs) => {
            if (lhs.isLeaf === rhs.isLeaf) {
              if (lhs.isLeaf) {
                let result;
                for (let i2 = 0; !result && i2 < length; i2++) {
                  const lv = fields[i2](lhs), rv = fields[i2](rhs);
                  if (lv === StopBranch || rv === StopBranch) {
                    return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
                  }
                  result = lv < rv ? -1 : rv > lv ? 1 : 0;
                }
                return result;
              } else if (typeof lhs.key === "string" && typeof rhs.key === "string") {
                return lhs.key.localeCompare(rhs.key, void 0, { numeric: true });
              } else {
                return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;
              }
            } else {
              return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
            }
          });
          n.children.forEach(sort);
        }
      };
      sort(newRoot);
      return newRoot;
    }
    //endregion
    treeifyFlatData(data) {
      const { childrenField, parentIdField } = this.modelClass;
      let hasParentId = false, shouldTransform = true;
      for (const node of data) {
        if (node.isModel || Array.isArray(node[childrenField])) {
          shouldTransform = false;
          break;
        }
        if (node[parentIdField] != null) {
          hasParentId = true;
        }
      }
      if (shouldTransform && hasParentId) {
        data = this.transformToTree(data);
      }
      return data;
    }
    /**
     * Increase the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.
     * @fires indent
     * @fires Core.data.Store#event-change
     * @category Tree
     */
    async indent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        let result = Boolean(node.previousSibling);
        while (result && !node.isRoot) {
          result = !nodes.includes(node.parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeIndent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
        me.endBatch();
        me.trigger("indent", { records: nodes });
        me.trigger("change", {
          action: "indent",
          records: nodes
        });
      }
    }
    /**
     * Decrease the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to outdent.
     * @fires outdent
     * @fires Core.data.Store#event-change
     * @category Tree
     */
    async outdent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        const { parent } = node;
        let result = parent && !parent.isRoot;
        while (result && !node.isRoot) {
          result = !nodes.includes(parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeOutdent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const { parent } = node, newChildren = parent.children.slice(parent.children.indexOf(node) + 1);
          parent.parent.insertChild(node, parent.nextSibling);
          node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
        me.endBatch();
        me.trigger("outdent", { records: nodes });
        me.trigger("change", {
          action: "outdent",
          records: nodes
        });
      }
    }
  }, __publicField(_a4, "$name", "StoreTree"), /**
   * A special `Symbol` signalizing treeify method that the current record grouping should be stopped.
   *
   * ```javascript
   * const newRoot = workerStore.treeify([
   *     // group workers by company
   *     worker => {
   *         // if the worker is unemployed we don't put it in a group
   *         // we just show such record on the root level
   *         if (!worker.company) {
   *             return Store.StopBranch
   *         }
   *
   *         return worker.company;
   *     ]
   * ]);
   * ```
   * @member {Symbol} StopBranch
   * @static
   * @category Advanced
   */
  __publicField(_a4, "StopBranch", StopBranch), __publicField(_a4, "configurable", {
    /**
     * Set to `true` to on load transform a flat dataset with raw objects containing `parentId` into the format
     * expected for tree data.
     *
     * Example input format:
     *
     * ```javascript
     * [
     *   { id : 1, name : 'Parent' },
     *   { id : 2, name : 'Child', parentId : 1 }
     * ]
     * ```
     *
     * Will be transformed into:
     *
     * ```javascript
     * [
     *   {
     *     id       : 1,
     *     name     : 'Parent',
     *     children : [
     *       { id : 2, name : 'Child', parentId : 1 }
     *     ]
     *   }
     * ]
     * ```
     *
     * @config {Boolean}
     * @category Tree
     */
    transformFlatData: null,
    /**
     * This flag prevents firing of 'remove' event when moving a node in the tree. In 6.0 this will be the default
     * behavior and this flag will be removed.
     * @config {Boolean}
     * @category Tree
     */
    fireRemoveEventForMoveAction: VersionHelper.checkVersion("core", "6.0", "<")
  }), _a4;
};

// ../Core/lib/Core/helper/WalkHelper.js
var WalkHelper = class {
  /**
   * Pre-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalk(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }
  /**
   * Pre-walks any hierarchical data structure, passing along a link to the parent node
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry, called with `parent` and `node`
   */
  static preWalkWithParent(data, childrenFn, fn) {
    const walkStack = [{ node: data, parent: null }];
    while (walkStack.length) {
      const { parent, node } = walkStack.pop();
      fn(parent, node);
      const children = childrenFn(node);
      if (Array.isArray(children)) {
        walkStack.push(...children.slice().reverse().map((child) => ({ node: child, parent: node })));
      }
    }
  }
  /**
   * Pre-walk unordered.
   *
   * Like {@link #function-preWalk-static} but doesn't reverse children before walk,
   * thus children will be walked last child first - first child last
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalkUnordered(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children);
      }
    }
  }
  /**
   * Post-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static postWalk(data, childrenFn, fn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        fn(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
  /**
   * Pre-/Post-walks any hierarchical data structure calling inFn each node when it walks in,
   * and outFn when it walks out.
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} inFn  Function to call on each entry upon enter
   * @param {Function} outFn Function to call on each entry upon exit
   */
  static prePostWalk(data, childrenFn, inFn, outFn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
};
WalkHelper._$name = "WalkHelper";

// ../Core/lib/Core/data/mixin/StoreSync.js
var StoreSync_default = (Target) => class StoreSync extends (Target || Base) {
  static get $name() {
    return "StoreSync";
  }
  static get configurable() {
    return {
      /**
       * Configure with `true` to sync loaded data instead of replacing existing with a new dataset.
       *
       * By default (or when configured with `false`) assigning to `store.data` replaces the entire dataset
       * with a new one, creating all new records:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first !== first;
       * ```
       *
       * When configured with `true` the new dataset is instead synced against the old, figuring out what was
       * added, removed and updated:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first === first;
       * ```
       *
       * After the sync, any configured sorters, groupers and filters will be reapplied.
       *
       * #### Threshold
       *
       * The sync operation has a configurable threshold, above which the operation will be treated as a
       * batch/refresh and only trigger a single `refresh` event. If threshold is not reached, individual events
       * will be triggered (single `add`, `remove` and possible multiple `update`). To enable the threshold,
       * supply a config object with a `threshold` property instead of `true`:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         threshold : '20%'
       *     }
       * });
       * ```
       *
       * `threshold` accepts numbers or strings. A numeric threshold means number of affected records, while a
       * string is used as a percentage of the whole dataset (appending `%` is optional). By default no threshold
       * is used.
       *
       * #### Missing fields
       *
       * The value of any field not supplied in the new dataset is by default kept as is (if record is not removed
       * by the sync). This behaviour is configurable, by setting `keepMissingValues : false` in a config object
       * it will reset any unspecified field back to their default values:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         keepMissingValues : false
       *     }
       * });
       * ```
       *
       * Considering the following sync operation:
       *
       * ```javascript
       * // Existing data
       * { id : 1, name : 'Saitama', powerLevel : 100 }
       * // Sync data
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * The result would by default (or when explicitly configured with `true`)  be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man', powerLevel : 100 }
       * ```
       *
       * If configured with `keepMissingValues : false` it would instead be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * <div class="note">Never enable `syncDataOnLoad` on a chained store, it will create an infinite loop when
       * it is populated from the main store (the main store can use the setting)</div>
       *
       * @config {Boolean|SyncDataOnLoadOptions} syncDataOnLoad
       * @default false
       * @category Common
       */
      syncDataOnLoad: null,
      /**
       * Experimental hook to allow app to determine if sync should be performed, and/or for which records.
       *
       * @config {Function} shouldSyncDataset
       * @param {Object} options
       * @param {Object[]} options.data New dataset, an array of incoming data objects
       * @param {Core.data.Store} options.store This store
       * @param {Core.data.Model[]} options.records Records currently in this store
       * @returns {Set|Boolean} A set of ids to apply changes to, or `false` to skip sync
       * @private
       */
      shouldSyncDataset: null,
      shouldSyncRecord: null,
      /**
       * When using {@link #config-syncDataOnLoad} and the store is neither sorted nor grouped, the order of the
       * incoming dataset is respected. This has a cost, since records in the store might have to be moved around.
       *
       * For stores where the order is not important, this behavior can be disabled to improve performance by
       * configuring `reorderOnSync` as `false`.
       *
       * @default
       * @private
       */
      reorderOnSync: true
    };
  }
  /**
   * Syncs a new dataset against the already loaded one, only applying changes.
   * Not intended to be called directly, please configure store with `syncDataOnLoad: true` and assign to
   * `store.data` as usual instead.
   *
   * ```
   * const store = new Store({
   *    syncDataOnLoad : true,
   *    data : [
   *        // initial data
   *    ]
   * });
   *
   * store.data = [ // new data ]; //  Difference between initial data and new data will be applied
   * ```
   *
   * @param {Object[]|Core.data.Model[]} data New dataset, an array of records or data objects
   * @private
   */
  syncDataset(data) {
    var _a4, _b, _c, _d;
    const me = this, { storage } = me, idsToCheck = (_d = (_a4 = me.shouldSyncDataset) == null ? void 0 : _a4.call(me, { data, store: me, records: me.records })) != null ? _d : (
      // If part of project, it might have an aggregated version of the hook
      (_c = (_b = me.project) == null ? void 0 : _b.shouldSyncDataset) == null ? void 0 : _c.call(_b, { data, store: me, records: me.records })
    );
    if (idsToCheck === false) {
      return;
    }
    me.trigger("startApplyChangeset");
    me.isSyncingDataOnLoad = true;
    const { toAdd, toRemove, toMove, updated, ids } = me.tree ? me.syncTreeDataset(data, idsToCheck) : me.syncFlatDataset(data, idsToCheck);
    let { threshold } = me.syncDataOnLoad, surpassed = false;
    if (threshold) {
      if (typeof threshold === "string") {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }
      surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;
    }
    if (me.tree) {
      if (toAdd.length) {
        const added = me.add(toAdd, surpassed);
        added.forEach((node) => node.clearParentId());
      }
      if (toMove.length) {
        for (const { parent, node, index } of toMove) {
          const newParent = me.getById(parent.id);
          newParent.insertChild(node, index);
        }
      }
      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        me.suspendEvents();
      }
      me.remove(toRemove);
      me.add(toAdd);
      if (surpassed) {
        me.resumeEvents();
      }
    }
    if (threshold && !surpassed) {
      updated.forEach(({ record, toSet, wasSet }) => me.onModelChange(record, toSet, wasSet));
    }
    me.acceptChanges();
    const event = { added: toAdd, removed: toRemove, updated, thresholdSurpassed: surpassed };
    if (me.isFiltered && !me.remoteFilter) {
      me.filter({
        silent: me.isRemoteDataLoading
      });
    }
    if (me.isGrouped) {
      me.group(null, null, false, true, me.isRemoteDataLoading);
    } else if (me.isSorted) {
      if (me.remoteSort) {
        storage.replaceValues({
          values: storage.values.sort(me.createSorterFn(me.sorters)),
          silent: true
        });
      } else {
        me.sort();
      }
    } else if (me.reorderOnSync) {
      if (!me.tree) {
        if (storage.values.some((record, index) => ids[record.id] !== index)) {
          storage.replaceValues({
            values: storage.values.sort((a, b) => ids[a.id] - ids[b.id]),
            silent: true
          });
          !surpassed && me.afterPerformSort();
        }
      } else {
        let unsorted = false, i = 0;
        WalkHelper.preWalk(
          me.rootNode,
          (n) => Array.isArray(n.children) && !unsorted ? n.children : null,
          (node) => {
            if (node.id !== ids[i++]) {
              unsorted = true;
            }
          }
        );
        if (unsorted) {
          me.sort((a, b) => ids[a.id] - ids[b.id], void 0, void 0, true);
          me.clearSorters(true);
          !surpassed && me.afterPerformSort();
        }
      }
    }
    if (surpassed) {
      me.trigger("refresh", {
        action: "batch",
        data,
        records: storage.values,
        syncInfo: event
      });
    }
    me.isSyncingDataOnLoad = false;
    me.trigger("endApplyChangeset");
    me.trigger("loadSync", event);
  }
  // Used by syncDataset()
  syncFlatDataset(data, idsToCheck) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, { idField, allFields } = me.modelClass, toRemove = [], toAdd = [], updated = [], usedIds = {}, ids = {}, limitedSet = idsToCheck instanceof Set;
    const { threshold, keepMissingValues } = me.syncDataOnLoad;
    let hitCount = 0;
    data.forEach((rawData, i) => {
      var _a4, _b;
      rawData = rawData.isModel ? rawData.data : rawData;
      const id = rawData[idField], record = me.getById(id);
      if (!limitedSet || idsToCheck.has(id)) {
        if (record) {
          if (me.shouldSyncRecord ? me.shouldSyncRecord({ record, data: rawData, store: me }) !== false : rawData !== record.data) {
            (_a4 = me.beforeSyncRecord) == null ? void 0 : _a4.call(me, { record, data: rawData });
            if (keepMissingValues === false) {
              for (const field of allFields) {
                if (!(field.dataSource in rawData) && field.dataSource in record.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            const wasSet = record.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record,
                wasSet,
                toSet: rawData
              });
            }
            (_b = me.afterSyncRecord) == null ? void 0 : _b.call(me, { record, data: rawData });
          }
        } else {
          toAdd.push(me.processRecord(me.createRecord(rawData)));
        }
      }
      if (record) {
        hitCount++;
      }
      usedIds[id] = 1;
      ids[id] = i;
    });
    if (hitCount < me.allRecords.filter((x) => !x.isSpecialRow).length) {
      if (idsToCheck) {
        for (const id of idsToCheck) {
          if (!usedIds[id]) {
            toRemove.push(me.getById(id));
          }
        }
      } else {
        me.forEach((record) => {
          if (!usedIds[record.id]) {
            toRemove.push(record);
          }
        }, me, {
          includeFilteredOutRecords: true,
          includeCollapsedGroupRecords: true
        });
      }
    }
    return { toAdd, toRemove, toMove: [], updated, ids };
  }
  // Used by syncDataset()
  syncTreeDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      parentIdField,
      childrenField,
      allFields
    } = me.modelClass, {
      keepMissingValues,
      threshold
    } = me.syncDataOnLoad, toRemove = [], toAdd = [], toMove = [], updated = [], matchedNodes = /* @__PURE__ */ new Set(), ids = {};
    let index = 0;
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    WalkHelper.preWalkWithParent({ isRoot: true, id: me.rootNode.id, children: data }, (n) => n.children, (parent, rawData) => {
      if (parent) {
        const { id, node } = me.resolveSyncNode(rawData);
        if (node) {
          if (me.shouldSyncRecord ? me.shouldSyncRecord({ record: node, data: rawData, store: me }) !== false : rawData !== node.data) {
            let childrenUpdated;
            const oldChildrenValue = node.children;
            if (oldChildrenValue !== true && rawData[childrenField] === true) {
              node.clearChildren();
              node.data[childrenField] = node.children = true;
              delete rawData[childrenField];
              me.toggleCollapse(node, true);
              childrenUpdated = true;
            }
            if (node.parent.id !== parent[idField]) {
              toMove.push({
                node,
                parent,
                index: parent[childrenField].indexOf(rawData)
              });
            }
            if (keepMissingValues === false) {
              for (const field of allFields) {
                if (field.name !== "parentId" && !(field.dataSource in rawData) && field.dataSource in node.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            if (typeof rawData.expanded === "boolean") {
              this.toggleCollapse(node, !rawData.expanded);
            }
            const wasSet = node.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record: node,
                wasSet,
                toSet: rawData
              });
            } else if (childrenUpdated) {
              node.signalNodeChanged({
                [childrenField]: {
                  value: true,
                  oldValue: oldChildrenValue
                }
              });
            }
          }
        } else {
          rawData[parentIdField] = parent[idField];
          toAdd.push({ ...rawData, ...Array.isArray(rawData[childrenField]) ? { children: [] } : void 0 });
        }
        matchedNodes.add(node);
        ids[id] = index++;
      }
    });
    if (matchedNodes.length !== data.length) {
      me.traverse((node) => {
        if (!matchedNodes.has(node)) {
          toRemove.push(node);
        }
      });
    }
    return { toAdd, toRemove, toMove, updated, ids };
  }
  // ColumnStore overrides this fn to allow syncing by field & type
  resolveSyncNode(rawData) {
    const id = rawData[this.modelClass.idField], node = this.getById(id);
    return { id, node };
  }
};

// ../Core/lib/Core/data/stm/mixin/StoreStm.js
var STM_PROP2 = Symbol("STM_PROP");
var StoreStm_default = (Target) => class StoreStm extends (Target || Base) {
  static get $name() {
    return "StoreStm";
  }
  static get defaultConfig() {
    return {
      /**
       * Reference to STM manager
       *
       * @config {Core.data.stm.StateTrackingManager}
       * @default
       * @category Advanced
       */
      stm: null,
      /**
       * Set to `false` to not record transaction during `applyChangeset` call
       *
       * @prp {Boolean}
       * @default
       * @category Advanced
       */
      ignoreRemoteChangesInSTM: false
    };
  }
  get stm() {
    return this[STM_PROP2];
  }
  set stm(stm) {
    var _a4;
    const me = this;
    if (me.stm !== stm) {
      if ((_a4 = me.stm) == null ? void 0 : _a4.hasStore(me)) {
        me.stm.removeStore(me);
      }
      me[STM_PROP2] = stm;
      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }
  // Overridden to notify STM about flat add action
  add(records, silent = false, options = {}) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      result = super.add(records, silent);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent, options);
    }
    return result;
  }
  // Overridden to notify STM about flat insert action
  insert(index, records, silent = false) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const context = (Array.isArray(records) ? records : [records]).reduce(
        (context2, r) => {
          const index2 = r instanceof Model ? this.indexOf(r) : void 0;
          if (index2 !== void 0 && index2 !== -1) {
            context2.set(r, index2);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.insert(index, records);
      if (result == null ? void 0 : result.length) {
        index = this.indexOf(result[0]);
        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }
    return result;
  }
  // Overridden to notify STM about flat removing action
  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map((r) => this.getById(r)).filter((r) => !!r);
      const context = recordsOrIdsNormalized.reduce(
        (context2, r) => {
          const index = this.indexOf(r);
          if (index !== void 0 && index !== -1) {
            context2.set(r, index);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }
    return result;
  }
  // Overridden to notify STM about flat clear action
  removeAll(silent) {
    const { stm } = this;
    let result;
    if (stm == null ? void 0 : stm.enabled) {
      const { tree, rootNode, allRecords } = this, wasNotEmpty = allRecords.length, records = tree ? rootNode.children.slice() : allRecords.slice();
      result = super.removeAll(silent);
      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      result = super.removeAll(silent);
    }
    return result;
  }
  beforeApplyChangeset() {
    const { stm, crudManager } = this;
    let shouldResume = false, transactionId = null;
    if (!(crudManager == null ? void 0 : crudManager.applyingChangeset) && (stm == null ? void 0 : stm.enabled)) {
      shouldResume = true;
      if (stm.isRecording) {
        transactionId = stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return { shouldResume, transactionId };
  }
  // When applying changes while STM is in the recording state, first we need to discard local changes, then apply
  // changes from remote, then try to apply local changes. This would emulate starting transaction as if data was
  // already in the correct state
  applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {
    const {
      shouldResume,
      transactionId
    } = this.beforeApplyChangeset(), log = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);
    this.afterApplyChangeset(shouldResume, transactionId);
    return log;
  }
  afterApplyChangeset(shouldResume, transactionId) {
    if (shouldResume) {
      const { stm } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash(transactionId);
    }
  }
};

// ../Core/lib/Core/data/Store.js
var dataAddRemoveActions = {
  splice: 1,
  clear: 1
};
var defaultTraverseOptions2 = {
  includeFilteredOutRecords: false,
  includeCollapsedGroupRecords: false
};
var fixTraverseOptions2 = (store, options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options,
      includeCollapsedGroupRecords: false
    };
  }
  return options || defaultTraverseOptions2;
};
var Store = class _Store extends Base.mixin(
  Delayable_default,
  Identifiable_default,
  Events_default,
  Pluggable_default,
  State_default,
  StoreFilter_default,
  StoreChanges_default,
  StoreCRUD_default,
  StoreRelation_default,
  // Private
  StoreSum_default,
  StoreSearch_default,
  StoreSort_default,
  StoreGroup_default,
  StoreChained_default,
  StoreState_default,
  StoreTree_default,
  StoreStm_default,
  StoreSync_default,
  StoreProxy_default
  // Private for now, thus not mentioned in @mixes block above
) {
  //region Config & properties
  static get $name() {
    return "Store";
  }
  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: /* @__PURE__ */ new Map(),
      addingClean: false
    };
  }
  static get configurable() {
    return {
      /**
       * Store's unique identifier.
       *
       * @member {String|Number} id
       * @readonly
       * @category Common
       */
      /**
       * Store's unique identifier. When set the store is added to a store map accessible through
       * `Store.getStore(id)`.
       *
       * @config {String|Number}
       * @category Common
       */
      id: true,
      /**
       * Class used to represent records in the store, should be a subclass of {@link Core.data.Model}. Only
       * applies when supplying data to the store (load, add), any supplied record instances are kept as is.
       *
       * ```javascript
       * class MyModel extends Model {
       *     static get fields() {
       *         return [
       *             'name',
       *             'city',
       *             'company'
       *         ]
       *     }
       * }
       *
       * const store = new Store({
       *     modelClass : MyModel,
       *     data : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Core.data.Model}
       * @default
       * @typings {typeof Model}
       * @category Common
       */
      modelClass: Model,
      /**
       * Verify that loaded data does not contain any generated ids. If it does, a warning is logged on console.
       *
       * Set this to `false` to disable the check and give a very minor performance boost.
       *
       * @prp {Boolean}
       * @default
       */
      verifyNoGeneratedIds: true
    };
  }
  static get defaultConfig() {
    return {
      /**
       * An array of field definitions used to create a {@link Core.data.Model} (modelClass) subclass. Optional.
       * If the Model already has fields defined, these fields will extend those.
       *
       * ```javascript
       * const store = new Store({
       *     fields : ['name', 'city', 'company'],
       *     data   : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * See {@link Core.data.Model} for more info on defining fields, changing data source and mapping fields to
       * nested objects.
       *
       * Note that pre-created record instances supplied to the store are kept as is and thus these fields will
       * not apply to them.
       *
       * @config {Array<String|ModelFieldConfig|Core.data.field.DataField>}
       * @category Common
       */
      fields: null,
      /**
       * Automatically detect from set data if used as tree store or flat store
       * @config {Boolean}
       * @default
       * @category Tree
       */
      autoTree: true,
      /**
       * Raw data to load initially.
       *
       * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
       * {@link #config-modelClass model} or in the {@link #config-fields} config).
       *
       * ```javascript
       * const store = new Store({
       *     data : [
       *         { id : 1, name : 'Linda', city : 'NY' },
       *         { id : 2, name : 'Olivia', city : 'Paris' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Object[]|Core.data.Model[]}
       * @category Common
       */
      data: null,
      /**
       * `true` to act as a tree store.
       * @config {Boolean}
       * @category Tree
       */
      tree: false,
      callOnFunctions: true,
      /**
       * A {@link Core/util/Collection}, or Collection config object
       * to use to contain this Store's constituent records.
       * @config {Core.util.Collection|CollectionConfig}
       * @category Advanced
       */
      storage: null,
      /**
       * Retools the loaded data objects instead of making shallow copies of them. This increases performance but
       * pollutes the incoming data and does not allow remapping of fields (dataSource).
       *
       * Also allows disabling certain steps in data loading, to further improve performance. Either accepts an
       * object with the params described below or `true` which equals `disableDuplicateIdCheck` and
       * `disableTypeConversion`.
       *
       * ```javascript
       * // No duplicate id checking, no type conversions
       * new Store({ useRawData : true });
       *
       * new Store({
       *   // No type conversions only
       *   useRawData : {
       *     disableTypeConversion : true
       *   }
       * });
       * ```
       *
       * @config {Boolean|Object}
       * @param {Boolean} [disableDuplicateIdCheck] Data must not contain duplicate ids, check is bypassed.
       * @param {Boolean} [disableDefaultValue] Default values will not be applied to record fields.
       * @param {Boolean} [disableTypeConversion] No type conversions will be performed on record data. Incoming
       * data must be in the correct format expected by each field, for example dates must be Date objects.
       * @category Advanced
       */
      useRawData: false,
      /**
       * Specify `false` to prevent loading records without ids, a good practise to enforce when syncing with a
       * backend.
       *
       * By default Store allows loading records without ids, in which case a generated id will be assigned.
       *
       * @config {Boolean}
       * @default true
       * @category Advanced
       */
      allowNoId: true,
      /**
       * Prevent dynamically subclassing the modelClass. It does so by default to not pollute it when exposing
       * properties. Should rarely need to be used.
       * @config {Boolean}
       * @default false
       * @private
       * @category Advanced
       */
      preventSubClassingModel: null,
      /**
       * Store class to use when creating the store when it is a part of a
       * [CrudManager](https://bryntum.com/products/scheduler/docs/api/Scheduler/data/CrudManager).
       *
       * ```javascript
       * crudManager : {
       *      eventStore {
       *          storeClass : MyEventStore
       *      }
       * }
       * ```
       *
       * @config {Class}
       * @typings {typeof Store}
       * @category Advanced
       */
      storeClass: null
    };
  }
  static get identifiable() {
    return {
      registerGeneratedId: false
    };
  }
  /**
   * Class used to represent records. Defaults to class Model.
   * @member {Core.data.Model} modelClass
   * @typings {typeof Model}
   * @category Records
   */
  //endregion
  //region Events
  /**
   * Fired when the id of a record has changed
   * @event idChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {String|Number} oldValue Old id
   * @param {String|Number} value New id
   */
  /**
   * Fired before record is modified in this store.
   * Modification may be vetoed by returning `false` from a handler.
   * @event beforeUpdate
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when a record is modified
   * @event update
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when one of this Store's constituent records is modified while in
   * {@link Core.data.Model#function-beginBatch batched} state. This may be used to keep
   * UIs up to date while "tentative" changes are made to a record which must not be synced with a server.
   * @event batchedUpdate
   * @private
   */
  /**
   * Fired when the root node is set
   * @event rootChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} oldRoot The old root node.
   * @param {Core.data.Model} rootNode The new root node.
   */
  /**
   * Data in the store was changed. This is a catch-all event which is fired for all changes
   * which take place to the store's data.
   *
   * This includes mutation of individual records, adding and removal of records, as well as
   * setting a new data payload using the {@link #property-data} property, sorting, filtering,
   * and calling {@link Core.data.mixin.StoreCRUD#function-removeAll}.
   *
   * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple
   * listeners to the {@link #event-update}, {@link Core.data.mixin.StoreCRUD#event-add},
   * {@link Core.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh} and
   * {@link Core.data.mixin.StoreCRUD#event-removeAll} events.
   *
   * A more complex databound widget such as a grid may use the more granular events to perform less
   * destructive updates more appropriate to each type of change. The properties will depend upon the value of the
   * `action` property.
   *
   * @event change
   * @param {Core.data.Store} source This Store.
   * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action
   * Name of action which triggered the change. May be one of the options listed above
   * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)
   * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`
   * @param {Object} changes Passed for the `'update'` action, info on which record fields changed
   */
  // NOTE: When updating params above, also update change event in ProjectModelMixin and dataChange in ProjectConsumer
  /**
   * Data in the store has completely changed, such as by a filter, or sort or load operation.
   * @event refresh
   * @param {Core.data.Store} source This Store.
   * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
   * @param {'dataset'|'sort'|'clearchanges'|'filter'|'create'|'update'|'delete'|'group'} action Name of
   * action which triggered the change. May be one of the options listed above.
   */
  //endregion
  /* break doc comment from next method */
  //region Init
  constructor(...args) {
    super(...args);
    if (this.objectify) {
      return this.initProxy();
    }
  }
  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {},
      oldIdMap: {}
    });
    if (config.storeId) {
      config = ObjectHelper.assign({ id: config.storeId }, config);
    }
    super.construct(config);
    me.initRelations();
  }
  /**
   * Retrieves/creates a store based on the passed config.
   *
   * | Type              | Result                                                                 |
   * |-------------------|------------------------------------------------------------------------|
   * | Core.data.Store   | Returns supplied store as is                                           |
   * | String            | Retrieves an existing store by id                                      |
   * | Object            | Creates a new store using supplied config object                       |
   * | Object[]          | Creates a new store, populated with records created from supplied data |
   * | Core.data.Model[] | Creates a new store, populated with supplied records                   |
   *
   *
   * @param {Core.data.Store|StoreConfig|String|StoreConfig[]|Core.data.Model[]} config
   * @param {Object} [defaults] Config object to apply when creating a new store for passed data
   * @param {Function} [converterFn] Function called for each data object prior to creating a record from it. The
   * return value is used to create a record.
   * @private
   */
  static from(config, defaults = {}, converterFn = null) {
    if (config && !config.isStore) {
      if (typeof config === "string") {
        config = _Store.getStore(config);
      } else {
        if (Array.isArray(config)) {
          if (converterFn) {
            config = config.map((data) => data.isModel ? data : converterFn(data));
          }
          config = ObjectHelper.assign({}, defaults, { data: config });
        } else {
          config = ObjectHelper.assign({}, defaults, config);
        }
        config = new _Store(config);
      }
    }
    return config;
  }
  doDestroy() {
    var _a4, _b, _c, _d;
    const me = this, allRecords = me.registeredRecords;
    (_b = (_a4 = me.stm) == null ? void 0 : _a4.removeStore) == null ? void 0 : _b.call(_a4, me);
    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      rec = allRecords[i];
      if (!(rec == null ? void 0 : rec.isDestroyed)) {
        rec.unjoinStore(me);
      }
    }
    (_c = me._storage) == null ? void 0 : _c.destroy();
    if (!me.isChained) {
      (_d = me.rootNode) == null ? void 0 : _d.destroy();
    }
    super.doDestroy();
  }
  /**
   * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to
   * update themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  beginBatch() {
    this.suspendEvents();
  }
  /**
   * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update
   * themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  endBatch() {
    if (this.resumeEvents()) {
      const { values: records } = this.storage;
      this.trigger("refresh", {
        action: "batch",
        data: records,
        records
      });
    }
  }
  set storage(storage) {
    const me = this;
    if (storage == null ? void 0 : storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;
    me._storage.autoSort = me.reapplySortersOnAdd;
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.ion({
      change: "onDataChange",
      thisObj: me
    });
  }
  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }
  /**
   * Returns all records from the store, ignoring any filters and including grouping headers / footers.
   * @property {Core.data.Model[]}
   * @readonly
   * @category Records
   */
  get allRecords() {
    var _a4;
    const me = this;
    if (((_a4 = me._allRecords) == null ? void 0 : _a4.generation) !== me.storage.generation) {
      if (me.isTree) {
        const result = me.collectDescendants(me.rootNode, void 0, void 0, { unfiltered: true }).all;
        if (me.rootVisible) {
          result.unshift(me.rootNode);
        }
        me._allRecords = result;
      } else {
        me._allRecords = me.isGrouped ? me.collectGroupRecords(true, true) : me.storage.allValues;
      }
      me._allRecords.generation = me.storage.generation;
    }
    return me._allRecords;
  }
  // All records except special rows such group headers etc
  getAllDataRecords(searchAllRecords) {
    const me = this;
    if (me.tree) {
      return searchAllRecords ? me.allRecords : me.rootNode.allChildren;
    }
    return me.isGrouped ? me.collectGroupRecords(searchAllRecords, false) : searchAllRecords ? me.storage.allValues : me.storage.values;
  }
  /**
   * Called by owned record when the record has its {@link Core.data.Model#property-isCreating}
   * property toggled.
   * @param {Core.data.Model} record The record that is being changed.
   * @param {Boolean} isCreating The new value of the {@link Core.data.Model#property-isCreating} property.
   * @internal
   */
  onIsCreatingToggle(record, isCreating) {
    const me = this, newlyPersistable = record.isPersistable && !isCreating;
    me.added[newlyPersistable ? "add" : "remove"](record);
    if (newlyPersistable) {
      me.trigger("addConfirmed", { record });
      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }
  }
  // Join added records to store, not called when loading
  joinRecordsToStore(records) {
    const { allCount } = this;
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      record.setData("parentIndex", allCount + i - records.length);
      record.joinStore(this);
    }
  }
  /**
   * Responds to mutations of the underlying storage Collection
   * @param {Object} event
   * @protected
   */
  onDataChange({ source: storage, action, added, removed, replaced, oldCount, items: items2, from, to }) {
    const me = this, isAddRemove = dataAddRemoveActions[action], addedCount = isAddRemove && (added == null ? void 0 : added.length), removedCount = isAddRemove && (removed == null ? void 0 : removed.length);
    let filtersWereReapplied, sortersWereReapplied;
    me._idMap = null;
    if (addedCount) {
      me.joinRecordsToStore(added);
    }
    replaced == null ? void 0 : replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unjoinStore(me, true);
      newRecord.joinStore(me);
    });
    super.onDataChange(...arguments);
    if (!me.isTree) {
      if (addedCount) {
        for (const record of added) {
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          } else if (!me.addingClean && !record.isLinked) {
            me.added.add(record);
          }
        }
        filtersWereReapplied = !me.remoteFilter && me.isFiltered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
        sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;
        if (sortersWereReapplied) {
          me.sort(null, null, false, true);
        }
      }
      if (removedCount) {
        for (const record of removed) {
          record.cancelBatch();
          record.unjoinStore(me);
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);
        filtersWereReapplied = !me.remoteFilter && me.isFiltered;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }
    switch (action) {
      case "clear":
        me.relationCache = {};
        me.updateDependentStores("removeall");
        me.trigger("removeAll");
        me.trigger("change", {
          action: "removeall"
        });
        break;
      case "splice":
        if (addedCount) {
          me.updateDependentStores("add", added);
          const oldIndex = added.reduce((lowest, record) => {
            const { previousIndex } = record.meta;
            if (previousIndex > -1 && previousIndex < lowest)
              lowest = previousIndex;
            return lowest;
          }, added[0].meta.previousIndex), index = storage.indexOf(added[0], !storage.autoFilter), params = {
            records: added,
            index
          };
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }
          me.trigger("add", params);
          me.trigger("change", Object.assign({ action: "add" }, params));
          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: "filter",
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
          if (sortersWereReapplied) {
            me.trigger("sort", { action: "sort", sorters: me.sorters, records: me.storage.allValues });
          }
        }
        if (removed.length) {
          me.updateDependentStores("remove", removed);
          me.trigger("remove", {
            records: removed
          });
          me.trigger("change", {
            action: "remove",
            records: removed
          });
        }
        if (replaced.length) {
          me.updateDependentStores("replace", replaced);
          me.trigger("replace", {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger("change", {
            action: "replace",
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;
      case "filter":
        if (me.isGrouped || me.isSorted) {
          me.performSort(true);
        }
        break;
      case "move": {
        const start = Math.min(from, to), end = Math.min(me.storage.allValues.length - 1, Math.max(from, to));
        for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {
          allRecords[i].setData("parentIndex", i);
        }
        me.trigger("move", {
          record: items2[0],
          records: items2,
          from,
          to
        });
        if (me.isFiltered) {
          me.performFilter();
        }
        me.trigger("change", {
          action,
          record: items2[0],
          records: items2,
          from,
          to
        });
        break;
      }
    }
  }
  onDataReplaced(action, data) {
    var _a4;
    const me = this, { storage } = me, all = storage.allValues, sorted = Boolean(me.sorters.length > 0);
    for (let i = 0; i < all.length; i++) {
      all[i].joinStore(me);
    }
    if (!me.remoteFilter && me.isFiltered) {
      me.filter({
        silent: true
      });
    }
    if (me.remoteSort) {
      if (me.isGrouped) {
        storage.replaceValues({
          // Need to update group records info (headers and footers)
          ...me.prepareGroupRecords(),
          silent: true
        });
      }
    } else {
      if (me.isGrouped) {
        me.group(null, null, false, !sorted, true);
      }
      if (sorted) {
        me.sort(null, null, false, true);
      }
    }
    if (!me.useRawData.disableDuplicateIdCheck) {
      const { idMap } = me;
      if (Object.keys(idMap).length < storage.values.length) {
        const collisions = [];
        storage.values.forEach((r) => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
        throw new Error(`Id collision on ${collisions.map((r) => r.id)}`);
      }
    }
    const event = { action, data, records: storage.values };
    me.updateDependentStores(action, event.records);
    (_a4 = me.afterLoadData) == null ? void 0 : _a4.call(me);
    if (!me.isRemoteDataLoading) {
      me.trigger("refresh", event);
    }
    me.trigger("change", event);
  }
  /**
   * This is called from Model after mutating any fields so that Stores can take any actions necessary at that point,
   * and distribute mutation event information through events.
   * @param {Core.data.Model} record The record which has just changed
   * @param {Object} toSet A map of the field names and values that were passed to be set
   * @param {Object} wasSet A map of the fields that were set. Each property is a field name, and
   * the property value is an object containing two properties: `oldValue` and `value` eg:
   * ```javascript
   *     {
   *         name {
   *             oldValue : 'Rigel',
   *             value : 'Nigel'
   *         }
   *     }
   *
   * @param {Boolean} silent Do not trigger events
   * @param {Boolean} fromRelationUpdate Update caused by a change in related model
   * @private
   */
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this, event = {
      record,
      records: [record],
      changes: wasSet,
      // Cannot use isBatching, since change is triggered when batching has reached 0
      // (but before it is set to null)
      batch: record.batching != null,
      fromRelationUpdate
    }, committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);
    me.storage.onItemMutation(record, wasSet);
    if ("id" in wasSet) {
      const { oldValue, value } = toSet.id;
      me.updateDependentRecordIds(oldValue, value);
      me.onRecordIdChange({ record, oldValue, value });
    } else if (!record.meta._ignoreRelatedIdUpdate) {
      me.updateDependentStores("update", [record], silent);
    }
    me.onUpdateRecord(record, wasSet);
    if (!silent) {
      if ("id" in wasSet) {
        const { oldValue, value } = toSet.id;
        me.trigger("idChange", {
          store: me,
          record,
          oldValue,
          value
        });
      }
      me.trigger("update", event);
      me.trigger("change", Object.assign({ action: "update" }, event));
    }
    if (me.autoCommit && committable) {
      me.doAutoCommit();
    }
  }
  updateModifiedBagForRecord(record) {
    const me = this;
    let addedToBag = false;
    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isRoot) {
        if (record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }
        addedToBag = true;
      }
    } else {
      me.modified.remove(record);
    }
    return addedToBag;
  }
  get idMap() {
    const me = this, needsRebuild = !me._idMap, idMap = me._idMap || (me._idMap = {});
    if (needsRebuild) {
      const processedRecords = me.storage.values;
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = { index, visibleIndex, record };
        if (!record.isSpecialRow) {
          visibleIndex++;
        }
      }
      if (me.isFiltered) {
        for (let index = 0, l = me.storage._values.length; index < l; index++) {
          const record = me.storage._values[index];
          if (record.id in idMap) {
            idMap[record.id].unfilteredIndex = index;
          } else {
            idMap[record.id] = { index: -1, unfilteredIndex: index, record };
          }
        }
      }
    }
    return idMap;
  }
  changeModelClass(ClassDef) {
    const { fields } = this;
    this.originalModelClass = ClassDef;
    let ClassDefEx = ClassDef;
    if (fields == null ? void 0 : fields.length) {
      class ModelClass extends ClassDef {
        static get fields() {
          return fields;
        }
      }
      ClassDefEx = ModelClass;
    } else if (!this.preventSubClassingModel) {
      class ModelClass extends ClassDef {
      }
      ClassDefEx = ModelClass;
    }
    ClassDefEx.initClass();
    return ClassDefEx;
  }
  //endregion
  //region Store id & map
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }
  changeId(id, oldId) {
    return super.changeId(id !== true && id, oldId);
  }
  updateId(id, oldId) {
    const duplicate = _Store.getById(id);
    duplicate && _Store.unregisterInstance(duplicate);
    super.updateId(id, oldId);
  }
  generateAutoId() {
    return _Store.generateId(`store-`);
  }
  get tree() {
    return this._tree;
  }
  set tree(tree) {
    this._tree = tree;
    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
      this.rootNode.isAutoRoot = true;
    }
  }
  // a hook to build a customized root node
  buildRootNode() {
    return {};
  }
  /**
   * Get a store from the store map by id.
   * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects
   * from which to create the contents of a new Store.
   * @returns {Core.data.Store} The store with the specified id
   */
  static getStore(id, storeClass) {
    if (id instanceof _Store) {
      return id;
    }
    if (this.getById(id)) {
      return this.getById(id);
    }
    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map((item) => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === "string") {
          item = {
            text: item
          };
        } else {
        }
        return item;
      });
      if (!storeModel) {
        class ModelClass extends Model {
        }
        storeModel = ModelClass;
      }
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel,
        allowNoId: true
        // String items have no id and are not guaranteed to be unique
      };
      if (!storeClass) {
        storeClass = _Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }
  /**
   * Get all registered stores
   * @property {Core.data.Store[]}
   */
  static get stores() {
    return _Store.registeredInstances;
  }
  //endregion
  //region Data
  /**
   * The invisible root node of this tree.
   * @property {Core.data.Model}
   * @readonly
   * @category Tree
   */
  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }
  set rootNode(rootNode) {
    var _a4;
    const me = this, oldRoot = me._rootNode;
    if (rootNode === oldRoot) {
      return;
    }
    if (oldRoot) {
      me.clear(true);
      me.removed.clear();
    }
    if (rootNode instanceof Model) {
      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);
    if (((_a4 = rootNode.children) == null ? void 0 : _a4.length) || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }
    me.trigger("rootChange", { oldRoot, rootNode });
  }
  /**
   * Sets data in the store.
   *
   * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
   * {@link #config-modelClass model} or in the {@link #config-fields} config).
   *
   * Called on initialization if data is in config otherwise call it yourself after ajax call etc. Can also be used to
   * get the raw original data.
   *
   * ```javascript
   * store.data = [
   *     { id : 1, name : 'Linda', city : 'NY' },
   *     { id : 2, name : 'Olivia', city : 'Paris' },
   *     ...
   * ];
   * ```
   *
   * @property {Object[]}
   * @fires refresh
   * @fires change
   * @category Records
   */
  set data(data) {
    this.setStoreData(data);
  }
  // For overridability in engine
  setStoreData(data) {
    const me = this, { idField, childrenField } = me.modelClass;
    if (me.transformFlatData && (data == null ? void 0 : data.length) > 0 && !Object.isExtensible(data[0])) {
      me.useRawData = me.useRawData || {
        disableDuplicateIdCheck: false,
        disableDefaultValue: false,
        disableTypeConversion: false
      };
      data = ObjectHelper.clone(data);
    }
    me.getConfig("plugins");
    me.processConfiguredListeners();
    if (data && !Array.isArray(data)) {
      data = ObjectHelper.transformNamedObjectToArray(data, idField);
    }
    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && (data == null ? void 0 : data.some((r) => r[childrenField]))));
    if (data && (me.remoteSort || me.remoteFilter)) {
      for (let i = 0; i < data.length; i++) {
        data[i]._remoteSortIndex = i;
      }
    }
    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;
      if (me.tree) {
        me.loadTreeData(data);
      } else {
        me.loadData(data);
      }
      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    } else {
      me.syncDataset(data);
    }
  }
  loadTreeData(data) {
    const me = this, root = me.rootNode;
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    root.isLoading = true;
    me.clear(true);
    root.appendChild(data);
    me.updateDependentStores("dataset", [root]);
    root.isLoading = false;
    if (data.length === 0) {
      const event = { action: "dataset", data: [], records: [] };
      me.trigger("refresh", event);
      me.trigger("change", event);
    } else if (me.isFiltered) {
      me.filter();
    }
  }
  loadData(data, action = "dataset") {
    var _a4;
    const me = this, { storage, allowNoId } = me, idField = me.modelClass.fieldMap.id.dataSource, creatingRecord = me.find((rec) => rec.isCreating);
    if (creatingRecord) {
      storage.values.splice(me.records.indexOf(creatingRecord), 1);
    }
    let warnGenerated = me.verifyNoGeneratedIds;
    me.removeHeadersAndFooters(me.storage.values);
    me._idMap = null;
    me.oldIdMap = {};
    if (data) {
      const isRaw = !(data[0] instanceof Model), count = data.length, records = new Array(count);
      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
      }
      for (let i = 0; i < count; i++) {
        let record = data[i];
        if (isRaw) {
          const id = record[idField];
          if (!allowNoId && id == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }
          if (warnGenerated && ((_a4 = id == null ? void 0 : id.startsWith) == null ? void 0 : _a4.call(id, "_generated"))) {
            console.warn(`Generated id found in data: ${id}. Generated ids are temporary and should be replaced with real ids by the backend`);
            warnGenerated = false;
          }
          record = me.createRecord(record, true);
        }
        if (!me.isFillingFromMaster) {
          record = me.processRecord(record, true);
          record.setData("parentIndex", i);
        }
        records[i] = record;
      }
      me.clear(true);
      storage.replaceValues({
        values: records,
        isNewDataset: true,
        silent: true
      });
      if (creatingRecord && !storage.values.includes(creatingRecord)) {
        storage.values.push(creatingRecord);
      }
      me._data = data;
      me.onDataReplaced(action, data);
    } else {
      me.clear(true);
      me._data = null;
    }
    me.isSyncingDataOnLoad = false;
  }
  get data() {
    return this._data;
  }
  /**
   * Creates an array of records from this store from the `start` to the `end' - 1
   * @param {Number} [start] The index of the first record to return
   * @param {Number} [end] The index *after* the last record to return `(start + length)`
   * @returns {Core.data.Model[]} The requested records.
   * @category Records
   */
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }
  /**
   * Creates a model instance, used internally when data is set/added.
   * Provide this method for your own custom conversion from data to record.
   * @config {Function} createRecord
   * @param {*} data Json data
   * @param {Boolean} [skipExpose=false] Supply true when batch setting to not expose properties multiple times
   * @returns {Core.data.Model}
   * @category Records
   */
  /**
   * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom
   * conversion from data to record.
   * @param {Object} data Json data
   * @param {Boolean} [skipExpose=false] Supply true when batch setting to not expose properties multiple times
   * @returns {Core.data.Model}
   * @category Records
   */
  createRecord(data, skipExpose = false, rawData = false) {
    return new this._modelClass(data, this, null, skipExpose, false, rawData);
  }
  processRecord(record, isDataset = false) {
    return record;
  }
  refreshData() {
    this.filter();
    this.sort();
  }
  onRecordIdChange({ record, oldValue, value }) {
    const me = this, idMap = me._idMap, { idRegister, oldIdMap } = me;
    me.storage._indicesInvalid = true;
    oldIdMap[oldValue] = record;
    if (idMap && !idMap[value]) {
      const entry = idMap[oldValue];
      delete idMap[oldValue];
      idMap[value] = entry;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }
  onUpdateRecord(record, changes) {
    const me = this, { internalId } = changes, { internalIdRegister } = me;
    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }
    if (me.reapplyFilterOnUpdate && me.isFiltered) {
      me.filter();
    }
  }
  get useRawData() {
    return this._useRawData;
  }
  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, { enabled: true }) : { enabled: false };
    }
  }
  //endregion
  //region Count
  /**
   * Number of records in the store
   * @param {Boolean} [countProcessed] Count processed (true) or real records (false)
   * @returns {Number} Record count
   * @category Records
   */
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }
  /**
   * Record count, for data records. Not including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get originalCount() {
    var _a4;
    return this.storage.totalCount - (((_a4 = this.groupRecords) == null ? void 0 : _a4.count) || 0);
  }
  /**
   * Record count, including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get count() {
    return this.storage.count;
  }
  /**
   * Returns the complete dataset size regardless of tree node collapsing or filtering
   * @property {Number}
   * @readonly
   * @category Records
   */
  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }
  //endregion
  //region Get record(s)
  /**
   * Returns all "visible" records.
   * **Note:** The returned value **may not** be mutated!
   * @property {Core.data.Model[]}
   * @readonly
   * @immutable
   * @category Records
   */
  get records() {
    return this.storage.values;
  }
  /**
   * Get the first record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get first() {
    return this.storage.values[0];
  }
  /**
   * Get the last record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }
  /**
   * Get the record at the specified index
   * @param {Number} index Index for the record
   * @returns {Core.data.Model} Record at the specified index
   * @category Records
   */
  getAt(index, all = false) {
    return this.storage.getAt(index, all);
  }
  // These are called by Model#join and Model#unjoin
  // register a record as a findable member keyed by id and internalId
  register(record) {
    const me = this;
    if (!me.useRawData.disableDuplicateIdCheck) {
      const existingRec = me.isTree && me.idRegister[record.id];
      if (existingRec && existingRec !== record) {
        throw new Error(`Id collision on ${record.id}`);
      }
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }
  get registeredRecords() {
    return Object.values(this.idRegister);
  }
  /**
   * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node
   * @param {Core.data.Model|String|Number} id Id of record to return.
   * @returns {Core.data.Model} A record with the specified id
   * @category Records
   */
  getById(id) {
    if (id == null ? void 0 : id.isModel) {
      const record = id;
      if (record.hasLinks && !this.storage.allValues.includes(record)) {
        return record.$links.find((r) => this.storage.allValues.includes(r));
      }
      return record;
    }
    return this.idRegister[id];
  }
  /**
   * Checks if a record is available, in the sense that it is not filtered out,
   * hidden in a collapsed group or in a collapsed parent node of a tree store.
   * @param {Core.data.Model|String|Number} recordOrId Record to check
   * @returns {Boolean}
   * @category Records
   */
  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }
  /**
   * Get a record by internalId.
   * @param {Number} internalId The internalId of the record to return
   * @returns {Core.data.Model} A record with the specified internalId
   * @category Records
   */
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }
  /**
   * Checks if the specified record is contained in the store
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record
   * @returns {Boolean}
   * @category Records
   */
  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }
    return this.indexOf(recordOrId) > -1;
  }
  //endregion
  //region Get index
  /**
   * Returns the index of the specified record/id, or `-1` if not found.
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.
   * @param {Boolean} [visibleRecords] Pass `true` to find the visible index.
   * as opposed to the dataset index. This omits group header records.
   * @param {Boolean} [allExceptFilteredOutRecords] For trees, when true this searches all except filtered out records
   * in the flattened tree, similar to a flat store.
   * @returns {Number} Index for the record/id, or `-1` if not found.
   * @category Records
   */
  indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {
    var _a4;
    if ((recordOrId == null ? void 0 : recordOrId.isModel) && !((_a4 = recordOrId.stores) == null ? void 0 : _a4.includes(this.$store || this))) {
      const linkedRecord = recordOrId.$links.find((r) => this.storage.allValues.includes(r));
      if (linkedRecord) {
        return this.indexOf(linkedRecord, visibleRecords);
      }
      return -1;
    }
    if (this.isTree) {
      return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));
    }
    const id = Model.asId(recordOrId);
    if (id == null) {
      return -1;
    }
    const found = this.idMap[id];
    return found ? found[visibleRecords ? "visibleIndex" : "index"] : -1;
  }
  allIndexOf(recordOrId) {
    if (this.isTree) {
      return this.allRecords.indexOf(this.getById(recordOrId));
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }
  //endregion
  //region Get values
  /**
   * Returns an array of distinct values for the specified field.
   *
   * ```javascript
   * store.getDistinctValues('age'); // Returns an array of the unique age values
   * ```
   *
   * @param {String} field Field to extract values for
   * @param {Boolean} [includeFilteredOutRecords] True to ignore any applied filters
   * @returns {Array} Array of values
   * @category Values
   */
  getDistinctValues(field, includeFilteredOutRecords = false) {
    const me = this, values = [], keys = {};
    let value;
    me.forEach((r) => {
      if (!r.isSpecialRow && !r.isRoot) {
        value = r.getValue(field);
        const primitiveValue = value instanceof Date ? value.getTime() : value;
        if (!keys[primitiveValue]) {
          values.push(value);
          keys[primitiveValue] = 1;
        }
      }
    }, me, { includeCollapsedGroupRecords: true, includeFilteredOutRecords });
    return values;
  }
  /**
   * Counts how many times the specified value appears in the store
   * @param {String} field Field to look in
   * @param {*} value Value to look for
   * @returns {Number} Found count
   * @category Values
   */
  getValueCount(field, value) {
    let count = 0;
    this.forEach((r) => {
      if (ObjectHelper.isEqual(r.getValue(field), value))
        count++;
    });
    return count;
  }
  //endregion
  //region JSON & console
  /**
   * Retrieve or set the data of all records as a JSON string
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonString = store.json;
   *
   * //jsonString:
   * '[{"id":1,"name":"Superman"},{"id":2,"name":"Batman"}]
   * ```
   *
   * @property {String}
   */
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.data = json;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Pretty printed version of {@link #property-json}
   * @readonly
   * @property {String}
   */
  get formattedJSON() {
    return StringHelper.safeJsonStringify(this, null, 4);
  }
  /**
   * Retrieve the data of all (unfiltered) records as an array of JSON objects.
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonArray = store.toJSON();
   *
   * //jsonArray:
   * [{id:1,name:"Superman"},{id:2,name:"Batman"}]
   * ```
   *
   * @returns {Object[]}
   */
  toJSON() {
    const me = this, { persistable, dataSource } = me.modelClass.getFieldDefinition("expanded");
    return (me.isTree ? me.rootNode.unfilteredChildren || me.rootNode.children || [] : me.allRecords).map((record) => {
      const json = record.toJSON();
      if (me.tree && record.isParent && persistable) {
        json[dataSource] = record.isExpanded(me);
      }
      return json;
    });
  }
  //endregion
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.project;
  }
  // Extract current data for all accessible records
  getInlineData(options) {
    var _a4;
    const data = [];
    if (this.tree) {
      (_a4 = this.rootNode.children) == null ? void 0 : _a4.forEach((r) => data.push(r.getCurrentConfig(options)));
    } else {
      this.forEach((r) => data.push(r.getCurrentConfig(options)));
    }
    return data;
  }
  // Extract current configs and data
  getCurrentConfig(options) {
    var _a4;
    const result = super.getCurrentConfig(options), { state } = this;
    if (result) {
      if (result.data) {
        result.data = this.getInlineData(options);
      }
      delete result.project;
      delete result.stm;
      delete result.asyncEvents;
      if (((_a4 = result.modelClass) == null ? void 0 : _a4.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2]) === this.constructor.defaultConfig.modelClass) {
        delete result.modelClass;
      }
      if (!this.tree) {
        delete result.tree;
      }
      if (state) {
        Object.assign(result, state);
      }
    }
    return result;
  }
  //endregion
  //region Iteration & traversing
  /**
   * Iterates over all normal records in store. Omits group header and footer records if this store is grouped.
   * @param {Function} fn A function that is called for each record. Returning `false` from that function cancels
   * iteration. It is called with the following arguments:
   * @param {Core.data.Model} fn.record Current record
   * @param {Number} fn.index Current index
   * @param {Object} [thisObj] `this` reference for the function
   * @param {Object|Boolean} [options] A boolean for `includeFilteredOutRecords`, or detailed options for
   * exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] `true` to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] `true` to also include records from collapsed groups of
   * grouped store
   * @category Iteration
   */
  forEach(fn, thisObj = this, options) {
    const me = this, callback = (r, i) => {
      if (!r.isRoot && !r.isSpecialRow) {
        return fn.call(thisObj, r, i);
      }
    };
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (me.isChained) {
        options = {
          ...options,
          sorterFn: me.sorterFn
        };
      }
      me.rootNode.traverseWhile(callback, false, options);
    } else {
      const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;
      if (me.isGrouped && options.includeCollapsedGroupRecords) {
        for (let i = 0; i < records.length; i++) {
          const record = records[i], groupChildren = options.includeFilteredOutRecords ? record.unfilteredGroupChildren : record.groupChildren;
          if (groupChildren && record.meta.collapsed === true) {
            for (let j = 0; j < groupChildren.length; j++) {
              const rec = groupChildren[j];
              if (callback(rec, j) === false) {
                return;
              }
            }
          } else if (callback(record, i) === false) {
            return;
          }
        }
      } else {
        for (let i = 0; i < records.length; i++) {
          if (callback(records[i], i) === false) {
            return;
          }
        }
      }
    }
  }
  /**
   * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record
   * @param {Function} fn
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array}
   * @category Iteration
   */
  map(fn, thisObj = this) {
    return this.storage.values.map(fn, thisObj);
  }
  /**
   * Equivalent to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap Array.flatMap()}.
   * Creates a new array by spreading the results of calling a provided function on every record
   * @param {Function} fn A function returning an array of items to be spread into the new array, or a single item to include in it
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array} The new array
   * @category Iteration
   */
  flatMap(fn, thisObj = this) {
    return this.storage.values.flatMap(fn, thisObj);
  }
  /**
   * Equivalent to Array.every(). Returns `true` if every call of the provided function
   * on each record yields a truthy value.
   * @param {Function} fn
   * @param {Function} fn.record The record to test.
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store.
   * @param {Boolean} [ignoreFilters] Pass `true` to iterate all records including filtered out ones.
   * @returns {Array}
   * @category Iteration
   */
  every(fn, thisObj = this, ignoreFilters) {
    return this.storage[ignoreFilters ? "allValues" : "values"].every(fn, thisObj);
  }
  /**
   * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to
   * reduce it to a single value.
   * @param {Function} fn
   * @param {*} initialValue
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {*}
   * @category Iteration
   */
  reduce(fn, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn = fn.bind(thisObj);
    }
    return this.storage.values.reduce(fn, initialValue, thisObj);
  }
  /**
   * Iterator that allows you to do for (let record of store)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }
  /**
   * Traverse all tree nodes (only applicable for Tree Store)
   * @param {Function} fn The function to call on visiting each node.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or detailed options for exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Traverse
   */
  traverse(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverse(fn, skipTopNode, options);
    } else {
      me.forEach((rec) => rec.traverse(fn, false, options), me, options);
    }
  }
  /**
   * Traverse all tree nodes while the passed `fn` returns true
   * @param {Function} fn The function to call on visiting each node. Returning `false` from it stops the traverse.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object} [options] An options object to exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @category Traverse
   */
  traverseWhile(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverseWhile(fn, skipTopNode, options);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn, false, options) === false) {
          break;
        }
      }
    }
  }
  /**
   * Finds the next record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   */
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    const record = records[idx + 1];
    if (skipSpecialRows && record && (record.isSpecialRow || typeof skipSpecialRows === "function" && skipSpecialRows(record))) {
      return me.getNext(records[idx + 1], wrap, skipSpecialRows);
    }
    return record;
  }
  /**
   * Finds the previous record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   */
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    const record = records[idx - 1];
    if (idx > 0 && skipSpecialRows && record && (record.isSpecialRow || typeof skipSpecialRows === "function" && skipSpecialRows(record))) {
      return me.getPrev(records[idx - 1], wrap, skipSpecialRows);
    }
    return record;
  }
  /**
   * Gets the next or the previous record. Optionally wraps from first -> last and vice versa
   * @param {String|Core.data.Model} recordOrId Record or records id
   * @param {Boolean} next Next (true) or previous (false)
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }
  /**
   * Finds the next record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getNextLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    return records[idx + 1];
  }
  /**
   * Finds the previous record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getPrevLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    return records[idx - 1];
  }
  /**
   * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and
   * vice versa
   * @param {String|Core.data.Model} recordOrId Record or record id
   * @param {Boolean} [next] Next (true) or previous (false)
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }
  //endregion
};
Store.initClass();
Store._$name = "Store";

// ../Core/lib/Core/data/AjaxStore.js
var processParamEntry = (paramArray, entry) => {
  if (Array.isArray(entry[1])) {
    entry[1].forEach((value) => paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(value)));
  } else {
    paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(entry[1]));
  }
  return paramArray;
};
var immediatePromise2 = Promise.resolve();
var prependZeros = (num) => {
  return String(num).padStart(2, "0");
};
var dateToString = (date) => {
  return `${date.getFullYear()}-${prependZeros(date.getMonth() + 1)}-${prependZeros(date.getDate())}T${prependZeros(date.getHours())}:${prependZeros(date.getMinutes())}:${prependZeros(date.getSeconds())}.${date.getMilliseconds()}`;
};
var AjaxStore = class extends Store {
  // region Events
  /**
   * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid
   * response.
   *
   * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual
   * operation, `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit
   * operation will also trigger an `exception` event when all the operations have finished, so if exceptions are
   * going to be handled gracefully, the event's `action` property must be examined, and the constituent operations of
   * the event must be examined.
   * @event exception
   * @param {Core.data.Store} source This Store
   * @param {Boolean} exception `true`
   * @param {'create'|'read'|'update'|'delete'|'commit'} action Action that failed, `'create'`, `'read'`,
   * `'update'` or `'delete'`. May also be fired with '`commit'` to indicate the failure of an aggregated `create`,
   * `update` and `delete` operation. In this case, the event will contain a property for each operation of the commit
   * named `'create'`, `'update'` and `'delete'`, each containing the individual `exception` events.
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object *if the exceptionType is `'server'`*
   */
  /**
   * Fired after committing added records
   * @event commitAdded
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired after committing modified records
   * @event commitModified
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired on successful load
   * @event load
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired on successful load of remote child nodes for a tree node.
   * @event loadChildren
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired after committing removed records
   * @event commitRemoved
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before loading starts. Allows altering parameters and is cancelable
   * @event beforeLoad
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable
   * @event beforeLoadChildren
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * When the store {@link #property-isPaged is paged}, this is fired before loading a page and is cancelable
   * @event beforeLoadPage
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * When the store {@link #property-isPaged is paged}, this is fired when a page is loaded.
   * @event loadPage
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * When the store {@link #property-isPaged is paged}, this is fired when a page load is beginning.
   * @event loadPageStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be
   * mutated at this stage.
   * @event loadStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the
   * event may still be mutated at this stage.
   * @event loadChildrenStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before any remote request is initiated.
   * @event beforeRequest
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing key/value pairs that are passed on the request query string
   * @param {Object} body The body of the request to be posted to the server.
   * @param {'create'|'read'|'update'|'delete'} action Action that is making the request, `'create'`,
   * `'read'`, `'update'` or `'delete'`
   */
  /**
   * Fired after any remote request has finished whether successfully or unsuccessfully.
   * @event afterRequest
   * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*
   * @param {'create'|'read'|'update'|'delete'} action Action that has finished, `'create'`, `'read'`,
   * `'update'` or `'delete'`
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`. *Only present
   * if the request triggered an exception.*
   * @param {Response} response The `Response` object
   * @param {Object} json The decoded response object if there was no `'network'` exception.
   */
  // endregion
  //region Config
  static get defaultConfig() {
    return {
      /**
       * A string keyed object containing the HTTP headers to add to each server request issued by this store.
       *
       * `AjaxStore` uses the Fetch API under the hood, read more about headers on
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#headers)
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    headers : {
       *        Authorization : 'auth-contents-goes-here'
       *    }
       * });
       * ```
       *
       * @config {Object<String,String>}
       * @category Remote
       */
      headers: null,
      /**
       * An object containing the Fetch options to pass to each server request issued by this store. Use this to
       * control if credentials are sent and other options, read more at
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options).
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    fetchOptions : {
       *        credentials : 'omit',
       *        redirect    : 'error'
       *    }
       * });
       * ```
       *
       * @config {Object}
       * @category Remote
       */
      fetchOptions: null,
      /**
       * Specify `true` to send payloads as form data, `false` to send as regular JSON.
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      sendAsFormData: null,
      /**
       * Specify `true` to send all model fields when committing modified records (as opposed to just the
       * modified fields)
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      writeAllFields: null,
      /**
       * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id`
       * to load when loading child nodes on demand if the node being expanded was created with data containing
       * `children: true`.
       * @config {String}
       * @default
       * @category Remote
       */
      parentIdParamName: "id",
      /**
       * The optional property name in JSON responses from the server that contains a boolean
       * success/fail status.
       * ```json
       * {
       *   "responseMeta" : {
       *   {
       *     "success" : true,
       *     "count" : 100
       *   },
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       *
       * The store would be configured with:
       * ```javascript
       *  {
       *      ...
       *      successDataProperty : 'responseMeta.success',
       *      responseTotalProperty : 'responseMeta.count'
       *      ...
       *  }
       *
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseSuccessProperty: "success",
      /**
       * The property name in JSON responses from the server that contains the data for the records
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseDataProperty: "data",
      /**
       * The property name in JSON responses from the server that contains the dataset total size
       * **when this store {@link #property-isPaged is paged}**
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ],
       *   // The property name used here should match that of 'responseTotalProperty'
       *   "total" : 65535
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseTotalProperty: "total",
      /**
       * The name of the HTTP parameter to use to pass any encoded filters when loading data from the server and a
       * filtered response is required.
       *
       * **Note:** When this is set, filters must be defined using a field name, an operator and a value
       * to compare, **not** a comparison function.
       * @config {String}
       * @category Remote
       */
      filterParamName: null,
      /**
       * Set this flag to true if you are filtering remote using restful URLs (e.g.
       * https://nominatim.openstreetmap.org/search/paris?format=json)
       *
       * **Note:** When this is set, the filter string is appended to the readUrl.
       * @config {Boolean}
       * @category Remote
       */
      restfulFilter: false,
      /**
       * The name of the HTTP parameter to use to pass any encoded sorters when loading data from the server and a
       * sorted response is required.
       *
       * **Note:** When this is set, sorters must be defined using a field name and an ascending flag,
       * **not** a sort function.
       * @config {String}
       * @category Remote
       */
      sortParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **one based** page number
       * required.
       * @config {String}
       * @category Paging
       */
      pageParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @category Paging
       */
      pageStartParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @default
       * @category Paging
       */
      pageSizeParamName: "pageSize",
      /**
       * Set to ´true´ to use restful {@link #config-httpMethods}
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      useRestfulMethods: null,
      /**
       * The HTTP methods to use for CRUD requests when {@link #config-useRestfulMethods} is enabled.
       *
       * ```javascript
       * new AjaxStore({
       *    useRestfulMethods : true,
       *    httpMethods : {
       *        create : 'POST',
       *        read   : 'POST',
       *        update : 'PATCH',
       *        delete : 'DELETE'
       *    }
       * });
       *
       * ```
       * @config {HttpMethods}
       * @default
       * @category Remote
       */
      httpMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        delete: "DELETE"
      },
      /**
       * When this config is enabled, the {@link #property-params} of "read" request are placed in the
       * request body instead of the query string, if the HTTP method allows.
       *
       * Default value is `false`, but it will be set to `true` from the 6.0.0 release.
       *
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      paramsInBody: VersionHelper.checkVersion("core", "6.0", ">=")
    };
  }
  // This function is called to automatically reload page whenever pageSize is set at runtime.
  updatePageSize(pageSize) {
    const me = this;
    if (!this.isConfiguring) {
      const currentPage = me.currentPage = me.currentPage ? Math.min(
        me.currentPage,
        Math.floor((me.allCount + pageSize - 1) / pageSize)
      ) : 1;
      if (pageSize) {
        me.loadPage(currentPage);
      }
    }
  }
  /**
   * Url to post newly created records to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} createUrl
   * @category CRUD
   */
  /**
   * Url to read data from.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * If the store {@link #property-isPaged is paged}, the total dataset size must be returned in the
   * {@link #config-responseTotalProperty} property:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }],
   *         "total": 65535
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} readUrl
   * @category CRUD
   */
  /**
   * Url to post record modifications to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} updateUrl
   * @category CRUD
   */
  /**
   * Url for deleting records.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true
   *     }
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} deleteUrl
   * @category CRUD
   */
  /**
   * True to initiate a load when the store is instantiated
   * @config {Boolean} autoLoad
   * @category Common
   */
  //endregion
  afterConstruct(config) {
    super.afterConstruct(config);
    if (this.autoLoad) {
      this.load().catch(() => {
      });
    }
  }
  /**
   * Returns a truthy value if the Store is currently loading.
   *
   * A load operation is initiated by a load call, but the network request is not sent until
   * after a delay until the next event loop because of allowing all operations which may
   * request a load to coalesce into one call.
   *
   * If the loading request is in this waiting state, the value will be `1`,
   *
   * If the network request is in flight, the value will be `2`
   * @property {Boolean|Number}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;
  }
  /**
   * Returns true if the Store is currently committing
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isCommitting() {
    var _a4;
    return Boolean((_a4 = this.commitPromise) != null ? _a4 : this.autoCommitTimeoutPromise);
  }
  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageStartParamName) {
      throw new Error("Configs pageStartParamName and pageParamName are mutually exclusive");
    }
    this._pageParamName = pageParamName;
  }
  get pageParamName() {
    return this._pageParamName;
  }
  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageParamName) {
      throw new Error("Configs pageParamName and pageStartParamName are mutually exclusive");
    }
    this._pageStartParamName = pageStartParamName;
  }
  get pageStartParamName() {
    return this._pageStartParamName;
  }
  /**
   * Yields `true` if this Store is loaded page by page. This yields `true` if either of the
   * {@link #config-pageParamName} of {@link #config-pageStartParamName} configs are set.
   * @property {Boolean}
   * @readonly
   * @category Paging
   */
  get isPaged() {
    return Boolean(this.pageParamName || this.pageStartParamName);
  }
  /**
   * Yields the complete dataset size. If the store is {@link #property-isPaged is paged} this is the value
   * returned in the last loaded data block in the {@link #config-responseTotalProperty} property. Otherwise it is
   * the number of records in the store's underlying storage collection.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get allCount() {
    return "remoteTotal" in this ? this.remoteTotal : super.allCount;
  }
  /**
   * **If the store {@link #property-isPaged is paged}**, yields the highest page number in the dataset as calculated
   * from the {@link #config-responseTotalProperty}
   * returned in the last page data block loaded.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }
  buildQueryString(url, ...paramObjects) {
    const hasParamsInUrl = url.includes("?"), queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join("&");
    return queryString ? (hasParamsInUrl ? "&" : "?") + queryString : "";
  }
  /**
   * Internal sort method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performSort(silent) {
    const me = this;
    if (me.remoteSort && !me.isRemoteDataLoading) {
      me.isRemoteDataLoading = true;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        me.afterPerformSort(silent);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performSort(silent);
    }
  }
  /**
   * Internal filter method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performFilter(silent) {
    var _a4;
    const me = this;
    if (me.filterBatching > 0) {
      me.needsFiltering = true;
      return;
    }
    if (me.remoteFilter) {
      (_a4 = me.loadingPromise) == null ? void 0 : _a4.abort();
      me.isRemoteDataLoading = true;
      const oldCount = me.count, { filters } = me;
      me.currentPage = 1;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        event = silent ? null : {
          action: "filter",
          filters,
          oldCount,
          records: me.storage.values
        };
        me.afterPerformFilter(event);
        me.trigger("refresh", event);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performFilter(silent);
    }
  }
  /**
   * A provided function which creates an array of values for the {@link #config-filterParamName} to pass
   * any filters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field         : <theFieldName>
   *        operator      : May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
   *        value         : The value to compare
   *        caseSensitive : true for case sensitive comparisons
   *    }]
   * ```
   * @param {Core.util.CollectionFilter[]} filters The filters to encode.
   */
  encodeFilterParams(filters) {
    const result = [];
    for (const { property, operator, value, caseSensitive } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }
    return JSON.stringify(result, function(key, value) {
      return key === "" ? value : this[key] instanceof Date ? dateToString(this[key]) : value;
    });
  }
  /**
   * A provided function which creates an array of values for the {#config-sortParamName} to pass
   * any sorters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field     : <theFieldName>
   *        ascending : true/false
   *    }]
   * ```
   *
   * @param {Sorter[]} sorters The sorters to encode.
   */
  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.filter((sorter) => !sorter.sortFn).map((sorter) => sorter));
  }
  buildReadUrl() {
    const { readUrl } = this;
    if (this.restfulFilter && this.filters.count) {
      const url = readUrl.endsWith("/") ? readUrl : readUrl + "/";
      return url + this.filters.first.value;
    }
    return readUrl;
  }
  /**
   * Internal data loading method.
   * @returns {Promise}
   * @internal
   */
  internalLoad(params, eventName, successFn, delay = 0) {
    params = ObjectHelper.assign({}, this.params, params);
    const me = this, url = me.buildReadUrl(), event = { action: "read" + eventName, params, url };
    if (!url) {
      throw new Error("No load url specified");
    }
    if (me.trigger("beforeLoad" + eventName, event) === false) {
      throw false;
    }
    me.loadArgs = [url, event, params, eventName, successFn];
    if (delay === false) {
      return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));
    }
    return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {
      me.setTimeout({
        delay,
        fn: "sendLoadRequest",
        args: [resolve, reject],
        cancelOutstanding: true
      });
    }));
  }
  // Send the request for the internalLoad.
  // This is called on a timeout 1ms after the internalLoad call.
  async sendLoadRequest(resolve, reject) {
    var _a4, _b;
    const me = this, [
      url,
      event,
      params,
      eventName,
      successFn
    ] = me.loadArgs;
    me.loadTriggerPromise = null;
    if (url) {
      me._isLoading = true;
      me.trigger(`load${eventName}Start`, event);
      me.trigger("beforeRequest", event);
      if (me.filterParamName && me.isFiltered) {
        params[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }
      if (me.remoteSort && me.isSorted) {
        params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }
      if (me.isPaged) {
        if (!(me.pageParamName in params || me.pageStartParamName in params)) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);
          if (me.pageParamName) {
            params[me.pageParamName] = page;
          } else {
            params[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }
        params[me.pageSizeParamName] = me.pageSize;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
        if (event.body) {
          options.body = JSON.stringify(event.body);
        }
      }
      try {
        const placeParametersInBody = me.paramsInBody && (((_a4 = options.method) == null ? void 0 : _a4.toUpperCase()) === "POST" || ((_b = options.method) == null ? void 0 : _b.toUpperCase()) === "PUT") && options.body == null, url2 = event.url + (placeParametersInBody ? "" : me.buildQueryString(event.url, params)), promise = me.loadingPromise = AjaxHelper.get(
          url2,
          ObjectHelper.assign(options, me.fetchOptions, placeParametersInBody ? { body: JSON.stringify(params) } : null)
        ), response = await promise, data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && ObjectHelper.getPath(data, me.responseSuccessProperty) !== false, remoteTotal = isArray3 ? null : ObjectHelper.getPath(data, me.responseTotalProperty);
        if (me.isDestroyed) {
          return;
        }
        me.loadingPromise = null;
        me._isLoading = false;
        event.response = response;
        event.json = data;
        if (success2) {
          if (remoteTotal != null) {
            me.remoteTotal = parseInt(remoteTotal, 10);
          }
          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error("A paged store must receive its responseTotalProperty in each data packet");
            }
          }
          event.data = isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty);
          await successFn(event);
          !me.isDestroyed && me.trigger("load" + eventName, event);
          resolve(event);
        } else {
          Object.assign(event, {
            exception: true,
            exceptionType: "server",
            error: data == null ? void 0 : data.error
          });
          !me.isDestroyed && me.trigger("exception", event);
          reject(event);
        }
        !me.isDestroyed && me.trigger("afterRequest", event);
      } catch (responseOrError) {
        me._isLoading = false;
        event.exception = true;
        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        reject(event);
        !me.isDestroyed && me.trigger("afterRequest", event);
      }
    }
  }
  /**
   * Load data from the {@link #config-readUrl}.
   * @param {Object} [params] A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.
   * @fires beforeLoad
   * @fires loadStart
   * @fires beforeRequest
   * @fires load
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async load(params) {
    const me = this;
    if (me.isPaged) {
      return me.loadPage(me.currentPage || 1, params);
    } else {
      return me.internalLoad(params, "", (event) => {
        me.data = event.data;
      });
    }
  }
  /**
   * Loads children into specified parent record. Parent records id is sent as a param (param name configured with
   * {@link #config-parentIdParamName}.
   * @param {Core.data.Model} parentRecord Parent record
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.
   * @fires beforeLoadChildren
   * @fires loadChildrenStart
   * @fires beforeRequest
   * @fires loadChildren
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadChildren(parentRecord) {
    return this.readUrl ? this.internalLoad({ [this.parentIdParamName]: parentRecord.id }, "Children", (event) => {
      event.parentRecord = parentRecord;
      if (parentRecord.children.length) {
        parentRecord.clearChildren(true);
      }
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    }, false) : this.immediatePromise;
  }
  /**
   * Loads a page of data from the {@link #config-readUrl}.
   * @param {Number} page The *one based* page number to load.
   * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadPage} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadPage} handler.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }
    const me = this, pageParam = me.pageParamName ? {
      [me.pageParamName]: page
    } : {
      [me.pageStartParamName]: (page - 1) * me.pageSize
    };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(ObjectHelper.assign(pageParam, params), "Page", (event) => {
      me.loadData(event.data, "pageLoad");
    });
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the {@link #property-lastPage}
   * then this will load the next page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async nextPage(params) {
    const me = this;
    return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise2;
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the first page
   * then this will load the previous page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise2;
  }
  /**
   * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},
   * {@link #config-updateUrl} and {@link #config-deleteUrl})
   * @fires beforeCommit
   * @returns {Promise|Boolean} A Promise which is resolved only if all pending changes (Create, Update and Delete)
   * successfully resolve. Both the resolve and reject functions are passed a `commitState` object which is stored the
   * {@link #event-afterRequest} event for each request. Each event contains the `exception`, `request` and `response`
   * properties eg:
   *
   * ```javascript
   * {
   *      // If *all* commits succeeded
   *      success: true,
   *      changes: {
   *          added: [records...],
   *          modified: [records...],
   *          removed: [records...],
   *      },
   *      added: {
   *          source: theStore,
   *
   *          // Only if the add request triggered an exception
   *          exception: true,
   *
   *          // Only if the add request triggered an exception
   *          exceptionType: 'server', // Or 'network'
   *
   *          response: Response,
   *          json: parsedResponseObject
   *      },
   *      // Same format as added
   *      modified: {},
   *      removed: {}
   * }
   * ```
   *
   * If there were no pending changes, the resolve and reject functions are passed no parameters.
   *
   * Returns `false` if a commit operation is already in progress.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred.
   * @category CRUD
   */
  async commit() {
    const me = this, { changes } = me, allPromises = [];
    me.clearTimeout("autoCommit");
    me.autoCommitTimeoutPromise = null;
    if (me.commitPromise) {
      return false;
    }
    if (!changes) {
      if (me.modified.count) {
        me.modified.forEach((record) => record.internalClearChanges(true, false));
        me.modified.clear();
      }
      return immediatePromise2;
    }
    if (me.trigger("beforeCommit", { changes }) !== false) {
      [...changes.added, ...changes.modified, ...changes.removed].forEach((record) => record.meta.committing = true);
      me.trigger("commitStart", { changes });
      const commitState = {
        action: "commit",
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }
      if (!allPromises.length) {
        me.modified.forEach((r) => r.internalClearChanges(true, false));
        me.modified.clear();
        me.added.forEach((r) => r.internalClearChanges(true, false));
        me.added.clear();
        me.removed.clear();
        me.trigger("commit", { changes });
        return immediatePromise2;
      }
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger("exception", commitState);
            reject(commitState);
          } else {
            me.trigger("commit", { changes });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }
  // Performs background autocommit with reject checking
  doAutoCommit() {
    const me = this;
    if (me.suspendCount <= 0 && !me.hasTimeout("autoCommit")) {
      me.autoCommitTimeoutPromise = new Promise((resolve) => {
        me.setTimeout({
          name: "autoCommit",
          fn: () => {
            me.autoCommitTimeoutPromise = null;
            me.commit().then().catch((commitState) => {
              const { response } = commitState;
              if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
                throw commitState;
              }
            });
            resolve();
          },
          delay: me.autoCommitTimeout
        });
      });
    }
  }
  /**
   * Commits added records by posting to {@link #config-createUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitAdded
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitAdded(commitState) {
    const me = this, added = me.added, event = { action: "create", params: me.params };
    return added.count && me.createUrl ? new Promise((resolve) => {
      const toAdd = added.values.map((r) => r.persistableData);
      commitState.create = event;
      event.body = { data: toAdd };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(toAdd));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true }, url = me.createUrl + me.buildQueryString(me.createUrl, me.params);
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }
      AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(added.values, isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty));
          added.clear();
          me.trigger("commitAdded");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          added.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        added.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        resolve(commitState);
        !me.isDestroyed && me.trigger("afterRequest", event);
      });
    }) : null;
  }
  /**
   * Commits modified records by posting to {@link #config-updateUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitModified
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitModified(commitState) {
    const me = this, { modified } = me.changes, event = { action: "update", params: me.params }, result = modified.length && me.updateUrl ? new Promise((resolve) => {
      const modifications = modified.map((record) => {
        if (me.writeAllFields) {
          return record.persistableData;
        } else {
          return record.modificationDataToWrite;
        }
      }).filter((el) => !ObjectHelper.isEmpty(el));
      if (modifications.length === 0) {
        me.modified.clear();
        modified.forEach((r) => r.meta.committing = false);
        resolve();
        return;
      }
      commitState.update = event;
      event.body = { data: modifications };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(modifications));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.update;
      }
      AjaxHelper.post(
        me.updateUrl + me.buildQueryString(me.updateUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(modified, isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);
          me.modified.clear();
          me.trigger("commitModified");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          modified.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        modified.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        resolve(commitState);
        !me.isDestroyed && me.trigger("afterRequest", event);
      });
    }) : null;
    if (!modified.length && me.modified.count) {
      me.modified.clear();
    }
    return result;
  }
  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this, Model2 = me.modelClass, idDataSource = Model2.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];
      record.internalClearChanges(true, false);
      record.syncId(recData[idDataSource]);
      Object.assign(localRecords[i].data, Model2.processData(recData, isUpdating, me, record));
    });
  }
  /**
   * Commits removed records by posting to {@link #config-deleteUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitRemoved
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitRemoved(commitState) {
    const me = this, {
      removed,
      includeChildrenInRemoveRequest
    } = me, event = { action: "delete", params: me.params };
    return removed.count && me.deleteUrl ? new Promise((resolve) => {
      var _a4, _b;
      commitState.delete = event;
      let removedRecords;
      if (!includeChildrenInRemoveRequest) {
        removedRecords = [];
        for (const record of removed.values) {
          const parentId = (_b = record.parentId) != null ? _b : (_a4 = record.meta.modified) == null ? void 0 : _a4.parentId;
          if (parentId != null && (parentId === me.rootNode.id || !removed.includes(parentId))) {
            removedRecords.push(record);
          }
        }
      } else {
        removedRecords = removed.values;
      }
      event.body = { ids: removedRecords.map((r) => r.id) };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("id", JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }
      AjaxHelper.post(
        me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          removed.forEach((record) => record.meta.committing = false);
          removed.clear();
          me.trigger("commitRemoved");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          removed.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        removed.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        resolve(commitState);
        !me.isDestroyed && me.trigger("afterRequest", event);
      });
    }) : null;
  }
  get remoteFilter() {
    return Boolean(this.filterParamName || this.restfulFilter);
  }
  get remoteSort() {
    return Boolean(this.sortParamName);
  }
};
__publicField(AjaxStore, "$name", "AjaxStore");
__publicField(AjaxStore, "configurable", {
  /**
   * An object containing key/value pairs that are passed on the request query string, or in the request body
   * if HTTP method allows. See {@link #config-paramsInBody} config.
   * @prp {Object}
   * @category Remote
   */
  params: null,
  /**
   * When paging of data is requested by setting _either_ the {@link #config-pageParamName} _or_ the
   * {@link #config-pageStartParamName}, this is the value to send in the {@link #config-pageSizeParamName}.
   *
   * **Note:** Setting pageSize at runtime will automatically reload the page.
   * @prp {Number}
   * @default
   * @category Paging
   */
  pageSize: 50,
  /**
   * The timeout in milliseconds to wait before persisting changes to the server.
   * Used when {@link #config-autoCommit} is set to `true`.
   * @config {Number}
   * @default
   * @category Common
   */
  autoCommitTimeout: 10,
  /**
   * Set to `false` to only include the id of a removed parent node in the request to the backend, and not the ids
   * of its children. Applies when configured with a {@link #config-deleteUrl}.
   *
   * Consider the following scenario, removing parent 1:
   *
   * ```javascript
   * {
   *   id : 1,
   *   children : [
   *     { id : 11 },
   *     { id : 12 }
   *   ]
   * }
   * ```
   *
   * With `includeChildrenInRemoveRequest : false`, the backend will only receive the removal of id 1.
   *
   * With `includeChildrenInRemoveRequest : true` (the default), the backend will receive the removal of id 1, 11
   * and 12.
   *
   * @config {Boolean}
   * @default true
   * @category Tree
   */
  includeChildrenInRemoveRequest: true
});
AjaxStore._$name = "AjaxStore";

// ../Core/lib/Core/data/DomDataStore.js
var DomDataStore = class {
  /**
   * Get data that is connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} [key] The name of the property in the element data to return
   * @returns {Object} Data
   */
  static get(element, key) {
    const result = element._domData || (element._domData = {});
    return key != null ? result[key] : result;
  }
  /**
   * Remove data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} key The name of the property in the element data to remove.
   */
  static remove(element, key) {
    const { _domData } = element, was = _domData == null ? void 0 : _domData[key];
    _domData == null ? true : delete _domData[key];
    return was;
  }
  /**
   * Set data connected to specified element (completely replacing any existing).
   * To update data, use DomDataStore#assign instead.
   * @param {HTMLElement} element DOM element
   * @param {Object|String} data Data object to set, or property name to set
   * @param {*} [value] If the previous parameter was a property name, this is the value to set.
   */
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }
  /**
   * Updates data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {Object} data Data to assign
   */
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
};
DomDataStore._$name = "DomDataStore";

// ../Core/lib/Core/data/stm/state/StateBase.js
var throwAbstractMethodCall = () => {
  throw new Error("Abstract method call!");
};
var throwInvalidMethodCall = () => {
  throw new Error("Method cannot be called at this state!");
};
var StateBase = class extends Base {
  canUndo(stm) {
    throwAbstractMethodCall();
  }
  canRedo(stm) {
    throwAbstractMethodCall();
  }
  onUndo(stm) {
    throwAbstractMethodCall();
  }
  onRedo(stm) {
    throwAbstractMethodCall();
  }
  onStartTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransactionDelayed(stm) {
    throwAbstractMethodCall();
  }
  onRejectTransaction(stm) {
    throwAbstractMethodCall();
  }
  onEnable(stm) {
    throwAbstractMethodCall();
  }
  onDisable(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOn(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOff(stm) {
    throwAbstractMethodCall();
  }
  onResetQueue(stm) {
    throwAbstractMethodCall();
  }
  onModelUpdate(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelAdd(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelInsert(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemove(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemoveAll(stm) {
    throwAbstractMethodCall();
  }
  onModelInsertChild(stm) {
    throwAbstractMethodCall();
  }
  onModelRemoveChild(stm) {
    throwAbstractMethodCall();
  }
};
StateBase._$name = "StateBase";

// ../Core/lib/Core/data/stm/Props.js
var STATE_PROP = Symbol("STATE_PROP");
var STORES_PROP = Symbol("STORES_PROP");
var QUEUE_PROP = Symbol("QUEUE_PROP");
var POS_PROP = Symbol("POS_PROP");
var TRANSACTION_PROP = Symbol("TRANSACTION_PROP");
var TRANSACTION_TIMER_PROP = Symbol("TRANSACTION_TIMER_PROP");
var AUTO_RECORD_PROP = Symbol("AUTO_RECORD_PROP");
var IS_APPLYING_STASH = Symbol("IS_APPLYING_STASH");
var PROPS = Object.freeze([
  STATE_PROP,
  STORES_PROP,
  QUEUE_PROP,
  POS_PROP,
  TRANSACTION_PROP,
  TRANSACTION_TIMER_PROP,
  AUTO_RECORD_PROP,
  IS_APPLYING_STASH
]);

// ../Core/lib/Core/data/stm/state/Registry.js
var registry = /* @__PURE__ */ new Map();
var registerStmState = (name, state) => {
  registry.set(name, state);
};
var resolveStmState = (state) => {
  if (typeof state === "string") {
    state = registry.get(state);
  }
  return state;
};
var Registry_default = {
  registerStmState,
  resolveStmState
};

// ../Core/lib/Core/data/stm/Helpers.js
var resetQueue = (stm, options) => {
  const { undo, redo } = options;
  let newProps;
  if (undo && !redo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(stm.position),
      [POS_PROP]: 0
    };
  } else if (redo && !undo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(0, stm.position)
    };
  } else {
    newProps = {
      [QUEUE_PROP]: [],
      [POS_PROP]: 0
    };
  }
  ;
  return [
    newProps,
    () => {
      stm.notifyStoresAboutQueueReset(options);
    }
  ];
};

// ../Core/lib/Core/data/stm/state/DisabledState.js
var DisabledStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable(stm) {
    return stm.autoRecord ? "autoreadystate" : "readystate";
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var DisabledState = new DisabledStateClass();
var DisabledState_default = DisabledState;
Registry_default.registerStmState("disabledstate", DisabledState);

// ../Core/lib/Core/data/stm/Transaction.js
var ACTION_QUEUE_PROP = Symbol("ACTION_QUEUE_PROP");
var Transaction = class extends Base {
  get defaultConfig() {
    return {
      /**
       * Transaction title
       *
       * @config {String}
       */
      title: null
    };
  }
  construct(...args) {
    this[ACTION_QUEUE_PROP] = [];
    super.construct(...args);
  }
  /**
   * Gets transaction's actions queue
   *
   * @property {Core.data.stm.action.ActionBase[]}
   */
  get queue() {
    return this[ACTION_QUEUE_PROP].slice(0);
  }
  /**
   * Gets transaction's actions queue length
   *
   * @property {Number}
   */
  get length() {
    return this[ACTION_QUEUE_PROP].length;
  }
  /**
   * Adds an action to the transaction.
   *
   * @param {Core.data.stm.action.ActionBase|Object} action
   */
  addAction(action) {
    this[ACTION_QUEUE_PROP].push(action);
  }
  /**
   * Undoes actions held
   */
  undo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = queue.length - 1; i >= 0; --i) {
      queue[i].undo();
    }
  }
  /**
   * Redoes actions held
   */
  redo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = 0, len = queue.length; i < len; ++i) {
      queue[i].redo();
    }
  }
  /**
   * Merges all update actions into one per model, keeping the oldest and the newest values
   */
  mergeUpdateModelActions() {
    var _a4, _b;
    const queue = this[ACTION_QUEUE_PROP], recordMap = /* @__PURE__ */ new Map(), keep = [];
    for (const action of queue) {
      if (action.isUpdateAction && ((_a4 = action.model) == null ? void 0 : _a4.isModel)) {
        const mergedRecordAction = recordMap.get(action.model);
        if (!mergedRecordAction) {
          recordMap.set(action.model, action);
          keep.push(action);
        } else {
          for (const key in action.oldData) {
            if (action.newData.hasOwnProperty(key)) {
              if (!mergedRecordAction.oldData.hasOwnProperty(key)) {
                mergedRecordAction.oldData[key] = action.oldData[key];
              }
              mergedRecordAction.newData[key] = action.newData[key];
            }
          }
        }
      } else {
        keep.push(action);
        if (action.isRemoveAction && ((_b = action.modelList) == null ? void 0 : _b.length)) {
          for (const model of action.modelList) {
            recordMap.delete(model);
          }
        }
      }
    }
    this[ACTION_QUEUE_PROP] = keep;
  }
};
Transaction._$name = "Transaction";

// ../Core/lib/Core/data/stm/state/ReadyState.js
var ReadyStateClass = class extends StateBase {
  canUndo(stm) {
    return 0 < stm.position && stm.position <= stm.length;
  }
  canRedo(stm) {
    return 0 <= stm.position && stm.position < stm.length;
  }
  onUndo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.max(0, curPos - steps), next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const undoneTransactions = [];
      while (curPos !== newPos) {
        const transaction = queue[--curPos];
        transaction.undo();
        undoneTransactions.push(transaction);
      }
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({ cause: "undo", transactions: undoneTransactions });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onRedo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.min(queue.length, curPos + steps);
    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const redoneTransactions = [];
      do {
        const transaction = queue[curPos++];
        transaction.redo();
        redoneTransactions.push(transaction);
      } while (curPos !== newPos);
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({ cause: "redo", transactions: redoneTransactions });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    return "disabledstate";
  }
  onAutoRecordOn() {
    return {
      [STATE_PROP]: "autoreadystate",
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({ title });
    return [{
      [STATE_PROP]: "recordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
    }];
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var ReadyState = new ReadyStateClass();
var ReadyState_default = ReadyState;
Registry_default.registerStmState("readystate", ReadyState);

// ../Core/lib/Core/data/stm/state/RecordingState.js
var RecordingStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onEnable() {
  }
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    return [{
      [STATE_PROP]: "autorecordingstate",
      [AUTO_RECORD_PROP]: true
    }, () => {
      stm.stopTransactionDelayed();
    }];
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "readystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
    }];
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP];
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return [
        "readystate",
        () => {
          stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
        }
      ];
    }];
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate(stm, model, newData, oldData, isInitialUserAction) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData, isInitialUserAction));
  }
  onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex, orderedBeforeNode) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex, orderedBeforeNode));
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
  }
  onStoreModelAdd(stm, store, models, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
  }
};
var RecordingState = new RecordingStateClass();
var RecordingState_default = RecordingState;
Registry_default.registerStmState("recordingstate", RecordingState);

// ../Core/lib/Core/data/stm/state/RestoringState.js
var RestoringStateClass = class extends StateBase {
  static get $name() {
    return "RestoringStateClass";
  }
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onQueueReset() {
    throwInvalidMethodCall();
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var RestoringState = new RestoringStateClass();
var RestoringState_default = RestoringState;
Registry_default.registerStmState("restoringstate", RestoringState);

// ../Core/lib/Core/data/stm/state/AutoReadyState.js
var AutoReadyStateClass = class extends ReadyStateClass {
  onAutoRecordOn() {
    throwInvalidMethodCall();
  }
  onAutoRecordOff() {
    return {
      [STATE_PROP]: "readystate",
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({ title });
    return [{
      [STATE_PROP]: "autorecordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
      stm.stopTransactionDelayed();
    }];
  }
  onModelUpdate(stm, model, newData, oldData) {
    stm.startTransaction();
    stm.onModelUpdate(model, newData, oldData);
  }
  onModelInsertChild(stm, parentModel, index, childModels, context) {
    stm.startTransaction();
    stm.onModelInsertChild(parentModel, index, childModels, context);
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    stm.startTransaction();
    stm.onModelRemoveChild(parentModel, childModels, context);
  }
  onStoreModelAdd(stm, store, models, silent) {
    stm.startTransaction();
    stm.onStoreModelAdd(store, models, silent);
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelInsert(store, index, models, context, silent);
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelRemove(store, models, context, silent);
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    stm.startTransaction();
    stm.onStoreRemoveAll(store, allRecords, silent);
  }
};
var AutoReadyState = new AutoReadyStateClass();
var AutoReadyState_default = AutoReadyState;
Registry_default.registerStmState("autoreadystate", AutoReadyState);

// ../Core/lib/Core/data/stm/state/AutoRecordingState.js
var AutoRecordingStateClass = class extends RecordingStateClass.mixin(Delayable_default) {
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    throwInvalidMethodCall();
  }
  onAutoRecordOff(stm) {
    const timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return {
      [STATE_PROP]: "recordingstate",
      [AUTO_RECORD_PROP]: false,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "autoreadystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
    }];
  }
  onStopTransactionDelayed(stm) {
    let timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    timer = this.setTimeout(
      () => {
        stm.stopTransaction();
      },
      stm.autoRecordTransactionStopTimeout
    );
    return {
      [STATE_PROP]: AutoRecordingState,
      [TRANSACTION_TIMER_PROP]: timer
    };
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return [
        "autoreadystate",
        () => {
          stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
        }
      ];
    }];
  }
  onModelUpdate(stm, ...rest) {
    super.onModelUpdate(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelInsertChild(stm, ...rest) {
    super.onModelInsertChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelRemoveChild(stm, ...rest) {
    super.onModelRemoveChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelAdd(stm, ...rest) {
    super.onStoreModelAdd(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelInsert(stm, ...rest) {
    super.onStoreModelInsert(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelRemove(stm, ...rest) {
    super.onStoreModelRemove(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreRemoveAll(stm, ...rest) {
    super.onStoreRemoveAll(stm, ...rest);
    stm.stopTransactionDelayed();
  }
};
var AutoRecordingState = new AutoRecordingStateClass();
var AutoRecordingState_default = AutoRecordingState;
Registry_default.registerStmState("autorecordingstate", AutoRecordingState);

// ../Core/lib/Core/data/stm/action/ActionBase.js
var throwAbstractMethodCall2 = () => {
  throw new Error("Abstract method call!");
};
var ActionBase = class extends Base {
  /**
   * Gets the type of the action (stringified class name).
   * @readonly
   * @property {String}
   */
  get type() {
    return this.constructor.name;
  }
  /**
   * Undoes an action
   */
  undo() {
    throwAbstractMethodCall2();
  }
  /**
   * Redoes an action
   */
  redo() {
    throwAbstractMethodCall2();
  }
};
ActionBase._$name = "ActionBase";

// ../Core/lib/Core/data/stm/action/UpdateAction.js
var MODEL_PROP = Symbol("MODEL_PROP");
var NEW_DATA_PROP = Symbol("NEW_DATA_PROP");
var OLD_DATA_PROP = Symbol("OLD_DATA_PROP");
var UpdateAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a model which has been updated.
       *
       * @prp {Core.data.Model}
       * @readonly
       * @default
       */
      model: void 0,
      /**
       * Map of updated properties with new values.
       *
       * @prp {Object}
       * @readonly
       * @typings {{[key: string]:any}}
       * @default
       */
      newData: void 0,
      /**
       * Map of updated properties with old values.
       *
       * @prp {Object}
       * @readonly
       * @typings {{[key: string]:any}}
       * @default
       */
      oldData: void 0,
      isInitialUserAction: false
    };
  }
  get type() {
    return "UpdateAction";
  }
  get model() {
    return this[MODEL_PROP];
  }
  set model(value) {
    this[MODEL_PROP] = value;
  }
  get newData() {
    return this[NEW_DATA_PROP];
  }
  set newData(value) {
    this[NEW_DATA_PROP] = { ...value };
  }
  get oldData() {
    return this[OLD_DATA_PROP];
  }
  set oldData(value) {
    this[OLD_DATA_PROP] = { ...value };
  }
  undo() {
    const { model, oldData } = this;
    if (model.$) {
      Object.assign(model, oldData);
    }
    model.set(oldData, null, null, null, Boolean(model.$));
  }
  redo() {
    const { model, newData } = this;
    if (model.$) {
      Object.assign(model, newData);
    }
    model.set(newData, null, null, null, Boolean(model.$));
  }
};
__publicField(UpdateAction, "$name", "UpdateAction");
UpdateAction._$name = "UpdateAction";

// ../Core/lib/Core/data/stm/action/InsertChildAction.js
var PARENT_MODEL_PROP = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP = Symbol("CHILD_MODELS_PROP");
var INSERT_INDEX_PROP = Symbol("INSERT_INDEX_PROP");
var ORDERED_PRP = Symbol("ORDERED_PROP");
var CONTEXT_PROP = Symbol("CONTEXT_PROP");
var InsertChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been added to.
       *
       * @prp {Core.data.Model}
       * @readonly
       * @default
       */
      parentModel: void 0,
      /**
       * Children models inserted.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      childModels: void 0,
      /**
       * Index a children models are inserted at
       *
       * @prp {Number}
       * @readonly
       * @default
       */
      insertIndex: void 0,
      /**
       * Reference node in the ordered tree
       *
       * @prp {Core.data.Model}
       * @readonly
       * @default
       * @internal
       */
      orderedBeforeNode: void 0,
      /**
       * Map having children models as keys and values containing previous parent
       * of each model and index at the previous parent.
       *
       * @prp {Object}
       * @readonly
       * @default
       */
      context: void 0
    };
  }
  get type() {
    return "InsertChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP] = models.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP] = index;
  }
  get orderedBeforeNode() {
    return this[ORDERED_PRP];
  }
  set orderedBeforeNode(node) {
    this[ORDERED_PRP] = node;
  }
  get context() {
    return this[CONTEXT_PROP];
  }
  set context(ctx) {
    this[CONTEXT_PROP] = ctx;
  }
  undo() {
    const { parentModel, context, childModels } = this, byFromParent = /* @__PURE__ */ new Map(), newlyAdded = /* @__PURE__ */ new Set();
    for (const childModel of childModels) {
      const ctx = context.get(childModel);
      if (!ctx) {
        newlyAdded.add(childModel);
      } else {
        let undoTaskData = byFromParent.get(ctx.parent);
        if (!undoTaskData) {
          undoTaskData = { moveRight: [], moveLeft: [], moveFromAnotherParent: [] };
          byFromParent.set(ctx.parent, undoTaskData);
        }
        if (ctx.parent === parentModel) {
          if (ctx.index > childModel.parentIndex) {
            undoTaskData.moveRight.push({ parent: ctx.parent, model: childModel, index: ctx.index + 1 });
          } else {
            undoTaskData.moveLeft.push({ parent: ctx.parent, model: childModel, index: ctx.index });
          }
        } else {
          undoTaskData.moveFromAnotherParent.push({ parent: ctx.parent, model: childModel, index: ctx.index });
        }
      }
    }
    newlyAdded.forEach((model) => model.parent.removeChild(model));
    for (const undoTaskData of byFromParent.values()) {
      const { moveRight, moveLeft, moveFromAnotherParent } = undoTaskData;
      moveFromAnotherParent.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
      moveLeft.sort((a, b) => a.index - b.index);
      moveRight.sort((a, b) => b.index - a.index);
    }
    for (const undoTaskData of byFromParent.values()) {
      const { moveRight, moveLeft } = undoTaskData;
      moveLeft.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
      moveRight.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
    }
  }
  redo() {
    var _a4, _b;
    const { parentModel, insertIndex, childModels, orderedBeforeNode } = this, insertBefore = (_a4 = parentModel.children) == null ? void 0 : _a4[insertIndex];
    parentModel.insertChild(childModels, insertBefore, false, {
      orderedBeforeNode: orderedBeforeNode != null ? orderedBeforeNode : (_b = insertBefore == null ? void 0 : insertBefore.previousSibling) == null ? void 0 : _b.nextOrderedSibling
    });
  }
};
InsertChildAction._$name = "InsertChildAction";

// ../Core/lib/Core/data/stm/action/RemoveChildAction.js
var PARENT_MODEL_PROP2 = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP2 = Symbol("CHILD_MODELS_PROP");
var CONTEXT_PROP2 = Symbol("CONTEXT_PROP");
var RemoveChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been removed to.
       *
       * @prp {Core.data.Model}
       * @readonly
       * @default
       */
      parentModel: void 0,
      /**
       * Children models removed.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      childModels: void 0,
      /**
       * Map having children models as keys and values containing previous parent
       * index at the parent.
       *
       * @prp {Object}
       * @readonly
       * @default
       */
      context: void 0
    };
  }
  get type() {
    return "RemoveChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP2];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP2] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP2];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP2] = models.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP2];
  }
  set context(ctx) {
    this[CONTEXT_PROP2] = ctx;
  }
  undo() {
    const { parentModel, context, childModels } = this;
    childModels.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs).parentIndex, rhsIndex = context.get(rhs).parentIndex;
      return lhsIndex - rhsIndex;
    });
    childModels.forEach((m) => {
      const ctx = context.get(m);
      parentModel.insertChild(m, ctx.parentIndex, void 0, { orderedParentIndex: ctx.orderedParentIndex });
    });
  }
  redo() {
    this.parentModel.removeChild(this.childModels);
  }
};
RemoveChildAction._$name = "RemoveChildAction";

// ../Core/lib/Core/data/stm/action/AddAction.js
var STORE_PROP = Symbol("STORE_PROP");
var MODEL_LIST_PROP = Symbol("MODEL_LIST_PROP");
var AddAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been added into.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * List of models added into the store.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      modelList: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "AddAction";
  }
  get store() {
    return this[STORE_PROP];
  }
  set store(store) {
    this[STORE_PROP] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP] = list.slice(0);
  }
  undo() {
    this.store.remove(this.modelList, this.silent);
  }
  redo() {
    this.store.add(this.modelList, this.silent);
  }
};
AddAction._$name = "AddAction";

// ../Core/lib/Core/data/stm/action/InsertAction.js
var STORE_PROP2 = Symbol("STORE_PROP");
var MODEL_LIST_PROP2 = Symbol("MODEL_LIST_PROP");
var INSERT_INDEX_PROP2 = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP3 = Symbol("CONTEXT_PROP");
var InsertAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been inserted into.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * List of models inserted into the store.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      modelList: void 0,
      /**
       * Index the models have been inserted at.
       *
       * @prp {Number}
       * @readonly
       * @default
       */
      insertIndex: void 0,
      /**
       * Models move context (if models has been moved), if any.
       * Map this {@link Core/data/Model} instances as keys and their
       * previous index as values
       *
       * @prp {Map}
       * @readonly
       * @default
       */
      context: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "InsertAction";
  }
  get store() {
    return this[STORE_PROP2];
  }
  set store(store) {
    this[STORE_PROP2] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP2];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP2] = list.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP2];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP2] = index;
  }
  get context() {
    return this[CONTEXT_PROP3];
  }
  set context(context) {
    this[CONTEXT_PROP3] = context;
  }
  undo() {
    const { store, modelList, context, silent } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex !== void 0 && rhsIndex !== void 0 ? lhsIndex - rhsIndex : 0;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      m._undoingInsertion = true;
      if (index !== void 0) {
        store.insert(index, m, silent);
      } else {
        store.remove(m, silent);
      }
      m._undoingInsertion = false;
    });
  }
  redo() {
    const me = this;
    me.store.insert(me.insertIndex, me.modelList, me.silent);
  }
};
InsertAction._$name = "InsertAction";

// ../Core/lib/Core/data/stm/action/RemoveAction.js
var STORE_PROP3 = Symbol("STORE_PROP");
var MODEL_LIST_PROP3 = Symbol("MODEL_LIST_PROP");
var CONTEXT_PROP4 = Symbol("CONTEXT_PROP");
var RemoveAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been removed from.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * List of models removed from the store.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      modelList: void 0,
      /**
       * Models removing context.
       *
       * @prp {Object}
       * @readonly
       * @default
       */
      context: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "RemoveAction";
  }
  get store() {
    return this[STORE_PROP3];
  }
  set store(store) {
    this[STORE_PROP3] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP3];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP3] = list.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP4];
  }
  set context(context) {
    this[CONTEXT_PROP4] = context;
  }
  undo() {
    const { store, context, modelList, silent } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      store.insert(index, m, silent);
    });
  }
  redo() {
    this.store.remove(this.modelList, this.silent);
  }
};
__publicField(RemoveAction, "$name", "RemoveAction");
RemoveAction._$name = "RemoveAction";

// ../Core/lib/Core/data/stm/action/RemoveAllAction.js
var STORE_PROP4 = Symbol("STORE_PROP");
var ALL_RECORDS_PROP = Symbol("ALL_RECORDS_PROP");
var RemoveAllAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store cleared.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * All store records removed
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      allRecords: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "RemoveAllAction";
  }
  get store() {
    return this[STORE_PROP4];
  }
  set store(store) {
    this[STORE_PROP4] = store;
  }
  get allRecords() {
    return this[ALL_RECORDS_PROP];
  }
  set allRecords(records) {
    this[ALL_RECORDS_PROP] = records.slice(0);
  }
  undo() {
    const { store, allRecords, silent } = this;
    store.add(allRecords, silent);
  }
  redo() {
    this.store.removeAll(this.silent);
  }
};
RemoveAllAction._$name = "RemoveAllAction";

// ../Core/lib/Core/data/stm/StateTrackingManager.js
var makeModelUpdateAction = (model, newData, oldData, isInitialUserAction) => {
  return new UpdateAction({
    model,
    newData,
    oldData,
    isInitialUserAction
  });
};
var makeModelInsertChildAction = (parentModel, insertIndex, childModels, context, orderedBeforeNode) => {
  return new InsertChildAction({
    parentModel,
    childModels,
    insertIndex,
    orderedBeforeNode,
    context
  });
};
var makeModelRemoveChildAction = (parentModel, childModels, context) => {
  return new RemoveChildAction({
    parentModel,
    childModels,
    context
  });
};
var makeStoreModelAddAction = (store, modelList, silent) => {
  return new AddAction({
    store,
    modelList,
    silent
  });
};
var makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
  return new InsertAction({
    store,
    insertIndex,
    modelList,
    context,
    silent
  });
};
var makeStoreModelRemoveAction = (store, modelList, context, silent) => {
  return new RemoveAction({
    store,
    modelList,
    context,
    silent
  });
};
var makeStoreRemoveAllAction = (store, allRecords, silent) => {
  return new RemoveAllAction({
    store,
    allRecords,
    silent
  });
};
var stateTransition = (stm, event, ...args) => {
  const oldState = stm.state, newState = event.call(stm[STATE_PROP], stm, ...args);
  if (typeof newState === "string") {
    stm[STATE_PROP] = Registry_default.resolveStmState(newState);
  } else if (newState instanceof StateBase) {
    stm[STATE_PROP] = newState;
  } else if (Array.isArray(newState)) {
    const [state, next] = newState;
    if (typeof state === "string") {
      stm[STATE_PROP] = Registry_default.resolveStmState(state);
    } else if (state instanceof StateBase) {
      stm[STATE_PROP] = state;
    } else if (state && typeof state === "object") {
      stm = Object.assign(stm, state);
      stm[STATE_PROP] = Registry_default.resolveStmState(stm[STATE_PROP]);
    }
    if (typeof next === "function") {
      stateTransition(stm, next, ...args);
    }
  } else if (newState && typeof newState === "object") {
    stm = Object.assign(stm, newState);
    stm[STATE_PROP] = Registry_default.resolveStmState(stm[STATE_PROP]);
  }
  if (oldState !== ReadyState_default && oldState !== AutoReadyState_default && (newState !== ReadyState_default && newState !== AutoReadyState_default)) {
    stm.trigger("ready");
  }
};
var StateTrackingManager = class extends Events_default(Base) {
  static get defaultConfig() {
    return {
      /**
       * Default manager disabled state
       *
       * @config {Boolean}
       * @default
       */
      disabled: true,
      /**
       * Whether to start transaction recording automatically in case the Manager is enabled.
       *
       * In the auto recording mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.
       * records any changes in its monitored stores. The transaction lasts for {@link #config-autoRecordTransactionStopTimeout} and
       * afterwards creates one undo/redo step, including all changes in the stores during that period of time.
       *
       * In non auto recording mode you have to call {@link #function-startTransaction} / {@link #function-stopTransaction} to start and end
       * a transaction.
       *
       * @config {Boolean}
       * @default
       */
      autoRecord: false,
      /**
       * The transaction duration (in ms) for the auto recording mode {@link #config-autoRecord}
       *
       * @config {Number}
       * @default
       */
      autoRecordTransactionStopTimeout: 100,
      /**
       * By the end of a transaction, with this config set to `true`, all model update actions will be merged to
       * one action per model. Only the initial start value and the last change will be kept.
       *
       * If non auto recording mode, you can call {@link #function-mergeTransactionUpdateActions}.
       *
       * @config {Boolean}
       * @default
       */
      autoRecordMergeUpdateActions: true,
      /**
       * Store model update action factory
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelUpdateAction,
      /**
       * Store insert child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelInsertChildAction,
      /**
       * Store remove child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelRemoveChildAction,
      /**
       * Store add model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelAddAction,
      /**
       * Store insert model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelInsertAction,
      /**
       * Store remove model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelRemoveAction,
      /**
       * Store remove all models action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreRemoveAllAction,
      /**
       * Function to create a transaction title if none is provided.
       * The function receives a transaction and should return a title.
       *
       * @config {Function}
       * @param {Core.data.stm.Transaction} transaction
       * @returns {String}
       * @default
       */
      getTransactionTitle: null
    };
  }
  construct(...args) {
    Object.assign(this, {
      [STATE_PROP]: ReadyState_default,
      [STORES_PROP]: [],
      [QUEUE_PROP]: [],
      [POS_PROP]: 0,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null,
      [AUTO_RECORD_PROP]: false,
      [IS_APPLYING_STASH]: false,
      stashedTransactions: {}
    });
    super.construct(...args);
  }
  /**
   * Gets current state of the manager
   *
   * @property {Core.data.stm.state.StateBase}
   */
  get state() {
    return this[STATE_PROP];
  }
  /**
   * Gets current undo/redo queue position
   *
   * @property {Number}
   */
  get position() {
    return this[POS_PROP];
  }
  /**
   * Gets current undo/redo queue length
   *
   * @property {Number}
   */
  get length() {
    return this[QUEUE_PROP].length;
  }
  /**
   * Gets all the stores registered in STM
   *
   * @property {Core.data.Store[]}
   */
  get stores() {
    return Array.from(this[STORES_PROP]);
  }
  /**
   * Checks if a store has been added to the manager
   *
   * @param  {Core.data.Store} store
   * @returns {Boolean}
   */
  hasStore(store) {
    return this[STORES_PROP].includes(store);
  }
  /**
   * Adds a store instance to the manager
   * ```javascript
   * const stm = new StateTrackingManager({ ... })
   * const store = new Store({ ... });
   * stm.addStore(store);
   * ```
   *
   * @param {Core.data.Store} store
   */
  addStore(store) {
    if (!this.hasStore(store)) {
      this[STORES_PROP].push(store);
      store.stm = this;
      store.forEach((model) => model.stm = this);
      if (store.isTree) {
        store.rootNode.stm = this;
      }
    }
  }
  /**
   * Removes a store from the manager
   *
   * @param {Core.data.Store} store
   */
  removeStore(store) {
    if (this.hasStore(store)) {
      this[STORES_PROP] = this[STORES_PROP].filter((s) => s !== store);
      store.stm = null;
      store.forEach((model) => model.stm = null);
    }
  }
  /**
   * Calls `fn` for each store registered in STM.
   *
   * @param {Function} fn (store, id) => ...
   */
  forEachStore(fn) {
    this[STORES_PROP].forEach((s) => fn(s, s.id));
  }
  //#region Disabled state
  /**
   * Get/set manager disabled state
   *
   * @property {Boolean}
   */
  get disabled() {
    return this.state === DisabledState_default;
  }
  set disabled(val) {
    const me = this;
    if (me.disabled !== val) {
      if (val) {
        stateTransition(me, me.state.onDisable, me);
      } else {
        stateTransition(me, me.state.onEnable, me);
      }
      me.trigger("stmDisabled", { disabled: val });
      me.trigger("disabled", { disabled: val });
    }
  }
  get enabled() {
    return !this.disabled;
  }
  /**
   * Enables manager
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Disables manager
   */
  disable() {
    this.disabled = true;
  }
  //#endregion
  /**
   * Checks manager ready state
   * @readonly
   * @property {Boolean}
   */
  get isReady() {
    return this.state === ReadyState_default || this.state === AutoReadyState_default;
  }
  waitForReadiness() {
    return this.await("ready", false);
  }
  /**
   * Checks manager recording state
   * @readonly
   * @property {Boolean}
   */
  get isRecording() {
    return this.state === RecordingState_default || this.state === AutoRecordingState_default;
  }
  /**
   * Checks if STM is restoring a stash
   * @readonly
   * @property {Boolean}
   * @internal
   */
  get isApplyingStash() {
    return this[IS_APPLYING_STASH];
  }
  /**
   * Gets/sets manager auto record option
   *
   * @property {Boolean}
   */
  get autoRecord() {
    return this[AUTO_RECORD_PROP];
  }
  set autoRecord(value) {
    const me = this;
    if (me.autoRecord != value) {
      if (value) {
        stateTransition(me, me.state.onAutoRecordOn, me);
      } else {
        stateTransition(me, me.state.onAutoRecordOff, me);
      }
    }
  }
  /**
   * Starts undo/redo recording transaction.
   *
   * @param {String} [title]
   */
  startTransaction(title = null) {
    stateTransition(this, this.state.onStartTransaction, title);
  }
  /**
   * Stops undo/redo recording transaction
   *
   * @param {String} [title]
   */
  stopTransaction(title = null) {
    if (this.autoRecord && this.autoRecordMergeUpdateActions) {
      this.mergeTransactionUpdateActions();
    }
    stateTransition(this, this.state.onStopTransaction, title);
  }
  /**
   * Stops undo/redo recording transaction after {@link #config-autoRecordTransactionStopTimeout} delay.
   *
   * @private
   */
  stopTransactionDelayed() {
    stateTransition(this, this.state.onStopTransactionDelayed);
  }
  /**
   * Rejects currently recorded transaction.
   */
  rejectTransaction() {
    stateTransition(this, this.state.onRejectTransaction);
  }
  /**
   * Gets currently recording STM transaction.
   * @readonly
   * @property {Core.data.stm.Transaction}
   */
  get transaction() {
    return this[TRANSACTION_PROP];
  }
  /**
   * Gets titles of all recorded undo/redo transactions
   * @readonly
   * @property {String[]}
   */
  get queue() {
    return this[QUEUE_PROP].map((t) => t.title);
  }
  get rawQueue() {
    return this[QUEUE_PROP];
  }
  /**
   * Gets manager restoring state.
   * @readonly
   * @property {Boolean}
   */
  get isRestoring() {
    return this.state === RestoringState_default || this.isApplyingStash;
  }
  /**
   * Checks if the manager can undo.
   *
   * @property {Boolean}
   */
  get canUndo() {
    return this.state.canUndo(this);
  }
  /**
   * Checks if the manager can redo.
   *
   * @property {Boolean}
   */
  get canRedo() {
    return this.state.canRedo(this);
  }
  /**
   * Undoes current undo/redo transaction.
   * @param {Number} [steps=1]
   * @returns {Promise} A promise which is resolved when undo action has been performed
   */
  async undo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onUndo, steps);
  }
  /**
   * Undoes all transactions.
   * @returns {Promise} A promise which is resolved when undo actions has been performed
   */
  async undoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.undo(this.length);
  }
  /**
   * Redoes current undo/redo transaction.
   *
   * @param {Number} [steps=1]
   * @returns {Promise} A promise which is resolved when redo action has been performed
   */
  async redo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onRedo, steps);
  }
  /**
   * Redoes all transactions.
   * @returns {Promise} A promise which is resolved when redo actions has been performed
   */
  async redoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.redo(this.length);
  }
  /**
   * Resets undo/redo queue.
   */
  resetQueue(options = { undo: true, redo: true }) {
    stateTransition(this, this.state.onResetQueue, options);
  }
  /**
   * Resets undo queue.
   */
  resetUndoQueue() {
    this.resetQueue({ undo: true });
  }
  /**
   * Resets redo queue.
   */
  resetRedoQueue() {
    this.resetQueue({ redo: true });
  }
  notifyStoresAboutStateRecordingStart(transaction) {
    this.forEachStore((store) => {
      var _a4;
      return (_a4 = store.onStmRecordingStart) == null ? void 0 : _a4.call(store, this, transaction);
    });
    this.trigger("recordingStart", { stm: this, transaction });
  }
  notifyStoresAboutStateRecordingStop(transaction, reason) {
    this.forEachStore((store) => {
      var _a4;
      return (_a4 = store.onStmRecordingStop) == null ? void 0 : _a4.call(store, this, transaction, reason);
    });
    this.trigger("recordingStop", { stm: this, transaction, reason });
  }
  notifyStoresAboutStateRestoringStart() {
    this.forEachStore((store) => {
      var _a4;
      return (_a4 = store.onStmRestoringStart) == null ? void 0 : _a4.call(store, this);
    });
    this.trigger("restoringStart", { stm: this });
  }
  /**
   * @param {'undo'|'redo'} cause The cause of the restore, if applicable
   * @internal
   */
  notifyStoresAboutStateRestoringStop({ cause, transactions }) {
    this.forEachStore((store) => {
      var _a4;
      return (_a4 = store.onStmRestoringStop) == null ? void 0 : _a4.call(store, this);
    });
    this.trigger("restoringStop", { stm: this, cause, transactions });
  }
  notifyStoresAboutQueueReset(options) {
    this.forEachStore((store) => {
      var _a4;
      return (_a4 = store.onStmQueueReset) == null ? void 0 : _a4.call(store, this, options);
    });
    this.trigger("queueReset", { stm: this, options });
  }
  /**
   * Method to call from model STM mixin upon model update
   *
   * @param {Core.data.Model} model
   * @param {Object} newData
   * @param {Object} oldData
   *
   * @private
   */
  onModelUpdate(model, newData, oldData, isInitialUserAction) {
    stateTransition(this, this.state.onModelUpdate, model, newData, oldData, isInitialUserAction);
  }
  /**
   * Method to call from model STM mixin upon tree model child insertion
   *
   * @param {Core.data.Model} parentModel Parent model
   * @param {Number} index Insertion index
   * @param {Core.data.Model[]} childModels Array of models inserted
   * @param {Map} context Map with inserted models as keys and objects with previous parent,
   *                      and index at previous parent.
   * @param {Core.data.Model} [orderedBeforeNode] Reference node in ordered tree
   * @private
   */
  onModelInsertChild(parentModel, index, childModels, context, orderedBeforeNode) {
    stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context, orderedBeforeNode);
  }
  /**
   * Method to call from model STM mixin upon tree model child removal
   *
   * @param {Core.data.Model} parentModel
   * @param {Core.data.Model[]} childModels
   * @param {Map} context
   *
   * @private
   */
  onModelRemoveChild(parentModel, childModels, context) {
    stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
  }
  /**
   * Method to call from store STM mixin upon store models adding
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} models
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelAdd(store, models, silent) {
    stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
  }
  /**
   * Method to call from store STM mixin upon store models insertion
   *
   * @param {Core.data.Store} store
   * @param {Number} index
   * @param {Core.data.Model[]} models
   * @param {Map} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelInsert(store, index, models, context, silent) {
    stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
  }
  /**
   * Method to call from store STM mixin upon store models removal
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} models
   * @param {Object} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelRemove(store, models, context, silent) {
    stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
  }
  /**
   * Method to call from store STM mixin upon store clear
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} allRecords
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreRemoveAll(store, allRecords, silent) {
    stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
  }
  // UI key event handling
  onUndoKeyPress(event) {
    const me = this;
    if (me.enabled) {
      if (event.shiftKey) {
        if (me.canRedo) {
          event.preventDefault();
          me.redo();
        }
      } else if (me.canUndo) {
        event.preventDefault();
        me.undo();
      }
    }
  }
  stash() {
    const me = this;
    if (me.transaction) {
      const id = IdHelper.generateId("_stashedTransactionGeneratedId_");
      me.stashedTransactions[id] = me.transaction;
      me.rejectTransaction();
      return id;
    }
  }
  applyStash(id) {
    const me = this, transaction = me.stashedTransactions[id];
    me[IS_APPLYING_STASH] = true;
    if (transaction) {
      me.startTransaction(transaction.title);
      transaction.redo();
      delete me.stashedTransactions[id];
    }
    me[IS_APPLYING_STASH] = false;
  }
  /**
   * Merges all update actions into one per model, keeping the oldest and the newest values.
   */
  mergeTransactionUpdateActions(transaction = this.transaction) {
    transaction.mergeUpdateModelActions();
  }
};
StateTrackingManager._$name = "StateTrackingManager";

// ../Core/lib/Core/helper/CSSHelper.js
var CSSHelper = class {
  /**
   * Inserts a CSS style rule based upon the passed text
   * @param {String} cssText The text of the rule including selector and rule body just as it would
   * be specified in a CSS file.
   * @returns {CSSRule} The resulting CSS Rule object if the add was successful.
   */
  static insertRule(cssText, parentElement = document.head) {
    const styleSheet = this.getStyleSheet(parentElement), oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }
  /**
   * Looks up the first rule which matched the passed selector.
   * @param {String|Function} selector Either the selector string to exactly match or a function which
   * when passed a required selector, returns `true`.
   * @returns {CSSRule} The first matching CSS Rule object if any found.
   */
  static findRule(selector) {
    let result;
    const isFn = typeof selector === "function";
    Array.prototype.find.call(document.head.querySelectorAll("link[rel=stylesheet],style[type*=css]"), (element) => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, (r) => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });
    return result;
  }
  static getStyleSheet(parentElement = document.head) {
    if (!parentElement.$bryntumStylesheet) {
      parentElement.$bryntumStylesheet = DomHelper.createElement({
        tag: "style",
        id: "bryntum-private-styles",
        type: "text/css",
        parent: parentElement
      }).sheet;
    }
    return parentElement.$bryntumStylesheet;
  }
  /**
   * Returns current CSS version
   * @returns {String}
   * @internal
   */
  static getCSSVersion() {
    return getComputedStyle(document.documentElement).getPropertyValue("--bryntum-version").replace(/[" ]/gm, "");
  }
};
CSSHelper._$name = "CSSHelper";

// ../Core/lib/Core/helper/DomSync.js
var arraySlice2 = Array.prototype.slice;
var emptyArray6 = Object.freeze([]);
var emptyObject6 = Object.freeze({});
var htmlRe2 = /[&<]/;
var { getPrototypeOf: getPrototypeOf2 } = Object;
var { toString: toString4 } = Object.prototype;
var { isEqual, isObject: isObject2 } = ObjectHelper;
var checkEqualityIgnore = {
  parent: 1,
  elementData: 1,
  ns: 1,
  syncOptions: 1
};
var makeCheckEqualityOptions = () => ({
  ignore: checkEqualityIgnore,
  refsFound: /* @__PURE__ */ new Set()
});
var isClass = {
  class: 1,
  className: 1,
  classname: 1
};
var simpleTypes = {
  bigint: 1,
  boolean: 1,
  function: 1,
  number: 1,
  // object
  string: 1,
  symbol: 1
  // undefined
};
var syncIgnoreAttributes = {
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  elementData: 1,
  retainElement: 1,
  compareHtml: 1,
  syncOptions: 1,
  listeners: 1,
  // eslint-disable-line bryntum/no-listeners-in-lib
  isReleased: 1,
  null: 1,
  "": 1,
  keepChildren: 1,
  retainChildren: 1
};
var addAndCacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (!value.includes(cls)) {
        value.push(cls);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (!propertyValue.includes(cls)) {
        propertyValue.push(cls);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.add(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      propertyValue[cls] = 1;
    }
  }
};
var removeAndUncacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (value.includes(cls)) {
        value.splice(value.indexOf(cls), 1);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (propertyValue.includes(cls)) {
        propertyValue.splice(propertyValue.indexOf(cls), 1);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.remove(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      delete propertyValue[cls];
    }
  }
};
var DomSync = class _DomSync {
  /**
   * Compares two DOM configs or properties of such objects for equality.
   * @param {Object} is The new value.
   * @param {Object} was The old value.
   * @param {Object} options An object with various options to control the comparison.
   * @param {Object} options.ignore An object containing names of attributes to ignore having `true` value.
   * @param {Map} options.equalityCache A map that can be used to record equality results for objects to avoid
   * recomputing the result for the same objects.
   * @param {Set} options.refsFound A Set that must be populated with the values of any `reference` properties found.
   * @param {Boolean|String} [ignoreRefs] Pass `true` to ignore `reference` properties on domConfigs. Pass `'children'`
   * to ignore `reference` properties only on child element configs.
   * @returns {Boolean}
   * @private
   */
  static checkEquality(is, was, options, ignoreRefs) {
    var _a4;
    if (is === was) {
      return true;
    }
    if (is == null) {
      return was == null;
    }
    if (!is || !was) {
      return false;
    }
    const typeA = typeof is, typeB = typeof was;
    if (typeA !== typeB || simpleTypes[typeA]) {
      return false;
    }
    let cache = options.equalityCache || (options.equalityCache = /* @__PURE__ */ new Map()), ignoreChildRefs = Boolean(ignoreRefs), equal2, i, ignore, ignoreRefOpt, key, syncOptions, val;
    cache = cache.get(is) || cache.set(is, /* @__PURE__ */ new Map()).get(is);
    equal2 = cache.get(was);
    if (equal2 === void 0) {
      equal2 = true;
      if (getPrototypeOf2(is) !== getPrototypeOf2(was) || is instanceof Node) {
        equal2 = false;
      } else if (Array.isArray(is)) {
        i = is.length;
        if (i !== was.length) {
          equal2 = false;
        } else {
          while (i-- > 0) {
            if (!_DomSync.checkEquality(is[i], was[i], options, ignoreChildRefs)) {
              equal2 = false;
              break;
            }
          }
        }
      } else {
        syncOptions = is.syncOptions;
        ignoreRefOpt = syncOptions == null ? void 0 : syncOptions.ignoreRefs;
        if (ignoreRefOpt) {
          ignoreChildRefs = true;
          ignoreRefs = ignoreRefOpt !== "children";
        }
        ignore = options.ignore || emptyObject6;
        for (key in was) {
          if (!ignore[key] && !(key in is) && !(ignoreRefs && key === "reference")) {
            equal2 = false;
            break;
          }
        }
        if (equal2) {
          if (toString4.call(was) === "[object Date]") {
            equal2 = is.getTime() === was.getTime();
          } else if (DomHelper.isReactElement(is) || DomHelper.isReactElement(was)) {
            equal2 = false;
          } else {
            for (key in is) {
              if (!ignore[key] && !(ignoreRefs && key === "reference")) {
                if (!(key in was)) {
                  equal2 = false;
                  break;
                }
                val = is[key];
                if (!_DomSync.checkEquality(val, was[key], options, ignoreChildRefs)) {
                  equal2 = false;
                  break;
                }
              }
            }
          }
        }
      }
      if (!ignoreRefs && isObject2(is) && is.reference) {
        (_a4 = options.refsFound) == null ? void 0 : _a4.add(is.reference);
      }
      cache.set(was, equal2);
    }
    return equal2;
  }
  /**
   * Sync a DOM config to a target element
   * @param {Object} options Options object
   * @param {DomConfig} options.domConfig A DOM config object
   * @param {HTMLElement} options.targetElement Target element to apply to
   * @param {Boolean} [options.strict=false] Specify `true` to limit synchronization to only the values set by
   * previous calls. Styles and classes placed directly on the DOM elements by other means will not be affected.
   * @param {String} [options.syncIdField] Field in dataset to use to match elements for re-usage
   * @param {String|String[]} [options.affected] The references affected by a partial sync.
   * @param {Function} [options.callback] A function that will be called on element re-usage, creation and similar
   * @param {Boolean} [options.configEquality] A function that will be called to compare an incoming config to
   * the last config applied to the `targetElement`. This function returns `true` if the passed values are equal and
   * `false` otherwise.
   * @returns {HTMLElement} Returns the updated target element (which is also updated in place)
   */
  static sync(options) {
    var _a4;
    const optionsIn = options, { refOwner } = options, refsWas = refOwner == null ? void 0 : refOwner.byRef, checkEqualityOptions = makeCheckEqualityOptions();
    let affected = options.affected, i, ref, targetNode, lastDomConfig;
    if (typeof affected === "string") {
      affected = [affected];
    }
    options = {
      ...options,
      checkEqualityOptions
    };
    if (refOwner) {
      refOwner.byRef = {};
      if (affected) {
        for (ref in refsWas) {
          if (!affected.includes(ref)) {
            refOwner.byRef[ref] = refsWas[ref];
          }
        }
      }
      options.refsWas = refsWas;
    }
    optionsIn.changed = _DomSync.performSync(options, options.targetElement);
    if (refOwner) {
      if (!affected) {
        affected = Object.keys(refsWas);
      }
      for (i = 0; i < affected.length; ++i) {
        ref = affected[i];
        targetNode = refsWas[ref];
        if (checkEqualityOptions.refsFound.has(ref) || targetNode.retainElement) {
          refOwner.byRef[ref] = targetNode;
        } else {
          lastDomConfig = targetNode.lastDomConfig;
          (_a4 = targetNode.blur) == null ? void 0 : _a4.call(targetNode);
          targetNode.remove();
          refOwner.detachRef(ref, targetNode, lastDomConfig);
        }
      }
    }
    return options.targetElement;
  }
  static performSync(options, targetElement) {
    const { domConfig, callback } = options, { lastDomConfig } = targetElement, configIsEqual = options.configEquality || _DomSync.checkEquality;
    if (!configIsEqual(domConfig, lastDomConfig, options.checkEqualityOptions, options.ignoreRefs)) {
      if (domConfig) {
        if (!domConfig.onlyChildren) {
          _DomSync.syncAttributes(domConfig, targetElement, options);
          _DomSync.syncContent(domConfig, targetElement);
        }
        if (!domConfig.keepChildren) {
          _DomSync.syncChildren(options, targetElement);
        }
      } else {
        targetElement.innerHTML = null;
        targetElement.syncIdMap = null;
      }
      targetElement.lastDomConfig = !((domConfig == null ? void 0 : domConfig.onlyChildren) && lastDomConfig) ? domConfig : {
        ...lastDomConfig,
        children: domConfig.children
      };
      return true;
    } else {
      callback == null ? void 0 : callback({
        action: "none",
        domConfig,
        targetElement
      });
    }
    return false;
  }
  //region Attributes
  static syncDataset(domConfig, targetElement) {
    const { lastDomConfig } = targetElement, sameConfig = domConfig === lastDomConfig, source = Object.keys(domConfig.dataset), target = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset), delta = ArrayHelper.delta(source, target);
    let attr, i, name, value;
    for (i = 0; i < delta.onlyInA.length; i++) {
      attr = delta.onlyInA[i];
      value = domConfig.dataset[attr];
      if (value != null) {
        targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, value);
      }
    }
    for (i = 0; i < delta.inBoth.length; i++) {
      attr = delta.inBoth[i];
      value = domConfig.dataset[attr];
      if (sameConfig || value != lastDomConfig.dataset[attr]) {
        name = `data-${StringHelper.hyphenate(attr)}`;
        if (value == null) {
          targetElement.removeAttribute(name);
        } else {
          targetElement.setAttribute(name, value);
        }
      }
    }
    for (i = 0; i < delta.onlyInB.length; i++) {
      targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
    }
  }
  /**
   * Adds CSS classes to the element and to the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static addCls(cls, targetElement) {
    const { lastDomConfig } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.add(cls2);
      addAndCacheCls(cls2, lastDomConfig);
    });
  }
  /**
   * Adds CSS classes from the element and from the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static removeCls(cls, targetElement) {
    const { lastDomConfig } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.remove(cls2);
      removeAndUncacheCls(cls2, lastDomConfig);
    });
  }
  static syncClassList(domConfig, targetElement, lastDomConfig) {
    let cls = domConfig.className || domConfig.class, changed = false, c, currentClasses, i, k, keep, last;
    if (lastDomConfig) {
      currentClasses = DomClassList.normalize(targetElement, "array");
      cls = DomClassList.normalize(cls, "object");
      last = DomClassList.normalize(lastDomConfig.className || lastDomConfig.class, "object");
      keep = [];
      for (i = 0, k = currentClasses.length; i < k; ++i) {
        c = currentClasses[i];
        if (cls[c] || !(c in last)) {
          last[c] = 1;
          keep.push(c);
        } else {
          changed = true;
        }
      }
      for (c in cls) {
        if (!last[c]) {
          keep.push(c);
          changed = true;
        }
      }
      if (!changed) {
        return;
      }
      cls = keep.join(" ");
    } else {
      cls = DomClassList.normalize(cls);
    }
    targetElement.setAttribute("class", cls);
  }
  // Attributes as map { attr : value, ... }
  static getSyncAttributes(domConfig) {
    const attributes = {}, names = [];
    if (domConfig) {
      Object.keys(domConfig).forEach((attr) => {
        if (!syncIgnoreAttributes[attr]) {
          const name = attr.toLowerCase();
          attributes[name] = domConfig[attr];
          names.push(name);
        }
      });
    }
    return { attributes, names };
  }
  static syncAttributes(domConfig, targetElement, options) {
    const { lastDomConfig } = targetElement, sameConfig = domConfig === lastDomConfig, sourceSyncAttrs = _DomSync.getSyncAttributes(domConfig), {
      attributes: sourceAttributes,
      names: sourceNames
    } = sourceSyncAttrs, {
      attributes: targetAttributes,
      names: targetNames
    } = sameConfig ? sourceSyncAttrs : _DomSync.getSyncAttributes(lastDomConfig), {
      onlyInA: toAdd,
      onlyInB: toRemove,
      inBoth: toSync
    } = sameConfig ? {
      onlyInA: emptyArray6,
      onlyInB: emptyArray6,
      inBoth: sourceNames
    } : ArrayHelper.delta(sourceNames, targetNames);
    let attr, i, handledClass = false;
    for (i = 0; i < toAdd.length; i++) {
      attr = toAdd[i];
      const sourceAttr = sourceAttributes[attr];
      if (attr === "style" && sourceAttr != null) {
        DomHelper.applyStyle(targetElement, sourceAttr, true);
      } else if (attr === "dataset") {
        _DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        _DomSync.syncClassList(domConfig, targetElement);
        handledClass = true;
      } else if (sourceAttr != null) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
    for (i = 0; i < toSync.length; i++) {
      attr = toSync[i];
      const sourceAttr = sourceAttributes[attr], targetAttr = targetAttributes[attr];
      if (sourceAttr == null) {
        targetElement.removeAttribute(attr);
      } else if (attr === "style") {
        if (options.strict) {
          if (sameConfig) {
            _DomSync.syncStyles(targetElement, sourceAttr);
          } else if (!isEqual(sourceAttr, targetAttr, true)) {
            _DomSync.syncStyles(targetElement, sourceAttr, targetAttr);
          }
        } else if (sameConfig || !isEqual(sourceAttr, targetAttr, true)) {
          DomHelper.applyStyle(targetElement, sourceAttr, true);
        }
      } else if (attr === "dataset") {
        _DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        _DomSync.syncClassList(domConfig, targetElement, options.strict && targetElement.lastDomConfig);
        handledClass = true;
      } else if (sameConfig || sourceAttr !== targetAttr) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
    for (i = 0; i < toRemove.length; i++) {
      attr = toRemove[i];
      if (!isClass[attr] || !handledClass) {
        targetElement.removeAttribute(attr);
      }
    }
  }
  static syncStyles(targetElement, sourceAttr, targetAttr) {
    let styles, key, value;
    if (!targetAttr) {
      styles = sourceAttr;
    } else {
      styles = {};
      sourceAttr = DomHelper.parseStyle(sourceAttr);
      targetAttr = DomHelper.parseStyle(targetAttr);
      if (sourceAttr) {
        for (key in sourceAttr) {
          value = sourceAttr[key];
          if (targetAttr[key] !== value) {
            styles[key] = value;
          }
        }
      }
      for (key in targetAttr) {
        if (!(key in sourceAttr)) {
          styles[key] = "";
        }
      }
    }
    DomHelper.applyStyle(targetElement, styles);
  }
  //endregion
  //region Content
  static syncContent(domConfig, targetElement) {
    var _a4;
    const { html, text } = domConfig, content = text != null ? text : html;
    targetElement.didSetTextContent = false;
    if (domConfig.elementData) {
      targetElement.elementData = domConfig.elementData;
    }
    if (content instanceof DocumentFragment) {
      if (targetElement.childNodes.length === 1 && DomHelper.getChildElementCount(targetElement) === 0 && content.childNodes.length === 1 && DomHelper.getChildElementCount(content) === 0) {
        DomHelper.setInnerText(targetElement, content.firstChild.data);
      } else {
        targetElement.innerHTML = "";
        targetElement.appendChild(content);
      }
    } else if (html != null && htmlRe2.test(html)) {
      targetElement.innerHTML = String(html);
    } else if (content != null) {
      const { lastDomConfig } = targetElement;
      if (((_a4 = lastDomConfig == null ? void 0 : lastDomConfig.children) == null ? void 0 : _a4.length) || (lastDomConfig == null ? void 0 : lastDomConfig.html) && htmlRe2.test(targetElement.lastDomConfig.html)) {
        targetElement.innerHTML = "";
      }
      DomHelper.setInnerText(targetElement, String(content));
      targetElement.didSetTextContent = true;
    }
  }
  static insertTextNode(text, targetElement, callback, refOwner, beforeElement = null) {
    const newNode = document.createTextNode(text);
    targetElement.insertBefore(newNode, beforeElement);
    if (refOwner) {
      newNode.$refOwnerId = refOwner.id;
    }
    callback == null ? void 0 : callback({
      action: "newNode",
      domConfig: text,
      targetElement: newNode
    });
  }
  static insertElement(domConfig, targetElement, targetNode, refOwner, syncIdMap, syncId, options) {
    var _a4;
    const newElement = options.ns ? document.createElementNS(options.ns, domConfig.tag || "svg") : document.createElement(domConfig.tag || "div");
    targetElement.insertBefore(newElement, targetNode);
    _DomSync.performSync(options, newElement);
    if (syncId != null) {
      syncIdMap[syncId] = newElement;
    }
    if (!domConfig.role && !domConfig.tabIndex && !domConfig["aria-hidden"] && !DomHelper.isFocusable(newElement, true) && !newElement.htmlFor) {
      newElement.setAttribute("role", "presentation");
    }
    if (refOwner) {
      newElement.$refOwnerId = refOwner.id;
      if (syncId) {
        newElement.$reference = syncId;
        refOwner.attachRef(syncId, newElement, domConfig);
      }
    }
    (_a4 = options.callback) == null ? void 0 : _a4.call(options, {
      action: "newElement",
      domConfig,
      targetElement: newElement,
      syncId
    });
  }
  //endregion
  //region Children
  static syncChildren(options, targetElement) {
    var _a4, _b, _c, _d;
    let {
      domConfig,
      syncIdField,
      callback,
      releaseThreshold,
      configEquality,
      ns: ns3,
      refOwner,
      refsWas,
      strict,
      checkEqualityOptions,
      ignoreRefs
    } = options, cleanupNodes = null, index, nextNode, syncId;
    const syncOptions = domConfig.syncOptions || {};
    if ((_a4 = domConfig.html) != null ? _a4 : domConfig.text) {
      return;
    }
    ignoreRefs = Boolean((_b = syncOptions.ignoreRefs) != null ? _b : ignoreRefs);
    if (ignoreRefs) {
      refOwner = refsWas = null;
    }
    if ("strict" in syncOptions) {
      strict = syncOptions.strict;
    }
    const newSyncIdMap = refOwner ? refOwner.byRef : {}, sourceConfigs = arraySlice2.call(domConfig.children || []), targetNodes = arraySlice2.call(targetElement.childNodes), syncIdMap = refsWas || targetElement.syncIdMap || {}, releasedIdMap = targetElement.releasedIdMap || {}, nextTarget = (remove) => {
      while (targetNodes.length && targetNodes[0].parentNode !== targetElement) {
        targetNodes.shift();
      }
      return (remove ? targetNodes.shift() : targetNodes[0]) || null;
    };
    syncIdField = syncOptions.syncIdField || syncIdField;
    strict = syncOptions.strict || strict;
    callback = syncOptions.callback || callback;
    configEquality = syncOptions.configEquality || configEquality;
    releaseThreshold = "releaseThreshold" in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;
    if (syncIdField) {
      targetElement.syncIdMap = newSyncIdMap;
    }
    const syncChildOptions = {
      checkEqualityOptions: checkEqualityOptions || makeCheckEqualityOptions(),
      ignoreRefs,
      refOwner,
      refsWas,
      strict,
      syncIdField,
      releaseThreshold,
      callback,
      configEquality
    };
    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();
      syncId = null;
      if (!sourceConfig) {
        continue;
      }
      if (DomHelper.isReactElement(sourceConfig)) {
        callback({ jsx: sourceConfig, targetElement, domConfig });
        continue;
      }
      if (Array.isArray(sourceConfig)) {
        this.syncChildren({
          ...options,
          domConfig: {
            ...options.domConfig,
            children: sourceConfig
          }
        }, targetElement);
        continue;
      }
      if (sourceConfig instanceof Node) {
        nextNode = nextTarget();
        if (sourceConfig !== nextNode) {
          targetElement.insertBefore(sourceConfig, nextNode);
        }
        index = targetNodes.indexOf(sourceConfig);
        if (index > -1) {
          targetNodes.splice(index, 1);
        }
        continue;
      }
      const isTextNode = typeof sourceConfig === "string";
      syncChildOptions.domConfig = sourceConfig;
      syncChildOptions.ns = sourceConfig.ns || ns3;
      if (!isTextNode) {
        if (refOwner) {
          syncId = sourceConfig.reference;
        } else if (syncIdField && sourceConfig.dataset) {
          syncId = sourceConfig.dataset[syncIdField];
        }
        if (syncId != null && !sourceConfig.unmatched) {
          const syncTargetElement = syncIdMap[syncId] || releasedIdMap[syncId];
          if (syncTargetElement) {
            const { lastDomConfig } = syncTargetElement;
            if (syncTargetElement.retainElement) {
            } else if (_DomSync.performSync(syncChildOptions, syncTargetElement)) {
              callback == null ? void 0 : callback({
                action: "reuseOwnElement",
                domConfig: sourceConfig,
                targetElement: syncTargetElement,
                lastDomConfig,
                syncId
              });
            }
            if (sourceConfig.retainElement) {
              syncTargetElement.retainElement = true;
            }
            newSyncIdMap[syncId] = syncTargetElement;
            ArrayHelper.remove(targetNodes, syncTargetElement);
            delete releasedIdMap[syncId];
            syncTargetElement.isReleased = false;
            nextNode = nextTarget();
            if (syncTargetElement.parentNode !== targetElement || strict && syncTargetElement.nextSibling !== nextNode) {
              targetElement.insertBefore(syncTargetElement, nextNode);
            }
          } else if (strict) {
            _DomSync.insertElement(
              sourceConfig,
              targetElement,
              nextTarget(),
              refOwner,
              newSyncIdMap,
              syncId,
              syncChildOptions
            );
          } else {
            sourceConfigs.push(sourceConfig);
            sourceConfig.unmatched = true;
          }
          continue;
        }
        if (sourceConfig.unmatched) {
          delete sourceConfig.unmatched;
        }
      }
      let beforeNode = null, targetNode = null, cleanupNode;
      while (!targetNode && (cleanupNode = nextTarget(true))) {
        if (refOwner) {
          if (cleanupNode.$refOwnerId !== refOwner.id) {
            continue;
          }
          if (cleanupNode.$reference) {
            if (!strict) {
              continue;
            }
            beforeNode = cleanupNode;
            break;
          }
          targetNode = cleanupNode;
        } else if (!cleanupNode.retainElement) {
          targetNode = cleanupNode;
        }
        if (!targetNode) {
          (cleanupNodes || (cleanupNodes = [])).push(cleanupNode);
        }
      }
      if (beforeNode || !targetNode) {
        if (isTextNode) {
          _DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, beforeNode);
        } else {
          _DomSync.insertElement(
            sourceConfig,
            targetElement,
            beforeNode,
            refOwner,
            newSyncIdMap,
            syncId,
            syncChildOptions
          );
        }
      } else {
        if (!isTextNode && targetNode.nodeType === Node.ELEMENT_NODE && (sourceConfig.tag || "div").toLowerCase() === targetNode.tagName.toLowerCase()) {
          const { lastDomConfig } = targetNode, result = _DomSync.performSync(syncChildOptions, targetNode);
          if (syncIdField && ((_c = lastDomConfig == null ? void 0 : lastDomConfig.dataset) == null ? void 0 : _c[syncIdField]) != null) {
            const lastSyncId = lastDomConfig.dataset[syncIdField];
            delete releasedIdMap[lastSyncId];
            delete syncIdMap[lastSyncId];
          }
          if (syncId != null) {
            newSyncIdMap[syncId] = targetNode;
          }
          targetNode.isReleased = false;
          result && (callback == null ? void 0 : callback({
            action: "reuseElement",
            domConfig: sourceConfig,
            targetElement: targetNode,
            lastDomConfig,
            syncId
          }));
        } else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
          targetNode.data = sourceConfig;
        } else {
          if (isTextNode) {
            _DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, targetNode);
          } else {
            _DomSync.insertElement(
              sourceConfig,
              targetElement,
              targetNode,
              refOwner,
              newSyncIdMap,
              syncId,
              syncChildOptions
            );
          }
          (_d = targetNode.blur) == null ? void 0 : _d.call(targetNode);
          targetNode.remove();
        }
      }
    }
    if (targetElement.didSetTextContent && targetNodes.length === 1 && targetNodes[0].nodeType === Node.TEXT_NODE) {
      return;
    }
    if (domConfig.retainChildren) {
      return;
    }
    while (nextNode = nextTarget(true)) {
      if (!refOwner || nextNode.$refOwnerId === refOwner.id && !nextNode.$reference) {
        (cleanupNodes || (cleanupNodes = [])).push(nextNode);
      }
    }
    if (cleanupNodes) {
      _DomSync.syncChildrenCleanup(
        targetElement,
        cleanupNodes,
        newSyncIdMap,
        callback,
        refOwner,
        releaseThreshold,
        syncIdField
      );
    }
  }
  static syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField) {
    var _a4;
    let releaseCount = 0, ref;
    for (const targetNode of cleanupNodes) {
      const { lastDomConfig } = targetNode;
      if (targetNode.nodeType === Element.TEXT_NODE) {
        targetNode.remove();
        continue;
      }
      if (!targetNode.retainElement) {
        if (!refOwner && syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {
          if (!targetNode.isReleased) {
            targetNode.className = "b-released";
            targetNode.isReleased = true;
            if (lastDomConfig == null ? void 0 : lastDomConfig.dataset) {
              if (!targetElement.releasedIdMap) {
                targetElement.releasedIdMap = {};
              }
              targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]] = targetNode;
            }
            callback == null ? void 0 : callback({
              action: "releaseElement",
              domConfig: lastDomConfig,
              lastDomConfig,
              targetElement: targetNode
            });
            if (lastDomConfig) {
              lastDomConfig.isReleased = true;
              if (lastDomConfig.className) {
                lastDomConfig.className = "b-released";
              }
              if (lastDomConfig.class) {
                lastDomConfig.class = "b-released";
              }
              if (lastDomConfig.style) {
                lastDomConfig.style = null;
              }
            }
          }
          releaseCount++;
        } else {
          (_a4 = targetNode.blur) == null ? void 0 : _a4.call(targetNode);
          targetNode.remove();
          if (refOwner) {
            ref = targetNode.$reference;
            if (ref) {
              refOwner.detachRef(ref, targetNode, lastDomConfig);
            }
          }
          if (targetElement.releasedIdMap && syncIdField && (lastDomConfig == null ? void 0 : lastDomConfig.dataset)) {
            delete targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]];
          }
          callback == null ? void 0 : callback({
            action: "removeElement",
            domConfig: targetNode.lastDomConfig,
            lastDomConfig: targetNode.lastDomConfig,
            targetElement: targetNode
          });
        }
      } else if (syncIdField) {
        if (lastDomConfig) {
          newSyncIdMap[targetNode.dataset[syncIdField]] = targetNode;
        }
      }
    }
  }
  /**
   * Remove a child element without syncing, for example when dragging an element to some other parent.
   * Removes it both from DOM and the parent elements syncMap
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   */
  static removeChild(parentElement, childElement) {
    if (parentElement.contains(childElement)) {
      const syncIdMap = parentElement.syncIdMap;
      if (syncIdMap) {
        const index = Object.values(syncIdMap).indexOf(childElement);
        if (index > -1) {
          delete syncIdMap[Object.keys(syncIdMap)[index]];
        }
      }
      parentElement.removeChild(childElement);
    }
  }
  /**
   * Adds a child element without syncing, making it properly available for later syncs. Useful for example
   * when dragging and dropping an element from some other parent.
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   * @param {String|Number} syncId
   */
  static addChild(parentElement, childElement, syncId) {
    parentElement.appendChild(childElement);
    if (!parentElement.syncIdMap) {
      parentElement.syncIdMap = {};
    }
    parentElement.syncIdMap[syncId] = childElement;
  }
  /**
   * Get a child element using a dot separated syncIdMap path.
   *
   * ```javascript
   * DomSync.getChild(eventWrap, 'event.percentBar');
   * ```
   *
   * @param {HTMLElement} element "root" element, under which the path starts
   * @param {String} path Dot '.' separated path of syncIdMap entries
   * @returns {HTMLElement} Child element or `null` if path did not match any element
   */
  static getChild(element, path) {
    var _a4;
    const syncIds = String(path).split(".");
    for (const id of syncIds) {
      element = (_a4 = element == null ? void 0 : element.syncIdMap) == null ? void 0 : _a4[id];
      if (!element) {
        return null;
      }
    }
    return element;
  }
  //endregion
};
DomSync._$name = "DomSync";

// ../Core/lib/Core/helper/util/Fullscreen.js
var Fullscreen = class _Fullscreen {
  static init() {
    const fnNames = ["fullscreenEnabled", "requestFullscreen", "exitFullscreen", "fullscreenElement"], prefixFn = (prefix) => fnNames.map((fn) => {
      let result = prefix + StringHelper.capitalize(fn);
      if (prefix === "moz") {
        result = result.replace("screen", "Screen");
        if ("mozCancelFullScreen" in document && fn === "exitFullscreen") {
          result = "mozCancelFullScreen";
        }
      }
      return result;
    });
    this.functions = "fullscreenEnabled" in document && fnNames || "webkitFullscreenEnabled" in document && prefixFn("webkit") || "mozFullScreenEnabled" in document && prefixFn("moz") || "msFullscreenEnabled" in document && prefixFn("ms") || [];
    const eventNames = [
      "fullscreenchange",
      "fullscreenerror"
    ], msEventNames = [
      "MSFullscreenChange",
      "MSFullscreenError"
    ], prefixEvt = (prefix) => eventNames.map((eventName) => prefix + StringHelper.capitalize(eventName));
    this.events = "fullscreenEnabled" in document && eventNames || "webkitFullscreenEnabled" in document && prefixEvt("webkit") || "mozFullscreenEnabled" in document && prefixEvt("moz") || "msFullscreenEnabled" in document && msEventNames || [];
    this.onFullscreenChange(this.onInternalFullscreenChange.bind(this));
  }
  /**
   * True if the fullscreen mode is supported and enabled, false otherwise
   * @property {Boolean}
   */
  static get enabled() {
    return Boolean(this.functions[0] && document[this.functions[0]]);
  }
  /**
   * Request entering the fullscreen mode.
   * @param {HTMLElement} element Element to be displayed fullscreen
   * @returns {Promise} A promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  static async request(element) {
    return this.functions[1] && (element == null ? void 0 : element[this.functions[1]]());
  }
  /**
   * Exit the previously entered fullscreen mode.
   * @returns {Promise} A promise which is resolved once the user agent has finished exiting full-screen mode
   */
  static async exit() {
    return this.functions[2] && document[this.functions[2]]();
  }
  /**
   * True if fullscreen mode is currently active, false otherwise
   * @property {Boolean}
   */
  static get isFullscreen() {
    return !!this.element;
  }
  static get element() {
    return this.functions[3] && document[this.functions[3]];
  }
  /**
   * Installs the passed listener to fullscreenchange event
   * @param {Function} fn The listener to install
   */
  static onFullscreenChange(fn) {
    if (this.events[0]) {
      document.addEventListener(this.events[0], fn);
    }
  }
  /**
   * Uninstalls the passed listener from fullscreenchange event
   * @param {Function} fn
   */
  static unFullscreenChange(fn) {
    if (this.events[0]) {
      document.removeEventListener(this.events[0], fn);
    }
  }
  // Make sure the floatRoot is added to any element going fullscreen
  static onInternalFullscreenChange() {
    const me = globalThis.bryntum, { element: fullscreenElement } = _Fullscreen;
    if (_Fullscreen.isFullscreen && me._floatRoot || !_Fullscreen.isFullscreen && !me._floatRoot) {
      return;
    }
    if (fullscreenElement) {
      if (!fullscreenElement.closest(".b-floatroot")) {
        const rootElement = DomHelper.getRootElement(fullscreenElement), { floatRoot } = rootElement;
        if (floatRoot) {
          me._floatRoot = floatRoot;
          me._oldParent = floatRoot.parentElement;
          fullscreenElement.appendChild(floatRoot);
        }
      }
    } else {
      if (me._floatRoot) {
        me._oldParent.appendChild(me._floatRoot);
      }
      me._oldParent = null;
      me._floatRoot = null;
    }
  }
};
Fullscreen.init();
Fullscreen._$name = "Fullscreen";

// ../Core/lib/Core/helper/ResizeMonitor.js
var resizeFireTimer = null;
var resizedQueue = [];
var isAbsolutelyPositioned = (n) => {
  var _a4;
  return n.nodeType === n.ELEMENT_NODE && ((_a4 = n.ownerDocument.defaultView) == null ? void 0 : _a4.getComputedStyle(n).getPropertyValue("position")) === "absolute";
};
var ResizeMonitor = class _ResizeMonitor {
  /**
   * Adds a resize listener to the passed element which is called when the element
   * is resized by layout.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function. Will be passed the element.
   */
  static addResizeListener(element, handler) {
    const me = this;
    if (element === document || element === globalThis) {
      element = document.body;
    }
    if (element.nodeType === element.DOCUMENT_FRAGMENT_NODE) {
      element = element.host;
    }
    if (!element.classList.contains("b-resize-monitored")) {
      element.classList.add("b-resize-monitored");
      element._bResizemonitor = {
        handlers: []
      };
    }
    if (element === document.body) {
      if (!me.hasWindowResizeListener) {
        globalThis.addEventListener("resize", me.onWindowResize);
        me.hasWindowResizeListener = true;
      }
    } else if (globalThis.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }
      me.resizeObserver.observe(element);
    } else {
      element.classList.add("b-no-resizeobserver");
      const [monitors, expand, shrink] = DomHelper.createElement({
        parent: element,
        className: "b-resize-monitors",
        children: [{
          className: "b-resize-monitor-expand"
        }, {
          className: "b-resize-monitor-shrink"
        }]
      }, { returnAll: true });
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1e6;
      expand.addEventListener("scroll", me.onSizeMonitorScroll, true);
      shrink.addEventListener("scroll", me.onSizeMonitorScroll, true);
      (handler.targetMutationMonitor = new MutationObserver((m) => {
        const addedNodes = [], removedNodes = [];
        for (const mr of m) {
          if (mr.type === "childList") {
            addedNodes.push.apply(addedNodes, mr.addedNodes);
            removedNodes.push.apply(removedNodes, mr.removedNodes);
          }
        }
        const changedNodes = [
          ...addedNodes.filter((r) => !removedNodes.includes(r)),
          ...removedNodes.filter((r) => !addedNodes.includes(r))
        ];
        if (changedNodes.length === 0) {
          return;
        }
        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }
        expand.dispatchEvent(new CustomEvent("scroll", { bubbles: false }));
      })).observe(element, {
        childList: true,
        subtree: true
      });
      handler.monitorElement = monitors;
    }
    element._bResizemonitor.handlers.push(handler);
  }
  /**
   * Removes a resize listener from the passed element.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function to remove.
   */
  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === globalThis) {
        element = document.body;
      }
      const resizeMonitor = element._bResizemonitor;
      let listenerCount = 0;
      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);
        listenerCount = resizeMonitor.handlers.length;
      }
      if (!listenerCount) {
        element.classList.remove("b-resize-monitored");
        if (this.resizeObserver) {
          this.resizeObserver.unobserve(element);
        } else {
          if (handler.monitorElement) {
            handler.monitorElement.remove();
            handler.monitorElement = null;
          }
          if (handler.targetMutationMonitor) {
            handler.targetMutationMonitor.disconnect();
          }
        }
      }
    }
  }
  static onElementResize(entries) {
    for (const resizeObserverEntry of entries) {
      const resizedElement = resizeObserverEntry.target, resizeMonitor = resizedElement._bResizemonitor, newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();
      if (hasLayout(resizedElement)) {
        if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;
          for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }
  static onSizeMonitorScroll(e) {
    var _a4;
    if (e.target.isConnected || ((_a4 = document.body) == null ? void 0 : _a4.contains(e.target))) {
      e.stopImmediatePropagation();
      const monitorNode = e.target.parentNode, resizedElement = monitorNode.parentNode, resizeMonitor = resizedElement._bResizemonitor, newRect = resizedElement.getBoundingClientRect();
      if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;
        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(_ResizeMonitor.fireResizeEvents);
        }
      }
      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1e6;
    }
  }
  static onWindowResize(e) {
    const resizedElement = document.body, resizeMonitor = resizedElement._bResizemonitor, oldRect = resizeMonitor.rectangle;
    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();
    for (const resizeHandler of resizeMonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }
  static fireResizeEvents() {
    for (const resizedEntry of resizedQueue) {
      for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }
    resizeFireTimer = null;
    resizedQueue.length = 0;
  }
  static removeGlobalListeners() {
    globalThis.removeEventListener("resize", this.onWindowResize);
  }
};
ResizeMonitor._$name = "ResizeMonitor";

// ../Core/lib/Core/helper/util/Scroller.js
var scrollLiterals = {
  auto: "auto",
  true: "auto",
  false: "hidden",
  "hidden-scroll": "auto",
  clip: BrowserHelper.supportsOverflowClip ? "clip" : "hidden"
};
var scrollerCls = "b-widget-scroller";
var defaultScrollOptions = {
  block: "nearest"
};
var immediatePromise3 = Promise.resolve();
var scrollPromise = (element) => new Promise((resolve) => EventHelper.on({
  element: element === document.documentElement ? globalThis : element,
  scroll: resolve,
  once: true
}));
var xAxis = {
  x: 1
};
var isScrollable = {
  auto: 1,
  scroll: 1
};
var isScrollableConfig = {
  true: 1,
  auto: 1
};
var allScroll = {
  overflowX: "auto",
  overflowY: "auto"
};
var normalizeEdgeOffset = (edgeOffset) => {
  var _a4, _b, _c, _d;
  let top, bottom, start, end;
  if (!edgeOffset) {
    top = bottom = start = end = 0;
  } else if (typeof edgeOffset === "number") {
    top = bottom = start = end = edgeOffset;
  } else {
    top = (_a4 = edgeOffset.top) != null ? _a4 : 0;
    bottom = (_b = edgeOffset.bottom) != null ? _b : 0;
    start = (_c = edgeOffset.start) != null ? _c : 0;
    end = (_d = edgeOffset.end) != null ? _d : 0;
  }
  return { top, bottom, start, end };
};
var Scroller = class _Scroller extends Delayable_default(Events_default(Base)) {
  static get configurable() {
    return {
      /**
       * The widget which is to scroll.
       * @config {Core.widget.Widget}
       */
      widget: null,
      /**
       * The element which is to scroll. Defaults to the {@link Core.widget.Widget#property-overflowElement} of
       * the configured {@link #config-widget}
       * @config {HTMLElement}
       */
      element: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * The element, or a selector which identifies a descendant element whose size
       * will affect the scroll range.
       * @config {HTMLElement|String}
       */
      contentElement: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * How to handle overflowing in the `X` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar,
       * for example a grid header. Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowX: null,
      /**
       * How to handle overflowing in the `Y` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar.
       * Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowY: null,
      /**
       * If configured as `true`, the {@link #config-element} is not scrolled but is translated using CSS
       * transform when controlled by this class's API. Scroll events are fired when the element is translated.
       * @default
       * @config {Boolean}
       */
      translate: null,
      x: 0,
      y: 0,
      rtlSource: null,
      /**
       * Configure as `true` to immediately sync partner scrollers when being synced by a controlling partner
       * instead of waiting for our own `scroll` event to pass the scroll on to partners.
       * @prp {Boolean}
       * @default false
       */
      propagateSync: null
    };
  }
  static get delayable() {
    return {
      onScrollEnd: {
        type: "buffer",
        delay: 100
      }
    };
  }
  /**
   * Fired when scrolling happens on this Scroller's element. The event object is a native `scroll` event
   * with the described extra properties injected.
   * @event scroll
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * Fired when scrolling finished on this Scroller's element. The event object is the last native `scroll` event
   * fires by the element with the described extra properties injected.
   * @event scrollend
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * The `overflow-x` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowX
   */
  /**
   * The `overflow-y` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowY
   */
  get isRTL() {
    var _a4;
    return Boolean((_a4 = this.rtlSource) == null ? void 0 : _a4.rtl);
  }
  syncOverflowState() {
    const me = this, { element } = me, {
      hasOverflowX,
      hasOverflowY
    } = me, x = me.hasOverflowX = element.scrollWidth > element.clientWidth, y = me.hasOverflowY = element.scrollHeight > element.clientHeight;
    if (hasOverflowX !== x || hasOverflowY !== y) {
      const classList = new DomClassList(element.classList, {
        "b-horizontal-overflow": x,
        "b-vertical-overflow": y
      });
      DomHelper.syncClassList(element, classList);
      if (!me.isConfiguring) {
        me.trigger("overflowChange", { x, y });
      }
    }
  }
  /**
   * Returns `true` if there is overflow in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis is showing a space-consuming scrollbar, see {@link #function-hasScrollbar}.
   * @internal
   */
  hasOverflow(axis = "y") {
    const me = this, overflowSetting = me[`overflow${axis.toUpperCase()}`], otherAxis = me[`overflow${axis === "y" ? "x" : "y"}`];
    if (!DomHelper.scrollBarWidth || !isScrollableConfig[overflowSetting] || otherAxis === "hidden-scroll") {
      const dimension = axis === "y" ? "Height" : "Width";
      return me[`scroll${dimension}`] > me[`client${dimension}`];
    }
    return me[`hasOverflow${axis.toUpperCase()}`];
  }
  /**
   * Returns `true` if there is a *space-consuming* scrollbar controlling scroll in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis *has any* overflow, see {@link #function-hasOverflow}.
   * @internal
   */
  hasScrollbar(axis = "y") {
    const { element } = this;
    if (element && DomHelper.scrollBarWidth) {
      const vertical = axis === "y", dimension = vertical ? "Width" : "Height", clientSize = element[`client${dimension}`], borderSize = parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Left" : "Top"}Width`)) + parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Right" : "Bottom"}Width`)), difference = element[`offset${dimension}`] - borderSize - clientSize;
      return Math.abs(difference - DomHelper.scrollBarWidth) < 2;
    }
  }
  /**
   * Partners this Scroller with the passed scroller in order to sync the scrolling position in the passed axes
   * @param {Core.helper.util.Scroller} otherScroller
   * @param {String|Object} [axes='x'] `'x'` or `'y'` or `{x: true/false, y: true/false}` axes to sync
   * @param {Boolean} [axes.x] Sync horizontal scroll
   * @param {Boolean} [axes.y] Sync vertical scroll
   */
  addPartner(otherScroller, axes = xAxis) {
    const me = this;
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (!me.partners) {
      me.partners = {};
    }
    me.partners[otherScroller.id] = {
      scroller: otherScroller,
      axes
    };
    if (axes.x) {
      otherScroller.x = me.x;
    }
    if (axes.y) {
      otherScroller.y = me.y;
    }
    if (!otherScroller.isPartneredWith(me)) {
      otherScroller.addPartner(me, axes);
    }
  }
  eachPartner(fn) {
    const { partners } = this;
    if (partners) {
      Object.values(partners).forEach(fn);
    }
  }
  /**
   * Breaks the link between this Scroller and the passed Scroller set up by the
   * {@link #function-addPartner} method.
   * @param {Core.helper.util.Scroller} otherScroller The Scroller to unlink from.
   */
  removePartner(otherScroller) {
    if (otherScroller && this.isPartneredWith(otherScroller)) {
      delete this.partners[otherScroller.id];
      otherScroller.removePartner(this);
    }
  }
  isPartneredWith(otherScroller) {
    var _a4;
    return Boolean((_a4 = this.partners) == null ? void 0 : _a4[otherScroller.id]);
  }
  /**
   * Breaks the link between this Scroller and all other Scrollers set up by the
   * {@link #function-addPartner} method.
   * @internal
   */
  clearPartners() {
    if (this.partners) {
      Object.values(this.partners).forEach((otherScroller) => otherScroller.scroller.removePartner(this));
    }
  }
  /**
   * Scrolls the passed element or {@link Core.helper.util.Rectangle} into view according to the passed options.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle in document space to scroll
   * into view.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  async scrollIntoView(element, options = defaultScrollOptions) {
    const me = this, { isRectangle } = element, originalRect = isRectangle ? element : Rectangle.from(element), { xDelta, yDelta } = me.getDeltaTo(element, options), result = me.scrollBy(xDelta, yDelta, options);
    if (options.highlight || options.focus) {
      result.then(() => {
        var _a4, _b;
        element = isRectangle ? originalRect.translate(-xDelta, -yDelta) : (_b = (_a4 = options.elementAfterScroll) == null ? void 0 : _a4.call(options)) != null ? _b : element;
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            (me.widget || me).callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, me);
          }
        }
        if (options.focus) {
          element.focus({ preventScroll: true });
        }
      });
    }
    return result;
  }
  /**
   * Scrolls the passed element into view according to the passed options.
   * @param {HTMLElement} element The element in document space to scroll into view.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  static async scrollIntoView(element, options = defaultScrollOptions, rtl = false) {
    const target = Rectangle.from(element), animate = typeof options === "object" ? options.animate : options, globalScroller = _Scroller._globalScroller || (_Scroller._globalScroller = new _Scroller()), deltas = [];
    globalScroller.rtlSource = { rtl };
    let totalX = 0, totalY = 0, result;
    if (options.maxWidth) {
      target.width = Math.min(target.width, options.maxWidth);
      options.maxWidth = null;
    }
    if (options.maxHeight) {
      target.height = Math.min(target.height, options.maxHeight);
      options.maxHeight = null;
    }
    for (let ancestor = element.parentNode; ancestor.nodeType === Node.ELEMENT_NODE; ancestor = ancestor.parentNode) {
      if (ancestor === document.body && ancestor !== document.scrollingElement) {
        continue;
      }
      const style = ancestor === document.scrollingElement ? allScroll : ancestor.ownerDocument.defaultView.getComputedStyle(ancestor), s = DomDataStore.get(ancestor, "scroller");
      if (options.y !== false && ((s == null ? void 0 : s.hasOverflowY) || isScrollable[style.overflowY] && ancestor.scrollHeight > ancestor.clientHeight) || options.x !== false && ((s == null ? void 0 : s.hasOverflowX) || isScrollable[style.overflowX] && ancestor.scrollWidth > ancestor.clientWidth)) {
        let scroller = globalScroller;
        if (s) {
          scroller = s;
        } else {
          globalScroller.element = ancestor;
          globalScroller.positionDirty = true;
        }
        const { xDelta, yDelta } = scroller.getDeltaTo(target, options);
        if (xDelta || yDelta) {
          deltas.push({
            element: ancestor,
            x: ancestor.scrollLeft,
            y: ancestor.scrollTop,
            xDelta,
            yDelta
          });
          target.translate(-xDelta, -yDelta);
          totalX += xDelta;
          totalY += yDelta;
        }
      }
    }
    if (deltas.length) {
      const absX = Math.abs(totalX), absY = Math.abs(totalY);
      let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
      if (duration && (absX > 10 || absY > 10)) {
        if (Math.max(absX, absY) < 50) {
          duration = Math.min(duration, 500);
        }
        result = globalScroller.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
          const isEnd = progress === 1;
          for (const { element: element2, x, y, xDelta, yDelta } of deltas) {
            globalScroller.element = element2;
            if (xDelta) {
              globalScroller.x = Math[rtl ? "min" : "max"](x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
            }
            if (yDelta) {
              globalScroller.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
            }
          }
        }, null, animate.easing);
        result.then(() => {
          globalScroller.scrollAnimation = null;
        });
      } else {
        for (const { element: element2, xDelta, yDelta } of deltas) {
          element2.scrollTop += yDelta;
          element2.scrollLeft += xDelta;
        }
        result = scrollPromise(deltas[deltas.length - 1].element);
      }
    } else {
      result = immediatePromise3;
    }
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            globalScroller.callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, globalScroller);
          }
        }
        if (options.focus) {
          element.focus({ preventScroll: true });
        }
      });
    }
    return result;
  }
  /**
   * Scrolls by the passed deltas according to the passed options.
   * @param {Number} [xDelta=0] How far to scroll in the X axis.
   * @param {Number} [yDelta=0] How far to scroll in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {Boolean} [options.silent] Set to `true` to suspend `scroll` events during scrolling.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {
    const me = this, animate = typeof options === "object" ? options.animate : options, absX = Math.abs(xDelta), absY = Math.abs(yDelta);
    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }
    if (xDelta || yDelta) {
      me.silent = options.silent;
    }
    let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
    if (duration && (absX > 10 || absY > 10)) {
      const { x, y } = me;
      let lastX = x, lastY = y;
      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }
      me.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
        var _a4, _b;
        const isEnd = progress === 1;
        if (xDelta) {
          if (Math.abs(me.x - lastX) > 1 && !options.force) {
            return (_a4 = me.scrollAnimation) == null ? void 0 : _a4.cancel();
          }
          me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
        }
        if (yDelta) {
          if (Math.abs(me.y - lastY) > 1 && !options.force) {
            return (_b = me.scrollAnimation) == null ? void 0 : _b.cancel();
          }
          me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
        }
        lastX = me.x;
        lastY = me.y;
      }, me, animate.easing);
      me.element.classList.add("b-scrolling");
      me.scrollAnimation.then(() => {
        if (!me.isDestroyed) {
          me.element.classList.remove("b-scrolling");
          me.scrollAnimation = null;
        }
      });
      return me.scrollAnimation;
    } else {
      if (xDelta || yDelta) {
        const xBefore = me.x, yBefore = me.y;
        if (Math.round(absX) >= 1) {
          me.x += xDelta;
        }
        if (Math.round(absY) >= 1) {
          me.y += yDelta;
        }
        if (me.x !== xBefore || me.y !== yBefore) {
          return scrollPromise(me.element);
        }
      }
      return immediatePromise3;
    }
  }
  /**
   * Scrolls to the passed position according to the passed options.
   * @param {Number} [toX=0] Where to scroll to in the X axis.
   * @param {Number} [toY=0] Where to scroll to in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  async scrollTo(toX, toY, options) {
    const { x, y } = this, xDelta = toX == null ? 0 : toX - x, yDelta = toY == null ? 0 : toY - y;
    this.scrollingToCenter = options == null ? void 0 : options.scrollingToCenter;
    return this.scrollBy(xDelta, yDelta, options);
  }
  doDestroy() {
    var _a4, _b;
    const me = this;
    if (me._element) {
      me._element.removeEventListener("scroll", me.scrollHandler);
      (_a4 = me.wheelListenerRemover) == null ? void 0 : _a4.call(me);
    }
    (_b = me.scrollAnimation) == null ? void 0 : _b.cancel();
    Object.values(me.partners || {}).forEach(({ scroller }) => scroller.removePartner(me));
    super.doDestroy();
  }
  /**
   * Respond to style changes to monitor scroll *when this Scroller is in `translate: true` mode.*
   * @param {Object[]} mutations The ElementMutation records.
   * @private
   */
  onElMutation(mutations) {
    const me = this, [x, y] = DomHelper.getTranslateXY(me.element);
    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent("scroll", { bubbles: true });
      Object.defineProperty(scrollEvent, "target", {
        get: () => me.element
      });
      me.onScroll(scrollEvent);
    }
  }
  onElResize() {
    const me = this, { widget } = me;
    if (!(widget == null ? void 0 : widget.isAnimating)) {
      me.syncOverflowState();
    } else if (widget.findListener("animationend", "onElResize", me) === -1) {
      widget.ion({
        animationEnd: "onElResize",
        thisObj: me,
        once: true
      });
    }
  }
  onScroll(e) {
    const me = this, { _x, _y, element } = me;
    let vetoed = 0;
    if (me.overflowX === "clip" && element.scrollLeft !== _x) {
      element.scrollLeft = _x;
      ++vetoed;
    }
    if (me.overflowY === "clip" && element.scrollTop !== _y) {
      element.scrollTop = _y;
      ++vetoed;
    }
    if (vetoed === 2) {
      return;
    }
    if (!me.widget || !me.widget.isDestroyed) {
      me.positionDirty = true;
      if (!element.classList.contains("b-scrolling")) {
        element.classList.add("b-scrolling");
      }
      e.widget = me.widget;
      e.scrollingToCenter = me.scrollingToCenter;
      if (!me.silent) {
        me.trigger("scroll", e);
      }
      me.syncPartners();
      me.controllingPartner = null;
      me.onScrollEnd(e);
    }
  }
  /**
   * Syncs all attached scrolling partners with the scroll state of this Scroller.
   * @param {Boolean} force Allow this to sync a partner which is controlling this via a sync.
   * @param {Boolean} [propagate] Propagate any change immediately onwards through
   * further linked partners immediately rather than waiting for our own scroll event.
   * @internal
   */
  syncPartners(force, propagate = this.propagateSync) {
    const me = this;
    if (me.partners) {
      Object.values(me.partners).forEach(({ axes, scroller }) => {
        if (scroller !== me.controllingPartner || force) {
          if (scroller.sync(me, axes) && propagate) {
            scroller.syncPartners(force, propagate);
          }
        }
      });
    }
  }
  onScrollEnd(e) {
    const me = this;
    if (me.silent) {
      me.silent = false;
    }
    me.trigger("scrollEnd", e);
    me.scrollingToCenter = false;
    me.controllingPartner = null;
    me.element.classList.remove("b-scrolling");
  }
  /**
   * Returns the xDelta and yDelta values in an object from the current scroll position to the
   * passed element or Rectangle.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle to calculate deltas for.
   * @param {Object} [options] How to scroll.
   * @param {'start'|'end'|'center'|'nearest'} [options.block] How far to scroll the element.
   * @param {Number} [options.edgeOffset] A margin around the element or rectangle to bring into view.
   * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @param {Number} [options.maxWidth] How much of the target's width to bring into view if the target is wider.
   * @param {Number} [options.maxHeight] How much of the target's height to bring into view if the target is taller.
   * @param {Boolean} [options.constrainToScrollable=true] Pass as `false` to allow offsets beyond the available scroll range.
   * @returns {Object} `{ xDelta, yDelta }`
   * @internal
   */
  getDeltaTo(element, options) {
    const me = this;
    if (!me.viewport) {
      return {
        xDelta: 0,
        yDelta: 0
      };
    }
    const {
      x,
      y,
      scrollWidth,
      scrollHeight,
      isRTL
    } = me, elementRect = element instanceof Rectangle ? element : Rectangle.from(element), block = options.block || "nearest", scrollerRect = me.viewport, edgeOffset = normalizeEdgeOffset(options.edgeOffset);
    if (options.maxWidth) {
      if (elementRect.x < scrollerRect.x) {
        elementRect.x = elementRect.right - options.maxWidth;
        edgeOffset.start = 0;
      } else {
        elementRect.width = Math.min(elementRect.width, options.maxWidth);
        edgeOffset.end = 0;
      }
    }
    if (options.maxHeight) {
      if (elementRect.y < scrollerRect.y) {
        elementRect.y = elementRect.bottom - options.maxHeight;
        edgeOffset.top = 0;
      } else {
        elementRect.height = Math.min(elementRect.height, options.maxHeight);
        edgeOffset.bottom = 0;
      }
    }
    const xOffset = scrollerRect.width >= elementRect.width + (edgeOffset.start + edgeOffset.end) ? edgeOffset : { start: 0, end: 0 }, yOffset = scrollerRect.height >= elementRect.height + (edgeOffset.top + edgeOffset.bottom) ? edgeOffset : { top: 0, bottom: 0 }, constrainTo = new Rectangle(
      isRTL ? scrollerRect.right - -x - scrollWidth : scrollerRect.x - x,
      scrollerRect.y - y,
      scrollWidth,
      scrollHeight
    ), elRect = elementRect.clone().adjust(-xOffset.start, -yOffset.top, xOffset.end, yOffset.bottom).constrainTo(constrainTo), targetRect = elRect.clone(), xFactor = me.isRTL ? -1 : 1;
    let xDelta = 0, yDelta = 0;
    if (block === "start") {
      targetRect.moveTo(scrollerRect.x + (me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "end") {
      targetRect.moveTo(scrollerRect.x + (!me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.bottom - targetRect.height);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "center") {
      const center = scrollerRect.center;
      targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
      xDelta = xDelta || elRect.x - targetRect.x;
      yDelta = yDelta || elRect.y - targetRect.y;
    } else {
      if (targetRect.width > scrollerRect.width) {
        xDelta = targetRect.x - scrollerRect.x;
      } else {
        if (targetRect.right > scrollerRect.right) {
          xDelta = targetRect.right - scrollerRect.right;
        } else if (targetRect.x < scrollerRect.x) {
          xDelta = targetRect.x - scrollerRect.x;
        }
      }
      if (targetRect.height > scrollerRect.height) {
        yDelta = targetRect.y - scrollerRect.y;
      } else {
        if (targetRect.bottom > scrollerRect.bottom) {
          yDelta = targetRect.bottom - scrollerRect.bottom;
        } else if (targetRect.y < scrollerRect.y) {
          yDelta = targetRect.y - scrollerRect.y;
        }
      }
    }
    xDelta = xFactor * Math.round(xDelta);
    yDelta = Math.round(yDelta);
    if (options.constrainToScrollable !== false) {
      xDelta = Math.max(Math.min(xDelta, me.maxX - x), -x);
      yDelta = Math.max(Math.min(yDelta, me.maxY - y), -y);
    }
    return {
      xDelta: options.x === false ? 0 : xDelta,
      yDelta: options.y === false ? 0 : yDelta
    };
  }
  /**
   * A {@link Core/helper/util/Rectangle} describing the bounds of the scrolling viewport.
   * @property {Core.helper.util.Rectangle}
   */
  get viewport() {
    return Rectangle.client(this.element);
  }
  updateWidget(widget) {
    this.rtlSource = this.owner = widget;
  }
  updateElement(element, oldElement) {
    var _a4;
    const me = this;
    if (me === _Scroller._globalScroller) {
      me._element = element;
      me.positionDirty = true;
      return;
    }
    const scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me)), resizeHandler = me.resizeHandler || (me.resizeHandler = me.onElResize.bind(me));
    if (oldElement) {
      DomDataStore.remove(oldElement, "scroller");
      if (me.translate) {
        (_a4 = me.mutationObserver) == null ? void 0 : _a4.disconnect();
      } else {
        oldElement.removeEventListener("scroll", scrollHandler);
        oldElement.classList.remove(scrollerCls);
        oldElement.style.overflowX = oldElement.style.overflowY = "";
      }
      ResizeMonitor.removeResizeListener(oldElement, resizeHandler);
    }
    if (element) {
      DomDataStore.set(element, "scroller", me);
      if (me.translate) {
        if (!me.mutationObserver) {
          me.mutationObserver = new MutationObserver(me.mutationHandler || (me.mutationHandler = me.onElMutation.bind(me)));
        }
        me._x = me._y = 0;
        if (document.contains(element)) {
          const [x, y] = DomHelper.getTranslateXY(element);
          me._x = -x;
          me._y = -y;
        }
        me.mutationObserver.observe(element, { attributes: true });
      } else {
        element.addEventListener("scroll", scrollHandler);
        element.classList.add(scrollerCls);
      }
      ResizeMonitor.addResizeListener(element, resizeHandler);
      if (!me.widget) {
        me.rtlSource = {
          get rtl() {
            return DomHelper.getStyleValue(element, "direction") === "rtl";
          }
        };
      }
      if (me.isRTL) {
        element.classList.add("b-rtl");
      }
      if (me.positionDirty) {
        me.updateOverflowX(me.overflowX);
        me.updateOverflowY(me.overflowY);
      }
      me.syncOverflowState();
      if (me.isConfiguring) {
        me._x && me.updateX(me._x);
        me._y && me.updateY(me._y);
      }
    }
    me.positionDirty = true;
  }
  /**
   * The horizontal scroll position of the widget.
   *
   * Note that this is always +ve. Horizontal scrolling using the `X` property akways proceeds
   * in the +ve direction.
   *
   * @property {Number}
   */
  get x() {
    const me = this, { element } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = Math.abs(element.scrollLeft);
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._x;
  }
  /**
   * The natural DOM horizontal scroll position of the widget.
   *
   * Note that this proceeds from 0 into negative space in RTL mode.
   *
   * @property {Number}
   */
  get scrollLeft() {
    return this.x * (this.isRTL ? -1 : 1);
  }
  changeX(x) {
    x = Math.max(x, 0);
    if (!this.isConfiguring || x) {
      return x;
    }
    this._x = x;
  }
  updateContentElement(contentElement) {
    if (contentElement) {
      contentElement = typeof contentElement === "string" ? this.element.querySelector(contentElement) : contentElement;
      ResizeMonitor.addResizeListener(contentElement, this.resizeHandler);
    }
  }
  updateX(x) {
    var _a4;
    const me = this, { element } = me;
    if (element && !((_a4 = me.widget) == null ? void 0 : _a4.isConfiguring)) {
      x = Math.round(x);
      me.trigger("scrollStart", { x });
      if (me.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = me.isRTL ? -x : x;
      }
    }
    me.positionDirty = true;
  }
  /**
   * Syncs this Scroller with the passed Scroller in the passed axes.
   * @param {Core.helper.util.Scroller} controllingPartner The Scroller which is dictating our new scroll position.
   * @param {Object} axes `{x : <boolean>, y : <boolean> }` which axes to sync.
   * @param {Boolean} axes.x Sync horizontal scroll.
   * @param {Boolean} axes.y Sync vertical scroll.
   * @returns {Boolean} `true` if this Scroller needed the passed axes syncing, `false`
   * if no changes were made.
   * @internal
   */
  sync(controllingPartner, axes) {
    const me = this, { x, y } = axes;
    let result = false;
    if (x != null) {
      if (me.x !== controllingPartner.x) {
        me.controllingPartner = controllingPartner;
        me.x = controllingPartner.x;
        result = true;
      }
    }
    if (y != null) {
      if (me.y !== controllingPartner.y) {
        me.controllingPartner = controllingPartner;
        me.y = controllingPartner.y;
        result = true;
      }
    }
    return result;
  }
  /**
   * The vertical scroll position of the widget.
   * @property {Number}
   */
  get y() {
    const me = this, { element } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._y;
  }
  changeY(y) {
    if (!this.isConfiguring || y) {
      return y;
    }
    this._y = y;
  }
  updateY(y) {
    const { element, widget } = this;
    if (element && !(widget == null ? void 0 : widget.isConfiguring)) {
      this.trigger("scrollStart", { y });
      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }
    }
    this.positionDirty = true;
  }
  /**
   * The maximum `X` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }
  /**
   * The maximum `Y` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }
  /**
   * The furthest possible `scrollLeft` position of the widget. Will be -ve
   * if in writing direction is RTL.
   * @property {Number}
   * @readonly
   */
  get lastScrollLeft() {
    return (this.scrollWidth - this.clientWidth) * (this.isRTL ? -1 : 1);
  }
  updateOverflowX(overflowX, oldOverflowX) {
    const me = this, { element, translate } = me, { style, classList } = element;
    if (oldOverflowX === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowX === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowY];
      if (otherAxisScrollable) {
        overflowX = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowX = scrollLiterals[overflowX] || overflowX;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  updateOverflowY(overflowY, oldOverflowY) {
    const me = this, { element, translate } = me, { style, classList } = element;
    if (oldOverflowY === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowY === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowX];
      if (otherAxisScrollable) {
        overflowY = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowY = scrollLiterals[overflowY] || overflowY;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  enableWheel() {
    if (!this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: "onWheel",
        thisObj: this
      });
    }
  }
  onWheel(e) {
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && this.overflowX === "hidden-scroll") {
      this.x += e.deltaX;
    } else if (this.overflowY === "hidden-scroll") {
      this.y += e.deltaY;
    }
  }
  /**
   * The horizontal scroll range of the widget.
   * @property {Number}
   * @readonly
   */
  get scrollWidth() {
    var _a4, _b;
    return (_b = (_a4 = this.element) == null ? void 0 : _a4.scrollWidth) != null ? _b : 0;
  }
  set scrollWidth(scrollWidth) {
    const me = this, { element, isRTL } = me;
    let stretcher = me.widthStretcher;
    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      scrollWidth = Math.abs(scrollWidth);
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: "b-scroller-stretcher b-horizontal-stretcher",
          // Should survive its surroundings being DomSynced
          retainElement: true
        });
      }
      stretcher.style.transform = `translateX(${(scrollWidth - 1) * (isRTL ? -1 : 1)}px)`;
      if (element && !element.contains(stretcher)) {
        element.insertBefore(stretcher, element.firstElementChild);
      }
    }
    if (me.propagate !== false) {
      me.eachPartner(({ scroller }) => {
        scroller.propagate = false;
        scroller.scrollWidth = scrollWidth;
        delete scroller.propagate;
      });
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get scrollHeight() {
    var _a4, _b;
    return (_b = (_a4 = this.element) == null ? void 0 : _a4.scrollHeight) != null ? _b : 0;
  }
  /**
   * The vertical scroll range of the widget. May be set to larger than the actual data
   * height to enable virtual scrolling. This is how the grid extends its scroll range
   * while only rendering a small subset of the dataset.
   * @property {Number}
   */
  set scrollHeight(scrollHeight) {
    const me = this, stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
      className: "b-scroller-stretcher"
    }));
    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  /**
   * The client width of the widget.
   * @property {Number}
   * @readonly
   */
  get clientWidth() {
    var _a4;
    return ((_a4 = this.element) == null ? void 0 : _a4.clientWidth) || 0;
  }
  /**
   * The client height of the widget.
   * @property {Number}
   * @readonly
   */
  get clientHeight() {
    var _a4;
    return ((_a4 = this.element) == null ? void 0 : _a4.clientHeight) || 0;
  }
  /**
   * The unique ID of this Scroller
   * @property {String}
   * @readonly
   */
  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId("scroller-");
      }
    }
    return this._id;
  }
  //region Extract configs
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs();
    delete configs.widget;
    delete configs.element;
  }
  //endregion
};
Scroller._$name = "Scroller";

// ../Core/lib/Core/helper/util/Promissory.js
var Promissory = class {
  constructor(fn) {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    if (fn) {
      fn(this);
    }
  }
};
Promissory._$name = "Promissory";

// ../Core/lib/Core/widget/Renderable.js
var { defineProperty: defineProperty6 } = Reflect;
var Renderable = class _Renderable extends Base.mixin(Localizable_default, Events_default, Delayable_default, Identifiable_default) {
  static get configurable() {
    return {
      /**
       * The top-level DOM element for this object. This element is produced from the {@link #function-renderDom}
       * method of the derived class. As configs used by `renderDom` change, a synchronization of the DOM is
       * scheduled by calling {@link #function-refreshDom}. This call is made automatically by this class, making
       * it rarely necessary to call `refreshDom` directly.
       * @config {HTMLElement}
       * @category DOM
       */
      element: null
    };
  }
  static get delayable() {
    return {
      refreshDom: "raf"
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns the Set of configs defined as `render: true`, that is, the configs that determine the rendering (via
   * `renderDom`). If no such configs are defined, this method returns `null`.
   *
   * @returns {Set}
   * @private
   */
  static get renderConfigs() {
    const me = this, meta = me.$meta;
    let renderConfigs = meta.renderConfigs, configs, name;
    if (renderConfigs === void 0) {
      renderConfigs = null;
      configs = meta.configs;
      for (name in configs) {
        if (configs[name].render) {
          (renderConfigs || (renderConfigs = /* @__PURE__ */ new Set())).add(name);
        }
      }
      meta.renderConfigs = me.prototype.$renderConfigs = renderConfigs;
    }
    return renderConfigs;
  }
  //region Init
  construct(...args) {
    this.$iid = ++_Renderable.$idSeed;
    this.byRef = {};
    super.construct(...args);
    if (this.onDraw !== _Renderable.prototype.onDraw) {
      this.initDrawable();
    }
  }
  startConfigure(config) {
    this.element = this.renderContext.renderDom();
    super.startConfigure(config);
  }
  //endregion
  //region Configs
  get element() {
    this.refreshDom.flush();
    return this._element;
  }
  /**
   * This is called when the `element` config is assigned (via the setter).
   * @param {HTMLElement} element The new element being assigned.
   * @param {HTMLElement|null} oldElement The old element (previously assigned) or `null`.
   * @returns {HTMLElement}
   * @private
   */
  changeElement(element, oldElement) {
    const me = this;
    if (oldElement) {
      oldElement.remove();
    }
    if (element) {
      element.id = me.id;
      element = DomHelper.createElement(element, {
        refOwner: me
      });
    }
    return element;
  }
  updateId(id, oldId) {
    const me = this;
    if (oldId) {
      const element = me.element;
      element.id = id;
      me.fixRefOwnerId(element, id, oldId);
    }
  }
  //endregion
  //region Misc
  /**
   * Returns the `classList` of this instance's `element`.
   * @property {DOMTokenList}
   */
  get classes() {
    return this.element.classList;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {HTMLElement} el The element to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      const ref = el.$reference;
      if (ref) {
        el.id = `${id}-${ref}`;
      }
      for (const c of el.childNodes) {
        this.fixRefOwnerId(c, id, oldId);
      }
    }
  }
  onConfigChange({ name }) {
    if (!this.isConfiguring && this.$renderConfigs.has(name)) {
      this.refreshDom();
    }
  }
  //endregion
  //region Rendering
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name, { listeners } = domConfig;
    if (!(key in me)) {
      defineProperty6(me, name, {
        get() {
          me.refreshDom.flush();
          return me[key];
        },
        set(el2) {
          me[key] = el2;
        }
      });
    }
    el.id = `${me.id}-${name}`;
    me.byRef[name] = el;
    me[name] = el;
    if (listeners) {
      domConfig.listeners = {
        on: listeners,
        un: EventHelper.on(Object.assign({
          element: el,
          thisObj: me
        }, listeners))
      };
    }
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  detachRef(name, el, domConfig) {
    if (domConfig.listeners) {
      domConfig.listeners.un();
      domConfig.listeners = null;
    }
    this[name] = null;
    delete this.byRef[name];
  }
  /**
   * This method returns a {@link Core.helper.DomHelper#function-createElement-static} config object that describes
   * the desired elements for this instance.
   *
   * This method is called to produce the initial DOM structure and again as necessary to generate the DOM for the
   * current state. The DOM produced by these subsequent calls is then passed through
   * {@link Core.helper.DomSync#function-sync-static DomSync.sync()} to update the DOM.
   * @returns {Object}
   */
  renderDom() {
    return {};
  }
  /**
   * This property is the object to use when calling the `renderDom` method. It may evaluate to this instance (if
   * the class declares its render configs) or a helper object to track config usage during the `renderDom` call.
   * @property {Object}
   * @private
   */
  get renderContext() {
    const me = this, meta = me.$meta, C = me.constructor;
    let renderConfigs = meta.renderConfigs || C.renderConfigs, context = me;
    if (!renderConfigs) {
      context = Object.create(me);
      renderConfigs = /* @__PURE__ */ new Set();
      for (const name in meta.configs) {
        defineProperty6(context, name, {
          get() {
            renderConfigs.add(name);
            return me[name];
          }
        });
      }
      context.renderDom = () => {
        return me.renderDom.call(context);
      };
      me.$renderConfigs = renderConfigs;
    }
    defineProperty6(me, "renderContext", {
      value: context
    });
    return context;
  }
  /**
   * This method synchronized the DOM produced by {@link #function-renderDom} with what was previously produced and
   * updates the elements accordingly.
   *
   * This method is buffered such that calls to it do not immediately execute. To perform the refresh immediately,
   * do this:
   *```
   *  instance.refreshDom.now();
   *```
   * To flush any potential updates to the DOM (and do nothing if there are none), do this:
   *```
   *  instance.refreshDom.flush();
   *```
   * To determine if there are updates to the DOM pending, do this:
   *```
   *  if (instance.refreshDom.isPending) {
   *      ...
   *  }
   *```
   */
  refreshDom() {
    DomSync.sync({
      targetElement: this.element,
      domConfig: this.renderContext.renderDom(),
      refOwner: this,
      // This limits the sync() to only removing the classes and styles added by previous renderings. This
      // allows dynamically added styles and classes to be preserved:
      strict: true
    });
  }
  //endregion
  onListen(eventName) {
    if (eventName === "draw") {
      this.initDrawable();
    }
  }
  initDrawable() {
    const me = this;
    if (!me.intersector) {
      let el = Object.values(me.byRef).find((el2) => el2.classList.contains("b-drawable"));
      if (!el) {
        el = me.element;
        el.classList.add("b-drawable");
      }
      me.intersector = new IntersectionObserver((entries) => {
        if (!me.isDestroyed) {
          entries.forEach((ent) => {
            if (ent.isIntersecting) {
              me.onDraw({
                count: ++me.drawCounter
              });
            }
          });
        }
      });
      me.intersector.observe(el);
    }
  }
  onDraw(ev) {
    this.trigger("draw", ev);
  }
};
Renderable.$idSeed = 0;
Object.assign(Renderable.prototype, {
  drawCounter: 0,
  hasGeneratedId: false,
  intersector: null
});
Renderable._$name = "Renderable";

// ../Core/lib/Core/widget/Mask.js
var _Mask = class _Mask extends Renderable {
  construct(config) {
    if (config) {
      let el = config.element, cfg;
      if (el) {
        VersionHelper.deprecate("Core", "4.0.0", 'Mask "element" config has been renamed to "target"');
        config = cfg = Object.assign({}, config);
        delete cfg.element;
        cfg.target = el;
      }
      el = config.target;
      if (typeof el === "string") {
        config = cfg = cfg || Object.assign({}, config);
        cfg.target = config.owner[el];
      }
    }
    super.construct(config);
    const me = this, { type } = me;
    if (!me.target) {
      me.target = document.body;
    }
    me.maskName = `mask${typeof type === "string" ? type.trim() : ""}-${_Mask.counter++}`;
    me.show();
  }
  doDestroy() {
    const me = this, { element } = me;
    if (me.type === "trial") {
      return false;
    }
    if (element) {
      me.element = null;
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(element, (child) => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }
      me.target.classList.remove("b-masked");
      me.target[me.maskName] = null;
      ArrayHelper.remove(_Mask.masks, me);
    }
    super.doDestroy();
  }
  get maskElement() {
    return this.element;
  }
  set error(value) {
    this.setConfig(this.errorDefaults);
    this.text = value;
  }
  renderDom() {
    const me = this, { maxProgress } = me;
    return {
      class: {
        "b-mask": 1,
        "b-delayed-show": me.showDelay,
        "b-widget": 1,
        [`b-mask-${me.mode}`]: 1,
        "b-progress": maxProgress,
        "b-prevent-transitions": !me.useTransition
      },
      children: [{
        reference: "maskContent",
        class: "b-mask-content b-drawable",
        children: [
          maxProgress ? {
            reference: "progressElement",
            class: "b-mask-progress-bar",
            style: {
              width: `${Math.max(0, Math.min(100, Math.round(me.progress / maxProgress * 100)))}%`
            }
          } : null,
          {
            reference: "maskText",
            class: "b-mask-text",
            html: (me.icon ? `<i class="b-mask-icon ${me.icon}"></i>` : "") + me.text
          }
        ]
      }]
    };
  }
  //endregion
  //region Static
  static mergeConfigs(...sources) {
    const ret = {};
    for (const src of sources) {
      if (typeof src === "string") {
        ret.text = src;
      } else {
        ObjectHelper.assign(ret, src);
      }
    }
    return ret;
  }
  /**
   * Shows a mask with the specified message.
   *
   * Masks stack, call {@link #function-unmask-static} to remove the topmost mask. Or call {@link #function-close}
   * on the returned mask to close it specifically.
   *
   * @param {String|MaskConfig} text Message
   * @param {HTMLElement} [target] The element to mask
   * @returns {Core.widget.Mask}
   */
  static mask(text, target = document.body) {
    return _Mask.new({ target }, typeof text !== "string" ? { ...text } : { text });
  }
  /**
   * Close the topmost mask for the specified element
   * @param {HTMLElement} element Element to unmask
   * @returns {Promise|null} A promise which is resolved when the mask is gone, or null if element is not masked
   */
  static unmask(element = document.body) {
    const masks = this.getElementMasks(element);
    if (masks.length > 0) {
      return masks[masks.length - 1].close();
    }
    return null;
  }
  /**
   * Close all masks for the specified element
   * @internal
   */
  static unmaskAll(element = document.body) {
    return this.getElementMasks(element).forEach((mask) => mask.close());
  }
  static getElementMasks(element) {
    return this.masks.filter((mask) => mask.target === element);
  }
  //endregion
  //region Config
  updateAutoClose(delay) {
    this.deferredClose.cancel();
    if (delay) {
      this.deferredClose.delay = delay;
      this.deferredClose();
    }
  }
  updateCover() {
    this.syncCover();
  }
  syncCover() {
    var _a4, _b;
    (_b = (_a4 = this.owner) == null ? void 0 : _a4.syncMaskCover) == null ? void 0 : _b.call(_a4, this);
  }
  onOwnerResize() {
    this.syncCover();
  }
  updateOwner(owner) {
    this.detachListeners("cover");
    owner == null ? void 0 : owner.ion({
      name: "cover",
      recompose: "onOwnerResize",
      resize: "onOwnerResize",
      thisObj: this
    });
  }
  updateShowDelay(delay) {
    const { delayedShow } = this;
    delayedShow.delay = delay;
    if (!delay) {
      delayedShow.flush();
    }
  }
  //endregion
  //region Show & hide
  deferredClose() {
    var _a4;
    const { owner } = this;
    this.close().then(() => {
      var _a5;
      (_a5 = owner == null ? void 0 : owner.onMaskAutoClose) == null ? void 0 : _a5.call(owner, this);
    });
    (_a4 = owner == null ? void 0 : owner.onMaskAutoClosing) == null ? void 0 : _a4.call(owner, this);
  }
  delayedShow() {
    this.classes.remove("b-delayed-show");
  }
  /**
   * Show mask
   */
  show() {
    const me = this, { element, target, hiding, maskName } = me;
    if (hiding) {
      hiding.resolve();
      me.hiding = null;
      me.clearTimeout("hide");
    }
    if (me.showDelay) {
      element.classList.add("b-delayed-show");
      me.delayedShow();
    }
    element.classList.add("b-visible");
    element.classList.remove("b-hidden");
    target.classList.add("b-masked");
    if (!target[maskName]) {
      target[maskName] = me;
      target.appendChild(element);
    }
    ArrayHelper.include(_Mask.masks, me);
    me.shown = true;
    me.trigger("show");
    if (me.mode.endsWith("blur")) {
      DomHelper.forEachChild(target, (child) => {
        if (child !== element) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }
  /**
   * Hide mask
   * @returns {Promise} A promise which is resolved when the mask is hidden, or immediately if already hidden
   */
  hide() {
    const me = this, { target, element } = me;
    let { hiding } = me;
    if (!hiding) {
      if (!me.shown) {
        return Promise.resolve();
      }
      me.hiding = hiding = new Promissory();
      me.shown = false;
      element.classList.remove("b-visible");
      element.classList.add("b-hidden");
      target.classList.remove("b-masked");
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(target, (child) => {
          if (child !== element) {
            child.classList.remove(`b-masked-${me.mode}`);
          }
        });
      }
      hiding.promise = hiding.promise.then(() => {
        if (me.hiding === hiding) {
          me.hiding = null;
        }
      });
      me.setTimeout(() => hiding.resolve(), 500, "hide");
    }
    return hiding.promise;
  }
  /**
   * Close mask (removes it)
   * @returns {Promise} A promise which is resolved when the mask is closed
   */
  async close() {
    await this.hide();
    this.destroy();
  }
  //endregion
};
//region Config
__publicField(_Mask, "$name", "Mask");
__publicField(_Mask, "type", "mask");
__publicField(_Mask, "configurable", {
  /**
   * Set this config to trigger an automatic close after the desired delay:
   * ```javascript
   *  mask.autoClose = 2000;
   * ```
   * If the mask has an `owner`, its `onMaskAutoClosing` method is called when the close starts and its
   * `onMaskAutoClose` method is called when the close finishes.
   * @config {Number}
   * @private
   */
  autoClose: null,
  /**
   * The portion of the {@link #config-target} element to be covered by this mask. By default, the mask fully
   * covers the `target`. In some cases, however, it may be desired to only cover the `'body'` (for example,
   * in a grid).
   *
   * This config is set in conjunction with `owner` which implements the method `syncMaskCover`.
   *
   * @config {String}
   * @private
   */
  cover: null,
  /**
   * The icon to show next to the text. Defaults to showing a spinner
   * @config {String}
   * @default
   */
  icon: "b-icon b-icon-spinner",
  errorDefaults: {
    icon: "b-icon b-icon-warning",
    autoClose: 3e3,
    showDelay: 0
  },
  /**
   * The maximum value of the progress indicator
   * @property {Number}
   */
  maxProgress: null,
  /**
   * Mode: bright, bright-blur, dark or dark-blur
   * @config {'bright'|'bright-blur'|'dark'|'dark-blur'}
   * @default
   */
  mode: "dark",
  /**
   * Number expressing the progress
   * @property {Number}
   */
  progress: null,
  // The owner is involved in the following features:
  //
  // - The `autoClose` timer calls `onMaskAutoClose`.
  // - The `cover` config calls `syncMaskCover`.
  // - If the `target` is a string, that string names the property of the `owner` that holds the
  //   `HTMLElement` reference.
  /**
   * The owning widget of this mask. This is required if `target` is a string.
   *
   * @config {Core.widget.Widget}
   */
  owner: {
    $config: "nullify",
    value: null
  },
  /**
   * The element to be masked. If this config is a string, that string is the name of the property of the
   * `owner` that holds the `HTMLElement` that is the actual target of the mask.
   *
   * NOTE: In prior releases, this used to be specified as the `element` config, but that is now, as with
   * `Widget`, the primary element of the mask.
   *
   * @config {String|HTMLElement}
   */
  target: null,
  /**
   * The text (or HTML) to show in mask
   * @prp {String}
   */
  text: null,
  type: null,
  /**
   * The number of milliseconds to delay before making the mask visible. If set, the mask will have an
   * initial `opacity` of 0 but will function in all other ways as a normal mask. Setting this delay can
   * reduce flicker in cases where load operations are typically short (for example, a second or less).
   *
   * @config {Number}
   */
  showDelay: null,
  useTransition: false
});
__publicField(_Mask, "delayable", {
  deferredClose: 0,
  delayedShow: 0,
  syncCover: {
    type: "throttle",
    delay: 100
  }
});
//endregion
//region Init
// Used to give masks unique names
__publicField(_Mask, "counter", 0);
// Tracks open masks
__publicField(_Mask, "masks", []);
var Mask = _Mask;
Mask._$name = "Mask";

// ../Core/lib/Core/widget/mixin/KeyMap.js
var KeyMap_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    get widgetClass() {
    }
    /**
     * Override to attach the keyMap keydown event listener to something else than this.element
     * @private
     */
    get keyMapElement() {
      return this.element;
    }
    /**
     * Override to make keyMap resolve subcomponent actions to something else than this.features.
     * @private
     */
    get keyMapSubComponents() {
      return this.features;
    }
    /**
     * Returns the `keyMap` property name which matches the passed KeyboardEvent if any.
     * @param {KeyboardEvent} keyEvent
     * @param {Object} [keyMap=this.keyMap]
     * @returns {String} the key into the `keyMap` matched by the passed KeyboardEvent
     * @internal
     */
    matchKeyMapEntry(keyEvent, keyMap = this.keyMap) {
      if (keyMap && !keyEvent.handled && keyEvent.key !== void 0) {
        return ObjectHelper.keys(keyMap).find((keyString) => {
          const keys = keyString.split("+"), requireAlt = keys.includes("Alt"), requireShift = keys.includes("Shift"), requireCtrl = keys.includes("Ctrl");
          let actualKey = keys[keys.length - 1].toLowerCase();
          if (actualKey === "space") {
            actualKey = " ";
          }
          return actualKey === keyEvent.key.toLowerCase() && (!keyEvent.altKey && !requireAlt || keyEvent.altKey && requireAlt) && (!keyEvent.ctrlKey && !requireCtrl || keyEvent.ctrlKey && requireCtrl) && (!keyEvent.shiftKey && !requireShift || keyEvent.shiftKey && requireShift);
        });
      }
    }
    /**
     * Called on keyMapElement keyDown
     * @private
     */
    performKeyMapAction(event) {
      var _a5;
      const { keyMap } = this;
      let actionHandled = false;
      if (keyMap && !event.handled && event.key !== void 0) {
        const key = this.matchKeyMapEntry(event);
        if (keyMap[key]) {
          const actions6 = ArrayHelper.asArray(keyMap[key]);
          event.fromKeyMap = true;
          event.widget = this;
          let preventDefault2;
          for (let action of actions6) {
            preventDefault2 = true;
            if (ObjectHelper.isObject(action)) {
              if (!action.handler) {
                continue;
              }
              if (action.preventDefault === false) {
                preventDefault2 = false;
              }
              action = action.handler;
            }
            if (typeof action === "string") {
              const {
                thisObj,
                handler
              } = this.resolveKeyMapAction(action);
              if (((_a5 = thisObj.isActionAvailable) == null ? void 0 : _a5.call(thisObj, { key, action, event, actionName: action.split(".").pop() })) !== false) {
                if (handler.call(thisObj, event) !== false) {
                  actionHandled = true;
                  break;
                }
              }
            } else if (action.call(this, event) !== false) {
              actionHandled = true;
              break;
            }
          }
          delete event.fromKeyMap;
          delete event.widget;
          if (actionHandled) {
            if (preventDefault2) {
              event.preventDefault();
            }
            event.handled = true;
          }
        }
      }
      return actionHandled;
    }
    /**
     * Resolves correct `this` and handler function.
     * If subComponent (action includes a dot) it will resolve in keyMapSubComponents (defaults to this.features).
     *
     * For example, in feature configurable:
     * `keyMap: {
     *     ArrowUp: 'navigateUp'
     * }`
     *
     * Will be translated (by InstancePlugin) to:
     * `keyMap: {
     *     ArrowUp: 'featureName.navigateUp'
     * }
     *
     * And resolved to correct function path here.
     *
     * Override to change action function mapping.
     * @private
     */
    resolveKeyMapAction(action) {
      const { keyMapSubComponents } = this;
      if (action.startsWith("up.") || action.startsWith("this.")) {
        return this.resolveCallback(action);
      }
      if (keyMapSubComponents && action.includes(".")) {
        const [component, actionName] = action.split(".");
        if (component && actionName) {
          return {
            thisObj: keyMapSubComponents[component],
            handler: keyMapSubComponents[component][actionName]
          };
        }
      }
      return {
        thisObj: this,
        handler: this[action]
      };
    }
    updateKeyMap(keyMap) {
      var _a5;
      (_a5 = this.keyMapDetacher) == null ? void 0 : _a5.call(this);
      if (!ObjectHelper.isEmpty(keyMap)) {
        this.keyMapDetacher = EventHelper.on({
          element: this.keyMapElement,
          keydown: "keyMapOnKeyDown",
          thisObj: this
        });
      }
    }
    // Hook on to this to catch keydowns before keymap does
    keyMapOnKeyDown(event) {
      this.performKeyMapAction(event);
    }
    /**
     * This function is used for merging two keyMaps with each other. It can be used for example by a Grid's feature to
     * merge the fetature's keyMap into the Grid's with the use of a subPrefix.
     * @param {Object} target - The existing keyMap.
     * @param {Object} source - The keyMap we want to merge into target.
     * @param {Object} subPrefix - If keyMap actions in source should be prefixed, the prefix should be provided here.
     * As example, the prefix * `rowCopyPaste` will give the action 'rowCopyPaste.action'.
     * @private
     */
    mergeKeyMaps(target, source, subPrefix = null) {
      const mergedKeyMap = {};
      if (target) {
        ObjectHelper.assign(mergedKeyMap, target);
      }
      for (const key in source) {
        if (!source[key]) {
          continue;
        }
        const existingActions = ArrayHelper.asArray(target == null ? void 0 : target[key]), actions6 = [];
        if (existingActions == null ? void 0 : existingActions.length) {
          actions6.push(...existingActions);
        }
        if (!(existingActions == null ? void 0 : existingActions.some((a) => {
          const handler = a.handler ? a.handler : a;
          return typeof handler === "string" && handler.startsWith(subPrefix + ".");
        }))) {
          for (const action of ArrayHelper.asArray(source[key])) {
            if (ObjectHelper.isObject(action) && action.handler) {
              actions6.push(ObjectHelper.assignIf({
                handler: (subPrefix ? subPrefix + "." : "") + action.handler
              }, action));
            } else if (typeof action === "function") {
              actions6.push(action);
            } else {
              actions6.push((subPrefix ? subPrefix + "." : "") + action);
            }
          }
          actions6.sort((a, b) => {
            const weight = (a.weight || 0) - (b.weight || 0);
            if (weight === 0 && (existingActions == null ? void 0 : existingActions.length)) {
              return existingActions.indexOf(a) - existingActions.indexOf(b);
            }
            return weight;
          });
        }
        mergedKeyMap[key] = actions6;
      }
      return mergedKeyMap;
    }
  }, __publicField(_a4, "$name", "KeyMap"), __publicField(_a4, "configurable", {
    keyMap: {
      value: null,
      $config: {
        merge: "objects",
        nullify: true
      }
    }
  }), _a4;
};

// ../Core/lib/Core/widget/mixin/RTL.js
var RTL_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    get widgetClass() {
    }
    // Replace generated is-property, to reduce risk of confusion
    get isRTL() {
      return this.rtl;
    }
    updateRtl(rtl) {
      const { element } = this;
      if (element) {
        element.classList.toggle("b-rtl", rtl === true);
        element.classList.toggle("b-ltr", rtl === false);
      }
    }
    startConfigure(config) {
      var _a5, _b;
      (_a5 = super.startConfigure) == null ? void 0 : _a5.call(this, arguments);
      if (!config.floating && config.rtl == null) {
        const me = this, el = config.rootElement || config.forElement || ((_b = me.parent) == null ? void 0 : _b.contentElement) || (me.floating ? me.floatRoot : me.changeElementRef(me.getRenderContext(config)[0] || config.adopt));
        if (el) {
          config.rtl = el.nodeType === 1 && getComputedStyle(el).getPropertyValue("direction") === "rtl";
        } else {
          const owner = config.owner || config.parent;
          if (owner) {
            config.rtl = owner[owner.isConfiguring ? "peekConfig" : "getConfig"]("rtl");
          } else {
            config.rtl = getComputedStyle(document.body).getPropertyValue("direction") === "rtl";
          }
        }
        if (config.rtl) {
          me.configDone.rtl = false;
        }
      }
    }
    // Render is only called on outer widgets, children read their setting from their owner unless explicitly set
    render(...args) {
      var _a5, _b, _c;
      (_a5 = super.render) == null ? void 0 : _a5.call(this, ...args);
      if (BrowserHelper.isChrome && BrowserHelper.chromeVersion < 87 || BrowserHelper.isFirefox && BrowserHelper.firefoxVersion < 66 || BrowserHelper.isSafari && BrowserHelper.safariVersion < 14.1) {
        this.element.classList.add("b-legacy-inset");
      }
      if (getComputedStyle(this.element).direction === "rtl" || ((_b = this.owner) == null ? void 0 : _b.rtl)) {
        this.rtl = true;
        (_c = this.childItems) == null ? void 0 : _c.forEach((i) => i.rtl = true);
      }
    }
  }, __publicField(_a4, "$name", "RTL"), __publicField(_a4, "configurable", {
    /**
     * If a widget is rendered into an element which has computed style `direction:rtl`, this property will be
     * set to `true`
     *
     * Rendering a widget into an element which, either by a CSS rule, or by its inline `style` has an
     * explicit direction will cause the widget to use that direction regardless of the owning document's
     * direction.
     *
     * In this way, an RTL widget may operate normally inside an LTR page and vice versa.
     *
     * If you are using Bryntum widgets in a different direction to that of the owning document, you
     * must use the following CSS rule to have Popups such as tooltips and event editors use
     * the desired direction instead of the direction of the document:
     *
     * ```CSS
     * .b-float-root {
     *     direction : xxx; // Floatings widgets to differ from the document
     * }
     * ```
     * @member {Boolean} rtl
     * @readonly
     * @private
     */
    /**
     * This may be configured as `true` to make the widget's element use the `direction:rtl` style.
     * @config {Boolean}
     * @default false
     * @private
     */
    rtl: null
  }), _a4;
};

// ../Core/lib/Core/widget/Widget.js
var assignValueDefaults = Object.freeze({
  highlight: false,
  onlyName: false
});
var floatRoots = [];
var highlightExternalChange = "highlightExternalChange";
var isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/;
var renderConfigObserver = Symbol("renderConfigObserver");
var textInputTypes = {
  INPUT: 1,
  TEXTAREA: 1
};
var addElementListeners = (me, element, domConfig, refName) => {
  let listeners = (domConfig == null ? void 0 : domConfig.listeners) || (domConfig == null ? void 0 : domConfig.internalListeners);
  listeners = (listeners == null ? void 0 : listeners.on) || listeners;
  if (listeners) {
    const un = EventHelper.on(ObjectHelper.assign({
      element,
      thisObj: me
    }, listeners));
    if (refName) {
      (me._refListeners || (me._refListeners = /* @__PURE__ */ Object.create(null)))[refName] = un;
    } else {
      domConfig.listeners = {
        on: listeners,
        un
      };
    }
  }
};
var mergeAnim = (value, was) => {
  return value && was && was[ObjectHelper.keys(value)[0]] ? Config.merge(value, was) : value;
};
var widgetTriggerPaint = (w) => {
  w.isVisible && w.triggerPaint();
};
var negationPseudo = /^:not\((.+)\)$/;
var nonFlowedPositions = /absolute|fixed/i;
var isScaled = (w) => w.scale != null;
var { hasOwn: hasOwn5 } = ObjectHelper;
var { defineProperty: defineProperty7 } = Reflect;
var parseDuration = (d) => parseFloat(d) * (d.endsWith("ms") ? 1 : 1e3);
var alignedClass = [
  "b-aligned-above",
  "b-aligned-right",
  "b-aligned-below",
  "b-aligned-left"
];
var returnFalseProp = {
  configurable: true,
  value: false
};
var localizeRE = /(?:L\{([^}.]+)\})/;
var alignSpecRe2 = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var mergeAlign = (oldValue, newValue) => {
  if (alignSpecRe2.test(oldValue)) {
    oldValue = { align: oldValue };
  }
  if (alignSpecRe2.test(newValue)) {
    newValue = { align: newValue };
  }
  return Config.merge(oldValue, newValue);
};
var callbackRe = /^[\w.]+$/;
var alignChangeDims = {
  1: "maxHeight",
  2: "height",
  4: "maxWidth",
  8: "width"
};
var isSingletonWidget = (w) => !w.isRipple && !w.closest((w2) => w2.isMessageDialog || w2.isSharedTooltip);
var getLayoutTarget = (el) => DomHelper.getStyleValue(el, "display") === "contents" ? getLayoutTarget(el.parentNode) : el;
var getEventTarget = (t) => {
  if (t == null ? void 0 : t.target) {
    let { offsetX, offsetY } = t, target = getLayoutTarget(t.target);
    if (DomHelper.getStyleValue(t.target, "display") === "contents") {
      const rect = target.getBoundingClientRect(target);
      offsetX -= rect.x;
      offsetY -= rect.y;
    }
    return {
      target: getLayoutTarget(t.target),
      offsetX,
      offsetY
    };
  }
};
var _Widget = class _Widget extends Base.mixin(Localizable_default, Events_default, Delayable_default, Identifiable_default, Factoryable_default, KeyMap_default, RTL_default) {
  //region Config
  // Used when a config is a class and internally stored as a DomClassList
  // So that subclasses can add class names.
  static mergeCls(newValue, oldValue) {
    if (oldValue && newValue) {
      newValue = new DomClassList(oldValue).assign(typeof newValue === "string" ? new DomClassList(newValue) : newValue);
    } else if (newValue && !newValue.isDomClassList) {
      newValue = new DomClassList(newValue);
    }
    return newValue;
  }
  /**
   * Class name getter.
   * Used when original ES6 class name is minified or mangled during production build.
   * Should be overridden in each class which extends Widget or it descendants.
   *
   * ```javascript
   * class MyNewClass extends Widget {
   *     static get $name() {
   *        return 'MyNewClass';
   *     }
   * }
   * ```
   *
   * @static
   * @member {String} $name
   * @advanced
   */
  static get $name() {
    return "Widget";
  }
  /**
   * Widget name alias which you can use in the `items` of a Container widget.
   *
   * ```javascript
   * class MyWidget extends Widget {
   *     static get type() {
   *        return 'mywidget';
   *     }
   * }
   * ```
   *
   * ```javascript
   * const panel = new Panel({
   *    title : 'Cool widgets',
   *    items : [
   *       { type : 'mywidget', html : 'Lorem ipsum dolor sit amet...' }
   *    ]
   * });
   * ```
   *
   * @static
   * @member {String} type
   */
  static get type() {
    return "widget";
  }
  static get configurable() {
    return {
      /**
       * Get this widget's encapsulating HTMLElement, which is created along with the widget but added to DOM at
       * render time.
       * @member {HTMLElement} element
       * @readonly
       * @category DOM
       */
      /**
       * A {@link Core.helper.DomHelper#function-createElement-static} config object or HTML string from which to
       * create the Widget's element.
       * @private
       * @config {DomConfig|String}
       * @category DOM
       */
      element: true,
      /**
       * Set to `false` to not call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       * @config {Boolean}
       * @default
       */
      callOnFunctions: true,
      /**
       * Get/set widgets id
       * @member {String} id
       * @category DOM
       */
      /**
       * Widget id, if not specified one will be generated. Also used for lookups through Widget.getById
       * @config {String}
       * @category DOM
       */
      id: null,
      /**
       * The HTML to display initially or a function returning the markup (called at widget construction time)
       *
       * This may be specified as the name of a function which can be resolved in the component ownership
       * hierarchy, such as 'up.getHTML' which will be found on an ancestor Widget.
       *
       * @config {String|Function}
       * @param {Core.widget.Widget} widget The calling Widget
       * @returns {String}
       * @category DOM
       */
      html: {
        $config: "lazy",
        value: null
      },
      /**
       * Set HTML content safely, without disturbing sibling elements which may have been
       * added to the {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * added to its classList, to allow targeted styling.
       * @member {String} content
       * @category DOM
       * @advanced
       */
      /**
       * The HTML content that coexists with sibling elements which may have been added to the
       * {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * class added to its classList, to allow targeted styling.
       * @config {String} content
       * @category DOM
       * @advanced
       */
      content: {
        $config: "lazy",
        value: null
      },
      /**
       * Custom CSS classes to add to element.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @prp {String|Object}
       * @category CSS
       */
      cls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Custom CSS class name suffixes to apply to the elements rendered by this widget. This may be specified
       * as a space separated string, an array of strings, or as an object in which property names with truthy
       * values are used as the class names.
       *
       * For example, consider a `Panel` with a `ui` config like so:
       *
       * ```javascript
       *  new Panel({
       *      text : 'OK',
       *      ui   : 'light'
       *  });
       * ```
       * This will apply the CSS class `'b-panel-ui-light'` to the main element of the panel as well as its many
       * child elements. This allows simpler CSS selectors to match the child elements of this particular panel
       * UI:
       *
       * ```css
       *  .b-panel-content.b-panel-ui-light {
       *      background-color : #eee;
       *  }
       * ```
       * Using the {@link #config-cls cls config} would make matching the content element more complex, and in
       * the presence of {@link Core.widget.Panel#config-strips docked items} and nested panels, impossible to
       * target accurately.
       *
       * @config {String|Object}
       * @category CSS
       */
      ui: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Determines how a {@link Core.widget.Panel#config-collapsed} panel will treat this widget if it resides
       * within the panel's header (for example, as one of its {@link Core.widget.Panel#config-strips} or
       * {@link Core.widget.Panel#config-tools}).
       *
       * Valid options are:
       *  - `null` : The widget will be moved to the overlay header when the panel is collapsed (the default).
       *  - `false` : The widget will be unaffected when the panel is collapsed and will remain in the primary
       *    panel header at all times.
       *  - `'hide'` : The widget will be hidden when the panel is collapsed.
       *  - `'overlay'` : The widget will only appear in the collapsed panel's overlay header. See
       *    {@link Core.widget.panel.PanelCollapserOverlay collapsible type='overlay'}.
       *
       * @config {Boolean|'hide'|'overlay'}
       * @internal
       */
      collapsify: null,
      /**
       * Custom CSS classes to add to the {@link #property-contentElement}.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       * @advanced
       */
      contentElementCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Custom CSS classes to add to this widget's `element`. This property is typically used internally to
       * assign default CSS classes while allowing `cls` to alter these defaults. It is not recommended that
       * client code set this config but instead should set `cls`.
       *
       * For example, to remove a class defined by `defaultCls` using `cls`, declare the class name as a key with
       * a falsy value:
       *
       * ```javascript
       *  cls : {
       *      'default-class' : false
       *  }
       * ```
       * @config {String|Object|String[]}
       * @internal
       */
      defaultCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Controls the placement of this widget when it is added to a {@link Core.widget.Panel panel's }
       * {@link Core.widget.Panel#config-strips strips collection}. Typical values for this config are `'top'`,
       * `'bottom'`, `'left'`, or `'right'`, which cause the widget to be placed on that side of the panel's
       * body. Such widgets are called "edge strips".
       *
       * Also accepts direction neutral horizontal values `'start'` and `'end'`.
       *
       * If this config is set to `'header'`, the widget is placed in the panel's header, following the title. If
       * this config is set to `'pre-header'`, the widget is placed before the title. Such widgets are called
       * "header strips".
       *
       * @config {'top'|'bottom'|'left'|'right'|'start'|'end'|'header'|'pre-header'|Object} dock
       * @category Layout
       */
      dock: null,
      /**
       * The events to forward from an overflow twin to its origin widget.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the event names:
       * ```javascript
       *  forwardTwinEvents : {
       *      change : this.syncTwinOnChange,
       *      input  : 1
       *  }
       *  ```
       * NOTE: This config cannot be dynamically changed after the `overflowTwin` has been created (see
       * {@link #function-ensureOverflowTwin}.
       * @config {String|String[]|Object}
       * @internal
       */
      forwardTwinEvents: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      parent: null,
      /**
       * The {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}.
       * @member {Core.widget.Tab} tab
       * @readonly
       * @category Misc
       */
      /**
       * A configuration for the {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}. For example, this config can be used to control the icon of the `tab` for
       * this widget:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          icon : 'b-fa-wrench'
       *      }
       *  }, ... ]
       * ```
       *
       * Another use for this config is to set the tab's {@link Core.widget.mixin.Rotatable#config-rotate} value
       * differently than the default managed by the `TabPanel`:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          rotate : false   // don't rotate even if tabBar is docked left or right
       *      }
       *  }, ... ]
       * ```
       *
       * Set this to `false` to prevent the creation of a `tab` for this widget. In this case, this widget must
       * be {@link #function-show shown} explicitly. The {@link Core.widget.TabPanel#config-activeTab} for the
       * tab panel will be -1 in this situation.
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      tab  : false,    // no tab for this item
       *
       *      // other configs...
       *  }, ... ]
       * ```
       *
       * @config {Boolean|TabConfig} tab
       * @category Misc
       */
      tab: null,
      /**
       * An object specifying attributes to assign to the root element of this widget
       * @internal
       * @config {Object}
       * @category Misc
       */
      elementAttributes: null,
      /**
       * The CSS class(es) to add when HTML content is being applied to this widget.
       * @config {String|Object}
       * @category CSS
       */
      htmlCls: {
        $config: {
          merge: "classList"
        },
        value: {
          "b-html": 1
        }
      },
      /**
       * Custom style spec to add to element
       * @config {String}
       * @category CSS
       */
      style: null,
      /**
       * Get/set element's disabled state
       * @member {Boolean} disabled
       * @category Misc
       */
      /**
       * Disable or enable the widget. It is similar to {@link #config-readOnly} except a disabled widget
       * cannot be focused, uses a different rendition (usually greyish) and does not allow selecting its value.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      disabled: null,
      /**
       * Get/set element's readOnly state. This is only valid if the widget is an input
       * field, __or contains input fields at any depth__. Updating this property will trigger
       * a {@link #event-readOnly} event.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @member {Boolean} readOnly
       * @category Misc
       */
      /**
       * Whether this widget is read-only.  This is only valid if the widget is an input
       * field, __or contains input fields at any depth__.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      readOnly: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Determines if the widgets read-only state should be controlled by its parent.
       *
       * When set to `true`, setting a parent container to read-only will not affect the widget. When set to
       * `false`, it will affect the widget.
       *
       * @category Misc
       * @config {Boolean}
       * @default false
       */
      ignoreParentReadOnly: null,
      /**
       * Element (or element id) to adopt as this Widget's encapsulating element. The widget's
       * content will be placed inside this element.
       *
       * If this widget has not been configured with an id, it will adopt the id of the element
       * in order to preserve CSS rules which may apply to the id.
       * @config {HTMLElement|String}
       * @default
       * @category DOM
       */
      adopt: null,
      /**
       * Element (or the id of an element) to append this widget's element to. Can be configured, or set once at
       * runtime. To access the element of a rendered widget, see {@link #property-element}.
       * @prp {HTMLElement}
       * @accepts {HTMLElement|String}
       * @category DOM
       */
      appendTo: null,
      /**
       * Element (or element id) to insert this widget before. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertBefore: null,
      /**
       * Element (or element id) to append this widget element to, as a first child. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertFirst: null,
      /**
       * Object to apply to elements dataset (each key will be used as a data-attribute on the element)
       * @config {Object<String,String>}
       * @category DOM
       */
      dataset: null,
      /**
       * Tooltip for the widget, either as a string or as a Tooltip config object.
       *
       * By default, the Widget will use a single, shared instance to display its tooltip as configured,
       * reconfiguring it to the specification before showing it. Therefore, it may not be permanently
       * mutated by doing things such as adding fixed event listeners.
       *
       * To have this Widget *own* its own `Tooltip` instance, add the property `newInstance : true`
       * to the configuration. In this case, the tooltip's {@link #property-owner} will be this Widget.
       *
       * __Note that in the absence of a configured {@link #config-ariaDescription}, the tooltip's value
       * will be used to populate an `aria-describedBy` element within this Widget.__
       *
       * @config {String|TooltipConfig}
       * @category Misc
       */
      tooltip: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * Set to false to not show the tooltip when this widget is {@link #property-disabled}
       * @config {Boolean}
       * @default
       * @category Misc
       */
      showTooltipWhenDisabled: true,
      /**
       * Prevent tooltip from being displayed on touch devices. Useful for example for buttons that display a
       * menu on click etc, since the tooltip would be displayed at the same time.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      preventTooltipOnTouch: null,
      /**
       * When this is configured as `true` a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)
       * is used to monitor this element for size changes caused by either style manipulation, or by CSS
       * layout.
       *
       * Size changes are announced using the {@link #event-resize} event.
       * @config {Boolean}
       * @default false
       * @category Misc
       * @advanced
       */
      monitorResize: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * Set to `true` to apply the default mask to the widget. Alternatively, this can be the mask message or a
       * {@link Core.widget.Mask} config object.
       * @config {Boolean|String|MaskConfig}
       * @category Misc
       */
      masked: {
        $config: "nullify",
        value: null
      },
      /**
       * This config object contains the defaults for the {@link Core.widget.Mask} created for the
       * {@link #config-masked} config. Any properties specified in the `masked` config will override these
       * values.
       * @config {MaskConfig}
       * @category Misc
       */
      maskDefaults: {
        target: "element"
      },
      /**
       * Set to `true` to move the widget out of the document flow and position it
       * absolutely in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      floating: null,
      /**
       * Set to `true` when a widget is rendered into another widget's {@link #property-contentElement}, but must
       * not participate in the standard layout of that widget, and must be positioned relatively to that
       * widget's {@link #property-contentElement}.
       *
       * {@link Core.widget.Editor Editor}s are positioned widgets.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      positioned: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to be able to drag a widget freely on the page. Or set to an object with a ´handleSelector´
       * property which controls when a drag should start.
       *
       * ```javascript
       *
       * draggable : {
       *     handleSelector : ':not(button)'
       * }
       *
       * ```
       *
       * @config {Boolean|Object}
       * @property {String} handleSelector CSS selector used to determine if drag can be started from a
       * mouse-downed element inside the widget
       * @default false
       * @category Float & align
       */
      draggable: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * How to align this element with its target when {@link #function-showBy} is called
       * passing a simple element as an align target.
       *
       * Either a full alignment config object, or for simple cases, the edge alignment string to use.
       *
       * When using a simple string, the format is `'[trblc]n-[trblc]n'` and it specifies our edge and
       * the target edge plus optional offsets from 0 to 100 along the edges to align to. Also supports direction
       * independent edges horizontally, `s` for start and `e` for end (maps to `l` and `r` for LTR, `r` and `l`
       * for RTL).
       *
       * See the {@link #function-showBy} function for more details about using the object form.
       *
       * Once set, this is stored internally in object form.
       * @config {AlignSpec|String}
       * @category Float & align
       */
      align: {
        $config: {
          merge: mergeAlign
        },
        value: "t-b"
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to centre the Widget in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      centered: null,
      /**
       * _Only valid if this Widget is {@link #config-floating} or {@link #config-positioned}._
       * Element, Widget or Rectangle to which this Widget is constrained.
       * @config {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle}
       * @default document.body
       * @category Float & align
       */
      constrainTo: void 0,
      /**
       * _Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}._
       * `true` to show a connector arrow pointing to the align target.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      anchor: null,
      /**
       * The owning Widget of this Widget. If this Widget is directly contained (that is it is one
       * of the {@link Core.widget.Container#property-items} of a Container), this config
       * will be ignored. In this case the owner is __always__ the encapsulating Container.
       *
       * If this Widget is floating, this config should be specified by the developer.
       *
       * Registering with an `owner` creates a lifecycle relationship with that owning Widget. When
       * the `owner` is destroyed this widget will also be destroyed.
       *
       * This also allows focus to be tracked in the ownership tree. If a widget `owns` another
       * widget, then even if that other widget is in a different element, focusing that owned
       * widget will *not* cause a {@link #event-focusOut} event, and the {@link #property-containsFocus}
       * property remains set.
       *
       * A widget can unregister from its `owner` and break this relationship at any time by setting
       * the property to `null`. It is then the developer's responsibility to ensure that this Widget
       * is destroyed.
       * @config {Core.widget.Widget}
       * @category Misc
       */
      owner: {
        $config: "nullify",
        value: null
      },
      /**
       * Defines what to do if document is scrolled while Widget is visible (only relevant when floating is set to true).
       * Valid values: ´null´: do nothing, ´hide´: hide the widget or ´realign´: realign to the target if possible.
       * @config {'hide'|'realign'|null}
       * @default
       * @category Float & align
       */
      scrollAction: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon hide, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 0,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      hideAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon show, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 1,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      showAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * The x position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      x: null,
      /**
       * The y position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      y: null,
      /**
       * Accessor to the {@link Core.helper.util.Scroller} which can be used
       * to both set and read scroll information.
       * @member {Core.helper.util.Scroller} scrollable
       * @category Layout
       */
      /**
       * Specifies whether (and optionally in which axes) a Widget may scroll. `true` means this widget may scroll
       * in both axes. May be an object containing boolean `overflowX` and `overflowY` properties which are
       * applied to CSS style properties `overflowX` and `overflowY`. If they are boolean, they are translated to
       * CSS overflow properties thus:
       *
       * - `true` -> `'auto'`
       * - `false` -> `'hidden'`
       *
       * After initialization, this property yields a {@link Core.helper.util.Scroller} which may be used to both
       * set and read scroll information.
       *
       * A Widget uses its {@link #property-overflowElement} property to select which element is to be scrollable. By default,
       * in the base `Widget` class, this is the Widget's encapsulating element. Subclasses may implement `get
       * overflowElement` to scroll inner elements.
       * @config {Boolean|ScrollerConfig|Core.helper.util.Scroller}
       * @default false
       * @category Scrolling
       */
      scrollable: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * The class to instantiate to use as the {@link #config-scrollable}. Defaults to
       * {@link Core.helper.util.Scroller}.
       * @internal
       * @config {Core.helper.util.Scroller}
       * @typings {typeof Scroller}
       * @category Scrolling
       */
      scrollerClass: Scroller,
      /**
       * The name of the property to set when a single value is to be applied to this Widget. Such as when used
       * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
       * @config {String}
       * @default 'html'
       * @category Misc
       */
      defaultBindProperty: "html",
      /**
       * Event that should be considered the default action of the widget. When that event is triggered the
       * widget is also expected to trigger an `action` event. Purpose is to allow reacting to most widgets in
       * a coherent way.
       * @private
       * @config {String}
       * @category Misc
       */
      defaultAction: null,
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default true
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: true,
        $config: null
      },
      /**
       * Widget's width, used to set element style.width. Either specify a valid width string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control width, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      width: null,
      /**
       * Widget's height, used to set element style.height. Either specify a valid height string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control height, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      height: null,
      /**
       * The element's maxHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxHeight: null,
      /**
       * The elements maxWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxWidth: null,
      /**
       * The elements minWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minWidth: null,
      /**
       * The element's minHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minHeight: null,
      // not public, only used by us in docs
      scaleToFitWidth: null,
      allowGrowWidth: true,
      // only used if scaleToFitWidth is true
      /**
       * Get element's margin property. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @member {Number|String} margin
       * @category Layout
       */
      /**
       * Widget's margin. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @config {Number|String}
       * @category Layout
       */
      margin: null,
      /**
       * Get element's flex property. This may be configured as a single number or a format string:
       *
       *      <flex-grow> <flex-shrink> <flex-basis>
       *
       * Numeric-only values are interpreted as the `flex-grow` value.
       * @member {Number|String} flex
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex">flex</a> style.
       * This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
       * numeric-only values are interpreted as the `flex-grow` value.
       * @config {Number|String}
       * @category Layout
       */
      flex: null,
      /**
       * A widgets weight determines its position among siblings when added to a {@link Core.widget.Container}.
       * Higher weights go further down.
       * @config {Number}
       * @category Layout
       */
      weight: null,
      /**
       * Get/set this widget's `align-self` flexbox setting. This may be set to modify how this widget is aligned
       * within the cross axis of a flexbox layout container.
       * @member {String} alignSelf
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-self">align-self</a> style.
       * @config {String}
       * @category Layout
       */
      alignSelf: null,
      /**
       * Configure as `true` to have the component display a translucent ripple when its
       * {@link #property-focusElement}, or {@link #property-element} is tapped *if the
       * current theme supports ripples*. Out of the box, only the Material theme supports ripples.
       *
       * This may also be a config object containing the properties listed below.
       *
       * eg:
       *```
       *    columns  : [{}...],
       *    ripple   : {
       *        color : 'red',
       *        clip  : '.b-grid-row'
       *    },
       *    ...
       *```
       * @config {Boolean|Object}
       * @property {String} [delegate] A CSS selector to filter which child elements trigger ripples. By default,
       * the ripple is clipped to the triggering element.
       * @property {String} [color='#000'] A CSS color name or specification.
       * @property {Number} [radius=100] The ending radius of the ripple. Note that it will be clipped by the
       * target element by default.
       * @property {String} [clip] A string which describes how to clip the ripple if it is not to be clipped to
       * the default element. Either the property of the widget to use as the clipping element, or a selector to
       * allow clipping to the closest matching ancestor to the target element.
       * @category Misc
       */
      ripple: null,
      /**
       * A title to display for the widget. Only in effect when inside a container that uses it (such as TabPanel)
       * @default
       * @config {String}
       * @category DOM
       */
      title: null,
      localizableProperties: ["title", "ariaLabel", "ariaDescription"],
      // Set this flag to require element to have a size to be considered visible
      requireSize: false,
      /**
       * An identifier by which this widget will be registered in the {@link Core.widget.Container#property-widgetMap}
       * of all ancestor containers.
       *
       * If omitted, this widget will be registered using its {@link #config-id}. In most cases `ref` is
       * preferable over `id` since `id` is required to be globally unique while `ref` is not.
       *
       * The `ref` value is also added to the elements dataset, to allow targeting it using CSS etc.
       * @prp {String}
       * @readonly
       * @category Misc
       */
      ref: null,
      /**
       * Get/set the widget hidden state.
       *
       * Note: `hidden : false` does *not* mean that this widget is definitely visible.
       * To ascertain visibility, use the {@link #property-isVisible} property.
       * @member {Boolean} hidden
       * @category Visibility
       */
      /**
       * Configure with true to make widget initially hidden.
       * @default false
       * @config {Boolean}
       * @category Layout
       */
      hidden: null,
      /**
       * Text alignment: 'left', 'center' or 'right'. Also accepts direction neutral 'start' and 'end'.
       *
       * Applied by adding a `b-text-align-xx` class to the widgets element. Blank by default, which does not add
       * any alignment class.
       *
       * To be compliant with RTL, 'left' yields same result as 'start' and 'right' as 'end'.
       *
       * @config {'left'|'center'|'right'|'start'|'end'}
       * @category Layout
       */
      textAlign: null,
      // When adding our scroll listeners to hide/realign, we ignore events
      // happening too quickly as a result of the show/align action
      ignoreScrollDuration: 500,
      /**
       * The tag name of this Widget's root element
       * @config {String}
       * @default
       * @category DOM
       * @advanced
       */
      tag: "div",
      /**
       * Set this config to `false` to disable batching DOM updates on animation frames for this widget. This
       * has the effect of synchronously updating the DOM when configs affecting the rendered DOM are modified.
       * Depending on the situation, this could simplify code while increasing time spent updating the DOM.
       * @config {Boolean}
       * @default true
       * @internal
       */
      recomposeAsync: null,
      /**
       * If you are rendering this widget to a shadow root inside a web component, set this config to the shadowRoot. If not inside a web component, set it to `document.body`
       * @config {ShadowRoot|HTMLElement}
       * @default
       * @category Misc
       */
      rootElement: null,
      htmlMutationObserver: {
        $config: ["lazy", "nullify"],
        value: {
          childList: true,
          subtree: true
        }
      },
      role: {
        $config: "lazy",
        value: "presentation"
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject as
       * the `aria-label` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaLabel: {
        $config: "lazy",
        value: null
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject
       * into an element which will be linked using the `aria-describedby` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaDescription: {
        $config: "lazy",
        value: null
      },
      /**
       * The `aria-live` value for this widget.
       *
       * See https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions
       * @prp {String}
       */
      ariaLive: {
        $config: "lazy",
        value: null
      },
      ariaElement: "element",
      ariaHasPopup: null,
      realignTimeout: 300,
      testConfig: {
        ignoreScrollDuration: 100,
        realignTimeout: 50
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * When configured as `true`, this widget uses {@link Core.helper.BrowserHelper#property-isMobile-static}
       * to maximize itself on mobile devices.
       * @prp {Number|String}
       * @category Float & align
       */
      maximizeOnMobile: null
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * true if no id was set, will use generated id instead (widget1, ...). Toggle automatically on creation
       * @member {Boolean} hasGeneratedId
       * @private
       * @category Misc
       */
      hasGeneratedId: false,
      /**
       * This readonly property is `true` for normal widgets in the {@link Core.widget.Container#config-items} of
       * a container. It is `false` for special widgets such as a {@link Core.widget.Panel#config-tbar}.
       * @member {Boolean} innerItem
       * @internal
       * @category Misc
       */
      innerItem: true
    };
  }
  static get declarable() {
    return [
      /**
       * This property declares the set of config properties that affect a Widget's rendering, i.e., the configs
       * used by the {@link #function-compose} method.
       *
       * For example:
       * ```javascript
       *  class Button extends Widget {
       *      static renderConfigs = [ 'cls', 'iconCls', 'text' ];
       *  }
       * ```
       *
       * Alternatively this can be an object:
       *
       * ```javascript
       *  class Button extends Widget {
       *      static renderConfigs = {
       *          cls     : true,
       *          iconCls : true,
       *          text    : true
       *      };
       *  }
       * ```
       * @member {Object|String[]} renderConfigs
       * @static
       * @category Configuration
       * @internal
       */
      "renderConfigs"
    ];
  }
  /**
   * An object providing the `record` and `column` for a widget embedded inside a {@link Grid.column.WidgetColumn}
   *
   * ```javascript
   * columns : [
   *    {
   *        type   : 'widget',
   *        widgets: [{
   *            type     : 'button',
   *            icon     : 'b-fa b-fa-trash',
   *            onAction : ({ source : btn }) => btn.cellInfo.record.remove()
   *        }]
   *    }
   * ]
   * ```
   * @readonly
   * @member {CellWidgetContext} cellInfo
   * @category Misc
   */
  static get delayable() {
    return {
      recompose: "raf",
      doHideOrRealign: "raf",
      // Screen size and orientation changes must be buffered in line with.
      // ResponsiveMixin whose responsiveUpdate method is on a RAF.
      onAlignConstraintChange: "raf"
    };
  }
  static get factoryable() {
    return {
      defaultType: "widget"
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns an array containing all existing Widgets. The returned array is generated by this call and is not an
   * internal structure.
   * @property {Core.widget.Widget[]}
   * @readonly
   * @internal
   */
  static get all() {
    return super.all;
  }
  /**
   * Get/set the {@link #config-recomposeAsync} config for all widgets. Setting this value will set the config for
   * all existing widgets and will be the default value for newly created widgets. Set this value to `null` to disable
   * the default setting for new widgets while leaving existing widgets unaffected.
   * @property {Boolean}
   * @internal
   */
  static get recomposeAsync() {
    return _Widget._recomposeAsync;
  }
  static set recomposeAsync(value) {
    _Widget._recomposeAsync = value;
    if (value != null) {
      const { all } = _Widget;
      for (let i = 0; i < all.length; ++i) {
        if (all[i].isComposable) {
          all[i].recomposeAsync = value;
        }
      }
    }
  }
  isType(type, deep) {
    return _Widget.isType(this, type, deep);
  }
  static setupRenderConfigs(cls, meta) {
    const classRenderConfigs = meta.getInherited("renderConfigs"), { renderConfigs } = cls;
    if (renderConfigs) {
      if (Array.isArray(renderConfigs)) {
        for (const name of renderConfigs) {
          classRenderConfigs[name] = true;
        }
      } else {
        ObjectHelper.assign(classRenderConfigs, renderConfigs);
      }
      classRenderConfigs[renderConfigObserver] = null;
    }
  }
  /**
   * Call once per class for custom widgets to have them register with the `Widget` class, allowing them to be created
   * by type.
   *
   * For example:
   * ```javascript
   * class MyWidget extends Widget {
   *   static get type() {
   *     return 'mywidget';
   *   }
   * }
   * MyWidget.initClass();
   * ```
   * @method initClass
   * @static
   * @category Lifecycle
   * @advanced
   */
  //endregion
  //region Init & destroy
  construct(config = {}, ...args) {
    const me = this, { domSyncCallback } = me, { recomposeAsync } = _Widget;
    if (recomposeAsync != null && me.recomposeAsync == null) {
      me.recomposeAsync = recomposeAsync;
    }
    if (!globalThis.bryntum.cssVersion) {
      const cssVersion = globalThis.bryntum.cssVersion = CSSHelper.getCSSVersion(), jsVersion = VersionHelper.getVersion("core");
      if (cssVersion && cssVersion !== jsVersion) {
        console.warn(`CSS version ${cssVersion} doesn't match bundle version ${jsVersion}!
Make sure you have imported css from the appropriate product version.`);
      }
    }
    me.configureAriaDescription = config.ariaDescription;
    me._isAnimatingCounter = 0;
    me.alignmentChanges = 0;
    me.byRef = /* @__PURE__ */ Object.create(null);
    me.onTargetResize = me.onTargetResize.bind(me);
    me.onFullscreenChange = me.onFullscreenChange.bind(me);
    me.domSyncCallback = domSyncCallback.$nullFn ? null : domSyncCallback.bind(me);
    me._isUserAction = false;
    super.construct(config, ...args);
    me.finalizeInit();
  }
  startConfigure(config) {
    super.startConfigure(config);
    this.getConfig("element");
  }
  /**
   * Called by the Base constructor after all configs have been applied.
   * @internal
   * @category Lifecycle
   */
  finalizeInit() {
    var _a4;
    const me = this, { adopt } = me, refElement = me.insertBefore || me.appendTo || me.insertFirst || adopt;
    me.getConfig("html");
    me.getConfig("content");
    if (refElement) {
      if (adopt) {
        me.element.classList.remove("b-hidden");
        me._hidden = false;
      }
      if (me.owner || ((_a4 = refElement.nodeType ? refElement : document.getElementById(refElement)) == null ? void 0 : _a4.isConnected)) {
        me.render();
      } else {
        me.onFirstResizeAfterConnect = me.onFirstResizeAfterConnect.bind(me);
        ResizeMonitor.addResizeListener(refElement, me.onFirstResizeAfterConnect);
      }
    }
  }
  onFirstResizeAfterConnect(el) {
    ResizeMonitor.removeResizeListener(el, this.onFirstResizeAfterConnect);
    if (!this.isDestroyed && !this.rendered) {
      this.render();
    }
  }
  doDestroy() {
    var _a4, _b, _c, _d;
    const me = this, {
      preExistingElements,
      element,
      adopt,
      _refListeners,
      _rootElement,
      eventRoot,
      ownedWidgets
    } = me;
    if (Fullscreen.element === element) {
      Fullscreen.exit();
    }
    if (_refListeners) {
      Object.values(_refListeners, (un) => un());
      me._refListeners = null;
    }
    if (element) {
      const sharedTooltip = !me._tooltip && _rootElement && ((_a4 = _Widget.Tooltip) == null ? void 0 : _a4.getSharedTooltip(_rootElement, eventRoot, true));
      if ((sharedTooltip == null ? void 0 : sharedTooltip.owner) === me) {
        sharedTooltip.owner = null;
        sharedTooltip.hide();
      }
      me.onExitFullscreen();
      me.clearTimeout("scrollListenerTimeout");
      me.clearTimeout("resizeListenerTimeout");
      me.removeTransientListeners();
      if (me.floating || me.positioned) {
        me.hide(false);
      } else {
        me.revertFocus();
      }
      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);
      if (adopt) {
        for (let nodes = Array.from(element.childNodes), i = 0, { length } = nodes; i < length; i++) {
          const el = nodes[i];
          if (!preExistingElements.includes(el) && el !== me.floatRoot) {
            el.remove();
          }
        }
        element.className = me.adoptedElementClassName;
        element.style.cssText = me.adoptedElementCssText;
      }
      (_b = me.dragEventDetacher) == null ? void 0 : _b.call(me);
      (_c = me.dragOverEventDetacher) == null ? void 0 : _c.call(me);
      me.dragGhost.remove();
    }
    (_d = me.connectedObserver) == null ? void 0 : _d.disconnect();
    super.doDestroy();
    ownedWidgets && Object.values(ownedWidgets).forEach((w) => {
      var _a5;
      return (_a5 = w.destroy) == null ? void 0 : _a5.call(w);
    });
    if (eventRoot && !Object.values(_Widget.identifiable.idMap).some(isSingletonWidget)) {
      GlobalEvents_default.detachFocusListeners(eventRoot);
    }
    if (!adopt) {
      element.remove();
    }
  }
  //endregion
  //region Values
  get assignValueDefaults() {
    return assignValueDefaults;
  }
  get valueName() {
    return this.name || this.ref || this.id;
  }
  getValueName(onlyName) {
    onlyName = onlyName && typeof onlyName === "object" ? onlyName.onlyName : onlyName;
    return onlyName ? this.name : this.valueName;
  }
  assignFieldValue(values, key, value) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (valueBindProperty in me) {
      me[valueBindProperty] = value;
    }
  }
  assignValue(values, options = assignValueDefaults) {
    const me = this, hec = me[highlightExternalChange], key = me.getValueName(options);
    if (key && (!values || key in values)) {
      if (options.highlight === false) {
        me[highlightExternalChange] = false;
      }
      me.assignFieldValue(values, key, values ? values[key] : null);
      me[highlightExternalChange] = hec;
    }
  }
  gatherValue(values) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (me.constructor !== _Widget && valueBindProperty in me) {
      values[me.name || me.ref || me.id] = me[valueBindProperty];
    }
  }
  gatherValues(values) {
    this.eachWidget((widget) => widget.gatherValue(values), false);
  }
  //endregion
  get forwardTwinEvents() {
    const value = this._forwardTwinEvents;
    return value && ObjectHelper.getTruthyKeys(value);
  }
  /**
   * This widget's twin that is placed in an overflow menu when this widget has been hidden by its owner, typically
   * a {@link Core.widget.Toolbar} due to {@link Core.widget.Toolbar#config-overflow}. The `overflowTwin` is created
   * lazily by {@link #function-ensureOverflowTwin}.
   *
   * @member {Core.widget.Widget} overflowTwin
   * @readonly
   * @internal
   */
  /**
   * This method returns the config object to use for creating this widget's {@link #property-overflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Object} The `overflowTwin` config object
   * @internal
   */
  configureOverflowTwin(overrides) {
    var _a4;
    const me = this;
    let config = ObjectHelper.clone(me.initialConfig);
    delete config.id;
    config.hidden = false;
    config.type = me.type;
    config._overflowTwinOrigin = me;
    config.disabled = me.disabled;
    if ("value" in me) {
      config.value = me.value;
    }
    (_a4 = me.forwardTwinEvents) == null ? void 0 : _a4.forEach((ev) => {
      delete config[`on${StringHelper.capitalize(ev)}`];
    });
    if (overrides) {
      config = typeof overrides === "function" ? overrides(config) || config : ObjectHelper.assign(config, overrides);
    }
    return config;
  }
  /**
   * This method creates the {@link #property-overflowTwin} for this widget. It is called by
   * {@link #function-ensureOverflowTwin} if the `overflowTwin` does not yet exist.
   *
   * The config for the {@link #property-overflowTwin} is produced by {@link #function-configureOverflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  createOverflowTwin(overrides) {
    var _a4;
    const me = this, config = me.configureOverflowTwin(overrides), overflowTwin = _Widget.create(config);
    (_a4 = me.forwardTwinEvents) == null ? void 0 : _a4.forEach((ev) => {
      overflowTwin.ion({
        [ev]: (info) => {
          if (me.overflowTwin === info.source) {
            info = ObjectHelper.assign({}, info);
            delete info.source;
            me.trigger(info.eventName, info);
          }
        }
      });
    });
    return overflowTwin;
  }
  /**
   * This method returns the existing {@link #property-overflowTwin} or creates it, if it has not yet been created
   * (see {@link #function-createOverflowTwin}).
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @param {Function} [onCreate] A function to call when the `overflowTwin` is initially created.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  ensureOverflowTwin(overrides, onCreate) {
    let { overflowTwin } = this;
    if (!overflowTwin) {
      this.overflowTwin = overflowTwin = this.createOverflowTwin(overrides);
      onCreate == null ? void 0 : onCreate(overflowTwin);
    }
    return overflowTwin;
  }
  //---------------------------------------------------------------------------------------------------------
  //region Render
  /**
   * Returns `true` if this class uses `compose()` to render itself.
   * @returns {Boolean}
   * @internal
   */
  get isComposable() {
    return !this.compose.$nullFn;
  }
  adoptElement(adopt) {
    const me = this, adoptElement = typeof adopt === "string" ? document.getElementById(adopt) : adopt, previousHolder = _Widget.fromElement(adoptElement);
    if (previousHolder && previousHolder.adopt && previousHolder !== me) {
      const previousHolderAdopt = typeof previousHolder.adopt === "string" ? document.getElementById(previousHolder.adopt) : previousHolder.adopt;
      if (previousHolderAdopt === adoptElement) {
        previousHolder.destroy();
      }
    }
    me.preExistingElements = Array.from(adoptElement.childNodes);
    me.adoptedElementClassName = adoptElement.className;
    me.adoptedElementCssText = adoptElement.style.cssText;
    adoptElement.lastDomConfig = null;
    adoptElement.$refOwnerId = me.id;
    adoptElement.className = adoptElement.style.cssText = "";
    return adoptElement;
  }
  /**
   * Defines an element reference accessor on the class prototype. This accessor is used to flush any pending DOM
   * changes prior to accessing such elements.
   * @param {String} name
   * @param {String} key
   * @private
   */
  addRefAccessor(name, key) {
    const { prototype: prototype2 } = this.constructor;
    defineProperty7(prototype2, key, {
      writable: true,
      value: null
    });
    defineProperty7(prototype2, name, {
      get() {
        this.recompose.flush();
        return this[key];
      },
      set(el) {
        this[key] = el;
      }
    });
  }
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} [domConfig] The DOM config object.
   * @internal
   */
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name;
    el.dataset && (el.dataset.ownerCmp = me.id);
    if (me.isComposable) {
      if (!(key in me)) {
        me.addRefAccessor(name, key);
      }
      addElementListeners(me, el, domConfig, name);
    }
    me.byRef[name] = el;
    me[name] = el;
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} domConfig The DOM config object.
   * @internal
   */
  detachRef(name, el, domConfig) {
    const me = this, listeners = me._refListeners;
    if (listeners == null ? void 0 : listeners[name]) {
      listeners[name]();
      delete listeners[name];
    }
    me[name] = null;
    delete me.byRef[name];
  }
  /**
   * This method is called following an update to the widget's rendered DOM.
   * @internal
   */
  afterRecompose() {
  }
  /**
   * Returns a {@link Core.helper.DomHelper#function-createElement-static} config object that defines this widget's
   * DOM structure. This object should be determined using {@link Core.Base#property-configurable-static} properties
   * to ensure this method is called again if these properties are modified.
   *
   * For more information see {@link Core.widget.Widget class documentation}.
   * @returns {DomConfig}
   * @advanced
   */
  compose() {
    return {
      class: DomClassList.normalize(this.widgetClassList, "object")
    };
  }
  /**
   * This method iterates the class hierarchy from Widget down to the class of this instance and calls any `compose`
   * methods implemented by derived classes.
   * @returns {Object}
   * @private
   */
  doCompose() {
    const me = this, { $meta: meta } = me, classes = meta.hierarchy, renderConfigs = meta.renderConfigs || meta.getInherited("renderConfigs");
    let { composers } = meta, domConfig = null, c, key, i, proto3;
    me.recompose.suspend();
    if (!composers) {
      meta.composers = composers = [];
      for (i = classes.indexOf(_Widget); i < classes.length; ++i) {
        proto3 = classes[i].prototype;
        if (hasOwn5(proto3, "compose")) {
          composers.push(proto3);
        }
      }
      if (!hasOwn5(renderConfigs, renderConfigObserver)) {
        renderConfigs[renderConfigObserver] = {
          get(name) {
            renderConfigs[name] = true;
          }
        };
      }
    }
    me.configObserver = renderConfigs[renderConfigObserver];
    for (i = 0; i < composers.length; ++i) {
      c = composers[i].compose.call(me, domConfig);
      domConfig = domConfig ? DomHelper.merge(domConfig, c) : c;
    }
    if (hasOwn5(me, "compose") && (c = me.compose)) {
      c = c.call(me, domConfig);
      DomHelper.merge(domConfig, c);
    }
    me.configObserver = null;
    return DomHelper.normalizeChildren(domConfig, (childName, hoist) => {
      if (hoist) {
        key = "_" + childName;
        if (!(key in me)) {
          me.addRefAccessor(childName, key);
        }
      }
    });
  }
  get element() {
    if (this.isComposable && !this.isDestroying) {
      this.recompose.flush();
    }
    return this._element;
  }
  /**
   * Template method called during DOM updates. See {@link Core.helper.DomSync#function-sync-static DomSync.sync()}.
   * @param {Object} info Properties describing the sync action taken.
   * @internal
   */
  domSyncCallback(info) {
  }
  changeElement(element) {
    const me = this, compose = me.isComposable, { adopt } = me;
    me.id = me.id || (adopt == null ? void 0 : adopt.id) || null;
    if (adopt) {
      element = me.adoptElement(adopt);
    } else {
      if (compose) {
        element = me.doCompose();
      }
    }
    if (typeof element === "string") {
      element = DomHelper.createElementFromTemplate(element);
    } else if (ObjectHelper.isObject(element)) {
      element = DomHelper.createElement(element, {
        refOwner: me,
        callback: me.domSyncCallback
        // mimic DomSync callbacks (needed by TaskBoard)
      });
      me.recompose.resume();
    } else if (DomHelper.isReactElement(me.peekConfig("html"))) {
      element = document.createElement("div");
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }
    !element.id && (element.id = me.id);
    if (me.elementAttributes) {
      DomHelper.setAttributes(element, me.elementAttributes);
    }
    return element;
  }
  updateElement(element) {
    const me = this, compose = me.isComposable;
    if (me.adopt) {
      me._hidden = true;
      compose && me.recomposeNow();
    }
    compose && addElementListeners(me, element, element.lastDomConfig);
    const { className } = element, { contentElement, contentElementCls, isComposable } = me, hasChildContent = contentElement !== element, namedElements = !isComposable && element.querySelectorAll("[data-reference]"), classes = isComposable ? [] : me.widgetClassList;
    let uiClasses = (hasChildContent || !isComposable) && me.uiClasses;
    className && classes.unshift(className);
    me._hidden && classes.push("b-hidden");
    me._readOnly && classes.push("b-readonly");
    FunctionHelper.noThrow(
      element,
      "remove"
      /*, () => { debugger; } /**/
    );
    if (uiClasses) {
      if (contentElementCls == null ? void 0 : contentElementCls.value) {
        uiClasses = uiClasses.slice();
        uiClasses.push(contentElementCls.value);
      }
      uiClasses = uiClasses.join(" ");
    } else {
      uiClasses = contentElementCls == null ? void 0 : contentElementCls.value;
    }
    if (uiClasses) {
      if (hasChildContent) {
        contentElement.className += " " + uiClasses;
      } else {
        classes.push(uiClasses);
      }
    }
    if (!me.parent) {
      const { defaultCls } = me, { outerCls } = _Widget;
      classes.push(...defaultCls ? outerCls.filter((c) => !(c in defaultCls) || defaultCls[c]) : outerCls);
    }
    element.className = classes.join(" ");
    if (namedElements) {
      for (let el, i = 0; i < namedElements.length; ++i) {
        el = namedElements[i];
        me.attachRef(el.getAttribute("data-reference"), el);
        el.removeAttribute("data-reference");
      }
    }
    if (!me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
    me.getConfig("role");
    me.getConfig("ariaLabel");
    me.getConfig("ariaDescription");
    if (me._html) {
      me.getConfig("htmlMutationObserver");
    }
    me.trigger("elementCreated", { element });
  }
  updateAriaDescription(ariaDescription) {
    const { ariaElement } = this, descElId = `${this.id}-aria-desc-el`;
    if (ariaDescription) {
      const ariaDescEl = this._ariaDescEl || (this._ariaDescEl = DomHelper.createElement({
        className: "b-aria-desc-element",
        id: descElId,
        parent: ariaElement
      }));
      ariaDescEl.innerText = ariaDescription.match(localizeRE) ? this.L(ariaDescription, this) : ariaDescription;
      DomHelper.addAttributeValue(ariaElement, "aria-describedBy", descElId);
    } else {
      DomHelper.removeAttributeValue(ariaElement, "aria-describedBy", descElId);
    }
  }
  updateAriaLabel(ariaLabel) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-label": (ariaLabel == null ? void 0 : ariaLabel.match(localizeRE)) ? this.L(ariaLabel, this) : ariaLabel
    });
  }
  updateAriaHasPopup(ariaHasPopup) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-haspopup": ariaHasPopup
    });
  }
  updateAriaLive(ariaLive) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-live": ariaLive
    });
  }
  updateRole(role) {
    var _a4, _b;
    if (role) {
      (_a4 = this.ariaElement) == null ? void 0 : _a4.setAttribute("role", role);
    } else {
      (_b = this.ariaElement) == null ? void 0 : _b.removeAttribute("role");
    }
  }
  get ariaElement() {
    this.getConfig("element");
    const { _ariaElement } = this;
    return _ariaElement.nodeType === Node.ELEMENT_NODE ? _ariaElement : ObjectHelper.getPath(this, _ariaElement);
  }
  /**
   * This method determines if this widget (typically a {@link Core.widget.Tool}) should be placed in the header of
   * the calling {@link Core.widget.Panel}.
   * @param {Object} options An object specifying various options.
   * @param {Boolean} options.collapsed True if the panel is in a {@link Core.widget.Panel#config-collapsed} state.
   * @param {Boolean} options.alt True if the panel is rendering its alternate panel header, false for the primary header.
   * @returns {Boolean}
   * @internal
   */
  isCollapsified({ collapsed, alt: alt2 }) {
    const { collapsify } = this, hideIfCollapsed = collapsify === "hide", alwaysPrimary = collapsify === false, altIfCollapsedElsePrimary = collapsify == null, alwaysAlt = collapsify === "overlay";
    return alt2 ? alwaysAlt || altIfCollapsedElsePrimary && collapsed : alwaysPrimary || hideIfCollapsed || altIfCollapsedElsePrimary && !collapsed;
  }
  /**
   * Calling this {@link Core.mixin.Delayable#property-delayable-static} method marks this widget as dirty. The DOM
   * will be updated on the next animation frame:
   *
   * ```javascript
   *  widget.recompose();
   *
   *  console.log(widget.recompose.isPending);
   *  > true
   * ```
   *
   * A pending update can be flushed by calling `flush()` (this does nothing if no update is pending):
   *
   * ```javascript
   *  widget.recompose.flush();
   * ```
   *
   * This can be combined in one call to force a DOM update without first scheduling one:
   *
   * ```javascript
   *  widget.recompose.now();
   * ```
   * @advanced
   */
  async recompose() {
    return this.recomposeInternal();
  }
  async recomposeInternal() {
    const me = this, options = {
      targetElement: me.element,
      domConfig: me.doCompose(),
      refOwner: me,
      callback: me.domSyncCallback,
      // This limits the sync() to only removing the classes and styles added by previous renderings. This
      // allows dynamically added styles and classes to be preserved:
      strict: true
    };
    if (me.transitionRecompose) {
      me.isTransitioningDom = true;
      await DomHelper.transition(ObjectHelper.assign({
        element: me.element,
        action() {
          DomSync.sync(options);
        }
      }, me.transitionRecompose));
      if (me.isDestroyed) {
        return;
      }
      me.isTransitioningDom = false;
      me.trigger("transitionedRecompose");
    } else {
      DomSync.sync(options);
    }
    if (options.changed) {
      me.afterRecompose();
      me.trigger("recompose");
    }
    me.resumeRecompose();
  }
  // To allow hooking into resuming recompose, used by TaskBoard
  resumeRecompose() {
    this.recompose.resume();
  }
  changeElementRef(el) {
    if (typeof el === "string") {
      const id = el;
      if (!(el = document.getElementById(id))) {
        throw new Error(`No element found with id '${id}'`);
      }
    }
    return el;
  }
  changeAppendTo(appendTo) {
    return this.changeElementRef(appendTo);
  }
  updateAppendTo(appendTo) {
    if (!this.isConfiguring && appendTo) {
      this.render();
    }
  }
  changeInsertBefore(insertBefore) {
    return this.changeElementRef(insertBefore);
  }
  updateInsertBefore(insertBefore) {
    if (!this.isConfiguring && insertBefore) {
      this.render();
    }
  }
  changeInsertFirst(insertFirst) {
    return this.changeElementRef(insertFirst);
  }
  updateInsertFirst(insertFirst) {
    if (!this.isConfiguring && insertFirst) {
      this.render();
    }
  }
  /**
   * Interprets the {@link #config-appendTo}, {@link #config-insertBefore} and {@link #config-insertFirst}
   * configs to return an array containing `[parentElement, insertBefore]`
   * @internal
   * @param {Core.widget.Widget} source The widget for which to ascertain its render context.
   * @returns {HTMLElement[]} The `[parentElement, insertBefore]` elements.
   */
  getRenderContext(config = this, renderTo) {
    let parentElement = renderTo || config.appendTo, { insertFirst, insertBefore } = config;
    if (insertFirst) {
      parentElement = insertFirst;
      insertBefore = parentElement.firstChild;
    }
    if (insertBefore) {
      if (!parentElement) {
        parentElement = insertBefore.parentElement;
      }
    }
    return [parentElement, insertBefore || void 0];
  }
  render(renderTo, triggerPaint = true) {
    var _a4;
    const me = this, { element } = me, [
      parentElement,
      insertBefore
    ] = me.getRenderContext(me, renderTo);
    me.emptyCache();
    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {
      parentElement == null ? void 0 : parentElement.insertBefore(element, insertBefore);
      me.currentElement = element;
    }
    if ((_a4 = element.parentElement) == null ? void 0 : _a4.closest(".b-widget")) {
      element.classList.remove(..._Widget.outerCls);
    }
    super.render(parentElement, triggerPaint);
    me.rendered = true;
    me.getConfig("role");
    if (triggerPaint) {
      me.getConfig("contentRange");
      me.triggerPaint();
    }
    me.setupFocusListeners();
  }
  /**
   * A function which, when passed an instance of this Widget, produces a valid HTML string which is compiled
   * to create the encapsulating element for this Widget, and its own internal DOM structure.
   *
   * Note that this just creates the DOM structure that *this* Widget owns. If it contains child widgets
   * (Such as for example a grid), this is not included. The template creates own structure.
   *
   * Certain elements within the generated element can be identified as special elements with a `reference="name"`
   * property. These will be extracted from the element upon creation and injected as the named property into
   * the Widget. For example, a {@link Core.widget.TextField} will have an `input` property which is its
   * `<input>` element.
   * @param {Core.widget.Widget} me The widget for which to produce the initial HTML structure.
   * @internal
   */
  template({ tag, html, htmlCls, name }) {
    const me = this;
    if (typeof html === "string" && callbackRe.test(html) && me.resolveCallback(html, me, false)) {
      html = me.callback(html, me, [me]);
    }
    const content = (html == null ? void 0 : html.call) ? html.call(me, me) : html;
    return `<${tag} class="${content ? htmlCls : ""}" ${name ? `data-name="${name}"` : ""}>${content || ""}</${tag}>`;
  }
  updateRecomposeAsync(async) {
    this.recompose.immediate = !async;
  }
  //endregion
  //---------------------------------------------------------------------------------------------------------
  onConfigChange({ name }) {
    var _a4;
    if (this._element && !this.isDestroying && ((_a4 = this.$meta.renderConfigs) == null ? void 0 : _a4[name])) {
      this.recompose();
    }
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Clean up configs
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.parent;
  }
  // Extract config's current value, special handling for style
  getConfigValue(name, options) {
    if (name === "style") {
      return this._style;
    }
    return super.getConfigValue(name, options);
  }
  // Extract current value of all initially used configs, special handling for widget type
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    if ((options == null ? void 0 : options.depth) > 0) {
      result.type = this.type;
    }
    return result;
  }
  //endregion
  /**
   * Get widgets elements dataset or assign to it
   * @property {Object}
   * @category DOM
   */
  get dataset() {
    return this.element.dataset;
  }
  changeDataset(dataset) {
    ObjectHelper.assign(this.dataset, dataset);
  }
  get dragGhost() {
    return this.constructor._dragGhost || (this.constructor._dragGhost = DomHelper.createElement({
      // Safari won't allow dragging an empty node
      html: "\xA0",
      style: "position:absolute;top:-10000em;left:-10000em"
    }));
  }
  updateParent(parent) {
    const { _element: element } = this;
    if (element) {
      element.classList[parent ? "remove" : "add"](..._Widget.outerCls);
    }
  }
  get constrainTo() {
    let result = this._constrainTo;
    result = result === void 0 ? globalThis : (result == null ? void 0 : result.nodeType) === Node.DOCUMENT_FRAGMENT_NODE ? result.host || result.ownerDocument : result;
    if (this.positioned) {
      const { offsetParent } = this.element;
      if (offsetParent && DomHelper.getStyleValue(offsetParent, "overflow") === "hidden") {
        result = Rectangle.from(offsetParent).moveTo(0, 0);
      } else if (result && !result.isRectangle) {
        const isViewport = result === document || result === globalThis;
        result = Rectangle.from(result, offsetParent);
        if (isViewport) {
          result.translate(globalThis.pageXOffset, globalThis.pageYOffset);
        }
      }
    }
    return result;
  }
  updateCentered(value) {
    const {
      element,
      _anchorElement
    } = this;
    if (value && !this.floating && !this.positioned) {
      throw new Error("`centered` is only relevant when a Widget is `floating` or `positioned`");
    }
    if (value) {
      element.classList.add("b-centered");
      element.style.transform = element.style.left = element.style.top = "";
      _anchorElement == null ? void 0 : _anchorElement.classList.add("b-hide-display");
      element.classList.remove("b-anchored");
    } else {
      element.classList.remove("b-centered");
    }
  }
  /**
   * The child element into which content should be placed. This means where {@link #config-html} should be put,
   * or, for {@link Core.widget.Container}s, where child items should be rendered.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get contentElement() {
    return this.element;
  }
  get contentRange() {
    const me = this, contentRange = me._contentRange || (me._contentRange = new Range());
    if (contentRange.collapsed) {
      if (me.initializingHtml && me.adopt) {
        contentRange.setStart(me.contentElement, 0);
      } else {
        contentRange.selectNodeContents(me.contentElement);
      }
    }
    return contentRange;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {Node} el The element or DOM node to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      for (let { childNodes } = el, i = childNodes.length; i-- > 0; ) {
        this.fixRefOwnerId(childNodes[i], id, oldId);
      }
    }
  }
  get placement() {
    var _a4;
    const me = this, { element } = me;
    let adjRect, placement, rect;
    if ((element == null ? void 0 : element.offsetParent) && !nonFlowedPositions.test(DomHelper.getStyleValue(element, "position"))) {
      const next = element.nextElementSibling, previous = element.previousElementSibling, last = !next && previous;
      placement = DomHelper.getStyleValue(element.parentElement, "flex-direction");
      if (placement) {
        placement = placement.startsWith("row") ? "h" : "v";
      } else {
        adjRect = (_a4 = next || previous) == null ? void 0 : _a4.getBoundingClientRect();
        rect = adjRect && element.getBoundingClientRect();
        placement = adjRect && Math.abs(adjRect.top - rect.top) < Math.abs(adjRect.left - rect.left) ? "h" : "v";
      }
      placement += placement === "h" ? last ? "r" : "l" : last ? "b" : "t";
    }
    return placement;
  }
  updateId(id, oldId) {
    super.updateId(id, oldId);
    if (oldId) {
      const { byRef, element } = this;
      for (const ref in byRef) {
        byRef[ref].dataset && (byRef[ref].dataset.ownerCmp = id);
      }
      element.id = id;
      this.fixRefOwnerId(element, id, oldId);
    }
  }
  /**
   * Get/set widgets elements style. The setter accepts a cssText string or a style config object, the getter always
   * returns a CSSStyleDeclaration
   * @property {CSSStyleDeclaration}
   * @accepts {String|Object|CSSStyleDeclaration}
   * @category DOM
   */
  get style() {
    const { element } = this;
    return (element == null ? void 0 : element.ownerDocument.defaultView.getComputedStyle(element)) || this._style;
  }
  updateStyle(style) {
    this.element && DomHelper.applyStyle(this.element, style);
  }
  updateTitle(title) {
    if (this.titleElement) {
      this.titleElement.innerHTML = title;
    }
  }
  //region floating
  // Hook used by Tooltip to handle RTL
  beforeAlignTo(spec) {
  }
  /**
   * If this Widget is {@link #config-floating} or {@link #config-positioned}, and visible, aligns the widget
   * according to the passed specification. To stop aligning, call this method without arguments.
   * @param {AlignSpec|HTMLElement} [spec] Alignment options. May be an alignment specification object, or an
   * `HTMLElement` to align to using this Widget's {@link #config-align} configuration.
   * @category Float & align
   */
  alignTo(spec) {
    var _a4, _b;
    const me = this, {
      lastAlignSpec,
      element
    } = me, {
      offsetParent,
      style,
      classList
    } = element;
    if (lastAlignSpec) {
      lastAlignSpec.monitorIntersection && me.intersectionObserver.unobserve(lastAlignSpec.target);
      if (isFinite(lastAlignSpec.zone)) {
        element.classList.remove(alignedClass[lastAlignSpec.zone]);
      }
    }
    if (!spec) {
      me.removeTransientListeners();
      me.anchor = me.lastAlignSpec = null;
      return;
    }
    me.beforeAlignTo(spec);
    if (spec.nodeType === Element.ELEMENT_NODE || spec.isWidget || spec.$$name === "Point") {
      spec = {
        target: spec
      };
    }
    me.releaseSizeConstraints();
    const {
      scrollable,
      constrainTo
    } = me, elMinHeight = DomHelper.measureSize(DomHelper.getStyleValue(element, "minHeight"), element), elMinWidth = DomHelper.measureSize(DomHelper.getStyleValue(element, "minWidth"), element), positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", scale = me.scale || 1, passedTarget = spec.target, targetEvent = spec.realignEvent || getEventTarget(spec.domEvent || spec.event || (((_a4 = passedTarget == null ? void 0 : passedTarget.target) == null ? void 0 : _a4.nodeType) === Node.ELEMENT_NODE ? passedTarget : null)), aligningToEvent = ((_b = targetEvent == null ? void 0 : targetEvent.target) == null ? void 0 : _b.nodeType) === Element.ELEMENT_NODE, target = aligningToEvent ? targetEvent.target : (passedTarget == null ? void 0 : passedTarget.isRectangle) ? passedTarget : (passedTarget == null ? void 0 : passedTarget.element) || passedTarget, aligningToElement = (target == null ? void 0 : target.nodeType) === Element.ELEMENT_NODE;
    spec = spec.realignTarget ? spec : ObjectHelper.merge({
      aligningToEvent,
      aligningToElement,
      constrainTo,
      align: "b-t",
      // we can end up w/o a value for this if an object replaces a string
      axisLock: me.axisLock,
      anchor: me.anchor
    }, me.align, spec);
    if (aligningToEvent) {
      spec.domEvent = targetEvent;
    }
    const minWidth = spec.minWidth || elMinWidth, minHeight = spec.minHeight || elMinHeight;
    me.lastAlignSpec = spec;
    if (aligningToElement) {
      spec.target = spec.anchoredTo = target;
      if (hasLayout(target instanceof SVGElement ? target.closest("svg") : target)) {
        spec = Object.setPrototypeOf({}, spec);
        spec.target = me.lastAlignSpec.targetRect = spec.realignTarget || (spec.allowTargetOut ? Rectangle.from(target, positioned ? offsetParent : null, !positioned) : DomHelper.isInView(aligningToEvent ? targetEvent : target, false, me));
        if (!spec.target) {
          const result2 = me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return result2;
        }
        spec.target.height = Math.max(spec.target.height, 1);
        spec.target.width = Math.max(spec.target.width, 1);
      }
    }
    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      if (!element.contains(me.anchorPathElement)) {
        element.appendChild(me.anchorElement);
      }
    }
    me.isAligning = true;
    me.trigger("beforeAlign", spec);
    const myPosition = Rectangle.from(element, positioned ? offsetParent : null, true), {
      width: startWidth,
      height: startHeight
    } = myPosition;
    myPosition.isAlignRectangle = true;
    minWidth && (myPosition.minWidth = minWidth * scale);
    minHeight && (myPosition.minHeight = minHeight * scale);
    me.isAligning = false;
    spec.rtl = me.rtl;
    if (spec.align.includes("s") || spec.align.includes("e")) {
      if (me.rtl) {
        spec.align = spec.align.replace(/s/g, "r").replace(/e/g, "l");
      } else {
        spec.align = spec.align.replace(/s/g, "l").replace(/e/g, "r");
      }
    }
    const result = me.lastAlignSpec.result = myPosition.alignTo(spec);
    let { align, anchor, x, y, width, height, overlap } = result;
    me.lastAlignSpec.zone = result.zone;
    if (height != startHeight) {
      const shrunk = height < startHeight;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 1 : 2);
      style[me.alignedHeightStyle = alignChangeDims[me.alignmentChanges & 3]] = `${height / scale}px`;
      if (shrunk && !me._minHeight && elMinHeight) {
        style.minHeight = `${Math.min(height, elMinHeight) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowY = shrunk;
      }
    }
    if (width != startWidth) {
      const shrunk = width < startWidth;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 4 : 8);
      style[me.alignedWidthStyle = alignChangeDims[me.alignmentChanges & 12]] = `${width / scale}px`;
      if (shrunk && !me._minWidth && elMinWidth) {
        style.minWidth = `${Math.min(width, elMinWidth) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowX = shrunk;
      }
    }
    if (align && me.alignmentChanges) {
      const newRect = Rectangle.from(element, positioned ? offsetParent : null, true);
      spec.align = align;
      const newResult = me.lastAlignSpec.result = newRect.alignTo(spec);
      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
    }
    if (!me.centered) {
      me.setXY(x, y);
    }
    if (!result.overlap && isFinite(result.zone)) {
      classList.add(alignedClass[result.zone]);
    }
    if (anchor == null ? void 0 : anchor.edge) {
      const { edge } = anchor, { anchorElement } = me, { style: anchorStyle } = anchorElement, { style: svgStyle } = anchorElement.firstChild, elRect = Rectangle.from(element), colorMatchPoint = [];
      if (edge === "top" || edge === "bottom") {
        colorMatchPoint[0] = anchor.x;
        colorMatchPoint[1] = edge === "top" ? 1 : elRect.height - 1;
      } else {
        colorMatchPoint[0] = edge === "left" ? 1 : elRect.width - 1;
        colorMatchPoint[1] = anchor.y;
      }
      anchorStyle.display = "none";
      let colourSource = DomHelper.childFromPoint(element, ...colorMatchPoint);
      if (((colourSource == null ? void 0 : colourSource.matches(":focus")) || colourSource === GlobalEvents_default.currentOverElement) && element.compareDocumentPosition(colourSource) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        colourSource = colourSource.parentNode;
      }
      if (colourSource && colourSource !== document) {
        let fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        while (fillColour.match(isTransparent) && DomHelper.getStyleValue(colourSource, "position") !== "absolute") {
          colourSource = colourSource.parentNode;
          if (colourSource === document) {
            break;
          }
          fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        }
        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute("fill", fillColour);
        }
      }
      anchorStyle.transform = anchorStyle.display = "";
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      anchor.x && (anchor.x /= scale);
      anchor.y && (anchor.y /= scale);
      svgStyle.translate = `${anchor.x || 0}px ${anchor.y || 0}px`;
      classList.add("b-anchored");
    } else if (me._anchorElement) {
      me.anchorElement.classList.add("b-hide-display");
      classList.remove("b-anchored");
    }
    if (!aligningToElement) {
      style.pointerEvents = "none";
      const el = DomHelper.elementFromPoint(x, y);
      if (!me.owns(el)) {
        me.lastAlignSpec.anchoredTo = el;
      }
      style.pointerEvents = "";
    }
    if ((me.scrollAction === "realign" && aligningToElement || me.scrollAction === "hide") && !me.documentScrollListener) {
      me.clearTimeout("scrollListenerTimeout");
      if (spec.monitorTargetMutation && !me.targetObserver) {
        const targetObserver = me.targetObserver || (me.targetObserver = new MutationObserver(me.onTargetParentMutation.bind(me)));
        targetObserver.observe(DomHelper.getRootElement(target), {
          childList: true,
          attributes: true,
          subtree: true
        });
      }
      me.setTimeout(() => {
        var _a5, _b2;
        const targetRoot = (_b2 = (_a5 = aligningToElement ? target : me.lastAlignSpec.anchoredTo).getRootNode) == null ? void 0 : _b2.call(_a5);
        me.documentScrollListener = EventHelper.addListener({
          element: document,
          scroll: "doHideOrRealign",
          transitionend: "realignOnTransitionEnd",
          capture: true,
          thisObj: me
        });
        if (targetRoot == null ? void 0 : targetRoot.mode) {
          me.targetRootScrollListener = EventHelper.addListener({
            element: targetRoot,
            scroll: "doHideOrRealign",
            transitionend: "realignOnTransitionEnd",
            capture: true,
            thisObj: me
          });
        }
      }, me.scrollAction === "hide" ? me.ignoreScrollDuration : 0, "scrollListenerTimeout");
    }
    if (aligningToElement) {
      if (spec.monitorResize && !me.observedTargetEl) {
        ResizeMonitor.addResizeListener(target, me.onTargetResize);
        me.observedTargetEl = target;
      }
      if (spec.monitorIntersection && !(overlap || target.contains(element) || target.ownerSVGElement)) {
        me.intersectionObserver.observe(target);
      }
    }
    if (!BrowserHelper.isAndroid) {
      if (!me.observedConstrainEl) {
        const el = (constrainTo == null ? void 0 : constrainTo.isRectangle) ? globalThis : constrainTo;
        me.clearTimeout("resizeListenerTimeout");
        me.setTimeout(() => {
          me.observedConstrainEl = el || globalThis;
          ResizeMonitor.addResizeListener(me.observedConstrainEl, me.onAlignConstraintChange);
        }, me.ignoreScrollDuration, "resizeListenerTimeout");
      }
    }
  }
  onTargetParentMutation(mutationRecords) {
    var _a4;
    const { element, lastAlignSpec } = this;
    if (lastAlignSpec == null ? void 0 : lastAlignSpec.aligningToElement) {
      if (!((_a4 = lastAlignSpec.target) == null ? void 0 : _a4.isConnected)) {
        this.hide();
      } else if (mutationRecords.some(({ target }) => target.contains(lastAlignSpec.target) && !element.contains(target))) {
        this.realign();
      }
    }
  }
  get intersectionObserver() {
    return this._intersectionObserver || (this._intersectionObserver = new IntersectionObserver(this.onTargetIntersectionchange.bind(this), {
      root: BrowserHelper.isSafari ? this.rootElement : this.rootElement.ownerDocument
    }));
  }
  onTargetIntersectionchange(entries) {
    if (!this.isDestroyed) {
      const e = entries[entries.length - 1];
      if (!e.isIntersecting) {
        this.onAlignTargetOutOfView(e.target);
      }
    }
  }
  onTargetResize() {
    const { lastAlignSpec } = this;
    if (lastAlignSpec) {
      const {
        width: lastWidth,
        height: lastHeight
      } = lastAlignSpec.targetRect, {
        width,
        height
      } = lastAlignSpec.target.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight) {
        this.onAlignConstraintChange(...arguments);
      }
    }
  }
  /**
   * This method is called when the {@link #function-alignTo} target element loses intersection with the
   * visible viewport. That means it has been scrolled out of view, or becomes zero size, or hidden or
   * is removed from the DOM.
   *
   * The base class implementation hides by default.
   * @param {HTMLElement} target The alignTo target that is no longer in view.
   * @internal
   */
  onAlignTargetOutOfView(target) {
    this.hide();
    this.lastAlignSpec && (this.lastAlignSpec.targetOutOfView = true);
  }
  onAlignConstraintChange(el, oldRect, { height }) {
    const { style } = this.contentElement, { overflowY } = style;
    this.setTimeout(this.realign, 50);
    if (oldRect && height > oldRect.height) {
      style.overflowY = "hidden";
      this.requestAnimationFrame(() => style.overflowY = overflowY);
    }
  }
  /**
   * Called when an element which affects the position of this Widget's
   * {@link #function-alignTo align target} scrolls so that this can realign.
   *
   * If the target has scrolled out of view, then this Widget is hidden.
   * @internal
   */
  realign() {
    const me = this, { lastAlignSpec } = me;
    if ((me.floating || me.positioned) && lastAlignSpec && me.isVisible) {
      if (lastAlignSpec.aligningToElement) {
        const insideTarget = lastAlignSpec.target.contains(this.element), realignTarget = DomHelper.isInView(lastAlignSpec.target, false, me);
        if (!lastAlignSpec.allowTargetOut && (!hasLayout(lastAlignSpec.target) || !realignTarget)) {
          me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return;
        }
        lastAlignSpec.realignEvent = lastAlignSpec.domEvent;
        lastAlignSpec.realignTarget = insideTarget || lastAlignSpec.aligningToEvent ? null : realignTarget;
      }
      DomHelper.addTemporaryClass(me.element, "b-realigning", me.realignTimeout, me);
      me.alignTo(lastAlignSpec);
    }
  }
  /**
   * Returns the specified bounding rectangle of this widget.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned is the
   * bounding rectangle that contains the `element` border. Pass any of these values to retrieve various rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangle(which, relativeTo, ignorePageScroll) {
    return this.rectangleOf("element", which, relativeTo, ignorePageScroll);
  }
  /**
   * Returns the specified bounding rectangle of the specified child `element` of this widget.
   * @param {String} [element] The child element name.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned
   * is the bounding rectangle that contains the `element` border. Pass any of these values to retrieve various
   * rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle. If `element` is not `'element'`, then this defaults to the widget's primary element.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangleOf(element, which, relativeTo, ignorePageScroll) {
    if (typeof which !== "string") {
      ignorePageScroll = relativeTo;
      relativeTo = which;
      which = "";
    } else if (which === "border") {
      which = "";
    }
    if (typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = void 0;
    }
    if (element !== "element" && relativeTo === void 0) {
      relativeTo = this.element;
    }
    relativeTo = (relativeTo == null ? void 0 : relativeTo.isWidget) ? relativeTo.element : relativeTo;
    return Rectangle[which || "from"](this[element], relativeTo, ignorePageScroll);
  }
  releaseSizeConstraints() {
    const me = this, {
      scrollable,
      element,
      alignmentChanges
    } = me, { style } = element;
    if (alignmentChanges & 12) {
      DomHelper.setLength(element, me.alignedWidthStyle, me[`_last${StringHelper.capitalize(me.alignedWidthStyle)}`] || "");
      style.minWidth = me._minWidth || "";
      if (scrollable) {
        scrollable.overflowY = scrollable.config.overflowY;
      }
    }
    if (alignmentChanges & 3) {
      DomHelper.setLength(element, me.alignedHeightStyle, me[`_last${StringHelper.capitalize(me.alignedHeightStyle)}`] || "");
      style.minHeight = me._minHeight || "";
      if (scrollable) {
        scrollable.overflowX = scrollable.config.overflowX;
      }
    }
    me.alignmentChanges = 0;
  }
  /**
   * Only valid for {@link #config-floating} Widgets. Moves to the front of the visual stacking order.
   * @category Float & align
   */
  toFront() {
    const { element } = this, parent = this.floating ? this.floatRoot : this.positioned ? element == null ? void 0 : element.parentNode : null, widgetsFrag = document.createDocumentFragment();
    if (this.containsFocus) {
      for (let followingEl = element.nextSibling, nextEl; followingEl; followingEl = nextEl) {
        nextEl = followingEl.nextSibling;
        if (parent.contains(followingEl) && !this.owns(followingEl)) {
          widgetsFrag.appendChild(followingEl);
        }
      }
      parent.insertBefore(widgetsFrag, element);
    } else {
      parent.appendChild(element);
    }
  }
  //endregion
  //region Getters/setters
  updateRef(ref) {
    this.element.dataset.ref = ref;
  }
  /**
   * The child element which scrolls if any. This means the element used by the {@link #config-scrollable}.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get overflowElement() {
    return this.contentElement;
  }
  get maxHeightElement() {
    return this.element;
  }
  changeAlign(align) {
    return typeof align === "string" ? { align } : align;
  }
  changeScrollable(scrollable, oldScrollable) {
    if (typeof scrollable === "boolean") {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }
    if (scrollable) {
      scrollable.element = this.overflowElement;
      scrollable.widget = this;
      if (!scrollable.isScroller) {
        scrollable = oldScrollable ? oldScrollable.setConfig(scrollable) : new this.scrollerClass(scrollable);
      }
      scrollable.syncOverflowState();
    } else {
      oldScrollable == null ? void 0 : oldScrollable.destroy();
    }
    return scrollable;
  }
  handleReactElement(html) {
    var _a4;
    const parent = this.closest((cmp) => cmp.reactComponent), reactComponent = (parent == null ? void 0 : parent.reactComponent) || ((_a4 = bryntum == null ? void 0 : bryntum.query((c) => {
      var _a5;
      return !!((_a5 = c.reactComponent) == null ? void 0 : _a5.state);
    })) == null ? void 0 : _a4.reactComponent);
    reactComponent == null ? void 0 : reactComponent.processWidgetContent({
      reactElement: html,
      widget: this,
      reactComponent
    });
  }
  /**
   * Get/set HTML to display. When specifying HTML, this widget's element will also have the
   * {@link #config-htmlCls} added to its classList, to allow targeted styling.
   * @property {String}
   * @category DOM
   */
  get html() {
    if (this.isConfiguring) {
      return this.content || this._html;
    }
    return this.contentElement.innerHTML;
  }
  updateHtml(html) {
    if (!this.initializingElement) {
      this.insertContent(html, !(this.initializingHtml && this.adopt));
    }
  }
  changeHtmlMutationObserver(htmlMutationObserver, was) {
    const me = this, { contentElement } = me;
    was == null ? void 0 : was.disconnect();
    if (htmlMutationObserver) {
      const result = new MutationObserver(() => {
        if (me.updatingHtml) {
          me.updatingHtml = false;
        } else {
          me._html = contentElement.innerHTML;
        }
      });
      result.observe(contentElement, htmlMutationObserver);
      return result;
    }
  }
  updateContent(html) {
    if (!this.initializingElement) {
      this.insertContent(html);
    }
  }
  insertContent(newContent, replace = false) {
    const me = this, {
      element,
      contentElement,
      htmlCls,
      contentRange,
      autoClose
    } = me, anchorEl = replace && contentElement === element && me._anchorElement;
    if (DomHelper.isReactElement(newContent)) {
      return me.handleReactElement(newContent);
    }
    me.updatingHtml = true;
    me.getConfig("htmlMutationObserver");
    if (anchorEl) {
      element.removeChild(anchorEl);
    }
    if (htmlCls) {
      htmlCls.values.forEach((value) => element.classList[newContent ? "add" : "remove"](value));
    }
    me.autoClose = false;
    if (newContent) {
      let done, newContentFragment;
      if (typeof newContent === "object") {
        newContentFragment = document.createDocumentFragment();
        DomSync.sync({
          domConfig: {
            ...newContent,
            onlyChildren: true
          },
          targetElement: newContentFragment
        });
      } else if (replace) {
        contentElement.innerHTML = newContent;
        done = true;
      } else {
        if (!replace) {
          contentRange.deleteContents();
        }
        newContentFragment = DomHelper.createElementFromTemplate(newContent, { fragment: true });
      }
      if (!done) {
        if (replace) {
          contentElement.innerHTML = "";
          contentElement.appendChild(newContentFragment);
        } else {
          if (element.isConnected) {
            contentRange.insertNode(newContentFragment);
          } else {
            contentElement.insertBefore(newContentFragment, contentElement.firstChild);
          }
        }
      }
    } else {
      if (replace || !element.isConnected) {
        contentElement.innerHTML = "";
      } else {
        contentRange.deleteContents();
      }
    }
    me.autoClose = autoClose;
    if (anchorEl) {
      element.appendChild(anchorEl);
    }
    me.contentRangeStartOffset = contentRange.startOffset;
    me.contentRangeEndOffset = contentRange.endOffset;
    if (me.isComposable) {
      me.recompose();
    }
    if ((me.floating || me.positioned) && !me.isAligning) {
      me.realign();
    }
  }
  onThemeChange() {
    var _a4;
    if ((_a4 = this.anchorElement) == null ? void 0 : _a4.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }
  /**
   * Returns an `[x, y]` array containing the width and height of the anchor arrow used when
   * aligning this Widget to another Widget or element.
   *
   * The height is the height of the arrow when pointing upwards, the width is the width
   * of the baseline.
   * @property {Number[]}
   * @category Float & align
   */
  get anchorSize() {
    const me = this;
    let result = this._anchorSize;
    if (!result) {
      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, "border-top-width")), borderColour = DomHelper.getStyleValue(me.element, "border-top-color"), anchorElement = me.anchorElement, { className } = anchorElement, svgEl = anchorElement.firstElementChild, pathElement = me.anchorPathElement = svgEl.lastElementChild, hidden = me._hidden;
      anchorElement.className = "b-anchor b-anchor-top";
      let backgroundColour = DomHelper.getStyleValue(me.contentElement, "background-color");
      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, "background-color");
      }
      me.defaultAnchorBackgroundColor = backgroundColour;
      result = svgEl.getBoundingClientRect();
      const [width, height] = result = me._anchorSize = [result.width, result.height];
      anchorElement.className = className;
      svgEl.setAttribute("height", height + borderWidth);
      svgEl.setAttribute("width", width);
      pathElement.setAttribute("d", `M0,${height}L${width / 2},0.5L${width},${height}`);
      if (borderWidth) {
        pathElement.setAttribute("stroke-width", borderWidth);
        pathElement.setAttribute("stroke", borderColour);
      }
      result[1] -= borderWidth;
      if (hidden) {
        me.element.classList.add("b-hidden");
      }
      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents_default.ion({
          theme: "onThemeChange",
          thisObj: me
        });
      }
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
    return result;
  }
  get anchorElement() {
    const me = this;
    if (!me._anchorElement) {
      const useFilter = me.floating, filterId = `${me.id}-shadow-filter`;
      me._anchorElement = DomHelper.createElement({
        parent: me.element,
        className: "b-anchor b-anchor-top",
        children: [{
          tag: "svg",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          class: "b-pointer-el",
          children: [useFilter ? {
            tag: "defs",
            children: [{
              tag: "filter",
              id: filterId,
              children: [{
                tag: "feDropShadow",
                dx: 0,
                dy: -1,
                stdDeviation: 1,
                "flood-opacity": 0.2
              }]
            }]
          } : null, {
            tag: "path",
            [useFilter ? "filter" : ""]: `url(#${filterId})`
          }]
        }]
      });
    }
    return me._anchorElement;
  }
  updateAnchor(anchor) {
    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? "remove" : "add"]("b-hide-display");
    }
  }
  updateDraggable(draggable) {
    var _a4, _b, _c;
    const me = this, { element } = me;
    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element,
        dragstart: "onWidgetDragStart",
        dragend: "onWidgetDragEnd",
        thisObj: me
      });
      me.dragDetacher = EventHelper.on({
        element,
        mousedown(event) {
          const { target } = event, closestWidget = _Widget.fromElement(target);
          if (!event.target.closest(".b-field-inner") && // Only allow drag to start when the action originates from the widget element itself,
          // or one of its toolbars. https://github.com/bryntum/support/issues/3214
          closestWidget === this || this.strips && Object.values(this.strips).includes(closestWidget)) {
            element.setAttribute("draggable", "true");
          }
        },
        // Only needed for automatic listener removal on destruction of the thisObj
        thisObj: me
      });
    } else {
      (_a4 = me.dragEventDetacher) == null ? void 0 : _a4.call(me);
      (_b = me.dragOverEventDetacher) == null ? void 0 : _b.call(me);
      (_c = me.dragDetacher) == null ? void 0 : _c.call(me);
    }
  }
  onWidgetDragStart(e) {
    var _a4;
    const me = this;
    if (!me.validateDragStartEvent(e)) {
      return;
    }
    const {
      element,
      align,
      constrainTo
    } = me, positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", parentElement = positioned ? element.parentElement : me.rootElement, myRect = Rectangle.from(element, positioned ? parentElement : null), dragStartX = e.clientX, dragStartY = e.clientY, scrollingPageElement = document.scrollingElement || document.body, [widgetX, widgetY] = positioned ? DomHelper.getOffsetXY(element, parentElement) : me.getXY(), constrainRect = (_a4 = positioned ? Rectangle.content(parentElement).moveTo(0, 0) : constrainTo && ((constrainTo == null ? void 0 : constrainTo.isRectangle) ? constrainTo : Rectangle.from(constrainTo))) == null ? void 0 : _a4.deflate(align.constrainPadding || 0), dragListeners = {
      element: parentElement,
      dragover: (event) => {
        element.classList.remove("b-centered");
        myRect.moveTo(
          widgetX + event.clientX - dragStartX - (positioned ? 0 : scrollingPageElement.scrollLeft),
          widgetY + event.clientY - dragStartY - (positioned ? 0 : scrollingPageElement.scrollTop)
        );
        if (constrainRect) {
          myRect.constrainTo(constrainRect);
        }
        DomHelper.setTranslateXY(element, myRect.x, myRect.y);
      }
    };
    if (BrowserHelper.isTouchDevice) {
      dragListeners.touchmove = (e13) => e13.preventDefault();
    }
    me.floatRoot.appendChild(me.dragGhost);
    me.setDragImage(e);
    e.dataTransfer.effectAllowed = "none";
    me.dragOverEventDetacher = EventHelper.addListener(dragListeners);
    me.alignTo();
  }
  /**
   * Validates a `dragstart` event with respect to the target element. Dragging is not normally
   * initiated when the target is interactive such as an input field or its label, or a button.
   * This may be overridden to provide custom drag start validation.
   * @param {DragEvent} e The `dragstart` event to validate.
   * @returns {Boolean} Return `true` if the drag is to be allowed.
   * @internal
   */
  validateDragStartEvent(e) {
    var _a4;
    const me = this, { element } = me, actualTarget = DomHelper.elementFromPoint(e.clientX, e.clientY), { handleSelector } = me.draggable;
    if (handleSelector) {
      const blacklist = (_a4 = negationPseudo.exec(handleSelector)) == null ? void 0 : _a4[1];
      if (blacklist) {
        if (actualTarget.closest(`#${element.id} ${blacklist}`)) {
          e.preventDefault();
          return false;
        }
      } else if (!actualTarget.closest(`#${element.id} ${handleSelector}`)) {
        e.preventDefault();
        return false;
      }
    }
    return true;
  }
  setDragImage(e) {
    if (e.dataTransfer.setDragImage) {
      e.dataTransfer.setData("application/node type", "");
      e.dataTransfer.setDragImage(this.dragGhost, -9999, -9999);
    }
  }
  setStyle(name, value) {
    DomHelper.applyStyle(this.element, ObjectHelper.isObject(name) ? name : { [name]: value });
    return this;
  }
  onWidgetDragEnd() {
    this.dragGhost.remove();
    this.dragOverEventDetacher();
    this.element.removeAttribute("draggable");
  }
  changeFloating(value) {
    return Boolean(value);
  }
  changePositioned(value) {
    return Boolean(value);
  }
  updatePositioned(positioned) {
    this.element.classList[positioned ? "add" : "remove"]("b-positioned");
  }
  getXY() {
    return [
      DomHelper.getPageX(this.element),
      DomHelper.getPageY(this.element)
    ];
  }
  /**
   * Moves this Widget to the x,y position. Both arguments can be omitted to just set one value.
   *
   * *For {@link #config-floating} Widgets, this is a position in the browser viewport.*
   * *For {@link #config-positioned} Widgets, this is a position in the element it was rendered into.*
   *
   * @param {Number} [x]
   * @param {Number} [y]
   * @category Float & align
   */
  setXY(x, y) {
    const me = this, { element } = me;
    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
      }
      if (y != null) {
        me._y = y;
      }
      if (DomHelper.getStyleValue(element, "position") === "fixed") {
        const r = element.getBoundingClientRect(), [cx, cy] = DomHelper.getTranslateXY(element), xDelta = x - r.x, yDelta = y - r.y;
        DomHelper.setTranslateXY(element, cx + xDelta, cy + yDelta);
      } else {
        DomHelper.setTranslateXY(element, me._x || 0, me._y || 0);
      }
      if (me.isConstructing) {
        me.centered = false;
      } else {
        element.classList.remove("b-centered");
      }
    }
  }
  /**
   * Moves this Widget to the desired x position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get x() {
    return this.getXY()[0];
  }
  changeX(x) {
    this.setXY(x);
  }
  /**
   * Moves this Widget to the desired y position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get y() {
    return this.getXY()[1];
  }
  changeY(y) {
    this.setXY(null, y);
  }
  /**
   * Get elements offsetWidth or sets its style.width, or specified width if element not created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get width() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._width == null) {
        me._width = element.offsetWidth;
      }
      return me._width;
    }
    return element.offsetWidth;
  }
  changeWidth(width) {
    const me = this;
    DomHelper.setLength(me.element, "width", width);
    me._lastWidth = width;
    me._flex = null;
    me.element.style.flex = "";
    if (me.monitorResize) {
      me._oldWidth = me._width;
      me._width = null;
    } else {
      return width;
    }
  }
  // This method is used by State API to drop cached width early to not rely on ResizeMonitor
  clearWidthCache() {
    this._width = null;
  }
  /**
   * Get/set elements maxWidth. Getter returns max-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }
  updateMaxWidth(maxWidth) {
    this._lastMaxWidth = maxWidth;
    DomHelper.setLength(this.element, "maxWidth", maxWidth);
  }
  /**
   * Get/set elements minWidth. Getter returns min-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }
  updateMinWidth(minWidth) {
    DomHelper.setLength(this.element, "minWidth", minWidth);
  }
  updateFlex(flex) {
    this.getConfig("width");
    if (typeof flex === "number" || !isNaN(flex)) {
      flex = `${flex} ${flex}`;
    }
    this.element.style.flex = flex;
    this.element.style.width = "";
  }
  updateAlignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }
  updateMargin(margin) {
    this.element.style.margin = this.parseTRBL(margin).join(" ");
  }
  updateTextAlign(align, oldAlign) {
    oldAlign && this.element.classList.remove(`b-text-align-${oldAlign}`);
    this.element.classList.add(`b-text-align-${align}`);
  }
  updatePlaceholder(placeholder) {
    if (this.input) {
      if (placeholder == null) {
        this.input.removeAttribute("placeholder");
      } else {
        this.input.placeholder = placeholder;
      }
    }
  }
  /**
   * Get element's offsetHeight or sets its style.height, or specified height if element no created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get height() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._height == null) {
        me._height = element.offsetHeight;
      }
      return me._height;
    }
    return element.offsetHeight;
  }
  changeHeight(height) {
    DomHelper.setLength(this.element, "height", height);
    this._lastHeight = height;
    this._height = null;
  }
  /**
   * Get/set element's maxHeight. Getter returns max-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }
  updateMaxHeight(maxHeight) {
    this._lastMaxHeight = maxHeight;
    DomHelper.setLength(this.maxHeightElement, "maxHeight", maxHeight);
  }
  /**
   * Get/set element's minHeight. Getter returns min-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }
  updateMinHeight(minHeight) {
    DomHelper.setLength(this.element, "minHeight", minHeight);
  }
  updateDisabled(disabled = false) {
    const {
      element,
      focusElement,
      ariaElement
    } = this;
    this.trigger("beforeUpdateDisabled", { disabled });
    if (disabled) {
      this.revertFocus();
      if (this._disabled !== disabled) {
        return;
      }
    }
    if (element) {
      element.classList[disabled ? "add" : "remove"]("b-disabled");
      if (focusElement) {
        focusElement.disabled = disabled;
      }
      if (ariaElement) {
        ariaElement.setAttribute("aria-disabled", disabled);
      }
    }
    this.onDisabled(disabled);
  }
  /**
   * Called when disabled state is changed.
   * Override in subclass that needs special handling when being disabled.
   * @param {Boolean} disabled current state
   * @private
   */
  onDisabled(disabled) {
  }
  /**
   * Disable the widget
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Enable the widget
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Requests fullscreen display for this widget
   * @returns {Promise} A Promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  requestFullscreen() {
    const me = this, result = Fullscreen.request(me.floating ? me.floatRoot : me.element);
    Fullscreen.onFullscreenChange(me.onFullscreenChange);
    me.element.classList.add("b-fullscreen");
    return result;
  }
  /**
   * Exits fullscreen mode
   * @returns {Promise} A Promise which is resolved once the user agent has finished exiting full-screen mode
   */
  exitFullscreen() {
    return Fullscreen.exit();
  }
  onFullscreenChange() {
    if (!Fullscreen.isFullscreen) {
      this.onExitFullscreen();
    }
  }
  onExitFullscreen() {
    Fullscreen.unFullscreenChange(this.onFullscreenChange);
    this.element.classList.remove("b-fullscreen");
  }
  /**
   * Get/set a tooltip on the widget. Accepts a string or tooltip config (specify true (or 'true') to use placeholder
   * as tooltip). When using a string it will configure the tooltip with `textContent: true` which enforces a default
   * max width.
   *
   * By default, this uses a singleton Tooltip instance which may be accessed from the `{@link Core.widget.Widget}`
   * class under the name `Widget.tooltip`. This is configured according to the config object on pointer over.
   *
   * To request a separate instance be created just for this widget, add `newInstance : true` to the configuration.
   *
   * @property {String|TooltipConfig}
   * @category Misc
   */
  get tooltip() {
    var _a4;
    const me = this;
    if (me._tooltip) {
      return me._tooltip;
    } else {
      const tooltip = (_a4 = _Widget.Tooltip) == null ? void 0 : _a4.getSharedTooltip(me.rootElement, me.eventRoot);
      if (tooltip && tooltip.activeTarget === me._element && tooltip.isVisible) {
        return tooltip;
      }
    }
  }
  //noinspection JSAnnotator
  changeTooltip(tooltip, oldTooltip) {
    const me = this, { element } = me;
    if (tooltip) {
      if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
        if (!tooltip.isTooltip && tooltip.constructor.name !== "Object") {
          tooltip = {
            html: typeof tooltip === "string" ? tooltip : me.placeholder,
            textContent: true
          };
        }
        if ((oldTooltip == null ? void 0 : oldTooltip.isTooltip) || tooltip.newInstance) {
          tooltip.type = "tooltip";
          if (!tooltip.forElement)
            tooltip.forElement = element;
          if (!("showOnHover" in tooltip) && !tooltip.forSelector)
            tooltip.showOnHover = true;
          if (!("autoClose" in tooltip))
            tooltip.autoClose = true;
          tooltip = _Widget.reconfigure(oldTooltip, tooltip, me);
          me.detachListeners("tooltipValueListener");
          if (!me.configureAriaDescription) {
            tooltip.ion({
              name: "tooltipValueListener",
              innerHtmlUpdate: "onTooltipValueChange",
              thisObj: me
            });
          }
        } else {
          element.dataset.btip = true;
          me.tipConfig = tooltip;
          return;
        }
      }
    } else {
      if (oldTooltip) {
        if (tooltip == null && oldTooltip.isTooltip) {
          oldTooltip.destroy();
        } else {
          oldTooltip.html = null;
          return;
        }
      } else {
        delete element.dataset.btip;
      }
    }
    return tooltip;
  }
  /**
   * The shared {@link Core.widget.Tooltip} instance which handles
   * {@link Core.widget.Widget#config-tooltip tooltips} which are __not__ configured
   * with `newInstance : true`.
   * @member {Core.widget.Tooltip} tooltip
   * @readonly
   * @static
   */
  // This property is defined in the Tooltip module but must be documented here.
  // If our tooltip is dynamic, then we must update our aria-describedBy whenever it changes.
  onTooltipValueChange({ value, source }) {
    this.ariaDescription = typeof value == "string" ? value : source.contentElement.innerText;
  }
  get tooltipText() {
    const tooltip = this._tooltip;
    if (tooltip) {
      return tooltip.isTooltip ? tooltip.contentElement.innerText : typeof tooltip === "string" ? tooltip : tooltip.html;
    } else if (this.tipConfig) {
      return this.tipConfig.html;
    }
  }
  /**
   * Determines visibility by checking if the Widget is hidden, or any ancestor is hidden and that it has an
   * element which is visible in the DOM
   * @property {Boolean}
   * @category Visibility
   * @readonly
   */
  get isVisible() {
    const me = this, { element } = me;
    let owner;
    return Boolean(
      element && !me._hidden && !me.isDestroying && element.isConnected && (!me.requireSize || hasLayout(element)) && (!(owner = me.parent) || owner.isVisible)
    );
  }
  // If the callback is a function (instead of the name of the function),
  // the id must be converted into string format to be used as key for `toCallWhenVisible` map element
  whenVisible(callback, thisObj = this, args, id = callback.toString()) {
    var _a4;
    const me = this;
    if (me.isVisible && me.isPainted) {
      (_a4 = me.toCallWhenVisible) == null ? void 0 : _a4.delete(id);
      me.callback(callback, thisObj, args);
    } else {
      (me.toCallWhenVisible || (me.toCallWhenVisible = /* @__PURE__ */ new Map())).set(id, { callback, thisObj, args });
    }
  }
  /**
   * Focuses this widget if it has a focusable element.
   */
  focus() {
    if (this.isFocusable) {
      this.focusElement.focus({ preventScroll: true });
    }
  }
  /**
   * Get this widget's primary focus holding element if this widget is itself focusable, or contains focusable widgets.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get focusElement() {
  }
  get isFocusable() {
    const focusElement = !this.isDestroying && this.isVisible && !this.disabled && this.focusElement;
    return focusElement && (focusElement === document.body || focusElement.offsetParent);
  }
  /**
   * Shows this widget
   * @param {Object} [options] modifications to the show operation
   * @param {AlignSpec} [options.align] An alignment specification as passed to {@link #function-alignTo}
   * @param {Boolean} [options.animate=true] Specify as `false` to omit the {@link #config-showAnimation}
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async show({ align, animate = true } = {}) {
    const me = this, {
      element,
      floating
    } = me, { style } = element, showAnimation = animate && me.showAnimation;
    let styleProp, animProps, trigger = !me.isVisible;
    if (trigger) {
      trigger = me.trigger("beforeShow");
      if (ObjectHelper.isPromise(trigger)) {
        trigger = await trigger;
      }
    }
    if (trigger !== false && (!me.internalBeforeShow || me.internalBeforeShow() !== false)) {
      return new Promise((resolve) => {
        me.cancelHideShowAnimation();
        me.updateCentered(me._centered);
        if (floating) {
          const floatRoot = me.floatRoot;
          if (!floatRoot.contains(element)) {
            if (me.rendered) {
              floatRoot.appendChild(me.element);
            } else {
              me.render(floatRoot, false);
            }
          }
          if (style.transform.includes("scale")) {
            me.scale = null;
            style.transform = style.transformOrigin = "";
          }
          const scaledAncestor = me.closest(isScaled);
          if (scaledAncestor) {
            const { scale } = scaledAncestor;
            me.scale = scale;
            style.transform = `scale(${scale})`;
            style.transformOrigin = `0 0`;
          }
        }
        me._hidden = false;
        element.classList.remove("b-hidden");
        if (floating && !isVisible(element)) {
          me.hide(false);
          return resolve();
        }
        me.onConfigChange({
          name: "hidden",
          value: false,
          was: true,
          config: me.$meta.configs.hidden
        });
        if (showAnimation) {
          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];
          const currentAnimation = me.currentAnimation = {
            showing: true,
            styleProp,
            resolve
          };
          me.isAnimating = true;
          style.transition = "none";
          style[styleProp] = animProps.from;
          DomHelper.getStyleValue(element, styleProp);
          me.currentAnimation.detacher = EventHelper.onTransitionEnd({
            element,
            property: styleProp,
            duration: parseDuration(animProps.duration) + 20,
            handler: () => me.afterHideShowAnimate(currentAnimation),
            thisObj: me
          });
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          style[styleProp] = animProps.to;
        }
        me.afterShow(align, !showAnimation ? resolve : null);
      });
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Show aligned to another target element or {@link Core.widget.Widget} or {@link Core.helper.util.Rectangle}
   * @param {AlignSpec|HTMLElement|Number[]} align Alignment specification, or the element to align to using the
   * configured {@link #config-align}.
   * @category Float & align
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showBy(align, yCoord, options) {
    const me = this, isArray3 = Array.isArray(align);
    if (isArray3 || typeof align === "number") {
      const xy = isArray3 ? align : [align, yCoord];
      align = Object.assign({
        target: new Point(xy[0] + 1, xy[1] + 1),
        // Override any matchSize that we might have in our align config.
        // Otherwise we are going to be 1px wide/high
        matchSize: false,
        align: "t0-b0"
      }, isArray3 ? yCoord : options);
    }
    me.requireSize = true;
    if (me.isVisible) {
      DomHelper.addTemporaryClass(me.element, "b-realigning", 300, me);
      me.alignTo(align);
    } else {
      return me.show({ align });
    }
  }
  /**
   * Show this widget anchored to a coordinate
   * @param {Number|Number[]} x The x position (or an array with [x,y] values) to show by
   * @param {Number} [y] The y position to show by
   * @param {AlignSpec} [options] See {@link #function-showBy} for reference
   * @category Float & align
   * @deprecated Since 5.0.2. Use {@link #function-showBy} method with the same signature.
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showByPoint() {
    VersionHelper.deprecate("Core", "6.0.0", "Widget.showByPoint() replaced by Widget.showBy() with the same signature");
    return this.showBy(...arguments);
  }
  afterShow(align, resolveFn) {
    var _a4, _b;
    const me = this;
    me.trigger("show");
    me._configuredAnchorState = me.anchor;
    (_b = (_a4 = me.owner) == null ? void 0 : _a4.onChildShow) == null ? void 0 : _b.call(_a4, me);
    me.triggerPaint();
    if (me.floating || me.positioned) {
      if (align) {
        me.alignTo(align);
      } else if (me.centered) {
        me.alignTo({
          target: me.constrainTo,
          align: "c-c"
        });
      } else if (me.forElement) {
        me.alignTo(me.forElement);
      }
    }
    resolveFn == null ? void 0 : resolveFn();
  }
  onChildHide() {
  }
  onChildShow(shown) {
    var _a4;
    if (shown.floating && ((_a4 = this.childItems) == null ? void 0 : _a4.includes[shown])) {
      this.ariaHasPopup = shown.role;
      this.ariaElement.setAttribute("aria-owns", shown.id);
    }
  }
  triggerPaint() {
    const me = this, { element, toCallWhenVisible } = me, firstPaint = !me.isPainted;
    if (me.isVisible) {
      if (firstPaint) {
        me.getConfig("scrollable");
        if (me.scaleToFitWidth && !me.monitorResize) {
          me.onParentElementResize = me.onParentElementResize.bind(me);
          ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);
          me.updateScale();
        }
        if (!me.hideBryntumDomMessage && (me.isTaskBoardBase || me.isGridBase || me.isCalendar)) {
          element.insertBefore(new Comment("POWERED BY BRYNTUM (https://bryntum.com)"), element.firstChild);
        }
        if (me.onConnectedCallback && globalThis.ResizeObserver) {
          me.connectedObserver = new ResizeObserver(() => {
            if (me.isElementConnected && !element.isConnected) {
              me.onConnectedCallback(false);
              me.isElementConnected = false;
            } else if (!me.isElementConnected && element.isConnected) {
              me.onConnectedCallback(true, me.isElementConnected == null);
              me.isElementConnected = true;
            }
          });
          me.connectedObserver.observe(element);
        }
      }
      me.eachWidget(widgetTriggerPaint, false);
      if (firstPaint) {
        me.getConfig("tooltip");
        if (!_Widget.Ripple && _Widget.RippleClass) {
          _Widget.Ripple = new _Widget.RippleClass({
            rootElement: me.rootElement
          });
        }
        if (globalThis.DocsBrowser && me.floating && me.closest((w) => {
          var _a4;
          return (_a4 = w.element) == null ? void 0 : _a4.closest(".fiddlePanelResult,.b-owned-by-fiddle");
        })) {
          element.classList.add("b-owned-by-fiddle");
        }
      }
      me.isPainted = true;
      firstPaint && me.triggerConfigs("paint");
      me.onInternalPaint({ firstPaint });
      me.trigger("paint", { firstPaint });
      if (toCallWhenVisible == null ? void 0 : toCallWhenVisible.size) {
        for (const { callback, thisObj, args } of toCallWhenVisible.values()) {
          me.callback(callback, thisObj, args);
        }
        toCallWhenVisible.clear();
      }
      if (firstPaint) {
        if (me.monitorResize && !me.scaleToFitWidth) {
          ResizeMonitor.onElementResize([{ target: element }]);
        }
      }
    }
  }
  onInternalPaint() {
  }
  cancelHideShowAnimation() {
    const me = this, { currentAnimation, element } = me;
    if (currentAnimation) {
      me.isAnimating = false;
      if (element.classList.contains("b-hiding")) {
        element.classList.remove("b-hiding");
        me._hidden = false;
      }
      currentAnimation.detacher();
      currentAnimation.resolve();
      element.style.transition = element.style[currentAnimation.styleProp] = "";
      me.currentAnimation = null;
      me.trigger(`${currentAnimation.showing ? "show" : "hide"}AnimationEnd`);
    }
  }
  afterHideShowAnimate(currentAnimation) {
    const me = this;
    if (currentAnimation === me.currentAnimation) {
      me.element.classList.remove("b-hiding");
      me.cancelHideShowAnimation();
      if (me._hidden) {
        me.afterHideAnimation();
      }
    }
  }
  /**
   * Temporarily changes the {@link #property-isVisible} to yield `false` regardless of this
   * Widget's true visibility state. This can be useful for suspending operations which rely on
   * the {@link #property-isVisible} property.
   *
   * This increments a counter which {@link #function-resumeVisibility} decrements.
   * @internal
   */
  suspendVisibility() {
    this._visibilitySuspended = (this._visibilitySuspended || 0) + 1;
    Object.defineProperty(this, "isVisible", returnFalseProp);
  }
  /**
   * Resumes visibility. If the suspension counter is returned to zero by this, then the
   * {@link #event-paint} event is triggered, causing a cascade of `paint` events on all
   * descendants. This can be prevented by passing `false` as the only parameter.
   * @param {Boolean} [triggerPaint=true] Trigger the {@link #event-paint} event.
   * @internal
   */
  resumeVisibility(triggerPaint = true) {
    if (!--this._visibilitySuspended) {
      delete this.isVisible;
      if (triggerPaint) {
        this.triggerPaint();
      }
    }
  }
  /**
   * Hide widget
   * @param {Boolean} animate Pass `true` (default) to animate the hide action
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget has been hidden
   */
  hide(animate = true) {
    return new Promise((resolve) => {
      const me = this, {
        element,
        lastAlignSpec
      } = me, { style } = element, hideAnimation = animate && me.hideAnimation;
      me.clearTimeout("scrollListenerTimeout");
      me.clearTimeout("resizeListenerTimeout");
      if (!me._hidden && me.trigger("beforeHide", { animate }) !== false) {
        me._hidden = true;
        if (lastAlignSpec) {
          lastAlignSpec.targetOutOfView = null;
          if (lastAlignSpec.monitorIntersection) {
            me.intersectionObserver.takeRecords();
            me.intersectionObserver.unobserve(lastAlignSpec.target);
          }
        }
        me.onConfigChange({
          name: "hidden",
          value: true,
          was: false,
          config: me.$meta.configs.hidden
        });
        if (!element) {
          resolve();
          return;
        }
        if (element.contains(DomHelper.getActiveElement(element))) {
          me.revertFocus(true);
        }
        if (me.isDestroyed) {
          resolve();
          return;
        }
        me.cancelHideShowAnimation();
        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0], animProps = hideAnimation[styleProp];
          if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
            const currentAnimation = me.currentAnimation = {
              hiding: true,
              styleProp,
              resolve
            };
            element.classList.add("b-hiding");
            me.isAnimating = true;
            me.currentAnimation.detacher = EventHelper.onTransitionEnd({
              element,
              property: styleProp,
              duration: parseDuration(animProps.duration) + 20,
              handler: () => me.afterHideShowAnimate(currentAnimation),
              thisObj: me
            });
            style[styleProp] = animProps.from;
            DomHelper.getStyleValue(element, styleProp);
            style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
            style[styleProp] = animProps.to;
          } else {
            element.classList.add("b-hidden");
          }
        } else {
          element.classList.add("b-hidden");
        }
        me.afterHide(!hideAnimation && resolve, hideAnimation);
      }
    });
  }
  realignOnTransitionEnd(event) {
    this.doHideOrRealign(event);
  }
  doHideOrRealign({ target, isTrusted }) {
    const me = this, {
      lastAlignSpec,
      element
    } = me, anchoredTo = lastAlignSpec == null ? void 0 : lastAlignSpec.anchoredTo, lastTarget = lastAlignSpec == null ? void 0 : lastAlignSpec.target, position = lastAlignSpec == null ? void 0 : lastAlignSpec.position, activeEl = DomHelper.getActiveElement(me);
    if (
      // If it's a synthesized scroll event (such as from our ResizeMonitor polyfill), ignore it.
      !isTrusted || // Realign happens on frame, might have been removed from DOM so check whether it has layout
      !hasLayout(element) || // event.target might be missing with LockerService enabled. we still need to call the logic as it does not
      // depend much on the scroll target
      target && // If the scroll is inside our element, ignore it.
      (element.contains(target) || target.nodeType === Element.ELEMENT_NODE && me.owns(target) || // If we're scrolling because a focused textual input field which we contain is being shifted into view,
      // we must not reposition - we'll just move with the document content.
      target.nodeType === Element.DOCUMENT_NODE && element.contains(activeEl) && textInputTypes[activeEl] && globalThis.innerHeight < document.body.offsetHeight)
    ) {
      return;
    }
    if (lastAlignSpec.aligningToElement) {
      const newTarget = DomHelper.isInView(lastTarget, false, me);
      if (newTarget && newTarget.equals(lastAlignSpec.targetRect)) {
        return;
      }
    }
    const xy = me.scrollAction === "hide" && me.getXY();
    me.realign();
    if (!me.isDestroyed && isVisible(element) && me.scrollAction === "hide") {
      const [newX, newY] = me.getXY(), moved = newX !== xy[0] || newY !== xy[1];
      if ((lastAlignSpec == null ? void 0 : lastAlignSpec.aligningToEvent) || (moved || (lastTarget == null ? void 0 : lastTarget.$$name) === "Point" || position) && (!anchoredTo || !hasLayout(anchoredTo) || target && DomHelper.isDescendant(target, anchoredTo))) {
        me.hide();
      }
    }
  }
  afterHide(resolveFn = null, hideAnimation = this.hideAnimation) {
    var _a4, _b;
    const me = this;
    me._anchor = me._configuredAnchorState;
    me.removeTransientListeners();
    if (!hideAnimation) {
      me.afterHideAnimation();
    }
    me.trigger("hide");
    (_b = (_a4 = me.owner) == null ? void 0 : _a4.onChildHide) == null ? void 0 : _b.call(_a4, me);
    resolveFn && resolveFn();
  }
  removeTransientListeners() {
    var _a4, _b;
    const me = this, { targetObserver } = me;
    me.clearTimeout("resizeListenerTimeout");
    me.clearTimeout("scrollListenerTimeout");
    if (targetObserver) {
      targetObserver.disconnect();
      delete me.targetObserver;
    }
    me.documentScrollListener = (_a4 = me.documentScrollListener) == null ? void 0 : _a4.call(me);
    me.targetRootScrollListener = (_b = me.targetRootScrollListener) == null ? void 0 : _b.call(me);
    if (me.observedTargetEl) {
      ResizeMonitor.removeResizeListener(me.observedTargetEl, me.onTargetResize);
      me.observedTargetEl = false;
    }
    if (me.observedConstrainEl) {
      ResizeMonitor.removeResizeListener(me.observedConstrainEl, me.onAlignConstraintChange);
      me.observedConstrainEl = false;
    }
  }
  afterHideAnimation() {
    const me = this, { element } = me;
    if (me.floating && me.floatRoot.contains(element)) {
      element.remove();
    } else {
      element.classList.add("b-hidden");
    }
    if (me.defaultAnchorBackgroundColor) {
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
  }
  changeHidden(value) {
    const me = this;
    let ret;
    if (me.isConfiguring) {
      ret = Boolean(value);
      me.element.classList[value ? "add" : "remove"]("b-hidden");
    } else {
      me.trigger("beforeChangeHidden", { hidden: value });
      if (value) {
        me.hide();
      } else {
        me.show();
      }
    }
    return ret;
  }
  /**
   * Get id assigned by user (not generated id)
   * @returns {String}
   * @readonly
   * @private
   * @category Misc
   */
  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }
  /**
   * Get this Widget's parent when used as a child in a {@link Core.widget.Container},
   * @member {Core.widget.Widget} parent
   * @readonly
   * @category Widget hierarchy
   */
  /**
   * The owning Widget of this Widget. If this Widget is directly contained (that is it is one
   * of the {@link Core.widget.Container#property-items} of a Container), __this property will
   * be read-only, and will refer to the the containing Widget__.
   *
   * If this property has not been set and this is a `Popup` with a {@link Core.widget.Popup#config-forElement},
   * this config will refer to that element's encapsulating Widget.
   *
   * If this Widget is floating, this property should be set by the developer.
   *
   * Registering with an `owner` creates a lifecycle relationship with that owning Widget. When
   * the `owner` is destroyed this widget will also be destroyed.
   *
   * A widget can unregister from its `owner` and break this relationship at any time by setting
   * the property to `null`. It is then the developer's responsibility to ensure that this Widget
   * is destroyed.
   * @member {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get owner() {
    return this.parent || this._owner || this.containingWidget;
  }
  changeOwner(owner) {
    if (!this.parent) {
      return owner;
    }
  }
  updateOwner(owner, previousOwner) {
    const { id } = this;
    if (previousOwner) {
      previousOwner.ownedWidgets && delete previousOwner.ownedWidgets[id];
      DomHelper.removeAttributeValue(previousOwner.ariaElement, "aria-owns", id);
    }
    if (owner) {
      (owner.ownedWidgets || (owner.ownedWidgets = {}))[id] = this;
      DomHelper.addAttributeValue(owner.ariaElement, "aria-owns", id);
    }
  }
  get containingWidget() {
    var _a4, _b;
    let result = this.parent;
    if (!result) {
      const owningEl = ((_a4 = this.forElement) == null ? void 0 : _a4.nodeType) === Element.ELEMENT_NODE ? this.forElement : (_b = this.element) == null ? void 0 : _b.parentNode;
      result = (owningEl == null ? void 0 : owningEl.closest(".b-widget")) && _Widget.fromElement(owningEl);
    }
    return result;
  }
  /**
   * Get this Widget's previous sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the previous sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get previousSibling() {
    return this.getSibling(-1);
  }
  /**
   * Get this Widget's next sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the next sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get nextSibling() {
    return this.getSibling(1);
  }
  getSibling(increment) {
    const me = this, { parent } = me, siblings = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll(".b-widget"));
    return parent ? siblings[siblings.indexOf(me) + increment] : _Widget.fromElement(siblings[siblings.indexOf(me.element) + increment]);
  }
  /**
   * Looks up the {@link #property-owner} axis to find an ancestor which matches the passed selector.
   * The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} [selector] A Type identifier or selection function. If not provided, this method returns
   * the {@link #property-owner} of this widget
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @returns {Core.widget.Widget|*}
   * @category Widget hierarchy
   */
  up(selector, deep, limit) {
    var _a4;
    const { owner } = this;
    return selector ? (_a4 = owner == null ? void 0 : owner.closest) == null ? void 0 : _a4.call(owner, selector, deep, limit) : owner;
  }
  /**
   * Starts with this Widget, then Looks up the {@link #property-owner} axis to find an ancestor which matches the
   * passed selector. The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} selector A Type identifier or selection function.
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @category Widget hierarchy
   */
  closest(selector, deep, limit) {
    const limitType = typeof limit, numericLimit = limitType === "number", selectorLimit = limitType === "string";
    for (let result = this, steps = 1; result; result = result.owner, steps++) {
      if (_Widget.widgetMatches(result, selector, deep)) {
        return result;
      }
      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && _Widget.widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }
  /**
   * Returns `true` if this Widget owns the passed Element, Event or Widget. This is based on the widget hierarchy,
   * not DOM containment. So an element in a `Combo`'s dropdown list will be owned by the `Combo`.
   * @param {HTMLElement|Event|Core.widget.Widget} target The element event or Widget to test for being
   * within the ownership tree of this Widget.
   * @category Widget hierarchy
   */
  owns(target) {
    if (target) {
      if ("eventPhase" in target) {
        target = target.target;
      }
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (this.element.contains(target)) {
          return true;
        }
        target = _Widget.fromElement(target);
      }
      while (target) {
        if (target === this) {
          return true;
        }
        target = target.owner;
      }
    }
    return false;
  }
  /**
   * Iterate over all ancestors of this widget.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn Function to execute for all ancestors. Terminate iteration by returning `false`.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachAncestor(fn) {
    let ancestor = this.owner;
    while (ancestor) {
      if (fn(ancestor) === false) {
        return false;
      }
      ancestor = ancestor.owner;
    }
    return true;
  }
  changeMaximizeOnMobile(maximizeOnMobile) {
    const me = this;
    if (me.floating && BrowserHelper.isMobile) {
      const { initialConfig } = me;
      if (maximizeOnMobile) {
        me.centered = me.modal = false;
        me.maximized = true;
      } else {
        me.centered = initialConfig.modal;
        me.modal = initialConfig.centered;
        me.maximized = initialConfig.maximized;
      }
    }
  }
  changeMonitorResize(monitorResize, oldMonitorResize) {
    const result = this.scaleToFitWidth ? false : Boolean(monitorResize);
    if (result !== Boolean(oldMonitorResize)) {
      return result;
    }
  }
  updateMonitorResize(monitorResize) {
    const me = this;
    if (!hasOwn5(me, "onElementResize")) {
      me.onElementResize = me.onElementResize.bind(me);
    }
    ResizeMonitor[monitorResize ? "addResizeListener" : "removeResizeListener"](me.element, me.onElementResize);
  }
  changeReadOnly(readOnly) {
    readOnly = Boolean(readOnly);
    if (Boolean(this._readOnly) !== readOnly) {
      return readOnly;
    }
  }
  updateReadOnly(readOnly) {
    var _a4;
    (_a4 = this.element) == null ? void 0 : _a4.classList[readOnly ? "add" : "remove"]("b-readonly");
    if (!this.isConfiguring) {
      this.eachWidget((widget) => {
        if (widget.ignoreParentReadOnly) {
          return;
        }
        if (!("_originalReadOnly" in widget)) {
          widget._originalReadOnly = widget.config.readOnly || false;
        }
        widget.readOnly = readOnly || widget._originalReadOnly;
      }, false);
      this.trigger("readOnly", { readOnly });
    }
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn A function to execute upon each descendant widget.
   * Iteration terminates if this function returns `false`.
   * @param {Core.widget.Widget} fn.widget The current descendant widget.
   * @param {Object} fn.control An object containing recursion control options.
   * @param {Boolean} fn.control.down A copy of the `deep` parameter. This can be adjusted by `fn` to decide which
   * widgets should be recursed. This value will always be the value of `deep` on entry and the value of `control.down`
   * upon return determines the recursion into the current widget.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachWidget(fn, deep = true, itemsBeforeAux) {
    const widgets = itemsBeforeAux ? this.childItemsOrderedByRelevance : this.childItems, length = (widgets == null ? void 0 : widgets.length) || 0, control = {};
    for (let i = 0; i < length; i++) {
      const widget = widgets[i];
      control.down = deep;
      if (fn(widget, control) === false) {
        return false;
      }
      if (control.down && widget.eachWidget) {
        if (widget.eachWidget(fn, deep, itemsBeforeAux) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Returns an array of all descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to include the widget in the results.
   * @returns {Core.widget.Widget[]} All matching descendant widgets.
   * @category Widget hierarchy
   */
  queryAll(filter) {
    const result = [];
    this.eachWidget((w) => {
      if (filter(w)) {
        result.push(w);
      }
    });
    return result;
  }
  /**
   * Returns the first descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to return the widget as the sole result.
   * @returns {Core.widget.Widget} The first matching descendant widget.
   * @category Widget hierarchy
   */
  query(filter, itemsBeforeAux) {
    let result = null;
    this.eachWidget((w) => {
      if (filter(w)) {
        result = w;
        return false;
      }
    }, true, itemsBeforeAux);
    return result;
  }
  /**
   * Get a widget by ref, starts on self and traverses up the owner hierarchy checking `widgetMap` at each level.
   * Not checking the top level widgetMap right away to have some acceptance for duplicate refs.
   * @param {String} ref ref to find
   * @returns {Core.widget.Widget}
   * @internal
   * @category Widget hierarchy
   */
  getWidgetByRef(ref) {
    var _a4, _b;
    if (ref instanceof _Widget) {
      return ref;
    }
    return ((_a4 = this == null ? void 0 : this.widgetMap) == null ? void 0 : _a4[ref]) || ((_b = this == null ? void 0 : this.owner) == null ? void 0 : _b.getWidgetByRef(ref));
  }
  onFocusIn(e) {
    const me = this, { element } = me;
    me.containsFocus = true;
    me.focusInEvent = e;
    if (me.floating || me.positioned) {
      me.toFront();
    }
    element.classList.add("b-contains-focus");
    me.updateAriaLabel(me.localizeProperty("ariaLabel"));
    me.updateAriaDescription(me.localizeProperty("ariaDescription"));
    if (element.contains(e._target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: "onInternalKeyDown",
        thisObj: me
      });
    }
    me.trigger("focusin", e);
  }
  onFocusOut(e) {
    const me = this;
    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }
    if (!me.isDestroyed) {
      if (!e.relatedTarget) {
        me.revertFocus(!me.isVisible);
      }
      me.containsFocus = false;
      me.element.classList.remove("b-contains-focus");
      me.updateAriaLabel(me.localizeProperty("ariaLabel"));
      me.updateAriaDescription(me.localizeProperty("ariaDescription"));
      me.trigger("focusout", e);
    }
  }
  /**
   * Returns a function that will set the focus (`document.activeElement`) to the most consistent element possible
   * based on the focus state at the time this method was called. Derived classes can implement `captureFocusItem()`
   * to refine this process to include logical items (e.g., a grid cell) that would be more stable than DOM element
   * references.
   *
   * If this widget does not contain the focus, the returned function will do nothing.
   * @returns {Function}
   * @internal
   */
  captureFocus() {
    const me = this, activeElementWas = DomHelper.getActiveElement(me), restore = me.contains(activeElementWas) && me.captureFocusItem(activeElementWas);
    return (scrollIntoView, force) => {
      if (restore && !me.isDestroying) {
        const activeElementNow = DomHelper.getActiveElement(me);
        if (activeElementNow !== activeElementWas || force) {
          restore(scrollIntoView);
        }
      }
    };
  }
  /**
   * This method is called by `captureFocus()` when this widget contains the focus and it returns a function that
   * restores the focus to the correct internal element. The returned function is only called if the current
   * `document.activeElement` is different from the passed `activeElement`.
   *
   * This method can be replaced by derived classes to capture stable identifiers for the currently focused, logical
   * item (for example, a cell of a grid).
   *
   * @param {HTMLElement} activeElement The current `document.activeElement`.
   * @returns {Function} Returns a function that accepts a boolean argument. Defaults to `true`, `false` attempts to
   * focus without scrolling.
   * @internal
   */
  captureFocusItem(activeElement) {
    return (scrollIntoView = true) => {
      if (this.contains(activeElement)) {
        scrollIntoView ? activeElement.focus() : activeElement.focus({ preventScroll: true });
      }
    };
  }
  /**
   * Returns `true` if this widget is or contains the specified element or widget.
   * @param {HTMLElement|Core.widget.Widget} elementOrWidget The element or widget
   * @param {Boolean} [strict] Pass `true` to test for strict containment (if `elementOrWidget` is this widget, the
   * return value will be `false`).
   * @returns {Boolean}
   * @category Widget hierarchy
   */
  contains(elementOrWidget, strict) {
    const { element } = this;
    if (elementOrWidget && element) {
      if (elementOrWidget.isWidget) {
        elementOrWidget = elementOrWidget.element;
      }
      return element.contains(elementOrWidget) && (!strict || element !== elementOrWidget);
    }
  }
  /**
   * If this Widget contains focus, focus is reverted to the source from which it entered if possible,
   * or to a close relative if not.
   * @param {Boolean} [force] Pass as `true` to move focus to the previously focused item, or the
   * closest possible relative even if this widget does not contain focus.
   * @advanced
   */
  revertFocus(force) {
    var _a4;
    const me = this, activeElement = DomHelper.getActiveElement(me);
    let target = (_a4 = me.focusInEvent) == null ? void 0 : _a4.relatedTarget;
    if (force || me.containsFocus && (target == null ? void 0 : target.nodeType) === Element.ELEMENT_NODE && me.element.contains(activeElement)) {
      if (!target || !DomHelper.isFocusable(target)) {
        target = me.getFocusRevertTarget();
      }
      me._isRevertingFocus = true;
      if (target && DomHelper.isFocusable(target)) {
        target._isRevertingFocus = true;
        target.focus({ preventScroll: true });
        target._isRevertingFocus = false;
      } else {
        activeElement == null ? void 0 : activeElement.blur();
      }
      me._isRevertingFocus = false;
    }
  }
  /**
   * This method finds a close sibling (or parent, or parent's sibling etc. recursively) to which focus
   * can be directed in the case of revertFocus not having a focusable element from our focusInEvent.
   *
   * This can happen when the "from" component is destroyed or hidden. We should endeavour to prevent
   * focus escaping to `document.body` for accessibility and ease of use, and keep focus close.
   * @internal
   */
  getFocusRevertTarget() {
    var _a4;
    const me = this, {
      owner,
      focusInEvent
    } = me, searchDirection = focusInEvent ? focusInEvent.backwards ? 1 : -1 : -1;
    let target = focusInEvent && focusInEvent.relatedTarget;
    const toComponent = target && _Widget.fromElement(target);
    if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || toComponent && !toComponent.isFocusable)) {
      target = null;
      if (owner.eachWidget) {
        const siblings = [];
        owner.eachWidget((w) => {
          if (w === me || w.isFocusable) {
            siblings.push(w);
          }
        }, false);
        if (siblings.length > 1) {
          const myIndex = siblings.indexOf(me);
          target = siblings[myIndex + searchDirection] || siblings[myIndex - searchDirection];
        }
      }
      if (!target && owner.isFocusable) {
        target = owner;
      }
      target = target ? target.focusElement : (_a4 = owner.getFocusRevertTarget) == null ? void 0 : _a4.call(owner);
    }
    return target;
  }
  /**
   * Returns a `DomClassList` computed from the `topMostBase` (e.g., `Widget` or `Panel`) with the given `suffix`
   * appended to each `widgetClass`.
   * @param {Function} topMostBase The top-most base class constructor at which to start gathering classes.
   * @param {String} [suffix] An optional suffix to apply to all widget classes.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  getStaticWidgetClasses(topMostBase, suffix) {
    const classList = new DomClassList(), hierarchy = this.$meta.hierarchy;
    let cls, i, name, widgetClass, widgetClassProperty;
    for (i = hierarchy.indexOf(topMostBase); i < hierarchy.length; ++i) {
      cls = hierarchy[i];
      widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, "widgetClass");
      if (widgetClassProperty == null ? void 0 : widgetClassProperty.get) {
        widgetClass = widgetClassProperty.get.call(this);
      } else {
        name = hasOwn5(cls, "$$name") || hasOwn5(cls, "$name") || hasOwn5(cls, "_$name") ? cls.$$name : cls.name;
        if (name.length < 3 || name.includes("$")) {
          console.warn(
            `Class "${name}" extending "${cls.$name}" should have "$name" static getter with no less than 3 chars.`
          );
        }
        widgetClass = `b-${name.toLowerCase()}`;
      }
      if (widgetClass) {
        classList.add(suffix ? widgetClass + suffix : widgetClass);
      }
    }
    return classList;
  }
  get rootUiClass() {
    return _Widget;
  }
  /**
   * Returns the `DomClassList` for this widget's class. This object should not be mutated.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get staticClassList() {
    const { $meta: meta } = this;
    let classList = meta.staticClassList;
    if (!classList) {
      meta.staticClassList = classList = this.getStaticWidgetClasses(_Widget);
      BrowserHelper.isTouchDevice && classList.add("b-touch");
    }
    return classList;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as an array of strings.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   *      [
   *          'b-widget-foo', 'b-field-foo', 'b-textfield-foo', 'b-pickerfield-foo', 'b-combo-foo',
   *          'b-widget-bar', 'b-field-bar', 'b-textfield-bar', 'b-pickerfield-bar', 'b-combo-bar'
   *      ]
   *
   * @returns {String[]}
   * @internal
   * @category DOM
   */
  get uiClasses() {
    this.getConfig("ui");
    return this._uiClasses;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as a `DomClassList` instance.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-field-ui-foo'       : 1,
   *          'b-textfield-ui-foo'   : 1,
   *          'b-pickerfield-ui-foo' : 1,
   *          'b-combo-ui-foo'       : 1,
   *
   *          'b-field-ui-bar'       : 1,
   *          'b-textfield-ui-bar'   : 1,
   *          'b-pickerfield-ui-bar' : 1,
   *          'b-combo-ui-bar'       : 1
   *      });
   * ```
   *
   * A Panel with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-panel-ui-foo' : 1,
   *          'b-panel-ui-bar' : 1
   *      });
   * ```
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get uiClassList() {
    this.getConfig("ui");
    return this._uiClassList;
  }
  /**
   * Used by the Widget class internally to create CSS classes based on this Widget's
   * inheritance chain to allow styling from each level to apply.
   *
   * For example Combo would yield `"["b-widget", "b-field", "b-textfield", "b-pickerfield", "b-combo"]"`
   *
   * May be implemented in subclasses to add or remove classes from the super.widgetClassList
   * @returns {String[]} The css class list named using the class name.
   * @internal
   * @category DOM
   */
  get widgetClassList() {
    const me = this, { cls, defaultCls, uiClasses } = me;
    let { staticClassList } = me;
    if (defaultCls || cls) {
      staticClassList = staticClassList.clone();
      defaultCls && staticClassList.assign(defaultCls);
      cls && staticClassList.assign(cls);
    }
    const classList = staticClassList.values;
    uiClasses && classList.push(...uiClasses);
    me.floating && classList.push("b-floating");
    if (me.collapsify === "hide") {
      classList.push("b-collapsify-hide");
    }
    return classList;
  }
  changeCls(cls) {
    return DomClassList.from(cls);
  }
  updateCls(cls, was) {
    if (!this.isConfiguring && !this.isComposable) {
      const { element } = this;
      if (was) {
        ObjectHelper.getTruthyKeys(was).forEach((c) => element.classList.remove(c));
      }
      cls.assignTo(element);
    }
  }
  changeContentElementCls(cls) {
    return DomClassList.from(cls);
  }
  changeHtmlCls(cls) {
    return DomClassList.from(cls);
  }
  changeDefaultCls(cls) {
    return DomClassList.from(
      cls,
      /* returnEmpty */
      true
    );
  }
  changeUi(ui) {
    return DomClassList.from(ui);
  }
  updateUi(ui) {
    let uiClassList = null, cls, suffix;
    if (ui) {
      const staticClassList = this.getStaticWidgetClasses(this.rootUiClass);
      for (suffix in ui) {
        if (ui[suffix]) {
          for (cls in staticClassList) {
            if (staticClassList[cls]) {
              (uiClassList || (uiClassList = new DomClassList()))[`${cls}-ui-${suffix}`] = 1;
            }
          }
        }
      }
    }
    this._uiClasses = uiClassList == null ? void 0 : uiClassList.values;
    this._uiClassList = uiClassList;
  }
  //endregion
  //region Cache
  /**
   * Gets dom elements in the view. Caches the results for faster future calls.
   * @param {String} query CSS selector
   * @param {Boolean} children true to fetch multiple elements
   * @param {HTMLElement} element Element to use as root for the query, defaults to the views outermost element
   * @returns {HTMLElement|HTMLElement[]|null} A single element or an array of elements (if parameter children is set to true)
   * @internal
   * @category DOM
   */
  fromCache(query, children = false, element = this.element) {
    var _a4;
    if (!element) {
      return null;
    }
    const me = this;
    if (!((_a4 = me.cache) == null ? void 0 : _a4[query])) {
      if (!me.cache) {
        me.cache = {};
      }
      return me.cache[query] = children ? DomHelper.children(element, query) : element.querySelector(query);
    }
    return me.cache[query];
  }
  /**
   * Clear caches, forces all calls to fromCache to requery dom. Called on render/rerender.
   * @internal
   * @category DOM
   */
  emptyCache() {
    if (this.cache) {
      this.cache = {};
    }
  }
  //endregion
  //region Mask
  changeMasked(mask, maskInstance) {
    var _a4;
    if (((_a4 = this.masked) == null ? void 0 : _a4.type) === "trial") {
      return;
    }
    if (mask === true || mask === "") {
      mask = "\xA0";
    }
    if (maskInstance && !maskInstance.isDestroyed) {
      if (typeof mask === "string") {
        maskInstance.text = mask;
        mask = maskInstance;
      } else if (mask) {
        maskInstance.setConfig(mask);
        mask = maskInstance;
      } else {
        maskInstance.destroy();
      }
    } else if (mask) {
      const Mask2 = _Widget.resolveType("mask");
      mask = Mask2.mergeConfigs(this.maskDefaults, mask);
      mask.owner = this;
      mask = Mask2.mask(mask);
    }
    return mask || null;
  }
  onMaskAutoClose(mask) {
    if (mask.isDestroyed && mask === this.masked) {
      this.masked = null;
    }
  }
  /**
   * Mask the widget, showing the specified message
   * @param {String|MaskConfig} msg Mask message (or a {@link Core.widget.Mask} config object
   * @returns {Core.widget.Mask}
   */
  mask(msg) {
    this.masked = msg;
    return this.masked;
  }
  /**
   * Unmask the widget
   */
  unmask() {
    this.masked = null;
  }
  //endregion
  //region Monitor resize
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }
  onElementResize(resizedElement, lastRect) {
    var _a4;
    const me = this, { element } = me, oldWidth = (_a4 = me._width) != null ? _a4 : me._oldWidth, oldHeight = me._height, newWidth = element.offsetWidth, newHeight = element.offsetHeight;
    if (me.floating && lastRect) {
      me.onFloatingWidgetResize(...arguments);
    }
    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
      me.trigger("resize", { width: newWidth, height: newHeight, oldWidth, oldHeight });
    }
  }
  onFloatingWidgetResize(resizedElement, lastRect, myRect) {
    const me = this, {
      lastAlignSpec,
      constrainTo
    } = me;
    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height, widthChange = !lastRect || myRect.width !== lastRect.width, failsConstraint = constrainTo && !Rectangle.from(constrainTo).contains(Rectangle.from(me.element, null, true));
      if (heightChange && lastAlignSpec.zone !== 2 || widthChange && lastAlignSpec.zone !== 1 || failsConstraint) {
        me.requestAnimationFrame(() => me.realign());
      }
    }
  }
  updateScale() {
    const me = this, element = me.element, parentElement = element.parentElement;
    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }
    element.style.display = "none";
    const rect = Rectangle.client(parentElement), scale = rect.width / me.configuredWidth, adjustedScale = me.scale = me.allowGrowWidth ? Math.min(scale, 1) : scale;
    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = "top left";
    element.style.display = "";
    if (me.allowGrowWidth && scale > 1) {
      me.width = me.configuredWidth * scale;
    }
  }
  onParentElementResize(event) {
    this.updateScale();
  }
  //endregion
  /**
   * Returns a `TRBL` array of values parse from the passed specification. This can be used to parse`
   * a value list for `margin` or `padding` or `border-width` etc - any CSS value which takes a `TRBL` value.
   * @param {Number|String|String[]} values The `TRBL` value
   * @param {String} [units=px] The units to add to values which are specified as numeric.
   * @internal
   */
  parseTRBL(values, units = "px") {
    values = values || 0;
    if (typeof values === "number") {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }
    const parts = values.split(" "), len = parts.length;
    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }
    return [
      isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0],
      isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2],
      isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3],
      isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]
    ];
  }
  // Returns root node for this widget, either a document or a shadowRoot
  get documentRoot() {
    var _a4;
    return ((_a4 = this.owner) == null ? void 0 : _a4.documentRoot) || this.element.getRootNode();
  }
  // Returns the root from which to add global events. Prioritizes owner last.
  get eventRoot() {
    var _a4, _b;
    return ((_a4 = this.element) == null ? void 0 : _a4.isConnected) ? DomHelper.getRootElement(this.element) : ((_b = this.owner) == null ? void 0 : _b.eventRoot) || this._rootElement;
  }
  // Returns top most DOM element of the visible DOM tree for this widget element, either document.body or a shadowRoot
  get rootElement() {
    var _a4, _b;
    const me = this;
    if (!me._rootElement) {
      let root = ((_a4 = me.owner) == null ? void 0 : _a4.rootElement) || DomHelper.getRootElement(me.forElement || (((_b = me.element) == null ? void 0 : _b.isConnected) ? me.element : me.getRenderContext()[0] || me.element));
      if (!root) {
        root = document.body;
      }
      me._rootElement = root;
    }
    return me._rootElement;
  }
  get floatRoot() {
    var _a4;
    const me = this, { rootElement } = me;
    let { floatRoot } = rootElement;
    if (!floatRoot) {
      const { outerCls } = _Widget, themeName = (_a4 = DomHelper.getThemeInfo(null, rootElement)) == null ? void 0 : _a4.name;
      if (!DomHelper.isValidFloatRootParent(rootElement)) {
        throw new Error("Attaching float root to wrong root");
      }
      if (themeName) {
        outerCls.push(`b-theme-${themeName.toLowerCase()}`);
      }
      floatRoot = rootElement.floatRoot = DomHelper.createElement({
        className: `b-float-root ${outerCls.join(" ")}`,
        parent: rootElement
      });
      floatRoots.push(floatRoot);
      if (BrowserHelper.isAndroid) {
        floatRoot.style.height = `${screen.height}px`;
        EventHelper.on({
          element: globalThis,
          orientationchange: () => floatRoot.style.height = `${screen.height}px`,
          thisObj: this
        });
      }
      GlobalEvents_default.ion({
        theme: ({ theme, prev }) => {
          floatRoot.classList.add(`b-theme-${theme.toLowerCase()}`);
          floatRoot.classList.remove(`b-theme-${prev.toLowerCase()}`);
        }
      });
    } else if (!rootElement.contains(floatRoot)) {
      rootElement.appendChild(floatRoot);
    }
    return floatRoot;
  }
  get floatRootMaxZIndex() {
    let max = 1;
    Array.from(this.floatRoot.children).forEach((child) => {
      const zIndex = parseInt(getComputedStyle(child).zIndex || 0, 10);
      if (zIndex > max) {
        max = zIndex;
      }
    });
    return max;
  }
  /**
   * This property is a shortcut to the static {@link #property-accessibility-static} property.
   *
   * It does *not* operate on a single widget basis.
   * @property {Boolean}
   */
  get accessibility() {
    return this.constructor.accessibility;
  }
  /**
   * Set this static flag to `true` to enable accessibility features.
   *
   * This includes tooltip activation upon __focus__ of a tooltip-enabled element.
   *
   * For example navigating onto a button, or input field, or grid cell with a cell tooltip
   * enabled will show the tooltip if this flag is set.
   * @property {Boolean}
   */
  static get accessibility() {
    return document.body.classList.contains("b-accessibility");
  }
  set accessibility(accessibility) {
    this.constructor.accessibility = accessibility;
  }
  static set accessibility(accessibility) {
    document.body.classList.toggle("b-accessibility", Boolean(accessibility));
  }
  static get floatRoots() {
    return floatRoots;
  }
  static removeFloatRoot(floatRoot) {
    floatRoots.splice(floatRoots.indexOf(floatRoot), 1);
  }
  // CSS classes describing outer-most Widgets to provide styling / behavioral CSS style rules
  static get outerCls() {
    const result = ["b-outer"], { platform } = BrowserHelper;
    if (platform) {
      result.push(`b-${platform}`);
    }
    if (BrowserHelper.isTouchDevice) {
      result.push("b-touch-events");
    }
    if (BrowserHelper.isMobile) {
      result.push("b-mobile");
    }
    if (DomHelper.scrollBarWidth) {
      result.push("b-visible-scrollbar");
    } else {
      result.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      result.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      result.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      result.push("b-firefox");
    }
    if (BrowserHelper.isPhone) {
      result.push("b-phone");
    }
    if (!globalThis.ResizeObserver) {
      result.push("b-no-resizeobserver");
    }
    return result;
  }
  get isAnimating() {
    return this._isAnimatingCounter > 0;
  }
  set isAnimating(value) {
    const me = this, { _isAnimatingCounter } = me;
    me._isAnimatingCounter = Math.max(0, _isAnimatingCounter + (value ? 1 : -1));
    if (_isAnimatingCounter === 0 && value) {
      me.element.classList.add("b-animating");
      me.trigger("animationStart");
    } else if (_isAnimatingCounter === 1 && !value) {
      me.element.classList.remove("b-animating");
      me.trigger("animationEnd");
    }
  }
  // Waits until all transitions are completed
  async waitForAnimations() {
    if (this.isAnimating) {
      await this.await("animationend", { checkLog: false });
    }
  }
  // Takes a snapshot of animations running before and after the function executes and waits for any animations
  // started due to that function to finish
  // Overridden for SalesForce in WidgetOverrideExecuteAndAwaitAnimations.js due to lack of support for
  // element.getAnimations()
  async executeAndAwaitAnimations(element, fn) {
    const animationsBeforeFunction = element.getAnimations({ subtree: true });
    await fn();
    const animationsAfterFunction = element.getAnimations({ subtree: true }), animationsFromFunction = ArrayHelper.delta(animationsBeforeFunction, animationsAfterFunction).onlyInB, finiteAnimations = animationsFromFunction.filter((animation) => animation.effect.getTiming().iterations !== Infinity);
    if (finiteAnimations.length) {
      await Promise.allSettled(finiteAnimations.map((animation) => animation.finished));
    }
  }
  /**
   * Analogous to `document.querySelector`, finds the first Bryntum widget matching the passed
   * selector. Right now, only class name (lowercased) selector strings, or
   * a filter function which returns `true` for required object are allowed:
   *
   * ```javascript
   * Widget.query('grid').destroy();
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget} The first matched widget if any.
   * @category Widget hierarchy
   */
  static query(selector, deep = false) {
    const { idMap } = _Widget.identifiable;
    for (const id in idMap) {
      if (_Widget.widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }
    return null;
  }
  /**
   * Analogous to document.querySelectorAll, finds all Bryntum widgets matching the passed
   * selector. Right now, only registered widget `type` strings, or a filter function which
   * returns `true` for required object are allowed:
   *
   * ```javascript
   * let allFields = Widget.queryAll('field', true);
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget[]} The first matched widgets if any - an empty array will be returned
   * if no matches are found.
   * @category Widget hierarchy
   */
  static queryAll(selector, deep = false) {
    const { idMap } = _Widget.identifiable, result = [];
    for (const id in idMap) {
      if (_Widget.widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }
    return result;
  }
  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromElement(element, type, limit) {
    const typeOfType = typeof type;
    if (element && !element.nodeType) {
      element = element.target;
    }
    if (typeOfType === "number" || type && type.nodeType === Element.ELEMENT_NODE) {
      limit = type;
      type = null;
    }
    let target = element, depth = 0, topmost, cmpId, cmp;
    if (typeof limit !== "number") {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }
    if (typeOfType === "string") {
      type = type.toLowerCase();
    }
    while (target && target.nodeType === Element.ELEMENT_NODE && depth < limit && target !== topmost) {
      cmpId = target.dataset && target.dataset.ownerCmp || target.id;
      if (cmpId) {
        cmp = _Widget.getById(cmpId);
        if (cmp) {
          if (type) {
            if (typeOfType === "function") {
              if (type(cmp)) {
                return cmp;
              }
            } else if (_Widget.widgetMatches(cmp, type, true)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }
        depth++;
      }
      target = getParent(target);
    }
    return null;
  }
  /**
   * Returns the widget with the specified id.
   * @function getById
   * @param {String} id Id of widget to find
   * @returns {Core.widget.Widget} The widget
   * @static
   * @category Misc
   */
  /**
   * Returns the Widget which owns the passed CSS selector.
   *
   * ```javascript
   * const button = Widget.fromSelector('#my-button');
   * ```
   *
   * @param {String} selector CSS selector
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromSelector(selector) {
    const element = document.querySelector(selector);
    return element ? _Widget.fromElement(element) : null;
  }
  // NOTE: Not named `triggerChange` to not conflict with existing fn on Field
  /**
   * Triggers a 'change' event with the supplied params. After triggering it also calls `onFieldChange()` on each
   * ancestor the implements that function, supplying the same set of params.
   * @param {Object} params Event params, used both for triggering and notifying ancestors
   * @param {Boolean} [trigger] `false` to not trigger, only notifying ancestors
   * @internal
   */
  triggerFieldChange(params, trigger = true) {
    var _a4;
    if (trigger) {
      this.trigger("change", params);
    } else {
      params.source = this;
    }
    (_a4 = this.eachAncestor) == null ? void 0 : _a4.call(this, (ancestor) => {
      var _a5, _b;
      (_a5 = ancestor.onFieldChange) == null ? void 0 : _a5.call(ancestor, params);
      if ((_b = ancestor.isolateFieldChange) == null ? void 0 : _b.call(ancestor, this)) {
        return false;
      }
    });
  }
  /**
   * Returns `true` if the given `field`'s value change should be isolated (kept hidden by this widget). By default,
   * this method returns the value of {@link Core.widget.Container#config-isolateFields} for all fields.
   * @param {Core.widget.Field} field The field in question.
   * @internal
   */
  isolateFieldChange(field) {
    return this.isolateFields;
  }
  // Sets up the focus listeners, one set for every document root (shadow root or document)
  setupFocusListeners() {
    GlobalEvents_default.setupFocusListenersOnce(this.eventRoot, EventHelper);
  }
  static widgetMatches(candidate, selector, deep) {
    if (selector === "*") {
      return true;
    }
    if (typeof selector === "function") {
      return selector(candidate);
    }
    return _Widget.isType(candidate, selector, deep);
  }
  /**
   * Attached a tooltip to the specified element.
   *
   * ```javascript
   * Widget.attachTooltip(element, {
   *   text: 'Useful information goes here'
   * });
   * ```
   *
   * @param {HTMLElement} element Element to attach tooltip for
   * @param {TooltipConfig|String} configOrText Tooltip config or tooltip string, see example and source
   * @returns {HTMLElement} The passed element
   * @category Misc
   */
  static attachTooltip(element, configOrText) {
    if (typeof configOrText === "string")
      configOrText = { html: configOrText };
    _Widget.create(Object.assign({
      forElement: element
    }, configOrText), "tooltip");
    return element;
  }
  //region RTL
  // Since we use flexbox docking flips correctly out of the box. start and end values can be mapped straight to
  // left and right, for both LTR and RTL
  changeDock(dock) {
    if (dock === "start") {
      return "left";
    }
    if (dock === "end") {
      return "right";
    }
    return dock;
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    this.eachWidget((item) => {
      if (!("rtl" in item.initialConfig)) {
        item.rtl = rtl;
      }
    });
  }
  //endregion
};
/**
 * By default, on touch devices, a two finger pinch gesture where both touch points are
 * within a Bryntum widget is converted to a `CTRL/wheel` event injected at the mid-point between
 * the two initial touches.
 *
 * This is so that Scheduler and Calendar views which are configured to `zoomOnMouseWheel` will
 * zoom on pinch on touch devices.
 *
 * That disables the platform's native pinch-zooming. Set this static flag to `false` to disable
 * the conversion:
 *
 * ```javascript:
 *     Widget.convertPinchToMousewheel = false;
 * ```
 * @member {Boolean} convertPinchToMousewheel
 * @static
 */
__publicField(_Widget, "convertPinchToMousewheel", true);
var Widget = _Widget;
var proto2 = Widget.prototype;
["compose", "domSyncCallback"].forEach((fn) => proto2[fn].$nullFn = true);
Widget.initClass();
Widget.register("mask", Mask);
DomHelper.Widget = Widget;
GlobalEvents_default.Widget = Widget;
Mask.identifiable.idMap = Widget.identifiable.idMap;
Object.assign(globalThis.bryntum || (globalThis.bryntum = {}), {
  get: Widget.getById.bind(Widget),
  query: Widget.query,
  queryAll: Widget.queryAll,
  fromElement: Widget.fromElement,
  fromSelector: Widget.fromSelector
});
Widget._$name = "Widget";

// ../Core/lib/Core/widget/layout/Layout.js
var Layout = class extends Base.mixin(Events_default, Factoryable_default) {
  get contentElement() {
    var _a4;
    return (_a4 = this.owner) == null ? void 0 : _a4.contentElement;
  }
  onChildAdd(item) {
  }
  onChildRemove(item) {
  }
  renderChildren() {
    const me = this, { owner, itemCls } = me, { contentElement, items: items2 } = owner, ownerItemCls = owner.itemCls, itemCount = items2 == null ? void 0 : items2.length;
    if (itemCount) {
      owner.textContent = false;
      for (let i = 0; i < itemCount; i++) {
        const item = items2[i], { element } = item, { classList } = element;
        element.dataset.itemIndex = i;
        if (classList.contains("b-outer")) {
          classList.remove(...Widget.outerCls);
        }
        if (itemCls) {
          classList.add(itemCls);
        }
        if (ownerItemCls) {
          classList.add(ownerItemCls);
        }
        item.render(contentElement, Boolean(owner.isPainted));
      }
    }
    me.syncPendingConfigs();
    me.syncChildCount();
  }
  removeChild(child) {
    const me = this, { element } = child, { owner, itemCls } = me, { contentElement } = owner, ownerItemCls = owner.itemCls;
    if (contentElement.contains(element)) {
      element.remove();
    }
    delete element.dataset.itemIndex;
    if (itemCls) {
      element.classList.remove(itemCls);
    }
    if (ownerItemCls) {
      element.classList.remove(ownerItemCls);
    }
    me.fixChildIndices();
    me.syncChildCount();
  }
  appendChild(child) {
    const { element } = child, { owner, itemCls } = this, { contentElement } = owner, ownerItemCls = owner.itemCls;
    element.dataset.itemIndex = owner.indexOfChild(child);
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    child.render(contentElement, Boolean(owner.isPainted));
    this.syncChildCount();
  }
  insertChild(toAdd, childIndex) {
    const me = this, { element } = toAdd, { owner, itemCls } = me, { contentElement } = owner, nextSibling = DomHelper.getChild(contentElement, `[data-item-index="${childIndex}"]`), ownerItemCls = owner.itemCls;
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    contentElement.insertBefore(element, nextSibling);
    toAdd.render(null, Boolean(owner.isPainted));
    me.fixChildIndices();
    me.syncChildCount();
  }
  fixChildIndices() {
    this.owner.items.forEach((child, index) => {
      child.element.dataset.itemIndex = index;
    });
  }
  syncChildCount() {
    var _a4;
    const { owner } = this, { length } = owner.items;
    (_a4 = owner.contentElement) == null ? void 0 : _a4.classList[length === 1 ? "add" : "remove"]("b-single-child");
  }
  /**
   * Registers a layout `config` property that cannot be acted upon at this time but must wait for the `owner` to
   * fully render its elements (in particular the `contentElement`).
   * @param {String} config The name of the config to sync later.
   * @internal
   */
  syncConfigLater(config) {
    const pendingConfigs = this.pendingConfigs || (this.pendingConfigs = []);
    if (!pendingConfigs.includes(config)) {
      pendingConfigs.push(config);
    }
  }
  /**
   * Sets the specified `style` to the value of the config given its `name`.
   * @param {Object} options The name of the config with the value to apply to the given `style`.
   * @param {String} options.name The name of the config with the value to apply to the given `style`.
   * @param {String} options.style The style property to set on the `contentElement`.
   * @param {String[]} [options.classes] A list of config values that should be added as CSS classes.
   * @param {Object} [options.map] An mapping object to convert the config's value to the `style` value.
   * @internal
   */
  syncConfigStyle({ name, style, classes, map }) {
    const me = this, baseCls = `b-box-${name}-`, { contentElement } = me, raw = me[name];
    let value = (map == null ? void 0 : map[raw]) || raw;
    if (contentElement) {
      if (classes) {
        const { classList } = contentElement;
        classes.forEach((c) => {
          if (c !== value) {
            classList.remove(baseCls + c);
          }
        });
        if (classes.includes(value)) {
          classList.add(baseCls + value);
          value = "";
        }
      }
      contentElement.style[style] = value;
    } else {
      me.syncConfigLater(name);
    }
  }
  syncPendingConfigs() {
    const me = this, { pendingConfigs } = me;
    let name;
    if (pendingConfigs) {
      me.pendingConfigs = null;
      while (name = pendingConfigs.pop()) {
        me[me.$meta.configs[name].updater](me[name]);
      }
    }
  }
};
__publicField(Layout, "type", "default");
__publicField(Layout, "configurable", {
  /**
   * The owning Widget.
   * @member {Core.widget.Widget} owner
   * @readonly
   */
  /**
   * @config {Core.widget.Widget} owner
   * @private
   */
  owner: null,
  /**
   * The CSS class which should be added to the owning {@link Core.widget.Container}'s.
   * {@link Core.widget.Widget#property-contentElement}.
   * @config {String}
   */
  containerCls: "b-auto-container",
  /**
   * The CSS class which should be added to the encapsulating element of child items.
   * @config {String}
   */
  itemCls: null
});
// establish this class as the Factoryable base
__publicField(Layout, "factoryable", {
  defaultType: "default"
});
Layout.initClass();
Layout._$name = "Layout";

// ../Core/lib/Core/widget/Ripple.js
var lastTouchTime = 0;
var hasRipple = (w) => w.ripple;
var Ripple = class extends Widget {
  static get defaultConfig() {
    return {
      old_element: {
        children: [{
          className: "b-ripple-inner",
          reference: "rippleElement"
        }]
      },
      element: {
        children: [{
          tag: "svg",
          class: "b-ripple-inner",
          reference: "rippleElement",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          viewBox: "0 0 100 100",
          children: [{
            reference: "circleElement",
            tag: "circle",
            cx: "0",
            cy: "0",
            r: 10
          }]
        }]
      },
      floating: true,
      hideAnimation: false,
      showAnimation: false,
      scrollAction: "realign",
      color: "rgba(0,0,0,.3)",
      startRadius: 10,
      radius: 100
    };
  }
  afterConstruct() {
    super.afterConstruct();
    EventHelper.on({
      element: this.rootElement,
      mousedown: "onRippleControllingEvent",
      thisObj: this,
      capture: true,
      once: true
    });
  }
  onRippleControllingEvent(event) {
    var _a4;
    const me = this;
    me.show();
    const rippleAnimation = DomHelper.getStyleValue(me.circleElement, "animationName");
    me.hide();
    (_a4 = me.listenerDetacher) == null ? void 0 : _a4.call(me);
    if (rippleAnimation && rippleAnimation !== "none") {
      me.listenerDetacher = EventHelper.on({
        // Trap all mousedowns and see if the encapsulating Component is configured to ripple
        mousedown: {
          element: me.rootElement,
          capture: true,
          handler: "onMousedown"
        },
        touchstart: {
          element: me.rootElement,
          capture: true,
          handler: "onTouchStart"
        },
        // Hide at the end of the ripple
        animationend: {
          element: me.circleElement,
          handler: "onAnimationEnd"
        },
        thisObj: me
      });
      if (event.type === "mousedown") {
        me.onMousedown(event);
        GlobalEvents_default.ion({
          theme: "onRippleControllingEvent",
          thisObj: this
        });
      }
    }
  }
  onTouchStart(event) {
    lastTouchTime = performance.now();
    this.handleTriggerEvent(event);
  }
  onMousedown(event) {
    if (performance.now() - lastTouchTime > 200) {
      this.handleTriggerEvent(event);
    }
  }
  handleTriggerEvent(event) {
    const targetWidget = Widget.fromElement(event.target, hasRipple);
    if (targetWidget) {
      const rippleCfg = targetWidget.ripple, target = rippleCfg.delegate ? event.target.closest(rippleCfg.delegate) : targetWidget.focusElement || targetWidget.element;
      if (target) {
        const ripple = ObjectHelper.assign({
          event,
          target,
          radius: this.radius
        }, rippleCfg);
        if (typeof ripple.clip === "string") {
          ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);
          if (!ripple.clip) {
            return;
          }
        }
        this.ripple(ripple);
      }
    }
  }
  ripple({
    event,
    point = EventHelper.getClientPoint(event),
    target = event.target,
    clip = target,
    radius = this.radius,
    color = this.color
  }) {
    this.clip = clip;
    clip = Rectangle.from(clip, null, true);
    const me = this, centreDelta = clip.getDelta(point), rippleStyle = me.rippleElement.style, circleElement = me.circleElement, borderRadius = DomHelper.getStyleValue(target, "border-radius");
    me.hide();
    rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
    rippleStyle.height = rippleStyle.width = `${radius}px`;
    me.element.style.borderRadius = borderRadius;
    circleElement.setAttribute("r", radius);
    circleElement.setAttribute("fill", color);
    me.showBy({
      target: clip,
      align: "c-c",
      matchSize: true
    });
  }
  // When fully expanded, it's all over.
  onAnimationEnd(event) {
    if (event.animationName === "b-ripple-expand") {
      this.hide();
    }
  }
};
__publicField(Ripple, "$name", "Ripple");
__publicField(Ripple, "type", "ripple");
Widget.RippleClass = Ripple;
Ripple._$name = "Ripple";

// ../Core/lib/Core/widget/Container.js
var emptyObject7 = Object.freeze({});
var { isArray: isArray2 } = Array;
var returnWeight = (i) => i.weight;
var sortByWeight = ({ weight: a }, { weight: b }) => {
  if (typeof a === "string" || typeof b === "string") {
    return String(a).localeCompare(String(b));
  }
  return (a != null ? a : Number.MAX_SAFE_INTEGER) - (b != null ? b : Number.MAX_SAFE_INTEGER);
};
var isNotHidden = (w) => w && !w.hidden;
var stylesToCheck = ["display", "flex-direction"];
var boxLayouts = {
  default: 1,
  box: 1
};
var Container = class extends Widget {
  static get configurable() {
    return {
      /**
       * An object containing typed child widget config objects or Widgets. May also be specified
       * as an array.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Core.widget.Widget#config-ref} name, and the value is the child component's config object.
       *
       * ```javascript
       *
       *  class MyContainer extends Container {
       *      static get configurable() {
       *          return {
       *              items : {
       *                  details : {
       *                      type : 'panel',
       *                      ....
       *                  },
       *                  button : {
       *                      type : 'button',
       *                      text : 'Save'
       *                  }
       *              }
       *          }
       *      }
       *  }
       *
       *  new MyContainer({
       *      title    : 'Test Container',
       *      floating : true,
       *      centered : true,
       *      width    : 600,
       *      height   : 400,
       *      layout   : 'fit',
       *      items    : {
       *          button : {
       *              disabled : true
       *          },
       *          details : {
       *              title : 'More coolness',
       *              html  : 'Details content'
       *          }
       *      }
       *  }).show();
       * ```
       *
       * The order of the child widgets is determined by the order they are defined in `items`, but can also be
       * affected by configuring a {@link Core.widget.Widget#config-weight} on one or more widgets.
       *
       * To remove existing items, set corresponding keys to `null`.
       *
       * If you want to customize child items of an existing class, you can do this using the child widget
       * 'ref' identifier (useful for reconfiguring Event Editor in Scheduler / Gantt):
       *
       * ```javascript
       *  new MyCustomTabPanel({
       *      items    : {
       *          // Reconfigure tabs
       *          firstTab : {
       *              title : 'My custom title'
       *          },
       *          secretTab : null // hide this tab
       *      }
       *  }).show();
       * ```
       *
       * @config {Object<String,ContainerItemConfig|MenuItemConfig|Boolean|null>|Array<ContainerItemConfig|MenuItemConfig|Core.widget.Widget>}
       * @category Content
       */
      items: null,
      /**
       * An array of {@link #config-items child item} _config objects_ which is to be converted into
       * instances only when this Container is rendered, rather than eagerly at construct time.
       *
       * _This is mutually exclusive with the {@link #config-items} config._
       *
       * @config {Object<String,ContainerItemConfig>|ContainerItemConfig[]|Core.widget.Widget[]}
       * @category Content
       */
      lazyItems: {
        $config: ["lazy"],
        value: null
      },
      /**
       * A config object containing default settings to apply to all child widgets.
       * @config {ContainerItemConfig}
       * @category Content
       */
      defaults: null,
      defaultType: "widget",
      /**
       * The CSS style properties to apply to the {@link Core.widget.Widget#property-contentElement}.
       *
       * By default, a Container's {@link Core.widget.Widget#property-contentElement} uses flexbox layout, so this
       * config may contain the following properties:
       *
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
       * @prp {Object}
       * @category Layout
       */
      layoutStyle: null,
      /**
       * An optional CSS class to add to child items of this container.
       * @config {String}
       * @category CSS
       */
      itemCls: null,
      /**
       * The {@link #config-layout} as an instance of {@link Core.widget.layout.Layout}.
       * This is a helper class which adds and removes child widgets to this Container's
       * DOM and applies CSS classes based upon its requirements.
       *
       * The {@link Core.widget.layout.Card card} layout provides for showing one child
       * widget at a time, and provides a switching API to change which child widget is
       * currently active.
       * @member {Core.widget.layout.Layout} layout
       * @category Layout
       */
      /**
       * The short name of a helper class which manages rendering and styling of child items.
       *
       * Or a config object which includes a `type` property which specifies which type
       * of layout to use, and how to configure that layout.
       *
       * By default, the only special processing that is applied is that the Container class's
       * {@link #config-itemCls} is added to child items.
       *
       * Containers use CSS flexbox in its default configuration to arrange child items. You may either use the
       * {@link #config-layoutStyle} configuration to tune how child items are layed out, or use one of the built
       * in helper classes which include:
       *
       *  - `fit` A single child item is displayed fitting exactly into the
       *  {@link Core.widget.Widget#property-contentElement}.
       *  - `card` Child items are displayed one at a time, size to fit the
       *  {@link Core.widget.Widget#property-contentElement} and are slid in from the side when activated.
       *  - `box` Child items are layed out using flexbox.
       *
       * For example:
       * ```javascript
       * {
       *     id     : 'myContainer',
       *     // Our child items flow downwards and are stretched to fill our width
       *     layout : {
       *         type       : 'box',
       *         direction  : 'column'
       *         align      : 'stretch'
       *     }
       * }
       * @config {String|ContainerLayoutConfig}
       * @category Layout
       */
      layout: {
        type: "default"
      },
      /**
       * An object containing named config objects which may be referenced by name in any {@link #config-items}
       * object. For example, a specialized {@link Core.widget.Menu Menu} subclass may have a `namedItems` default
       * value defined like this:
       *
       * ```javascript
       *  namedItems : {
       *      removeRow : {
       *          text : 'Remove row',
       *          onItem() {
       *              this.ownerGrid.remove(this.ownerGrid.selectedRecord);
       *          }
       *      }
       *  }
       * ```
       *
       * Then whenever that subclass is instantiated and configured with an {@link #config-items} object, the
       * items may be configured like this:
       *
       * ```javascript
       *  items : {
       *      removeRow : true,   // The referenced namedItem will be applied to this
       *      otherItemRef : {
       *          text : 'Option 2',
       *          onItem() {
       *          }
       *      }
       * }
       * ```
       * @config {Object<string,ContainerItemConfig>}
       * @category Content
       */
      namedItems: {
        $config: "lazy",
        value: null
      },
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default false
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Specify `true` for a container used to show text markup. It will apply the CSS class `b-text-content`
       * which specifies a default max-width that makes long text more readable.
       *
       * This CSS class is automatically removed if the container adds/defines child Widgets.
       * @config {Boolean}
       * @default
       * @category Content
       */
      textContent: true,
      /**
       * {@link Core.data.Model Record} whose values will be used to populate fields in the container.
       *
       * Any descendant widgets of this Container with a `name` property (or a `ref` if no name is configured)
       * will have its value set to the value of that named property of the record.
       *
       * If no record is passed, the widget has its value set to `null`.
       *
       * To strictly match by the `name` property, configure {@link #config-strictRecordMapping} as `true`.
       *
       * @prp {Core.data.Model}
       * @category Record
       */
      record: null,
      /**
       * Specify `true` to match fields by their `name` property only when assigning a {@link #config-record},
       * without falling back to `ref`.
       *
       * @prp {Boolean}
       * @default false
       * @category Record
       */
      strictRecordMapping: null,
      /**
       * Update assigned {@link #config-record} automatically on field changes
       * @config {Boolean}
       * @category Record
       */
      autoUpdateRecord: null,
      /**
       * Update fields if the {@link #config-record} changes
       * @config {Boolean}
       * @internal
       */
      autoUpdateFields: null,
      /**
       * Specify `true` to make this container hide when it has no visible children (Either empty
       * or all children hidden).
       *
       * Container will show itself when there are visible children, ie: hidden children are
       * shown, or new visible children are added.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      hideWhenEmpty: null,
      contentElMutationObserver: {
        $config: ["lazy", "nullify"],
        value: true
      },
      /**
       * Specify `true` to isolate record changes to this container and its ancestors. Prevents record updates
       * from propagating up from here and also prevents record updates from parent from propagating down to us.
       *
       * @config {Boolean}
       * @default false
       * @internal
       */
      isolateFields: false,
      /**
       * Can be set to `true` to make a focus of a focusable encapsulating element relay focus down into a
       * focusable child. This is normally `false` to allow mousedown to begin text selection in Popups.
       * @internal
       */
      focusDescendant: false,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null,
      /**
       * A {@link #function-query} selector function which can identify the descendant widget to which
       * focus should be directed by default.
       *
       * By default, the first focusable descendant widget is chosen. This may direct focus to a different
       * widget:
       *
       * ```javascript
       *     new Popup({
       *         title        : 'Details',
       *         width        : '25em',
       *         centered     : true,
       *         modal        : true,
       *
       *         // Focus goes straight to OK button in the bottom toolbar on show
       *         defaultFocus : w => w.ref === 'okButton',
       *         items        : {
       *             nameField : {
       *                 type  : 'textfield',
       *                 label : 'Name'
       *             },
       *             ageField  : {
       *                 type  : 'numberfield',
       *                 label : 'Name'
       *             }
       *         },
       *         bbar     : {
       *             items : {
       *                 okButton : {
       *                     text    : 'OK',
       *                     handler : okFunction
       *                 },
       *                 cncelButton : {
       *                     text    : 'Cancel',
       *                     handler : cancelFunction
       *                 }
       *             }
       *         }
       *     }).show();
       * ```
       * @config {Function}
       * @param {Core.widget.Widget} widget Widget passed to method
       * @returns {Boolean} truthy value if widget is the default one
       */
      defaultFocus: null
    };
  }
  static get prototypeProperties() {
    return {
      // These classes have opinions about how fields should fill the space, so allow them to be replaced by the
      // less opinionated b-hbox/b-vbox classes when that is not desired. Using ":not(.b-toolbar-content)" in
      // the CSS does not scale now that FieldSet wants similar treatment... adding more ":not()"s is not only a
      // messy approach, it increases the selector specificity and causes interference with other selectors (e.g.
      // TimePicker's number field rules).
      flexRowCls: "b-flex-row",
      flexColCls: "b-flex-column",
      /**
       * @member {Boolean} initialItems
       * This property is `true` until the container's initial `items` config has been processed. This property
       * is set to `false` by the `updateItems` method.
       * @readonly
       * @internal
       */
      initialItems: true
    };
  }
  startConfigure(config) {
    const items2 = config.items || config.lazyItems;
    if (!(this.hasItems = Boolean(items2 && (isArray2(items2) ? items2 : Object.keys(items2)).length))) {
      this.initialItems = false;
    }
    super.startConfigure(config);
  }
  /**
   * Returns the first widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get firstItem() {
    return this.getAt(0);
  }
  /**
   * Returns the last widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get lastItem() {
    return this.getAt(-1);
  }
  /**
   * Returns the widget at the specified `index` in this Container.
   * @param {Number} index The index of the widget to return. Negative numbers index for the last item. For example,
   * `index = -1` returns the last matching item, -2 the 2nd to last matching item etc..
   * @returns {Core.widget.Widget} The requested widget.
   */
  getAt(index) {
    return this.ensureItems().at(index);
  }
  /**
   * Removes the passed child/children from this Container.
   * @param  {...Core.widget.Widget} toRemove The child or children to remove.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the removed items. An array if multiple items
   * were removed, otherwise, just the item removed.
   */
  remove(...toRemove) {
    let returnArray = true;
    if (toRemove.length === 1) {
      if (isArray2(toRemove[0])) {
        toRemove = toRemove[0];
      } else {
        returnArray = false;
      }
    }
    const me = this, { _items } = me, result = [];
    for (let i = 0; i < toRemove.length; i++) {
      const childToRemove = toRemove[i];
      if (_items.includes(childToRemove)) {
        _items.remove(childToRemove);
        me.layout.removeChild(childToRemove);
        result.push(childToRemove);
        me.onChildRemove(childToRemove);
      }
    }
    return returnArray ? result : result[0];
  }
  /**
   * Removes all children from this Container.
   * @returns {Core.widget.Widget[]} All the removed items.
   */
  removeAll() {
    return this.remove(this.items);
  }
  /**
   * Appends the passed widget / widgets or config(s) describing widgets to this Container.
   *
   * If the widgets specify a `weight`, they are inserted at the correct index compared to the existing items weights.
   *
   * @param {ContainerItemConfig|ContainerItemConfig[]|Core.widget.Widget|Core.widget.Widget[]} toAdd The child or children instances (or config objects) to add.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the added widgets. An array if multiple items
   * were added, otherwise just the item added.
   */
  add(...toAdd) {
    const me = this, items2 = me.ensureItems(), result = [];
    let returnArray = true, childToAdd, i, index;
    if (toAdd.length === 1) {
      if (isArray2(toAdd[0])) {
        toAdd = toAdd[0];
      } else {
        returnArray = false;
      }
    }
    for (i = 0; i < toAdd.length; i++) {
      childToAdd = toAdd[i];
      if (childToAdd.isWidget) {
        childToAdd.parent = me;
      } else {
        childToAdd = me.createWidget(childToAdd);
      }
      if ((childToAdd == null ? void 0 : childToAdd.weight) != null) {
        index = ArrayHelper.findInsertionIndex(childToAdd, items2.values, sortByWeight);
        result.push(me.insert(childToAdd, index));
      } else if (childToAdd) {
        if (!items2.includes(childToAdd)) {
          items2.add(childToAdd);
          me.onChildAdd(childToAdd);
          me.layout.appendChild(childToAdd);
          result.push(childToAdd);
        }
      }
    }
    return returnArray ? result : result[0];
  }
  ensureItems() {
    const me = this;
    me.getConfig("items");
    me.getConfig("lazyItems");
    if (!me._items) {
      me.items = [];
    }
    return me._items;
  }
  /**
   * Inserts the passed widget into this Container at the specified position.
   * @param  {Core.widget.Widget} toAdd The child to insert.
   * @param {Number|Core.widget.Widget} index The index to insert at or the existing child to insert before.
   * @returns {Core.widget.Widget} The added widget.
   */
  insert(toAdd, index) {
    const me = this, items2 = me.ensureItems();
    if (toAdd instanceof Widget) {
      toAdd.parent = me;
    } else {
      toAdd = me.createWidget(toAdd);
    }
    if (items2.includes(index)) {
      index = me.indexOfChild(index);
    }
    index = Math.min(index, items2.count);
    const newValues = items2.values;
    newValues.splice(index, 0, toAdd);
    items2.values = newValues;
    me.onChildAdd(toAdd);
    me.layout.insertChild(toAdd, index);
    return toAdd;
  }
  indexOfChild(child) {
    return this.items.indexOf(child);
  }
  changeLazyItems(lazyItems) {
    this.items = lazyItems;
    this.layout.renderChildren();
  }
  changeItems(items2, oldItems) {
    const me = this, newItems = [], result = new Bag();
    if (isArray2(items2)) {
      me.processItemsArray(items2, newItems);
    } else if (items2) {
      me.processItemsObject(items2, me.namedItems, newItems);
    }
    if (newItems.some(returnWeight)) {
      newItems.sort(sortByWeight);
    }
    result.add(newItems);
    if (oldItems) {
      oldItems.forEach((w) => {
        me.remove(w);
        if (!result.includes(w) && w._createdBy === me) {
          w.destroy();
        }
      });
    }
    return result;
  }
  afterConstruct() {
    const { rtl } = this, { classList } = this.contentElement;
    classList.toggle("b-rtl", rtl === true);
    classList.toggle("b-ltr", rtl === false);
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    const { contentElement } = this;
    if (contentElement) {
      contentElement.classList.toggle("b-rtl", rtl === true);
      contentElement.classList.toggle("b-ltr", rtl === false);
    }
  }
  updateItems(items2, oldItems) {
    let index = 0;
    items2.forEach((item) => {
      this.onChildAdd(item);
      if (oldItems && !oldItems.temporary) {
        this.layout.insertChild(item, index);
      }
      ++index;
    });
    this.initialItems = false;
  }
  updateHideWhenEmpty() {
    this.syncChildCount(this.rendered);
  }
  /**
   * A property, which, when *read*, returns an array of the child items of this container in rendered order.
   *
   * This property may also be *set* to change the child items of the container. Just as in the
   * {@link #config-items initial items configuration}, the new value may either be an array of
   * Widgets/Widget configs or an object.
   *
   * If specified as an Object, the property names are used as the child Widget's
   * {@link Core.widget.Widget#config-ref} name, and the value is the child Widget/Widget config.
   *
   * When setting this, any items which are *only* in the outgoing child items which were created
   * by this container from raw config objects are destroyed.
   *
   * Usage patterns:
   *
   * ```javascript
   * myContainer.items = {
   *     name : {
   *         type  : 'textfield',
   *         label : 'User name'
   *     },
   *     age : {
   *         type  : 'numberfield',
   *         label : 'User age'
   *     }
   * };
   * ```
   *
   * or
   *
   * ```javascript
   * myContainer.items = [{
   *     ref   : 'name',
   *     type  : 'textfield',
   *     label : 'User name'
   * },
   *     ref   : 'age',
   *     type  : 'numberfield',
   *     label : 'User age'
   * }];
   * ```
   * @property {Core.widget.Widget[]}
   * @accepts {Array<ContainerItemConfig|MenuItemConfig|Core.widget.Widget>|Object<String,ContainerItemConfig|MenuItemConfig>}
   */
  get items() {
    const me = this;
    me.getConfig("lazyItems");
    if (!me._items) {
      if (me.initializingItems) {
        return [];
      }
      me._items = new Bag();
      me._items.temporary = true;
    }
    return me._items.values;
  }
  processItemsArray(items2, result) {
    const len = items2.length;
    let i, item;
    for (i = 0; i < len; i++) {
      item = items2[i];
      if (item instanceof Widget) {
        item.parent = this;
        item.element.classList.remove(...Widget.outerCls);
      } else {
        item = this.createWidget(item);
      }
      if (item) {
        if (item.ref || item.id) {
          this.addDescendant(item);
        }
        result.push(item);
      }
    }
  }
  processItemsObject(items2, namedItems, result = []) {
    let item, ref;
    for (ref in items2) {
      item = items2[ref];
      if (item) {
        if (namedItems && ref in namedItems) {
          item = typeof item === "object" ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }
        if (item) {
          if (item instanceof Widget) {
            item.parent = this;
          } else {
            if (item instanceof Object) {
              item.ref = ref;
            }
            item = this.createWidget(item);
          }
          if (item) {
            item.ref = ref;
            this.addDescendant(item);
            result.push(item);
          }
        }
      }
    }
    return result;
  }
  onChildAdd(item) {
    if (item.innerItem && this.readOnly && !item.ignoreParentReadOnly) {
      item.readOnly = true;
    }
    this.onChildAddLayout(item);
    if (item.ref || item.id) {
      for (let current = this; current; current = current.parent) {
        current.addDescendant(item);
      }
    }
    this.syncChildCount(true);
  }
  onChildAddLayout(item) {
    if (item.innerItem) {
      this.layout.onChildAdd(item);
    }
  }
  onChildHide(hidden) {
    var _a4;
    super.onChildHide(hidden);
    if ((_a4 = this._items) == null ? void 0 : _a4.includes(hidden)) {
      this.syncChildCount(true);
    }
  }
  onChildShow(shown) {
    var _a4;
    super.onChildShow(shown);
    if ((_a4 = this._items) == null ? void 0 : _a4.includes(shown)) {
      this.syncChildCount(true);
    }
  }
  syncChildCount(enforceHideWhenEmpty) {
    if (!this.isConfiguring) {
      const me = this, {
        // This must be our direct child item payload, not all items owned by this Container.
        // It's used to sync the b-first-visible-child/b-last-visible-child class presence.
        items: items2,
        hasItems
      } = me, visibleItems = items2.filter(isNotHidden), { length: visibleLength } = visibleItems;
      me.visibleChildCount = visibleLength;
      if (me.hideWhenEmpty && enforceHideWhenEmpty) {
        const shouldHide = Boolean(!visibleLength);
        if (Boolean(me._hidden) !== shouldHide) {
          me.hidden = shouldHide;
        }
      }
      items2.forEach((childItem) => childItem.element.classList.remove("b-last-visible-child", "b-first-visible-child"));
      if (visibleLength) {
        visibleItems[0].element.classList.add("b-first-visible-child");
        visibleItems[visibleLength - 1].element.classList.add("b-last-visible-child");
      }
      me.hasItems = Boolean(me.childItems.length);
      me.contentElement.classList[visibleLength ? "remove" : "add"]("b-no-visible-children");
      if (!me.isComposable) {
        me.updateTextContent(me._textContent);
      } else if (hasItems !== me.hasItems) {
        me.recompose();
      }
    }
  }
  syncFlexDirection() {
    const me = this, { contentElement, flexColCls, flexRowCls } = me, classList = new DomClassList(contentElement.className), styles = DomHelper.getStyleValue(contentElement, stylesToCheck);
    classList[flexRowCls] = classList[flexColCls] = 0;
    if (styles.display === "flex") {
      classList[styles["flex-direction"] === "row" ? flexRowCls : flexColCls] = 1;
    }
    DomHelper.syncClassList(contentElement, classList);
  }
  addDescendant(item) {
    const ref = item.ref || item.id, widgetMap = this._widgetMap || (this._widgetMap = {});
    if (!widgetMap[ref]) {
      widgetMap[ref] = item;
    }
  }
  onChildRemove(item) {
    const me = this, ref = item.ref || item.id;
    if (ref) {
      for (let current = me; current; current = current.parent) {
        if (current.widgetMap[ref] === item) {
          delete current.widgetMap[ref];
        }
      }
    }
    me.layout.onChildRemove(item);
    me.syncChildCount(true);
  }
  /**
   * An object which contains a map of descendant widgets keyed by their {@link Core.widget.Widget#config-ref}.
   * All descendant widgets will be available in the `widgetMap`.
   * @property {Object<String,Core.widget.Widget>}
   * @readonly
   * @category Widget hierarchy
   */
  get widgetMap() {
    if (!this._widgetMap) {
      this._widgetMap = {};
    }
    if (!this.initializingItems) {
      this.getConfig("items");
    }
    return this._widgetMap;
  }
  //region Record & values
  changeRecord(record) {
    this._record = record == null ? emptyObject7 : null;
    return record;
  }
  updateRecord(record) {
    var _a4;
    const me = this;
    (_a4 = me.recordUpdateDetacher) == null ? void 0 : _a4.call(me);
    me.trigger("beforeSetRecord", { record });
    me.setValues(record, {
      onlyName: me.strictRecordMapping,
      highlight: Boolean(me.$highlight)
    });
    if (me.autoUpdateFields && (record == null ? void 0 : record.firstStore)) {
      me.recordUpdateDetacher = record.firstStore.ion({
        update: me.onRecordUpdated,
        thisObj: me
      });
    }
  }
  setRecord(record, highlightChanges) {
    this.$highlight = highlightChanges;
    this.record = record;
    this.$highlight = false;
  }
  onRecordUpdated({ record }) {
    if (record === this.record) {
      this.setValues(this.record, true, true);
    }
  }
  /**
   * A function called by descendant widgets after they trigger their 'change' event, in reaction to field changes.
   * By default, implements the functionality for the `autoUpdateRecord` config.
   *
   * @param {Object} params Normally the event params used when triggering the 'change' event
   * @internal
   */
  onFieldChange({ source, userAction }) {
    if (this.autoUpdateRecord && userAction) {
      const { record, strictRecordMapping } = this, { name, ref, isValid = true, value } = source, key = strictRecordMapping ? name : name || ref;
      if (record && key && isValid) {
        if (record.isModel) {
          record.setValue(key, value);
        } else {
          record[key] = value;
        }
      }
    }
  }
  getValues(filterFn) {
    const values = {};
    this.eachWidget((widget, control) => {
      if (widget.isolateFields) {
        control.down = false;
      } else if ("name" in widget && (!filterFn || filterFn(widget))) {
        values[widget.name] = widget.value;
      }
    }, true);
    return values;
  }
  /**
   * Retrieves or sets all values from/to contained widgets.
   *
   * The property set or read from a contained widget is its {@link Core.widget.Widget#config-defaultBindProperty}.
   *
   * This defaults to the `value` for fields.
   *
   * You may add child widgets which may accept and yield a value to/from another property, such as a `Button` having
   * its {@link Core.widget.Button#config-href} set.
   *
   * Accepts and returns a map, using {@link Core.widget.Field#config-name}, {@link Core.widget.Widget#config-ref} or
   * {@link Core.widget.Widget#config-id} (in that order) as keys.
   *
   * ```javascript
   * const container = new Container({
   *     appendTo : document.body,
   *     items    : {
   *         firstName : {
   *             type : 'textfield
   *         },
   *         surName : {
   *             type : 'textfield
   *         }
   *         saveButton : {
   *             type                : 'button',
   *             text                : 'Save',
   *             defaultBindProperty : 'href'
   *             href                : '#'
   *         }
   *     }
   * });
   *
   * container.values = {
   *     firstName  : 'Clark',
   *     surname    : 'Kent',
   *     saveButton : '#save-route'
   * };
   * ```
   *
   * @property {Object<String,Object>}
   */
  get values() {
    const values = {};
    this.gatherValue(values);
    return values;
  }
  set values(values) {
    this.assignValue(values);
  }
  /**
   * Returns `true` if currently setting values. Allow fields to change highlighting to distinguishing between
   * initially setting values and later on changing values.
   * @property {Boolean}
   */
  get isSettingValues() {
    return Boolean(this.assigningValues);
  }
  get assigningValues() {
    var _a4;
    return this._assigningValues || ((_a4 = this.parent) == null ? void 0 : _a4.assigningValues);
  }
  set assigningValues(v) {
    this._assigningValues = v;
  }
  assignValue(values, options) {
    super.assignValue(values, options);
    if (!this.isolateFields) {
      this.setValues(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    if (!this.isolateFields) {
      this.gatherValues(values);
    }
  }
  setValues(values, options = this.assignValueDefaults) {
    this.assigningValues = options;
    this.eachWidget((widget) => widget.assignValue(values, options), false);
    this.assigningValues = false;
  }
  //endregion
  get hasNoChildren() {
    const me = this, { items: items2, lazyItems } = me.initialConfig, itemsArray = items2 && (isArray2(items2) ? items2 : ObjectHelper.values(items2)), lazyItemsArray = lazyItems && (isArray2(lazyItems) ? lazyItems : ObjectHelper.values(lazyItems)), whichItems = me.isConfiguring ? lazyItemsArray || itemsArray : me.items;
    return !(whichItems == null ? void 0 : whichItems.filter(isNotHidden).length);
  }
  afterRecompose() {
    super.afterRecompose();
    this.realign();
  }
  updateTextContent(textContent) {
    const me = this;
    if (!me.isComposable) {
      const needsClass = Boolean(textContent && me.hasNoChildren), { classList } = me.contentElement, changed = needsClass !== classList.contains("b-text-content");
      if (changed) {
        classList[needsClass ? "add" : "remove"]("b-text-content");
        if (me.rendered) {
          me.realign();
        }
      }
    }
  }
  updateLayoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
  }
  updateElement(element) {
    super.updateElement(...arguments);
    if (element) {
      const { classList } = this.contentElement, { containerCls } = this.layout;
      classList.add("b-content-element");
      if (containerCls) {
        classList.add(containerCls);
      }
    }
  }
  onInternalPaint() {
    var _a4;
    (_a4 = super.onInternalPaint) == null ? void 0 : _a4.call(this, ...arguments);
    this.getConfig("contentElMutationObserver");
  }
  changeContentElMutationObserver(contentElMutationObserver, oldContentElMutationObserver) {
    if (oldContentElMutationObserver) {
      oldContentElMutationObserver.takeRecords();
      oldContentElMutationObserver.disconnect();
    }
    if (contentElMutationObserver) {
      const me = this, {
        element,
        contentElement
      } = me;
      contentElMutationObserver = new MutationObserver((mutations) => me.onContentElMutation(mutations));
      contentElMutationObserver.observe(contentElement, { attributes: true });
      if (contentElement !== element) {
        contentElMutationObserver.observe(element, { attributes: true });
      }
      me.syncFlexDirection();
    }
    return contentElMutationObserver;
  }
  onContentElMutation(mutations) {
    if (boxLayouts[this.layout.type] && this.isVisible && mutations.some((m) => this.contentElement.contains(m.target))) {
      this.syncFlexDirection();
    }
  }
  changeLayout(config, existingLayout) {
    return Layout.reconfigure(existingLayout, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  // Items to iterate over
  get childItems() {
    return this.items;
  }
  get childItemsOrderedByRelevance() {
    return this.items;
  }
  /**
   * Returns a directly contained widget by id
   * @param {String} id The widget id
   * @returns {Core.widget.Widget}
   */
  getWidgetById(id) {
    return this.widgetMap[id];
  }
  /**
   * This function is called prior to creating widgets, override it in subclasses to allow containers to modify the
   * configuration of each widget. When adding a widget to a container hierarchy each parent containers
   * `processWidgetConfig` will be called. Returning false from the function prevents the widget from being added at
   * all.
   */
  processWidgetConfig(widget) {
  }
  /**
   * This method combines container {@link #config-defaults}
   * @param {String|ContainerItemConfig} widgetConfig
   * @param {String|Function} [type] The type of widget described by `widgetConfig`.
   * @returns {ContainerItemConfig}
   * @internal
   */
  setupWidgetConfig(widgetConfig, type) {
    const me = this;
    if (typeof widgetConfig === "string") {
      widgetConfig = {
        html: widgetConfig
      };
    } else if (widgetConfig.nodeType === Element.ELEMENT_NODE) {
      widgetConfig = {
        element: widgetConfig,
        id: widgetConfig.id
      };
    }
    if (typeof type === "string" || !type && (type = widgetConfig.type)) {
      if (type === "checkbox" && BrowserHelper.isMobile && Widget.resolveType("slidetoggle", true)) {
        type = widgetConfig.type = "slidetoggle";
      }
      type = Widget.resolveType(type, true);
    }
    widgetConfig = (type || Widget).mergeConfigs(me.defaults, widgetConfig, { parent: me });
    for (let ancestor = widgetConfig.parent; ancestor; ancestor = ancestor.parent) {
      if (ancestor.processWidgetConfig(widgetConfig) === false) {
        return null;
      }
    }
    if (me.trigger("beforeWidgetCreate", { widgetConfig }) === false) {
      return null;
    }
    return widgetConfig;
  }
  /**
   * This function converts a Widget config object into a Widget.
   * @param {ContainerItemConfig} widget A Widget config object.
   * @internal
   */
  createWidget(widget) {
    const result = Widget.create(this.setupWidgetConfig(widget), this.defaultType);
    result && (result._createdBy = this);
    return result;
  }
  // Reapply defaults, not used during config
  updateDefaults(defaults, oldDefaults) {
    if (!this.isConfiguring && defaults) {
      const entries = Object.entries(defaults);
      this.eachWidget((widget) => {
        entries.forEach(([prop, value]) => {
          if (!oldDefaults || widget[prop] === oldDefaults[prop]) {
            widget[prop] = value;
          }
        });
      }, false);
    }
  }
  render() {
    this.getConfig("lazyItems");
    this.layout.renderChildren();
    this.syncChildCount();
    super.render(...arguments);
  }
  get focusElement() {
    let firstFocusable = this.defaultFocus && this.query(this.defaultFocus);
    if (!this.defaultFocus || !firstFocusable) {
      firstFocusable = this.query((widget) => widget.isFocusable, true);
    }
    if (firstFocusable) {
      return firstFocusable.focusElement;
    }
    return super.focusElement;
  }
  doDestroy() {
    var _a4;
    (_a4 = this._items) == null ? void 0 : _a4.forEach((widget) => {
      var _a5;
      return (_a5 = widget.destroy) == null ? void 0 : _a5.call(widget);
    });
    this.layout.destroy();
    super.doDestroy();
  }
  /**
   * Returns `true` if all contained fields are valid, otherwise `false`
   * @property {Boolean}
   */
  get isValid() {
    let valid = true;
    this.eachWidget((widget) => {
      if (widget.isVisible && "isValid" in widget && !widget.isValid) {
        valid = false;
      }
    }, true);
    return valid;
  }
};
__publicField(Container, "$name", "Container");
__publicField(Container, "type", "container");
Container.initClass();
Container._$name = "Container";

// ../Core/lib/Core/util/Animator.js
var { assign } = ObjectHelper;
var now = () => performance.now();
var nostart = { start: false };
var unitRe = /^[.\d]+([^\d].*)?$/;
var getTransitions = (element) => {
  const $bryntum = element.$bryntum || (element.$bryntum = {});
  return $bryntum.transitions || ($bryntum.transitions = /* @__PURE__ */ Object.create(null));
};
var milliseconds = (duration, unit) => {
  var _a4;
  if (typeof duration === "string") {
    unit = (_a4 = unitRe.exec(duration)) == null ? void 0 : _a4[1];
    duration = parseFloat(duration);
  }
  return duration && duration * (unit === "s" || !unit && duration < 10 ? 1e3 : 1);
};
var syncTransitions = (element) => {
  const all = ObjectHelper.values(getTransitions(element)).filter((a) => a.completed == null).map((a) => a.toString());
  element.style.transition = all.join(", ");
};
var Anim = (Target) => class Anim extends Target {
  static get prototypeProperties() {
    return {
      _delay: null,
      _duration: null,
      _retain: null,
      _timing: null,
      _unit: null,
      owner: null,
      reverting: null
    };
  }
  constructor(...args) {
    super(...args);
    this.id = ++idSeed;
  }
  start() {
    this.startTime = now();
  }
  get delay() {
    var _a4, _b, _c;
    return milliseconds((_c = (_b = this._delay) != null ? _b : (_a4 = this.owner) == null ? void 0 : _a4.delay) != null ? _c : 0, this.unit);
  }
  set delay(v) {
    this._delay = v;
  }
  get duration() {
    var _a4;
    const { owner, unit } = this;
    return milliseconds((_a4 = this._duration) != null ? _a4 : owner ? owner.duration : Animator.defaultDuration, unit);
  }
  set duration(v) {
    this._duration = v;
  }
  get elapsed() {
    return now() - this.startTime;
  }
  get remaining() {
    return this.duration - this.elapsed;
  }
  get retain() {
    var _a4, _b;
    return (_b = this._retain) != null ? _b : (_a4 = this.owner) == null ? void 0 : _a4.retain;
  }
  set retain(v) {
    this._retain = v;
  }
  get timing() {
    var _a4, _b;
    return (_b = this._timing) != null ? _b : (_a4 = this.owner) == null ? void 0 : _a4.timing;
  }
  set timing(v) {
    this._timing = v;
  }
  get unit() {
    var _a4, _b;
    return (_b = this._unit) != null ? _b : (_a4 = this.owner) == null ? void 0 : _a4.unit;
  }
  set unit(v) {
    this._unit = v;
  }
};
var idSeed = 0;
var AnimatorTransition = class _AnimatorTransition extends Base.mixin(Anim) {
  static get $name() {
    return "AnimatorTransition";
  }
  static get prototypeProperties() {
    return {
      element: null,
      property: null,
      from: null,
      to: null,
      completed: null,
      promissory: null,
      reverting: null
    };
  }
  afterConstruct() {
    super.afterConstruct();
    const me = this, { element, transitions } = me;
    let { property } = me;
    [property, me.to] = DomHelper.unitize(property, me.to);
    me.from = DomHelper.unitize(property, me.from)[1];
    me.promissory = new Promissory();
    me.property = property;
    const was = transitions[property];
    transitions[property] = me;
    let { from } = me;
    if (was) {
      me.from = was.to;
      from = null;
      was.destroy();
    }
    if (from === null) {
      from = me.getCurrentStyleValue();
      if (!was) {
        me.from = from;
      }
    }
    element.style[property] = from;
    me.getCurrentStyleValue();
  }
  doDestroy() {
    const me = this;
    me.finish(false);
    if (me.completed && !me.retain) {
      me.clearStyle();
    }
    super.doDestroy();
  }
  get promise() {
    var _a4;
    return (_a4 = this.promissory) == null ? void 0 : _a4.promise;
  }
  get transitions() {
    return getTransitions(this.element);
  }
  clearStyle() {
    this.setStyle("");
  }
  finish(complete) {
    const me = this, { transitions, promissory, property } = me;
    if (promissory) {
      me.completed = complete;
      me.promissory = null;
      promissory.resolve(complete);
      if (transitions[property] === me) {
        delete transitions[property];
        if (!complete) {
          syncTransitions(me.element);
          me.clearStyle();
        }
      } else {
        me.completed = false;
      }
    }
  }
  getCurrentStyleValue() {
    return DomHelper.getStyleValue(this.element, this.property);
  }
  revert() {
    const { duration, elapsed, element, from, property, _retain: retain, _timing: timing } = this;
    return new _AnimatorTransition({
      element,
      property,
      retain,
      timing,
      duration: Math.round(Math.min(duration, elapsed)),
      reverting: this,
      to: from,
      unit: "ms"
    });
  }
  setStyle(value) {
    this.element.style[this.property] = value;
  }
  start() {
    const me = this, { delay, duration, element, property } = me;
    EventHelper.onTransitionEnd({
      element,
      property,
      duration: delay + duration + 20,
      thisObj: me.owner,
      handler: () => {
        var _a4;
        return (_a4 = me.finish) == null ? void 0 : _a4.call(me, true);
      }
      // finish() is gone if destroyed
    });
    super.start();
    me.setStyle(me.to);
  }
  toString() {
    const { delay, duration, property, timing } = this;
    return `${property} ${duration}ms ${timing || "ease-in-out"}${delay ? ` ${delay}ms` : ""}`;
  }
};
AnimatorTransition.initClass();
var Animator = class _Animator extends Base.mixin(Anim) {
  static get $name() {
    return "Animator";
  }
  static get prototypeProperties() {
    return {
      /**
       * The optional delay before starting the animation. Numbers less than 10 are assumed to be seconds
       * (instead of milliseconds) unless the `unit` property is specified.
       * @config {Number|String} delay
       */
      /**
       * The duration of the animation. Numbers less than 10 are assumed to be seconds (instead of milliseconds)
       * unless the `unit` property is specified.
       * @config {Number|String} duration
       * @default
       */
      /**
       * The element to animate.
       * @config {HTMLElement} element
       */
      element: null,
      /**
       * A callback function called when the animation completes. This is called after restoring styles to the
       * original values (based on {@link #config-retain}). When this function is provided, `retain` defaults to
       * `false`. By implementing this function, a CSS class can be applied to the {@link #config-element} to
       * give the proper style, while the inline styles are removed (e.g., a hide animation based on opacity).
       *
       * For example:
       * ```javascript
       *  const anim = Animator.run({
       *      element,
       *      duration : 500,
       *      opacity  : 0,
       *
       *      finalize() {
       *          element.classList.add('hidden');
       *      }
       *  });
       *
       *  await anim.done();
       * ```
       *
       * @config {Function} finalize
       * @returns {void}
       */
      finalize: null,
      /**
       * A callback function called when the animation completes. This is called prior to restoring styles to the
       * original values (based on {@link #config-retain}).
       *
       * @config {Function} prefinalize
       * @returns {void}
       * @internal
       */
      prefinalize: null,
      /**
       * Set to `true` to retain the style property values after the animation. This defaults to `true` if a
       * {@link #config-finalize} function is not specified, and `false` otherwise. When a `finalize` function
       * is provided, it is typically to apply a CSS class to achieve the desired styling so that inline styles
       * can be removed.
       * @config {Boolean} retain
       */
      /**
       * The [timing function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function) for
       * the animation.
       * @config {String} timing
       * @default 'ease-in-out'
       */
      /**
       * The duration/delay unit (either `'s'` or `'ms'`).
       * @config {'s'|'ms'} unit
       */
      /**
       * This readonly property is set to `true` when the animation completes or `false` if the animation is
       * aborted (by calling the `destroy()` method).
       * @member {Boolean} completed
       * @readonly
       */
      completed: null,
      /**
       * An array containing a mixture of `Animator` and/or `AnimatorTransition` objects, depending on what was
       * specified at construction time.
       * @member {Core.util.Animator[]|AnimatorTransition[]} items
       * @readonly
       */
      /**
       * When passed at construction time, `items` can be an array of other `Animator` config objects. This can be
       * used to animate multiple elements and wait for this instance to be {@link #function-done done}.
       * @config {Core.util.Animator[]} items
       */
      items: null
    };
  }
  static register(name, fn) {
    if (ObjectHelper.isObject(name)) {
      ObjectHelper.entries(name).forEach((entry) => _Animator.register(...entry));
      return;
    }
    _Animator.fx[name] = fn;
    _Animator[name] = (options) => {
      if (DomHelper.isElement(options)) {
        options = {
          element: options,
          [name]: {}
        };
      } else {
        options = {
          element: options.element,
          [name]: options
        };
        delete options[name].element;
      }
      return _Animator.run(options);
    };
  }
  /**
   * A short-hand way to create an `Animator` instance and call its {@link #function-start} method.
   *
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      duration : 500,
   *
   *      // style transitions:
   *      opacity : 0
   *  });
   *
   *  await anim.done();
   * ```
   * @param {Core.util.Animator|AnimatorConfig} options A config object for an `Animator` instance.
   * @returns {Core.util.Animator}
   */
  static run(options) {
    return new _Animator(options).start();
  }
  constructor(options) {
    var _a4;
    super(null);
    const me = this, items2 = [], properties = {};
    let anim, fx, key, t;
    if (Array.isArray(options)) {
      me.items = options;
    } else {
      for (key in options) {
        (_Animator.specialPropsRe.test(key) ? me : properties)[key] = options[key];
      }
    }
    ObjectHelper.keys(properties).forEach((property) => {
      t = properties[property];
      if (t != null && t !== false && t === t) {
        if (!(fx = _Animator.fx[property])) {
          t = assign(me.defaults, typeof t === "object" ? t : { to: t });
          t.owner = me;
          t.property = property;
          anim = new AnimatorTransition(t);
        } else {
          t = assign(me.defaults, fx(t, me, property));
          t.owner = me;
          anim = new _Animator(t);
        }
        items2.push(anim);
      }
    });
    (_a4 = me.items) == null ? void 0 : _a4.forEach((item) => {
      if (ObjectHelper.isInstantiated(item)) {
        item.owner = me;
      } else {
        item = assign(me.defaults, item);
        item.owner = me;
        item = new _Animator(item);
      }
      items2.push(item);
    });
    me.items = items2;
    me.promise = (items2.length === 1 ? items2[0].promise : Promise.all(items2.map((it) => it.promise))).then((res) => {
      var _a5;
      (_a5 = me.finish) == null ? void 0 : _a5.call(me, res);
      return me.completed || false;
    });
  }
  doDestroy() {
    this.items.forEach((a) => a.destroy());
    super.doDestroy();
  }
  get defaults() {
    return {
      element: this.element
    };
  }
  get retain() {
    const { _retain, finalize, owner } = this;
    return _retain != null ? _retain : finalize ? false : owner ? owner.retain : true;
  }
  set retain(v) {
    super.retain = v;
  }
  /**
   * Returns a `Promise` that resolves to a `Boolean` when this animation completes. The resolved value is that of
   * this instance's {@link #property-completed} property.
   * @async
   */
  done() {
    return this.promise;
  }
  finish(complete) {
    var _a4, _b;
    const me = this, { items: items2 } = me;
    syncTransitions(me.element);
    me.completed = typeof complete === "boolean" ? complete : !complete.some((a) => !a);
    (_a4 = me.prefinalize) == null ? void 0 : _a4.call(me, me.completed, me);
    while (items2.length) {
      items2.pop().destroy();
    }
    (_b = me.finalize) == null ? void 0 : _b.call(me, me.completed, me);
  }
  revert(options) {
    var _a4;
    const me = this, { reverting } = me, start = !options || ((_a4 = options.start) != null ? _a4 : true);
    let anim = me.defaults;
    if (reverting) {
      if (reverting.finalize) {
        anim.finalize = reverting.finalize;
      }
      if (reverting.prefinalize) {
        anim.prefinalize = reverting.prefinalize;
      }
      anim.retain = reverting._retain;
    }
    anim = assign(anim, options, {
      items: me.items.map((it) => it.revert(nostart)),
      reverting: me
    });
    anim = new _Animator(anim);
    start && anim.start();
    return anim;
  }
  /**
   * Starts this animation and returns a reference to itself. This method is called automatically by the
   * {@link #function-run-static} method.
   * @returns {Core.util.Animator}
   */
  start() {
    const { element, items: items2 } = this;
    super.start();
    if (items2.length) {
      syncTransitions(element);
      items2.forEach((a) => a.start());
    }
    return this;
  }
};
Animator.initClass().Transition = AnimatorTransition;
Animator.specialPropsRe = new RegExp(`^(?:${Object.keys(Animator.prototypeProperties).concat(
  Object.keys(Animator.superclass.prototypeProperties)
).map((s) => s[0] === "_" ? s.substr(1) : s).join("|")})$`);
Animator.defaultDuration = 200;
Animator.fx = {};
Animator.register({
  /**
   * A compound animation to achieve `transform: scale()` and `opacity: 0`. The `scale` defaults to 8 but can be set
   * in the `anim` config object.
   *
   * For example
   * ```javascript
   *  const puff = Animator.puff(element);
   *
   *  const puff = Animator.puff({
   *      element,
   *      scale : 12
   *  });
   * ```
   *
   * This compound animation can also be specified in an `Animator` config object along with other style transitions:
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      marginLeft : -200,
   *      puff       : true   // true for default scale, a number, or config object
   *  });
   * ```
   * @param {Element|AnimatorConfig|Core.util.Animator} anim The element to animate or the config object containing at least
   * the `element` property. This config object can contain an optional `scale` property to adjust the animation's
   * `transform: scale()` value.
   * @param {Number} [anim.scale=8] The scale value for the `transform:scale()` transition.
   * @returns {Core.util.Animator}
   * @static
   */
  puff(anim) {
    if (anim === true) {
      anim = {};
    } else if (typeof anim !== "object") {
      anim = {
        transform: `scale(${anim})`
      };
    } else if (anim.scale) {
      anim = ObjectHelper.clone(anim);
      anim.transform = `scale(${anim.scale})`;
      delete anim.scale;
    }
    return assign({
      opacity: 0,
      transform: "scale(8)"
    }, anim);
  }
});
Animator._$name = "Animator";

// ../Core/lib/Core/util/ClickRepeater.js
var ClickRepeater = class extends Base.mixin(Delayable_default) {
  static get configurable() {
    return {
      /**
       * The element on which to fire autorepeating `click` events when the mouse is held down.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * A query selector which specifies subtargets of this ClickRepeater's {@link #config-element}
       * which act as the click auto repeat event targets.
       * @config {String}
       * @default
       */
      delegate: null,
      /**
       * How long in milliSeconds to pause before starting the click repeats.
       * @config {Number}
       * @default
       */
      delay: 500,
      /**
       * Clicks per second to start firing after the initial {@link #config-delay}
       * @config {Number}
       * @default
       */
      startRate: 2,
      /**
       * Clicks per second to fire at top speed, after accelerating over the {@link #config-accelerateDuration}
       * @config {Number}
       * @default
       */
      endRate: 20,
      /**
       * How long in milliseconds to accelerate from the
       * {@link #config-startRate} to the {@link #config-startRate}.
       * @config {Number}
       * @default
       */
      accelerateDuration: 4e3,
      pressedCls: "b-pressed"
    };
  }
  doDestroy() {
    var _a4;
    (_a4 = this.mousedownRemover) == null ? void 0 : _a4.call(this);
    this.cancel();
    super.doDestroy();
  }
  cancel() {
    var _a4, _b, _c;
    const me = this;
    (_a4 = me.activeElement) == null ? void 0 : _a4.classList.remove(me.pressedCls);
    me.activeElement = null;
    (_b = me.acceleration) == null ? void 0 : _b.cancel();
    me.activeListenerRemover = (_c = me.activeListenerRemover) == null ? void 0 : _c.call(me);
    me.clearTimeout(me.autoRepeatTimer);
    me.clearTimeout(me.repeatTimer);
  }
  updateElement(element) {
    var _a4;
    (_a4 = this.mousedownRemover) == null ? void 0 : _a4.call(this);
    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: "onMouseDown",
      thisObj: this
    });
  }
  onMouseDown(e) {
    const me = this, target = me.delegate ? e.target.closest(me.delegate) : me.element;
    me.cancel();
    if (target) {
      me.activeElement = target;
      me.triggerEvent = e;
      target.classList.add(me.pressedCls);
      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          capture: true,
          handler: "onMouseUp"
        },
        mousemove: {
          element: target,
          handler: "onTargetMouseMove"
        },
        mouseleave: {
          element: target,
          handler: "onTargetMouseLeave"
        },
        mouseenter: {
          element: target,
          handler: "onTargetMouseEnter"
        },
        thisObj: me
      });
      me.autoRepeatTimer = me.setTimeout("startAutoRepeat", me.delay);
    }
  }
  onMouseUp() {
    this.cancel();
  }
  onTargetMouseLeave() {
    this.activeElement.classList.remove(this.pressedCls);
    this.clearTimeout(this.repeatTimer);
  }
  onTargetMouseEnter(e) {
    const me = this;
    if (!e.buttons) {
      me.cancel();
    } else {
      me.activeElement.classList.add(me.pressedCls);
      me.triggerEvent = e;
      me.fireClick();
    }
  }
  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }
  startAutoRepeat() {
    const me = this;
    me.interval = me.startInterval = 1e3 / me.startRate;
    me.accelerationDelta = me.startInterval - 1e3 / me.endRate;
    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, "easeOutQuad");
  }
  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }
  fireClick() {
    const me = this, clickEvent = new MouseEvent("click", me.triggerEvent);
    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }
};
ClickRepeater._$name = "ClickRepeater";

// ../Core/lib/Core/widget/mixin/Rotatable.js
var autoRotateRe = /^(?:undefined|null|LEFT|RIGHT)$/;
var inverted = {
  TOP: "BOTTOM",
  RIGHT: "LEFT",
  BOTTOM: "TOP",
  LEFT: "RIGHT"
};
var canonicalDock = (dock) => {
  const DOCK = dock == null ? void 0 : dock.toUpperCase();
  return [DOCK, DOCK === "LEFT" || DOCK === "RIGHT"];
};
var Rotatable_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Set to `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
         * @member {'left'|'right'} rotate
         */
        /**
         * Specify `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
         * @config {'left'|'right'}
         */
        rotate: null,
        invertRotate: null
      };
    }
    compose() {
      const { rotate } = this;
      return {
        class: {
          [`b-rotate-${(rotate || "").toLowerCase()}`]: rotate,
          "b-rotate-vertical": rotate
        }
      };
    }
    syncRotationToDock(dock) {
      if (autoRotateRe.test(String(this.rotate))) {
        const [DOCK, vertical] = canonicalDock(dock);
        this.rotate = vertical ? this.invertRotate ? inverted[DOCK] : DOCK : null;
      }
    }
    get widgetClass() {
      return null;
    }
  }, __publicField(_a4, "$name", "Rotatable"), _a4;
};

// ../Core/lib/Core/widget/Tool.js
var Tool = class extends Widget.mixin(Rotatable_default) {
  compose() {
    const { align, href } = this;
    return {
      tag: href != null ? "a" : "button",
      class: {
        [`b-align-${align || "end"}`]: 1,
        "b-icon": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onInternalClick"
      }
    };
  }
  get focusElement() {
    return this.element;
  }
  get panel() {
    var _a4, _b;
    if (((_a4 = this.parent) == null ? void 0 : _a4.isPanel) && ((_b = this.element) == null ? void 0 : _b.parentNode.matches(".b-panel-header"))) {
      return this.parent;
    }
  }
  changeAlign(align) {
    return align;
  }
  onInternalClick(domEvent) {
    const me = this, { handler, panel } = me, bryntumEvent = { domEvent, tool: me };
    if (me.disabled) {
      return;
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
      if (!me.isDestroyed && (panel == null ? void 0 : panel.trigger("toolClick", bryntumEvent)) !== false) {
        handler && me.callback(handler, panel, [domEvent, panel, me]);
      }
    }
  }
  onInternalKeyDown(keyEvent) {
    const keyName = keyEvent.key.trim() || keyEvent.code;
    if (keyName === "Enter") {
      keyEvent.cancelBubble = true;
      keyEvent.stopPropagation();
    }
  }
  updateDisabled(disabled, was) {
    var _a4;
    super.updateDisabled(disabled, was);
    disabled && ((_a4 = this.repeat) == null ? void 0 : _a4.cancel());
  }
  changeRepeat(repeat, oldRepeat) {
    oldRepeat == null ? void 0 : oldRepeat.destroy();
    return repeat && ClickRepeater.new({
      element: this.element
    }, repeat);
  }
};
__publicField(Tool, "$name", "Tool");
__publicField(Tool, "type", "tool");
__publicField(Tool, "configurable", {
  /**
   * Specify `'start'` to place the tool before the owner's central element (e.g., the `title` of the panel).
   * @config {'start'|'end'}
   * @default 'end'
   * @category Float & align
   */
  align: {
    value: null,
    $config: {
      merge: "replace"
    }
  },
  /**
   * If provided, turns the tool into a link
   * @config {String}
   */
  href: null,
  /**
   * The function to call when this tool is clicked. May be a function or function name
   * prepended by `"up."` that is resolvable in an ancestor component (such as an owning
   * Grid, Scheduler, Calendar, Gantt or TaskBoard)
   *
   * @config {Function|String} handler
   * @param {Event} handler.event The DOM event which activated the tool
   * @param {Core.widget.Panel} handler.panel The owning Panel of the tool
   * @param {Core.widget.Tool} handler.tool The clicked Tool
   * @returns {void}
   */
  /**
   * A {@link Core.util.ClickRepeater } config object to specify how click-and-hold gestures repeat the click
   * action.
   * @config {ClickRepeaterConfig}
   */
  repeat: null,
  defaultBindProperty: null
});
Tool.initClass();
Tool._$name = "Tool";

// ../Core/lib/Core/widget/panel/CollapseTool.js
var rightRe = /right/i;
var autoAlign = (tool) => (tool.collapsed || tool.collapsing) && // special case to align the expand tool with the collapse tool
tool.owner.expandedHeaderDock === "top" && tool.owner.collapsible.direction.match(rightRe) ? "start" : "end";
var CollapseTool = class extends Tool {
  static get configurable() {
    return {
      /**
       * Set to `false` to disable automatic adjustment of the {@link #config-align} config based on the state
       * of the panel's {@link Core.widget.Panel#config-collapsed} config and the
       * {@link Core.widget.panel.PanelCollapser#config-direction}.
       *
       * If this is set to a function, that function is called passing the owning `Panel` instance and its
       * return value is assigned to the {@link #config-align} config.
       *
       * @config {Boolean|Function}
       * @param {Core.widget.Panel} owner The owning `Panel` instance
       * @returns {Boolean} Auto align value
       * @default
       */
      autoAlign: true,
      collapsed: null,
      collapsing: null,
      collapsify: false,
      // ...unaffected when the panel is collapsed
      direction: "up",
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  compose() {
    const { collapsed, direction } = this;
    return {
      class: {
        [`b-icon-collapse-${direction}`]: 1,
        "b-collapsed": collapsed
      }
    };
  }
  changeAutoAlign(v) {
    return v === true ? autoAlign : v;
  }
  syncAutoAlign() {
    const { autoAlign: autoAlign2 } = this;
    if (autoAlign2) {
      this.align = autoAlign2(this);
    }
  }
  updateAutoAlign() {
    this.syncAutoAlign();
  }
  updateCollapsed() {
    this.syncAutoAlign();
  }
  updateCollapsing() {
    this.syncAutoAlign();
  }
  updateDirection() {
    this.syncAutoAlign();
  }
};
__publicField(CollapseTool, "$name", "CollapseTool");
__publicField(CollapseTool, "type", "collapsetool");
CollapseTool.initClass();
CollapseTool._$name = "CollapseTool";

// ../Core/lib/Core/widget/panel/PanelCollapser.js
var defaultedDirectionRe = /^(?:UP|DOWN|LEFT|RIGHT)$/;
var dockBeforeRe = /^(left|top)$/i;
var emptyObject8 = {};
var headerDockRe = /^b-dock-(top|left|right|bottom)$/;
var revealerCls = "b-panel-collapse-revealer";
var sideDockRe = /^(?:left|right)$/i;
var unflexCls = "b-collapse-unflex";
var { round } = Math;
var canonicalDirection = ["up", "down", "left", "right"].reduce((o, v) => {
  o[v.toUpperCase()] = o[v] = v;
  return o;
}, {});
var clipByDock = {
  top: ["top", "bottom"],
  right: ["right", "left"],
  bottom: ["bottom", "top"],
  left: ["left", "right"]
};
var collapseDirectionByPlacement = {
  hl: "LEFT",
  hr: "RIGHT",
  vb: "DOWN",
  vt: "UP"
};
var crossAxis = {
  h: "w",
  w: "h"
};
var dockByDirection = {
  up: "top",
  right: "right",
  down: "bottom",
  left: "left"
};
var dockIsHorz = {
  top: false,
  right: true,
  bottom: false,
  left: true
};
var directionByDock = {
  top: "UP",
  right: "RIGHT",
  bottom: "DOWN",
  left: "LEFT"
};
var transverseTransform = {
  top: (rect) => `translate(0, -${round(rect.height || 0)}px)`,
  bottom: (rect) => `translate(0, ${round(rect.height || 0)}px)`,
  right: (rect) => `translate(${round(rect.width || 0)}px, 0)`,
  left: (rect) => `translate(-${round(rect.width || 0)}px, 0)`
};
var idSeed2 = 0;
var PanelCollapser = class extends Base.mixin(Factoryable_default) {
  static get configurable() {
    return {
      /**
       * An animation config object.
       * @config {Object} animation
       * @property {Number} [animation.duration=200] The duration of the animation (in milliseconds).
       */
      animation: {
        duration: 200
      },
      /**
       * Tracks whether or not the panel is collapsed.
       * @config {Boolean}
       * @private
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * Specifies the direction of panel collapse. The default value for this config is determined dynamically
       * based on the {@link Core.widget.Panel#config-header header's} `dock` property and the containing layout's
       * flex direction and, therefore, often does not need to be explicitly specified.
       *
       * This config can be any of the following:
       * - `'up'`
       * - `'down'`
       * - `'left'`
       * - `'right'`
       *
       * @config {'up'|'down'|'left'|'right'}
       */
      direction: null,
      /**
       * The tooltip to use for the collapse tool when the panel is expanded.
       * @config {String}
       */
      collapseTooltip: "L{Collapse}",
      /**
       * The tooltip to use for the expand tool when the panel is collapsed.
       * @config {String}
       */
      expandTooltip: "L{Expand}",
      panel: {
        value: null,
        $config: "nullify"
      },
      /**
       * To support the panel's collapsed size, a minimum width and height may be assigned to the panel's header,
       * based on this config and the panel's positioning style.
       *
       * When a panel is collapsed it may need to retain the pre-collapse dimension perpendicular to the collapse
       * {@link #config-direction}. For example, the height of a panel that collapses to the left. The dimension
       * parallel to the collapse (the width in this example) may also need to be supported using the pre-collapse
       * size of the panel's header.
       *
       * When this config is set to `true`, or by default when the owning panel is `position: absolute`, both
       * axes are given a minimum size based on the panel's pre-collapse size. When this config is `false`, no
       * minimum sizes will be assigned.
       *
       * This config can also be a string containing the single letters 'w' and/or 'h' indicating which axis/axes
       * of the panel header should be assigned a minimum size. That is, 'w' to assign only a minimum width, 'h'
       * for only a minimum height, or 'wh' to assign both.
       *
       * @config {String|Boolean}
       * @internal
       */
      supportAxis: null,
      /**
       * The collapse/expand tool. The `type` of this instance should not be changed but the tool instance can be
       * configured in other ways via this config property.
       * @config {ToolConfig|Core.widget.Tool}
       */
      tool: {
        type: "collapsetool",
        handler(ev) {
          var _a4;
          (_a4 = this.collapsible) == null ? void 0 : _a4.onCollapseClick(ev);
        }
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "inline"
    };
  }
  get collapsing() {
    return this.collapsingExpanding === "collapsing";
  }
  get collapsingExpanding() {
    var _a4;
    const state = (_a4 = this.currentOperation) == null ? void 0 : _a4.collapsing;
    return state == null ? null : state ? "collapsing" : "expanding";
  }
  get currentDock() {
    var _a4, _b, _c, _d;
    return (_d = (_c = (_b = (_a4 = this.panel) == null ? void 0 : _a4.header) == null ? void 0 : _b.dock) == null ? void 0 : _c.toLowerCase()) != null ? _d : "top";
  }
  get expanding() {
    return this.collapsingExpanding === "expanding";
  }
  get collapseTool() {
    var _a4, _b;
    return (_b = (_a4 = this.panel) == null ? void 0 : _a4.tools) == null ? void 0 : _b.collapse;
  }
  get collapseDim() {
    return sideDockRe.test(this.collapseDir) ? "width" : "height";
  }
  getCollapseDir(canonical) {
    var _a4;
    let { direction, panel } = this;
    if (!direction || defaultedDirectionRe.test(direction)) {
      const placement = panel == null ? void 0 : panel.placement;
      if (placement) {
        direction = collapseDirectionByPlacement[placement];
      } else {
        direction = directionByDock[((_a4 = panel == null ? void 0 : panel.header) == null ? void 0 : _a4.dock) || "top"];
      }
    }
    return canonical ? canonicalDirection[direction] : direction;
  }
  get collapseDir() {
    return this.getCollapseDir(true);
  }
  get collapseDock() {
    return this.collapseInfo[0];
  }
  get collapseInfo() {
    const { panel } = this, headerDock2 = panel.hasHeader && panel.expandedHeaderDock;
    let dock = dockByDirection[this.collapseDir], transverse = false;
    if (headerDock2) {
      if (!(transverse = dockIsHorz[dock] !== dockIsHorz[headerDock2])) {
        dock = headerDock2;
      }
    }
    return [dock, transverse];
  }
  get toolsConfig() {
    const { direction, tool } = this;
    return tool && {
      collapse: ObjectHelper.assign({
        direction: direction.toLowerCase()
      }, tool)
    };
  }
  beforeCollapse(operation) {
    const { panel } = this, { element } = panel;
    if (element.contains(DomHelper.getActiveElement(element))) {
      panel.revertFocus(true);
    }
  }
  changeTool(tool) {
    const me = this, { panel } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      collapse: tool
    };
  }
  collapse(collapsed) {
    var _a4, _b;
    const me = this, { panel } = me, operation = {
      id: ++idSeed2,
      completed: false,
      panel
    };
    let { currentOperation } = me;
    collapsed = collapsed != null ? collapsed : true;
    if (ObjectHelper.isObject(collapsed)) {
      operation.collapsed = true;
      ObjectHelper.assign(operation, collapsed);
      collapsed = operation.collapsed;
      delete operation.collapsed;
    }
    operation.collapsing = collapsed;
    operation.previous = currentOperation != null ? currentOperation : null;
    if (collapsed !== me.collapsed) {
      if (currentOperation) {
        if (currentOperation.collapsing !== collapsed) {
          operation.animation = currentOperation.animation.revert({
            finalize() {
              var _a5;
              (_a5 = me.collapseFinalize) == null ? void 0 : _a5.call(me, operation, true);
            }
          });
          operation.collapsing = collapsed;
          currentOperation = operation;
        }
      } else {
        operation.animation = ObjectHelper.clone(("animation" in operation ? operation : me).animation);
        if (me.beforeCollapse(operation) !== false) {
          if (operation.animation) {
            operation.animation.finalize = (complete) => {
              var _a5;
              return (_a5 = me.collapseFinalize) == null ? void 0 : _a5.call(me, operation, complete);
            };
          }
          panel.changingCollapse = true;
          me[collapsed ? "collapseBegin" : "expandBegin"](operation);
          if (operation.animation) {
            currentOperation = operation;
          } else {
            operation.completed = true;
            me[collapsed ? "collapseEnd" : "expandEnd"](operation);
          }
          panel.changingCollapse = false;
          if (!operation.animation) {
            me.onComplete(collapsed ? "collapse" : "expand");
          }
        }
      }
    } else if (currentOperation && currentOperation.collapsing !== collapsed) {
      me[collapsed ? "expandRevert" : "collapseRevert"](operation);
      operation.animation = currentOperation.animation.revert({
        finalize() {
          var _a5;
          (_a5 = me.collapseFinalize) == null ? void 0 : _a5.call(me, operation, false);
        }
      });
      currentOperation = operation;
    }
    me.currentOperation = currentOperation;
    return (_b = (_a4 = currentOperation == null ? void 0 : currentOperation.animation) == null ? void 0 : _a4.done()) != null ? _b : Promise.resolve(collapsed === me.collapsed);
  }
  collapseFinalize(operation, complete) {
    const me = this, { currentOperation, panel } = me, action = panel.collapsed ? "expand" : "collapse";
    if (currentOperation === operation) {
      me.currentOperation = null;
      operation.completed = complete;
      panel.changingCollapse = true;
      me[action + "End"](operation);
      panel.changingCollapse = false;
      complete && me.onComplete(action);
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    const me = this, { currentDock, panel } = me, dock = collapsed ? me.collapseDock : panel.expandedHeaderDock;
    if (dock !== currentDock && panel.hasHeader) {
      panel.header = {
        dock
      };
      flush && panel.recompose.flush();
    }
  }
  composeHeader(header) {
    const { panel } = this, { class: cls } = header, dock = panel.expandedHeaderDock || Object.keys(cls).filter((k) => cls[k] && headerDockRe.test(k)).map((k) => headerDockRe.exec(k)[1][0]);
    cls[revealerCls] = 1;
    cls[`b-collapsible-${dock[0]}${this.collapseDir[0]}`] = 1;
    return header;
  }
  composeTitle(title) {
    title.class[revealerCls] = 1;
    return title;
  }
  collapseBegin(operation) {
    var _a4;
    const me = this, { animation } = operation, { collapseDim, collapseTool, panel } = me, { element, placement } = panel, [collapseDock, transverse] = me.collapseInfo, collapseToolClasses = collapseTool == null ? void 0 : collapseTool.element.classList, unflex = !placement || placement[0] === "h" && collapseDim === "width" || placement[0] === "v" && collapseDim === "height";
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.transverseCollapse = transverse;
    me.applyHeaderDock(true);
    const panelRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[collapseDock], headerRect = (_a4 = panel.headerElement) == null ? void 0 : _a4.getBoundingClientRect(), collapsedSize = round((headerRect == null ? void 0 : headerRect[collapseDim]) || 0);
    element.classList.toggle(unflexCls, unflex);
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      element.classList.add("b-collapsing");
      collapseToolClasses == null ? void 0 : collapseToolClasses.add("b-collapsed", "b-collapsing");
      if (collapseTool) {
        collapseTool.collapsing = true;
      }
      if (collapseToolClasses) {
        collapseToolClasses.remove("b-collapsed");
        panel.rectangle();
        collapseToolClasses.remove("b-collapsing");
        collapseToolClasses.add("b-collapsed");
      }
      animation.element = element;
      animation.retain = true;
      animation[collapseDim] = {
        from: round(panelRect[collapseDim]),
        to: collapsedSize
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapRect})`,
          to: `rect(${bodyWrapClipRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: transverseTransform[collapseDock](headerRect),
            to: `translate(0, 0)`
          }
        });
      }
      operation.animation = Animator.run(animation);
    } else {
      element.style[collapseDim] = `${collapsedSize}px`;
      if (collapseTool) {
        collapseToolClasses.add("b-collapsing", "b-collapsed");
        collapseTool.rectangle();
        collapseToolClasses.remove("b-collapsing");
      }
    }
  }
  collapseEnd(operation) {
    const me = this, { collapseTool } = me;
    me.panel.element.classList.remove("b-collapsing");
    if (collapseTool) {
      collapseTool.collapsing = false;
    }
    if (operation.completed) {
      me.collapsed = true;
    } else {
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  collapseRevert(operation) {
    var _a4;
    (_a4 = this.collapseTool) == null ? void 0 : _a4.element.classList.remove("b-collapsed");
  }
  expandBegin(operation) {
    const me = this, { animation } = operation, { collapseDim, collapseTool, panel } = me, [collapseDock, transverse] = me.collapseInfo, { element } = panel, elementClassList = element.classList, unflex = elementClassList.contains(unflexCls), fromRect = panel.rectangle();
    elementClassList.remove("b-collapsed", "b-collapsing");
    panel.element.style[collapseDim] = "";
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    const toRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[me.collapseDock];
    collapseTool == null ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      elementClassList.add("b-collapsed", "b-expanding");
      unflex && elementClassList.add(unflexCls);
      animation.element = element;
      animation[collapseDim] = {
        from: round(fromRect[collapseDim]),
        to: round(toRect[collapseDim])
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapClipRect})`,
          to: `rect(${bodyWrapRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: `translate(0, 0)`,
            to: transverseTransform[collapseDock](fromRect)
          }
        });
      }
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    const me = this;
    me.panel.element.classList.remove("b-expanding");
    if (operation.completed) {
      me.collapsed = false;
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  expandRevert(operation) {
    var _a4;
    (_a4 = this.collapseTool) == null ? void 0 : _a4.element.classList.add("b-collapsed");
  }
  get innerElement() {
    return this.panel.collapseWrapElement || this.panel.bodyWrapElement;
  }
  get innerSizeElement() {
    return this.transverseCollapse ? this.panel.element : this.innerElement;
  }
  get supportAxis() {
    let { _supportAxis } = this;
    const fullSupport = _supportAxis === true;
    if (fullSupport || _supportAxis == null) {
      _supportAxis = this.collapseDim[0];
      if (fullSupport || DomHelper.getStyleValue(this.panel.element, "position") === "absolute") {
        _supportAxis += crossAxis[_supportAxis];
      }
    }
    return _supportAxis || "";
  }
  lockInnerSize(lock = true) {
    const me = this, { innerElement, panel } = me, supportAxis = lock ? me.supportAxis : "", panelEl = panel.element, headerEl = panel.headerElement, headerRect = lock && headerEl && Rectangle.from(headerEl, panelEl), innerRect = lock && Rectangle.from(me.innerSizeElement, panelEl), innerStyle = innerElement.style;
    if (headerEl) {
      headerEl.style.minWidth = supportAxis.includes("w") ? `${headerRect.width}px` : "";
      headerEl.style.minHeight = supportAxis.includes("h") ? `${headerRect.height}px` : "";
    }
    innerStyle.width = lock ? `${innerRect.width}px` : "";
    innerStyle.height = lock ? `${innerRect.height}px` : "";
    innerElement.classList[lock ? "add" : "remove"]("b-panel-collapse-size-locker");
    return innerRect;
  }
  onCollapseClick(e) {
    let collapsed = this.collapsing ? false : this.expanding ? true : !this.collapsed;
    if (e.altKey) {
      collapsed = {
        animation: null,
        collapsed
      };
    }
    this.collapse(collapsed);
  }
  onComplete(action) {
    var _a4;
    (_a4 = this.panel) == null ? void 0 : _a4.trigger(action);
  }
  onPanelHeaderClick({ event }) {
    if (event.button === 0 && this.panel.collapsed && event.target.classList.contains(revealerCls)) {
      this.onRevealerClick();
    }
  }
  onPanelConfigChange({ name, value }) {
    const me = this, { panel } = me;
    if (name === "collapsed") {
      if (panel.isPainted) {
        me.collapsed = value;
      }
    } else if (name === "header" && !panel.changingCollapse) {
      me.syncDirection();
    }
  }
  onPanelPaint() {
    this.syncDirection();
    if (this.panel.collapsed && !this.collapsed) {
      this.collapse({
        animation: null,
        collapsed: true
      });
    }
  }
  onRevealerClick() {
    this.panel._collapse({ collapsed: false });
  }
  restoreConfiguredSize(which) {
    const { configuredHeight, configuredWidth, panel } = this;
    which = which != null ? which : "wh";
    panel.element.classList.remove(unflexCls);
    if (configuredWidth != null && which.includes("w")) {
      panel.width = configuredWidth;
    }
    if (configuredHeight != null && which.includes("h")) {
      panel.height = configuredHeight;
    }
  }
  splitHeaderItems({ as, dock } = emptyObject8) {
    var _a4;
    return (_a4 = this.panel) == null ? void 0 : _a4.splitHeaderItems({ as, dock, alt: true });
  }
  syncDirection() {
    const me = this, { direction } = me;
    if (!direction || defaultedDirectionRe.test(direction)) {
      me.direction = me.getCollapseDir();
    }
  }
  changeCollapsed(collapsed) {
    return Boolean(collapsed);
  }
  updateCollapsed(collapsed) {
    const { collapseTool, panel } = this;
    if (panel) {
      panel.collapsed = collapsed;
      panel.element.classList[collapsed ? "add" : "remove"]("b-collapsed");
    }
    if (collapseTool) {
      collapseTool.collapsed = collapsed;
    }
  }
  updateDirection(direction) {
    const { collapseTool, panel } = this;
    if (collapseTool) {
      collapseTool.direction = canonicalDirection[direction];
    }
    if (panel == null ? void 0 : panel.rendered) {
      panel.recompose();
    }
  }
  updatePanel(panel) {
    var _a4;
    const me = this;
    me.syncDirection();
    (_a4 = me.panelChangeDetacher) == null ? void 0 : _a4.call(me);
    me.panelChangeDetacher = panel && FunctionHelper.after(panel, "onConfigChange", "onPanelConfigChange", me, {
      return: false
    });
  }
  wrapCollapser(key, body) {
    var _a4;
    const me = this, [collapseDock, transverse] = me.collapseInfo;
    if (!transverse) {
      return [key, body];
    }
    const { collapseDir, panel } = me, { expandedHeaderDock, header: panelHeader, uiClassList } = panel, recollapse = (_a4 = panel.tools) == null ? void 0 : _a4.recollapse, [before, after] = me.splitHeaderItems({ as: "element", dock: collapseDock }), title = panel.hasHeader ? panel.title || (panelHeader == null ? void 0 : panelHeader.title) || "\xA0" : null, headerElement = title && {
      tag: "header",
      class: new DomClassList({
        ...uiClassList,
        [`b-dock-${expandedHeaderDock}`]: 1,
        "b-panel-header": 1,
        "b-panel-collapser-header": 1
      }, panelHeader == null ? void 0 : panelHeader.cls),
      children: [
        ...before,
        {
          reference: "collapserTitleElement",
          html: title,
          class: {
            ...uiClassList,
            [`b-align-${(panelHeader == null ? void 0 : panelHeader.titleAlign) || "start"}`]: 1,
            "b-header-title": 1
          }
        },
        ...after
      ]
    };
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return [
      "collapseWrapElement",
      {
        class: {
          ...uiClassList,
          [`b-panel-collapser-header-${expandedHeaderDock}`]: 1,
          [`b-panel-collapser-${collapseDir}`]: 1,
          [`b-${dockIsHorz[expandedHeaderDock] ? "h" : "v"}box`]: 1,
          "b-panel-collapser": 1,
          "b-box-center": 1
        },
        children: dockBeforeRe.test(expandedHeaderDock) ? {
          collapserHeaderElement: headerElement,
          [key]: body
        } : {
          [key]: body,
          collapserHeaderElement: headerElement
        }
      }
    ];
  }
};
__publicField(PanelCollapser, "$name", "PanelCollapser");
__publicField(PanelCollapser, "type", "inline");
PanelCollapser.maps = {
  clipByDock,
  dockByDirection,
  dockIsHorz
};
PanelCollapser.initClass();
PanelCollapser._$name = "PanelCollapser";

// ../Core/lib/Core/util/DynamicObject.js
var PENDING = Symbol("pendingCreate");
var DynamicObject = class extends Base {
  static get prototypeProperties() {
    return {
      /**
       * Optional function that will be passed an instance prior to destroying it.
      *
       * @config {Function}
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced
       * @param {Object} instance The value of the property
       * @returns {void}
       */
      cleanup: null,
      /**
       * Optional name of the config property managed by this instance. If changes are made directly, this
       * property is used to run the `onConfigChange` method of the `owner`.
       * @config {String}
       */
      configName: null,
      /**
       * Optional function to call as instances are created. Each new instance is passed to this function.
       *
       * @config {Function}
       * @param {Object} instance The newly created instance.
       * @param {String} key The property name in the dynamic object by which the new instance may be referenced.
       * @returns {void}
       */
      created: null,
      /**
       * The {@link Core.mixin.Factoryable factory} to use to create instances.
       * @config {Object}
       */
      factory: null,
      /**
       * By default, the name of the member is used for the type. Set this config to `true` to also allow the
       * config object for a property to contain a `type` property. Set this to `false` to ignore the name of the
       * member and rely on the {@link #config-factory} to process the config object.
       * @config {Boolean|String}
       * @default
       */
      inferType: "name",
      /**
       * The owning object to pass along to the instances as the `ownerName` property.
       * @config {Object}
       */
      owner: null,
      /**
       * The property name by which to store the `owner` on each instance.
       * @config {String}
       */
      ownerName: null,
      /**
       * Set to `false` to prevent using a `Proxy` even if that JavaScript platform feature is available. Using
       * a `Proxy` is ideal because it allows for all forms of access to the dynamic properties to be handled
       * instead of only those that have predefined configuration values.
       * @config {Boolean}
       * @private
       */
      proxyable: typeof Proxy !== "undefined",
      /**
       * Optional function that will be passed a config object prior to instantiating an object. This function
       * can either modify the passed object or return a new object.
       *
       * @config {Function}
       * @param {Object} config The config object used to create the object
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced
       * @returns {Object|null}
       */
      setup: null,
      /**
       * Optional function that will be passed a raw config object prior to processing and the value it returns
       * replaces the raw value. This function is used to transform strings or arrays (for example) into proper
       * config objects.
       *
       * @config {Function}
       * @param {*} config The original value of the config object parameter
       * @returns {*}
       */
      transform: null
    };
  }
  static get properties() {
    return {
      /**
       * Holds config objects for each defined object. These are used to hold class and instance config values
       * and use them to create instances on first request, or when `flush()` is called. Further, if the instance
       * is initially assigned instead of retrieved, these values act as the defaults for the instance and are
       * combined with those provided in the assignment.
       * @member {Object} defaults
       * @private
       */
      defaults: {},
      /**
       * This object holds the actual instances that are retrieved by the dynamic accessor or `Proxy`.
       * @member {Object} instances
       * @private
       */
      instances: {},
      /**
       * The object that contains the dynamic accessors for each instance. This object is not used when using a
       * `Proxy`.
       * @member {Object} object
       * @private
       */
      object: /* @__PURE__ */ Object.create({})
    };
  }
  /**
   * Returns the `Proxy` instance used to manage dynamic assignments. If the JavaScript platform does not support the
   * `Proxy` class, this will be `null`.
   * @property {Proxy}
   * @private
   */
  get proxy() {
    const me = this;
    let proxy = null;
    if (me.proxyable) {
      proxy = new Proxy(me.instances, {
        get(o, name) {
          return me.get(name);
        },
        set(o, name, value) {
          me.set(name, value);
          return true;
        },
        deleteProperty(o, name) {
          me.set(name, null);
          return true;
        }
      });
    }
    Reflect.defineProperty(me, "proxy", {
      configurable: true,
      // allow destroy() to delete it
      value: proxy
    });
    return proxy;
  }
  /**
   * Returns the object that contains the dynamic properties. This may be a `Proxy` instance or an object with getter
   * and setter accessors.
   * @property {Object}
   * @internal
   */
  get target() {
    return this.proxy || this.object;
  }
  /**
   * This method establishes the initial definition of a dynamic property. When using a `Proxy`, this method simply
   * needs to cache away the initial config for use by the getter. When `Proxy` is unavailable, this method will
   * also defined a getter/setter to intercept access to the dynamic property.
   * @param {String} name The name of the dynamic property.
   * @param {Object} config The initial config object for the dynamic property.
   * @private
   */
  define(name, config) {
    const me = this, { transform } = me, transformed = transform ? transform(config, name) : config, instantiated = ObjectHelper.isInstantiated(transformed);
    me.instances[name] = PENDING;
    if (!instantiated) {
      me.setDefaults(name, transformed);
    }
    me.defineProp(name, true);
    if (instantiated) {
      me.set(name, transformed);
    }
  }
  /**
   * Define the get/set accessors for `name` on our `object` or its prototype.
   * @param {String} name
   * @param {Boolean} [base] Pass `true` to indicate the property should be defined on the prototype.
   * @private
   */
  defineProp(name, base) {
    const me = this, { object } = me;
    if (!me.proxy) {
      Reflect.defineProperty(base ? Object.getPrototypeOf(object) : object, name, {
        configurable: !base,
        enumerable: true,
        get() {
          return me.get(name);
        },
        set(value) {
          return me.set(name, value);
        }
      });
    }
  }
  /**
   * Ensures that all defined members are touched to trigger their creation.
   * @internal
   */
  flush() {
    var _a4;
    const me = this;
    try {
      me.updating = true;
      for (const name in me.defaults) {
        me.get(name);
      }
      me.afterConfigureOwner = (_a4 = me.afterConfigureOwner) == null ? void 0 : _a4.call(me);
    } finally {
      me.updating = false;
    }
  }
  /**
   * Returns (lazily creating as necessary) the value of a dynamic property given its name.
   * @param {String} name
   * @returns {Object}
   * @private
   */
  get(name) {
    const { defaults, instances } = this;
    if (instances[name] === PENDING) {
      this.set(name, PENDING);
    }
    return instances[name] || defaults[name] && null;
  }
  /**
   * Sets the value of a dynamic property given its name and value.
   * @param {String} name
   * @param {Object} value
   * @private
   */
  set(name, value) {
    var _a4;
    const me = this, { cleanup, configName, defaults, factory, instances, owner, setup, transform, updating } = me, inform = owner && configName && !updating, was = instances[name] === PENDING ? null : instances[name], instance = factory.reconfigure(was, value === PENDING ? {} : value || null, {
      cleanup: cleanup && ((instance2) => cleanup(instance2, name)),
      defaults: defaults[name] || me.setDefaults(name, {}),
      owner: me.owner,
      setup: setup && ((config, type, defaults2) => setup(config, name, type, defaults2)),
      transform: transform && ((config) => transform(config, name))
    });
    if (instance !== was) {
      const before = inform && { ...instances };
      instances[name] = instance;
      if (instance) {
        me.defineProp(name);
        (_a4 = me.created) == null ? void 0 : _a4.call(me, instance, name);
      } else {
        delete me.object[name];
        delete instances[name];
      }
      if (inform) {
        owner.onConfigChange({
          name: configName,
          config: owner.$meta.configs[configName],
          value: me.target,
          was: before
        });
      }
    }
  }
  /**
   * Stores the default config values for use in the factory reconfiguration process.
   * @param {String} name The name and default type of the dynamic property. Depending on {@link #config-inferType},
   * this may not be overridden by a type property in the config object.
   * @param {Object} config The config object.
   * @returns {Object}
   * @private
   */
  setDefaults(name, config) {
    const { defaults, factory, inferType, instances, owner, ownerName } = this, { typeKey } = factory.factoryable;
    config = config === true ? {} : ObjectHelper.assign({}, config);
    if (inferType === "name" || inferType === true && !config[typeKey]) {
      config[typeKey] = name;
    }
    if (ownerName) {
      config[ownerName] = owner;
    }
    config.beforeConfigure = (instance) => {
      instances[name] = instance;
    };
    return defaults[name] = config;
  }
  /**
   * Updates the members of `object` based on the provided configuration.
   * @param {Object} members The configuration for the instances of `object`.
   * @internal
   */
  update(members) {
    const me = this, { owner } = me;
    let name, config;
    try {
      me.updating = true;
      if (members) {
        for (name in members) {
          config = members[name];
          if (me.defaults[name]) {
            me.set(name, config);
          } else if (config) {
            me.define(name, config);
          }
        }
      } else {
        for (name in me.instances) {
          me.set(name, null);
        }
      }
    } finally {
      me.updating = false;
    }
    if (owner) {
      if (!owner.isConfiguring) {
        me.flush();
      } else if (!me.afterConfigureOwner) {
        me.afterConfigureOwner = FunctionHelper.before(owner, "afterConfigure", "flush", me);
      }
    }
  }
};
DynamicObject.initClass();
DynamicObject._$name = "DynamicObject";

// ../Core/lib/Core/widget/mixin/Toolable.js
var emptyArray7 = [];
var emptyObject9 = {};
var toolConfigs = {
  align: 1,
  // hidden : 1,
  weight: 1
};
var Toolable_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Widget) {
    static get configurable() {
      return {
        /**
         * The {@link Core.widget.Tool tools} as specified by the {@link #config-tools} configuration. Each is a
         * {@link Core.widget.Tool} instance which may be hidden, shown and observed and styled just like any other
         * widget.
         * @member {Object<String,Core.widget.Tool>} tools
         * @accepts {Object<String,Core.widget.Tool|ToolConfig>}
         * @category Content
         */
        /**
         * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
         * property name is the reference by which an instantiated tool may be retrieved from the live
         * `{@link #property-tools}` property.
         * @config {Object<String,ToolConfig>} tools
         * @category Content
         */
        tools: {
          value: null,
          $config: {
            nullify: true
          }
        },
        /**
         * An object containing config defaults for corresponding {@link #config-tools} objects with a matching name.
         *
         * This object contains a key named `'*'` with default config properties to apply to all tools. This
         * object provides the default `type` (`'tool').
         * @config {Object} toolDefaults
         * @private
         */
        toolDefaults: {
          "*": {
            type: "tool",
            align: "end"
          }
        }
      };
    }
    byWeightSortFn(a, b) {
      return (a.weight || 0) - (b.weight || 0);
    }
    byWeightReverseSortFn(a, b) {
      return (b.weight || 0) - (a.weight || 0);
    }
    gatherTools({ align, alt: alt2, refs } = emptyObject9) {
      var _a5, _b, _c;
      const { collapsed, tools } = this, options = { collapsed, alt: alt2 };
      let ret = [], alignment, key, i, item, tool;
      for (key in tools) {
        tool = tools[key];
        alignment = (_c = (_b = (_a5 = tool == null ? void 0 : tool.align) == null ? void 0 : _a5.align) != null ? _b : tool == null ? void 0 : tool.align) != null ? _c : "end";
        if (alignment === align && tool.isCollapsified(options)) {
          ret.push(tool);
        }
      }
      ret.sort(this[align === "end" ? "byWeightReverseSortFn" : "byWeightSortFn"]);
      if (refs) {
        const asWidget = refs === "widget", asRefs = {};
        for (i = 0; i < ret.length; ++i) {
          item = ret[i];
          asRefs[item.ref] = asWidget ? item : item.element;
        }
        ret = asRefs;
      }
      return ret;
    }
    getEndTools({ alt: alt2, refs } = emptyObject9) {
      return this.gatherTools({ align: "end", alt: alt2, refs });
    }
    getStartTools({ alt: alt2, refs } = emptyObject9) {
      return this.gatherTools({ align: "start", alt: alt2, refs });
    }
    get childItems() {
      return [
        ...this.getStartTools(),
        ...this._items || emptyArray7,
        ...this.getEndTools()
      ];
    }
    changeTools(tools, oldTools) {
      const me = this, manager = me.$tools || (me.$tools = new DynamicObject({
        configName: "tools",
        factory: Widget,
        inferType: false,
        // the name of a tool in the tools object is not its type
        owner: me,
        created(instance) {
          var _a5, _b;
          instance.innerItem = false;
          (_b = instance.syncRotationToDock) == null ? void 0 : _b.call(instance, (_a5 = me.header) == null ? void 0 : _a5.dock);
          FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
            if (toolConfigs[name]) {
              me.onConfigChange({
                name: "tools",
                value: manager.target
              });
            }
          });
          me.onChildAdd(instance);
        },
        setup(config, name) {
          config = ObjectHelper.merge({}, me.toolDefaults["*"], me.toolDefaults[name], config);
          config.parent = me;
          config.ref = name;
          return config;
        }
      }));
      manager.update(tools);
      if (!oldTools) {
        return manager.target;
      }
    }
    get widgetClass() {
    }
  }, __publicField(_a4, "$name", "Toolable"), _a4;
};

// ../Core/lib/Core/widget/layout/Box.js
var directionCls = [
  "b-hbox",
  "b-vbox"
];
var syncAlign = {
  name: "align",
  style: "alignItems"
};
var syncContentAlign = {
  name: "contentAlign",
  style: "alignContent"
};
var syncDirection = {
  name: "direction",
  style: "flexDirection"
};
var syncJustify = {
  name: "justify",
  style: "justifyContent",
  classes: ["stretch"]
};
var syncWrap = {
  name: "wrap",
  style: "flexWrap",
  map: {
    false: "nowrap",
    true: "wrap",
    reverse: "wrap-reverse"
  }
};
var Box = class extends Layout {
  /**
   * Set this value to `true` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
   * to `column`. Or alternatively, set {@link #config-horizontal} to `false`.
   * @config {Boolean} vertical
   * @default false
   */
  get vertical() {
    return this.horizontal === false;
  }
  set vertical(v) {
    return this.horizontal = !v;
  }
  updateAlign() {
    this.syncConfigStyle(syncAlign);
  }
  updateContentAlign() {
    this.syncConfigStyle(syncContentAlign);
  }
  updateDirection() {
    this.syncConfigStyle(syncDirection);
  }
  updateHorizontal() {
    var _a4;
    const me = this, classList = (_a4 = me.contentElement) == null ? void 0 : _a4.classList, vertical = Number(me.vertical);
    if (classList) {
      classList.remove(directionCls[1 - vertical]);
      classList.add(directionCls[vertical]);
    } else {
      me.syncConfigLater("horizontal");
    }
    me.syncDirection();
  }
  updateJustify() {
    this.syncConfigStyle(syncJustify);
  }
  updateReverse() {
    this.syncDirection();
  }
  updateWrap() {
    this.syncConfigStyle(syncWrap);
  }
  syncDirection() {
    const me = this, { reverse } = me;
    me.direction = reverse ? `${me.vertical ? "column" : "row"}${reverse ? "-reverse" : ""}` : null;
  }
};
__publicField(Box, "$name", "Box");
__publicField(Box, "type", "box");
__publicField(Box, "alias", "hbox");
__publicField(Box, "configurable", {
  containerCls: "b-box-container",
  itemCls: "b-box-item",
  /**
   * Sets the [align-items](https://developer.mozilla.org/en-US/docs/Web/CSS/align-items) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} align
   * @default 'stretch'
   */
  align: null,
  /**
   * Sets the [align-content](https://developer.mozilla.org/en-US/docs/Web/CSS/align-content) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} contentAlign
   * @default 'normal'
   */
  contentAlign: null,
  /**
   * Sets the [direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * This config is not set directly. Set {@link #config-horizontal}, {@link #config-vertical}, and/or
   * {@link #config-reverse} instead.
   * @config {String} direction
   * @private
   */
  direction: null,
  /**
   * Set this value to `false` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
   * to `column`. Or alternatively, set {@link #config-vertical} to `true`.
   * @config {Boolean} horizontal
   * @default
   */
  horizontal: true,
  /**
   * Sets the [justify-content](https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} justify
   * @default 'flex-start'
   */
  justify: null,
  /**
   * Set this value to `true` to add `'-reverse'` to the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * This config combines with {@link #config-horizontal} or {@link #config-vertical} to set the `flex-direction`
   * style.
   * @config {Boolean} reverse
   * @default false
   */
  reverse: null,
  /**
   * Sets the [flex-wrap](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   *
   * The value of `true` is equivalent to `'wrap'`, `false` is equivalent to `'nowrap'`, and `'reverse'` is
   * equivalent to `'wrap-reverse'`.
   *
   * ```javascript
   *  layout : {
   *      type : 'box',
   *      wrap : false        // equivalent to 'nowrap'
   *      wrap : true         // equivalent to 'wrap'
   *      wrap : 'reverse'    // equivalent to 'wrap-reverse'
   *  }
   * ```
   * @config {String|Boolean} wrap
   * @default false
   */
  wrap: null
});
Box.initClass();
Box._$name = "Box";

// ../Core/lib/Core/widget/layout/VBox.js
var VBox = class extends Box {
};
__publicField(VBox, "$name", "VBox");
__publicField(VBox, "type", "vbox");
__publicField(VBox, "configurable", {
  horizontal: false
});
VBox.initClass();
VBox._$name = "VBox";

// ../Core/lib/Core/widget/mixin/Badge.js
var Badge_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Get/sets and display badge, set to null or empty string to hide.
         * @member {String} badge
         * @category Misc
         */
        /**
         * Initial text to show in badge.
         * @config {String} badge
         * @category Misc
         */
        badge: null
      };
    }
    compose() {
      const { badge } = this;
      return {
        dataset: {
          badge
        },
        class: {
          "b-badge": badge != null && badge !== ""
        }
      };
    }
  }, __publicField(_a4, "$name", "Badge"), _a4;
};

// ../Core/lib/Core/widget/Button.js
var bIcon = /(?:^|\s)b-icon-/;
var bFa = /(?:^|\s)b-fa-/;
var defaultToggleable = Symbol("defaultToggleable");
var fullConfigKeys = ["items", "type", "widgets", "html", "listeners"];
var menuListenersName = Symbol("defaultListener");
var Button = class extends Widget.mixin(Badge_default, Rotatable_default) {
  static get configurable() {
    return {
      /**
       * Button icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @prp {String}
       */
      icon: null,
      /**
       * The menu icon class to show when the button has a menu. Set to `null` to not show a menu icon.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * @prp {String}
       * @default
       */
      menuIcon: "b-icon-picker",
      /**
       * Icon class for the buttons pressed state. Only applies to toggle buttons
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       *
       * ```
       * new Button({
       *    // Icon for unpressed button
       *    icon        : 'b-fa-wine-glass',
       *
       *    // Icon for pressed button
       *    pressedIcon : 'b-fa-wine-glass-alt',
       *
       *    // Only applies to toggle buttons
       *    toggleable  : true
       * });
       * ```
       *
       * @prp {String}
       */
      pressedIcon: null,
      /**
       * Button icon alignment. May be `'start'` or `'end'`. Defaults to `'start'`
       * @prp {'start'|'end'}
       * @default
       */
      iconAlign: "start",
      /**
       * The button behavioral type, will be applied as a `type` attribute to this button's element.
       * @prp {'button'|'submit'|'reset'}
       * @default
       */
      behaviorType: "button",
      /**
       * The button's text.
       * @prp {String}
       */
      text: {
        value: null,
        $config: null,
        default: ""
      },
      /**
       * Button color (should have match in button.scss or your custom styling). Valid values in Bryntum themes
       * are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       * Combine with specifying `b-raised` for raised/filled style (theme dependent).
       *
       * ```
       * new Button({
       *    color : 'b-teal b-raised'
       * });
       * ```
       *
       * @prp {String}
       */
      color: null,
      /**
       * Enabled toggling of the button (stays pressed when pressed).
       * @prp {Boolean}
       * @default false
       */
      toggleable: defaultToggleable,
      /**
       * Initially pressed or not. Only applies with `toggleable = true`.
       *
       * ```javascript
       * const toggleButton = new Button({
       *    toggleable : true,
       *    text : 'Enable cool action'
       * });
       * ```
       * @prp {Boolean}
       * @default
       */
      pressed: false,
      /**
       * Indicates that this button is part of a group where only one button can be pressed. Assigning a value
       * also sets `toggleable` to `true`.
       *
       * When part of a {@link Core.widget.ButtonGroup}, you can set {@link Core.widget.ButtonGroup#config-toggleGroup}
       * on it as an alternative to on each button. This config can then be used to override that value if needed.
       *
       * ```javascript
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @prp {String}
       */
      toggleGroup: null,
      /**
       * Set to `true` to perform action on clicking the button if it's already pressed
       * and belongs to a {@link #config-toggleGroup}.
       * @config {Boolean}
       * @default
       */
      supportsPressedClick: false,
      ripple: {
        radius: 75
      },
      forwardTwinEvents: ["action", "toggle"],
      localizableProperties: ["text"],
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration objects from which to create a
       * submenu which is shown when this button is pressed.
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the
       * submenu.
       *
       * May also be specified as a fully instantiated {@link Core.widget.Widget#config-floating floating Widget}
       * such as a {@link Core/widget/Popup}.
       * @config {Object<String,MenuItemConfig|ContainerItemConfig>|Array<MenuItemConfig|ContainerItemConfig>}
       */
      menu: {
        $config: ["lazy", "nullify"],
        value: null
      },
      menuDefaults: {
        type: "menu",
        autoShow: false,
        autoClose: true,
        floating: true,
        scrollAction: "realign",
        align: "t0-b0"
      },
      /**
       * If provided, turns the button into a link.
       * <div class="note">Not compatible with the {@link Core.widget.Widget#config-adopt} config.</div>
       * @prp {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @prp {String}
       */
      target: null,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  construct(...args) {
    super.construct(...args);
    this.ion({ hide: "onInternalHide" });
  }
  updateElement(element, oldElement) {
    var _a4, _b, _c;
    const me = this, { constructor } = me, result = super.updateElement(element, oldElement), menu = me.peekConfig("menu"), role = menu ? menu.isWidget ? menu.role : ((_b = (_a4 = constructor.resolveType(menu.type)) == null ? void 0 : _a4.configurable) == null ? void 0 : _b.role) || ((_c = constructor.configurable.menuDefaults) == null ? void 0 : _c.type) || "menu" : false;
    me.ariaHasPopup = role;
    return result;
  }
  compose() {
    const {
      color,
      href,
      icon,
      iconAlign,
      pressed,
      pressedIcon,
      target,
      text,
      toggleable,
      toggleGroup,
      menuIcon,
      behaviorType
    } = this, hasMenu = this.hasConfig("menu"), iconCls = pressed && pressedIcon ? pressedIcon : icon;
    return {
      tag: href ? "a" : "button",
      href,
      target,
      type: behaviorType,
      class: {
        [`b-icon-align-${iconAlign}`]: icon,
        [color]: Boolean(color),
        "b-pressed": pressed && toggleable,
        "b-text": Boolean(text),
        "b-has-menu": hasMenu
      },
      [toggleable && !hasMenu ? "aria-pressed" : ""]: pressed,
      dataset: {
        group: toggleGroup
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onInternalClick",
        mousedown: "onInternalMousedown"
      },
      children: {
        iconElement: (icon || pressedIcon) && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            ...DomClassList.normalize(iconCls, "object"),
            "b-icon": bIcon.test(iconCls),
            "b-fa": bFa.test(iconCls)
          }
        },
        label: text && {
          tag: "label",
          for: this.id,
          text
        },
        menuIconElement: hasMenu && menuIcon && {
          tag: "i",
          class: {
            "b-icon": bIcon.test(menuIcon),
            "b-fa": bFa.test(menuIcon),
            "b-button-menu-icon": 1,
            [menuIcon]: 1
          }
        }
      }
    };
  }
  //endregion
  configureOverflowTwin(overrides) {
    const me = this, config = super.configureOverflowTwin(overrides);
    if (!config.text) {
      config.text = me.text || me.tooltipText;
    }
    return config;
  }
  onInternalHide() {
    var _a4;
    (_a4 = this._menu) == null ? void 0 : _a4.hide();
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-menu} config being a lazy config and only being converted to be a
   * `Menu` instance just before it's shown, the menu will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    return this._menu && [this.menu];
  }
  onFocusOut(e) {
    var _a4;
    super.onFocusOut(e);
    (_a4 = this.menu) == null ? void 0 : _a4.hide();
  }
  //region Getters/Setters
  get focusElement() {
    return this.element;
  }
  changeText(text) {
    return text == null ? "" : text;
  }
  changeToggleable(toggleable) {
    if (toggleable === defaultToggleable) {
      return this.toggleGroup || this.config.menu;
    }
    return toggleable;
  }
  changeMenu(menu, oldMenu) {
    const me = this, { element: forElement } = me;
    if (menu) {
      if (menu.isWidget) {
        menu.forElement = forElement;
        menu.owner = me;
        menu.constrainTo = me.rootElement;
      } else {
        if (typeof menu === "object" && !fullConfigKeys.some((key) => key in menu)) {
          menu = {
            lazyItems: menu
          };
        }
        menu = Widget.reconfigure(oldMenu, menu ? ObjectHelper.merge({
          owner: me,
          constrainTo: me.rootElement,
          forElement
        }, me.menuDefaults, menu) : null, me);
      }
      menu.align.constrainPadding = 10;
      me.detachListeners(menuListenersName);
      menu.ion({
        name: menuListenersName,
        beforeShow: "onMenuBeforeShow",
        hide: "onMenuHide",
        show: "onMenuShow",
        thisObj: this
      });
    } else {
      oldMenu == null ? void 0 : oldMenu.destroy();
    }
    return menu;
  }
  onMenuBeforeShow({ source }) {
    return this.trigger("beforeShowMenu", {
      menu: source
    });
  }
  onMenuShow() {
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  onMenuHide() {
    this.ariaElement.setAttribute("aria-expanded", false);
    this.toggle(false);
  }
  updateMenu(menu) {
    this.toggleable = Boolean(menu);
  }
  updatePressed(pressed) {
    var _a4, _b;
    const me = this;
    if (!me.toggleable || me.isConfiguring) {
      return;
    }
    const { menu } = me;
    if (pressed) {
      DomHelper.forEachSelector(me.rootElement, `button[data-group=${me.toggleGroup}]`, (btnEl) => {
        if (btnEl !== me.element) {
          Widget.getById(btnEl.id).pressed = false;
        }
      });
    }
    if (menu) {
      menu.owner = me;
      menu.forElement = me.element;
      if (!menu.initialConfig.minWidth) {
        menu.minWidth = me.width;
      }
      menu.align.minHeight = (_a4 = menu._minHeight) != null ? _a4 : 100;
      menu.align.minWidth = (_b = menu._minWidth) != null ? _b : 100;
      menu[pressed ? "show" : "hide"]();
    }
    me.trigger("toggle", { pressed, userAction: me._isUserAction });
  }
  //endregion
  //region Events
  onInternalMousedown(event) {
    var _a4;
    if (((_a4 = this._menu) == null ? void 0 : _a4.containsFocus) && this.pressed) {
      event.preventDefault();
    }
  }
  /**
   * Triggers events when user clicks button
   * @fires click
   * @fires action
   * @internal
   */
  onInternalClick(event) {
    const me = this, bryntumEvent = { event };
    if (me.disabled) {
      return;
    }
    me._isUserAction = true;
    if (me.toggleable) {
      if (me.toggleGroup && me.pressed && !me.supportsPressedClick) {
        return;
      }
      if (!me.toggleGroup || !me.pressed) {
        me.toggle(!me.pressed);
      }
      if (me.isDestroyed) {
        return;
      }
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
    }
    if (!me.href) {
      event.preventDefault();
      event.stopPropagation();
    }
    me._isUserAction = false;
  }
  //endregion
  //region Misc
  /**
   * Toggle button state (only use with toggleable = true)
   * @param {Boolean} pressed Specify to force a certain toggle state
   * @fires toggle
   */
  toggle(pressed = !this.pressed) {
    if (this.trigger("beforeToggle", { pressed, userAction: this._isUserAction }) !== false) {
      this.pressed = pressed;
    }
  }
  //endregion
};
//region Config
__publicField(Button, "$name", "Button");
__publicField(Button, "type", "button");
Button.initClass();
Button._$name = "Button";

// ../Core/lib/Core/widget/Toolbar.js
var asElementRefs = { refs: "element" };
var onCreateTwin = (overflowTwin) => overflowTwin.element.style.margin = "";
var isToolbar = (w) => w.isToolbar;
var itemScoreFn = (ent) => ent[0] + (ent[1].minifiable ? 0 : 9e9);
var twinOverrides = {
  // If the initialConfig was hidden, we must override that
  hidden: false,
  // Item must obey menu's align-items : stretch style.
  width: ""
};
var twinOverridesHorz = {
  ...twinOverrides,
  // Don't allow horizontal flex styles to apply in the vertical layout of the Menu.
  flex: ""
};
var widthAffecting = {
  flex: 1,
  hidden: 1,
  maxWidth: 1,
  minWidth: 1,
  width: 1
};
var _axisProps = [{
  box: "hbox",
  clientSizeProp: "clientWidth",
  edgeProp: "right",
  flexDir: "row",
  horizontal: true,
  max: "maxX",
  overflow: "overflowX",
  pos: "x",
  scrollSize: "scrollWidth",
  sizeProp: "width"
}, {
  box: "vbox",
  clientSizeProp: "clientHeight",
  edgeProp: "bottom",
  flexDir: "column",
  horizontal: false,
  max: "maxY",
  overflow: "overflowY",
  pos: "y",
  scrollSize: "scrollHeight",
  sizeProp: "height"
}];
var defaultRepeat = {
  delay: 0,
  startRate: 40,
  endRate: 200,
  accelerateDuration: 500
};
var nonSyncedConfigs = {
  menu: 1,
  pressed: 1
};
var _Toolbar = class _Toolbar extends Container.mixin(Toolable_default) {
  static get delayable() {
    return {
      syncOverflowVisibility: {
        type: "raf",
        cancelOutstanding: true
      }
      // && 50   // restore the "&& 50" here to help when debugging syncOverflowVisibility
    };
  }
  static get configurable() {
    return {
      defaultType: "button",
      dock: "top",
      layout: {
        type: "box"
      },
      /**
       * An object containing typed child widget config objects or {@link Core/widget/Widget Widgets}. Can also be
       * specified as an array.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Core.widget.Widget#config-ref} name, and the value is the child component's config object.
       *
       * ```javascript
       *  new Toolbar({
       *      appendTo : document.body
       *      items    : [{
       *          type : 'button',
       *          onClick() {
       *
       *          }
       *      }]
       *  })
       * ```
       *
       * Some special items can also be added:
       *
       * - `->` Pushes following items to the other side
       * - `|` Adds a vertical separator
       *
       * ```javascript
       *  new Toolbar({
       *      appendTo : document.body
       *      items    : [
       *      {
       *          type : 'button',
       *          text : 'Click me',
       *          onClick() {
       *
       *          }
       *      },
       *      '|', // separator
       *      {
       *          type : 'textfield',
       *          label : 'Enter name'
       *      },
       *      // Align following items to the end of the toolbar
       *      '->',
       *      {
       *          type : 'button',
       *          text : 'Save',
       *          onClick() {
       *
       *          }
       *      }]
       *  })
       * ```
       *
       * @config {Object<String,ToolbarItems|Boolean|null>|ToolbarItems[]|Core.widget.Widget[]} items
       * @category Content
       */
      /**
       * How this Toolbar should deal with items that overflow its main axis.
       *
       * Values may be:
       * - `'menu'` A button with a menu is shown and the menu contains the overflowing items.
       * - `'scroll'` The items overflow and mey be scrolled into view using the mouse or scroll buttons.
       * - `null` Disable overflow handling
       *
       * When mode is `'menu'`, clones of overflowing toolbar item are created and added to a Menu. Any config
       * changes to the original toolbar item are propagated to the menu's clone, so disabling a toolbar
       * item will make the clone in the menu disabled.
       *
       * The clone of an input field will propagate its `value` changes back to the original. The
       * overflow button, its menu, and the clones should not be accessed or manipulated by application code.
       *
       * Note that cloned items will be allocated a unique, generated ID because all IDs must be unique,
       * so CSS targeting an element ID will not apply to a clone in the overflow menu.
       *
       * Values may also be specified in object form containing the following properties:
       * @config {String|Object|null} overflow
       * @property {'scroll'|'menu'} overflow.type `'scroll'` or `'menu'`
       * @property {ClickRepeaterConfig} overflow.repeat A config object to reconfigure the
       * {@link Core.util.ClickRepeater} which controls auto repeat speed when holding down the scroll buttons
       * when `type` is `'scroll'`
       * @property {Function} overflow.filter A filter function which may return a falsy value to prevent toolbar
       * items from being cloned into the overflow menu.
       * @default 'menu'
       */
      overflow: {
        // Wait until first paint to evaluate so that we can read our CSS style.
        // Set to null on destroy which destroys the overflow Tools and Scroller.
        $config: ["lazy", "nullify"],
        value: {
          type: "menu"
        }
      },
      toolDefaults: {
        overflowMenuButton: {
          type: "button",
          hidden: true,
          icon: "b-icon-menu",
          menuIcon: null,
          ariaLabel: "Show overflowing items",
          defaultCls: {
            "b-overflow-button": 1
          }
        },
        overflowScrollEnd: {
          handler: "up.onEndScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-right": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        },
        overflowScrollStart: {
          align: "start",
          handler: "up.onStartScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-left": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        }
      },
      /**
       * Custom CSS class to add to toolbar widgets
       * @config {String}
       * @category CSS
       */
      widgetCls: null,
      /**
       * Determines if the toolbars read-only state should be controlled by its parent.
       *
       * When set to `true`, setting a parent container to read-only will not affect the widget. When set to
       * `false`, it will affect the widget.
       *
       * @category Misc
       * @config {Boolean}
       * @default
       */
      ignoreParentReadOnly: true
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  /**
   * Returns the Core.widget.Widget[] of items to hide to clear an overflow. The `visibleItems` array should be in
   * order of the `items` in the container.
   * @param {Core.widget.Widget[]} visibleItems
   * @returns {Array}
   * @private
   */
  static getEvictionList(visibleItems) {
    const ret = visibleItems.filter((it) => it.overflowable !== "none");
    ret.forEach((it, n) => ret[n] = [n, it]);
    ret.sort((a, b) => itemScoreFn(b) - itemScoreFn(a));
    return ret;
  }
  compose() {
    const me = this, { axisProps, dock } = me, endToolElementRefs = me.getEndTools(asElementRefs), startToolElementRefs = me.getStartTools(asElementRefs);
    return {
      class: {
        [`b-dock-${dock}`]: 1,
        [`b-${dock}-toolbar`]: 1,
        [`b-${axisProps.box}`]: 1
      },
      children: {
        ...startToolElementRefs,
        toolbarContent: {
          class: {
            "b-box-center": 1,
            "b-toolbar-content": 1
          }
        },
        ...endToolElementRefs
      }
    };
  }
  get axisProps() {
    return _axisProps[this.layout.horizontal ? 0 : 1];
  }
  get contentElement() {
    return this.toolbarContent;
  }
  get overflowMenuButton() {
    var _a4;
    return (_a4 = this.tools) == null ? void 0 : _a4.overflowMenuButton;
  }
  get overflowType() {
    const { overflow } = this;
    return typeof overflow === "string" ? overflow : overflow == null ? void 0 : overflow.type;
  }
  onChildAdd(item) {
    var _a4;
    super.onChildAdd(item);
    this.processAddedLeafItem(item);
    (_a4 = item.syncRotationToDock) == null ? void 0 : _a4.call(item, this.dock);
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    this.syncOverflowVisibility();
  }
  processAddedLeafItem(item) {
    FunctionHelper.after(item, "onConfigChange", this.onLeafItemConfigChange, item);
    if (item.isContainer) {
      item.eachWidget((w) => this.processAddedLeafItem(w));
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a4;
    (_a4 = super.onInternalPaint) == null ? void 0 : _a4.call(this, ...arguments);
    if (firstPaint) {
      this.getConfig("overflow");
    }
  }
  updateDock(dock) {
    var _a4;
    const me = this, { layout } = me, { vertical } = layout;
    layout.vertical = canonicalDock(dock)[1];
    if (!me.initialItems) {
      if (vertical !== layout.vertical) {
        me.updateOverflow(me.overflow);
      }
      for (const item of me.childItems) {
        (_a4 = item.syncRotationToDock) == null ? void 0 : _a4.call(item, dock);
      }
    }
  }
  updateOverflow(overflow, oldOverflow) {
    var _a4, _b;
    const me = this, { axisProps, contentElement, overflowType } = me, { flexDir } = axisProps, overflowMenu = (_a4 = me.overflowMenuButton) == null ? void 0 : _a4._menu, overflowTools = {};
    if (overflowMenu) {
      if (overflow) {
        overflowMenu == null ? void 0 : overflowMenu.removeAll();
      } else {
        overflowMenu.eachWidget((overflowTwin) => {
          overflowTwin._overflowTwinOrigin.overflowTwin = null;
        });
      }
    }
    if (oldOverflow === "menu") {
      overflowTools.overflowMenuButton = null;
    } else if (oldOverflow === "scroll") {
      overflowTools.overflowScrollStart = overflowTools.overflowScrollEnd = null;
    }
    if (overflowType === "menu") {
      (_b = me.scrollable) == null ? void 0 : _b.destroy();
      contentElement.style.overflow = contentElement.style.overflowX = contentElement.style.overflowY = "";
      overflowTools.overflowMenuButton = {
        cls: {
          [`b-${flexDir}-menu`]: 1
        }
      };
    } else if (overflowType === "scroll") {
      const repeat = typeof overflow === "object" && (overflow == null ? void 0 : overflow.repeat) || defaultRepeat;
      me.scrollable = {
        [axisProps.overflow]: "hidden-scroll",
        element: contentElement,
        internalListeners: {
          scroll: "onContentScroll",
          thisObj: me
        }
      };
      overflowTools.overflowScrollStart = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-start-scroller`]: 1
        }
      };
      overflowTools.overflowScrollEnd = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-end-scroller`]: 1
        }
      };
    }
    me.tools = overflowTools;
    if (overflowType) {
      contentElement.classList.add("b-overflow");
      me.monitorResize = true;
      me.syncOverflowVisibility();
    } else {
      contentElement.classList.remove("b-overflow");
      me.monitorResize = false;
    }
  }
  onContentScroll() {
    this.syncScrollerState();
  }
  onStartScrollClick() {
    this.scrollable[this.axisProps.pos] -= 2;
  }
  onEndScrollClick() {
    this.scrollable[this.axisProps.pos] += 2;
  }
  // Only called when monitorResize is true, which is only set when we have an overflow mode
  onInternalResize() {
    super.onInternalResize(...arguments);
    if (this.isPainted) {
      this.syncOverflowVisibility();
    }
  }
  syncOverflowVisibility() {
    const me = this, { overflowType, contentElement, isVisible: isVisible2 } = me, { clientSizeProp, edgeProp, sizeProp } = me.axisProps, { overflowMenuButton, overflowScrollStart, overflowScrollEnd } = me.tools, rtl = me.rtl && me.layout.horizontal, menuOverflow = overflowType === "menu", getAvailSpace = () => Math.ceil(
      contentElement[clientSizeProp] + // Since we cannot simply hide these to remove their influence, we need to add their width/height:
      (!overflowScrollStart || overflowScrollStart.hidden ? 0 : overflowScrollStart.rectangle("outer")[sizeProp]) + (!overflowScrollEnd || overflowScrollEnd.hidden ? 0 : overflowScrollEnd.rectangle("outer")[sizeProp])
    ), getContentSize = () => {
      if (visibleItems.length === 0) {
        return 0;
      }
      const rect = visibleItems[visibleItems.length - 1].rectangle(contentElement);
      return Math.floor(rtl ? contentElement[clientSizeProp] - rect.left : rect[edgeProp]);
    };
    let availableSpace, contentSize, eviction, evictionList, it, itemSize, minifiable, minifiables, minified, overflowable, overflowItems, visibleItems;
    if (!isVisible2 || !overflowType || me.items.length === 0) {
      return;
    }
    me.inSyncOverflowVisibility = true;
    overflowMenuButton == null ? void 0 : overflowMenuButton.hide();
    me.eachWidget((item, control) => {
      minifiable = item.minifiable;
      overflowable = item.overflowable;
      overflowable = minifiable ? overflowable || minifiable : overflowable;
      if (item.floating) {
        control.down = false;
      } else {
        control.down = !overflowable;
        if (item.innerItem) {
          if (item._toolbarOverflow) {
            item.hidden = item._toolbarOverflow = false;
          }
          if (item._toolbarMinified) {
            item.minified = item._toolbarMinified = false;
          }
          if (item.isVisible) {
            minifiable && (minifiables || (minifiables = [])).push(item);
            overflowable && (visibleItems || (visibleItems = [])).push(item);
          }
        }
      }
    });
    if (visibleItems) {
      availableSpace = getAvailSpace();
      contentSize = getContentSize();
    }
    if (visibleItems && contentSize > availableSpace) {
      if (menuOverflow) {
        while (contentSize > availableSpace && (it = minifiables == null ? void 0 : minifiables.pop())) {
          itemSize = contentSize;
          it._toolbarMinified = true;
          it.minified = true;
          contentSize = getContentSize();
          itemSize -= contentSize;
          (minified || (minified = [])).push([it, itemSize]);
        }
        if (contentSize > availableSpace) {
          overflowMenuButton.show();
          availableSpace = getAvailSpace();
          evictionList = _Toolbar.getEvictionList(visibleItems);
          for (eviction of evictionList) {
            if (contentSize > availableSpace) {
              it = eviction[1];
              it._toolbarOverflowWidth = it.width;
              it._toolbarOverflow = true;
              it.hidden = true;
              visibleItems.splice(visibleItems.indexOf(it), 1);
              (overflowItems || (overflowItems = [])).push(eviction);
              contentSize = getContentSize();
            }
          }
          if (overflowItems) {
            overflowItems.sort((a, b) => a[0] - b[0]).forEach((ent, n) => overflowItems[n] = ent[1]);
            while (minified == null ? void 0 : minified.length) {
              [it, itemSize] = minified.pop();
              if (contentSize + itemSize <= availableSpace && !it._toolbarOverflow) {
                contentSize += itemSize;
                it.minified = it._toolbarMinified = false;
              }
            }
            me.syncOverflowMenuButton(overflowItems);
          } else {
            overflowMenuButton.hide();
          }
        }
      } else {
        overflowScrollEnd.show();
        overflowScrollStart.show();
        me.syncScrollerState();
      }
    } else if (!menuOverflow) {
      overflowScrollEnd == null ? void 0 : overflowScrollEnd.hide();
      overflowScrollStart == null ? void 0 : overflowScrollStart.hide();
    }
    me.inSyncOverflowVisibility = false;
  }
  syncOverflowMenuButton(overflowItems) {
    var _a4;
    const me = this, { axisProps, overflowMenuButton } = me, menu = {
      cls: "b-toolbar-overflow-menu",
      minWidth: 280,
      items: [],
      align: {
        align: axisProps.horizontal ? "t100-b100" : "r100-l100",
        axisLock: "flexible"
      }
    };
    me.addToMenu(menu, overflowItems.filter((item) => me.overflowItemFilter(item)));
    if ((_a4 = overflowMenuButton._menu) == null ? void 0 : _a4.isMenu) {
      const existingMenu = overflowMenuButton.menu, {
        toAdd,
        toRemove
      } = ArrayHelper.delta(menu.items, existingMenu.items, 1);
      existingMenu.remove(toRemove);
      if (existingMenu.items.length) {
        for (let i = toAdd.length - 1; i >= 0; i--) {
          existingMenu.insert(toAdd[i], 0);
        }
      } else {
        existingMenu.add(toAdd);
      }
    } else {
      overflowMenuButton.menu = menu;
    }
  }
  syncScrollerState() {
    const me = this, { axisProps, scrollable } = me, { overflowScrollStart, overflowScrollEnd } = me.tools, scrollPos = scrollable[axisProps.pos], maxScrollPos = scrollable[axisProps.max];
    overflowScrollStart.disabled = !scrollPos;
    overflowScrollEnd.disabled = Math.abs(Math.ceil(scrollPos)) >= Math.abs(maxScrollPos);
  }
  overflowItemFilter(item) {
    const { filter } = this.overflow;
    return Boolean(filter ? filter.call(this, item) : DomHelper.getChildElementCount(item.element));
  }
  addToMenu(menu, overflowingItems) {
    const overrides = this.horizontal ? twinOverridesHorz : twinOverrides;
    for (const item of overflowingItems) {
      const overflowTwin = item.ensureOverflowTwin(overrides, onCreateTwin);
      menu.items.push(overflowTwin);
    }
  }
  // Note that this is called with the thisObj of the tbar item being reconfigured.
  // It propagates the new setting into its toolbar overflow clone.
  onLeafItemConfigChange(origResult, { name, value }) {
    const item = this, toolbar = item.up(isToolbar), overflow = toolbar.hasConfig("overflow"), { overflowTwin } = item;
    if (!overflow || (toolbar == null ? void 0 : toolbar.inSyncOverflowVisibility) || name === "hidden" && value === item._toolbarOverflow) {
      return;
    }
    if (!widthAffecting[name]) {
      if (
        // The way fixed-width widgets manage their _width property is a bit tricky because when monitorResize
        // is in effect. The _width property holds a cached width instead of a configured one.
        item._width != null && !item.monitorResize || // The size of a widget w/flex like '1 1 auto' (ie, the flex-basis is auto) is influenced by its content
        // so config changes could affect its size. Otherwise, the widget is sized to the toolbar's content
        // element and is unaffected by other configs.
        item._flex && !String(item._flex).endsWith("auto")
      ) {
        return;
      }
    }
    if (overflowTwin && !nonSyncedConfigs[name]) {
      overflowTwin[name] = value;
    }
    if ((toolbar == null ? void 0 : toolbar.isPainted) && item.ref !== "overflowMenuButton") {
      if (!(item.isTextField && name === "value" && (item.containsFocus || (overflowTwin == null ? void 0 : overflowTwin.containsFocus)))) {
        toolbar.syncOverflowVisibility();
      }
    }
  }
  createWidget(widget) {
    if (widget === "->") {
      widget = {
        type: "widget",
        cls: "b-toolbar-fill"
      };
    } else if (widget === "|") {
      widget = {
        type: "widget",
        cls: "b-toolbar-separator"
      };
    } else if (typeof widget === "string") {
      widget = {
        type: "widget",
        cls: "b-toolbar-text",
        html: widget
      };
    }
    const result = super.createWidget(widget);
    if (this.widgetCls) {
      result.element.classList.add(this.widgetCls);
    }
    return result;
  }
};
__publicField(_Toolbar, "$name", "Toolbar");
__publicField(_Toolbar, "type", "toolbar");
var Toolbar = _Toolbar;
Toolbar.initClass();
Toolbar._$name = "Toolbar";

// ../Core/lib/Core/widget/Panel.js
var acceptNode = (e) => !e.classList.contains("b-focus-trap") && DomHelper.isFocusable(e) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
var emptyArray8 = [];
var emptyObject10 = {};
var emptySplit = [emptyArray8, emptyArray8];
var finishBodyWrap = (config, classes, final) => {
  const { vertical } = config;
  delete config.vertical;
  return {
    ...config,
    class: {
      ...classes,
      [`b-${vertical ? "v" : "h"}box`]: 1,
      "b-box-center": 1,
      "b-panel-bar-wrap": !final
    }
  };
};
var wrapBody = (inner, bodyWrapTag, vertical = false) => {
  const wrap = {
    vertical,
    children: inner ? [inner] : []
  };
  if (bodyWrapTag) {
    wrap.tag = bodyWrapTag;
  }
  return wrap;
};
var setCls = (elOrConfig, cls) => {
  if (elOrConfig == null ? void 0 : elOrConfig.classList) {
    elOrConfig == null ? void 0 : elOrConfig.classList.add(cls);
  } else if (elOrConfig == null ? void 0 : elOrConfig.class) {
    if (typeof elOrConfig.class === "string") {
      elOrConfig.class = { [elOrConfig.class]: 1 };
    }
    elOrConfig.class[cls] = 1;
  }
};
var barConfigs = {
  dock: 1,
  hidden: 1,
  weight: 1
};
var dockDirection = {
  //       [vertical, before]
  top: [true, true],
  bottom: [true, false],
  left: [false, true],
  right: [false, false]
};
var headerDock = {
  header: 1,
  "pre-header": 1
};
var _Panel = class _Panel extends Container.mixin(State_default, Toolable_default) {
  static get configurable() {
    return {
      localizableProperties: ["title"],
      /**
       * Controls whether the panel is collapsed (the body of the panel is hidden while only the header is
       * visible). Only valid if the panel is {@link #config-collapsible}.
       * @config {Boolean}
       * @category Layout
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * This config enables collapsibility for the panel. See {@link #config-collapsed}.
       *
       * For example:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : true
       *      }
       * ```
       * This is managed by an instance of {@link Core.widget.panel.PanelCollapser} which can be configured if an
       * object is passed for this config property:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : {
       *              direction : 'left'
       *          }
       *      }
       * ```
       * The config object form can contain a `type` property to specify the type of collapse the panel will use.
       * This property can be one of the following:
       *
       * - `'inline'` (see {@link Core.widget.panel.PanelCollapser})
       * - `'overlay'` (see {@link Core.widget.panel.PanelCollapserOverlay})
       *
       * @config {Boolean|PanelCollapserConfig|PanelCollapserOverlayConfig}
       * @category Layout
       */
      collapsible: {
        value: null,
        $config: "nullify"
      },
      /**
       * Custom CSS classes to add to the panel's body element.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       *
       * ```javascript
       *  bodyCls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       */
      bodyCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      bodyTag: null,
      bodyWrapTag: null,
      /**
       * By default, tabbing within a Panel is not contained, ie you can TAB out of the Panel
       * forwards or backwards.
       * Configure this as `true` to disallow tabbing out of the Panel, and make tabbing circular within this Panel.
       * @config {Boolean}
       * @default false
       * @category Content
       */
      trapFocus: null,
      /**
       * Get/set this Panel's title which is used when the panel has a header, or is part of a TabPanel. If a
       * header has been disabled by configuring the {@link #config-header}as `false`, setting it will have no
       * effect.
       * @member {String} title
       */
      /**
       * A title to display in the header or owning TabPanel. Causes creation and docking of a header
       * to the top if no header is configured.
       *
       * If specified, overrides any title configured within the {@link #config-header} configuration.
       * @default
       * @config {String}
       * @category Misc
       */
      title: null,
      /**
       * A config {@link PanelHeader object} for the panel's header or a string in place of a `title`.
       *
       * Configuring this as `false` explicitly removes the header bar, overriding any
       * {@link #config-tools} or {@link #config-title} configs.
       * @default
       * @config {String|Boolean|PanelHeader}
       * @category Content
       */
      header: null,
      stateful: ["collapsed"],
      /**
       * An object containing config defaults for corresponding {@link #config-strips} objects with a matching name.
       *
       * By default, this object contains the keys `'bbar'` and `'tbar'` to provide default config values for the
       * {@link #config-bbar} and {@link #config-tbar} configs.
       *
       * This object also contains a key named `'*'` with default config properties to apply to all strips. This
       * object provides the default `type` (`'toolbar') and {@link Core.widget.Widget#config-dock} (`'top'`)
       * property for strips.
       * @config {Object} stripDefaults
       * @internal
       * @category Content
       */
      stripDefaults: {
        "*": {
          type: "toolbar",
          dock: "top"
        },
        bbar: {
          dock: "bottom",
          weight: -1e3
        },
        tbar: {
          weight: -1e3
        }
      },
      /**
       * An object containing widgets keyed by name. By default (when no `type` is given), strips are
       * {@link Core.widget.Toolbar toolbars}. If you want to pass an array, you can use
       * the toolbar's {@link Core.widget.Container#config-items}.
       *
       * The {@link #config-bbar} and {@link #config-tbar} configs are shortcuts for adding toolbars to the
       * panel's `strips`.
       *
       * Strips are arranged based on their {@link Core.widget.Widget#config-dock} and
       * {@link Core.widget.Widget#config-weight} configs.
       *
       * For widgets using a `dock` of `'top'`, `'bottom'`, `'left'`, `'right'`, `'start'` or `'end'`(an "edge
       * strip"), the higher the `weight` assigned to a widget, the closer that widget will be to the panel body.
       *
       * For widgets with `'header'` or `'pre-header'` for `dock` (a "header strip"), higher `weight` values
       * cause the widget to be placed closer to the panel's title.
       *
       * ```javascript
       *  new Panel({
       *      title : 'Test',
       *      html  : 'Panel strip test',
       *      strips : {
       *          left : {
       *              dock  : 'left'
       *              items : [{
       *                  text : 'Go'
       *                }]
       *          }
       *      }
       *  });
       *
       * // Pass an array to tbar
       * strips : {
       *     tbar : {
       *         items: [
       *             {
       *                 type : 'button',
       *                 text : 'Add column',
       *                 icon : 'b-fa-plus',
       *                 onAction : ({ source }) => addColumn(source.element)
       *             },
       *             `Today is ${getCurrentDate()}` // consider 'getCurrentDate()` a custom function
       *         ]
       *     }
       * }
       * ```
       * @config {Object<String,ContainerItemConfig>} strips
       * @category Content
       */
      strips: {
        value: null,
        $config: "nullify"
      },
      toolDefaults: {
        close: {
          weight: -1e3
        },
        collapse: {
          weight: -990
        }
      },
      /**
       * Config object of a footer. May contain a `dock`, `html` and a `cls` property. A footer is not a widget,
       * but rather plain HTML that follows the last element of the panel's body and {@link #config-strips}.
       *
       * The `dock` property may be `top`, `right`, `bottom`, `left`, `start` or `end`
       *
       * @config {Object|String}
       * @property {'top'|'right'|'bottom'|'left'|'start'|'end'} dock Where to dock
       * @property {String} html Html to populate the footer with
       * @property {String} cls CSS class to add to the footer
       * @default
       * @category Content
       */
      footer: null,
      /**
       * This config is used with {@link Core.widget.panel.PanelCollapserOverlay} to programmatically control the
       * visibility of the panel's body. In this mode of collapse, the body of a collapsed panel is a floating
       * overlay. Setting this config to `true` will show this element, while `false` will hide it.
       * @config {Boolean}
       * @private
       */
      revealed: null,
      /**
       * The tool Widgets as specified by the {@link #config-tools} configuration
       * (and the {@link Core.widget.Popup#config-closable} configuration in the Popup subclass).
       * Each is a {@link Core.widget.Widget} instance which may be hidden, shown and observed and styled
       * just like any other widget.
       *
       * ```javascript
       * panel.tools.add = {
       *     cls : 'b-fa b-fa-plus',
       *     handler() {
       *         // Clicked the tool
       *     }
       * }
       * ```
       * @member {Object<String,Core.widget.Tool>} tools
       * @accepts {Object<String,Core.widget.Tool|ToolConfig>}
       */
      /**
       * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
       * property name is the reference by which an instantiated tool may be retrieved from the live
       * `{@link Core.widget.mixin.Toolable#property-tools}` property.
       * ```javascript
       * new Panel({
       *     ...
       *     tools : {
       *         add : {
       *             cls : 'b-fa b-fa-plus',
       *             handler() {
       *                 // Clicked the tool
       *             }
       *         }
       *     }
       * });
       * ```
       * @config {Object<string,ToolConfig>} tools
       * @category Content
       */
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the top of the panel
       * @member {Core.widget.Toolbar} tbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       * This creates a toolbar docked to the top of the panel immediately below the header.
       *
       * To add toolbars not docked to the top, see {@link #config-bbar} and {@link #config-strips}.
       *
       *```javascript
       * // Text only
       * tbar : ['Project Timeline Overview', '->', 'Key Milestones & Deadlines'],
       *
       * // Buttons
       * tbar : [
       *    {
       *       type     : 'button',
       *       ref      : 'addButton',
       *       text     : 'Add column',
       *       icon     : 'b-fa-plus',
       *       tooltip  : 'Add new column',
       *       onAction : ({ source }) => addColumn(source.element) // add new column
       *   },
       *   {
       *       type     : 'button',
       *       ref      : 'removeButton',
       *       text     : 'Remove last',
       *       icon     : 'b-fa-minus',
       *       tooltip  : 'Remove last column',
       *       onAction : () => grid.columns.count > 1 && grid.columns.last.remove() // remove last column
       *   }
       * ]
       *
       * // ToolbarConfig
       * tbar : {
       *     height : '4em',
       *     items  : {
       *         button1 : { text : 'A button', icon : 'b-fa b-fa-plus' },
       *         button2 : { text : 'Right button 1', icon : 'b-fa b-fa-trash', style : 'margin-left:auto' },
       *         button3 : { icon : 'b-fa b-fa-gear' }
       *     }
       * }
       * ```
       *
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @typings {Array<ContainerItemConfig|String>||ToolbarConfig||PagingToolbarConfig}
       * @category Content
       */
      tbar: null,
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the bottom of the panel
       * @member {Core.widget.Toolbar} bbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar. Another way to add a bbar is to use {@link #config-strips}.
       *
       * ```javascript
       * // Text only
       * bbar : [`Total number of students: ${totalStds}`, '->', `Passed Students: ${passedStds}`],
       *
       * // Buttons
       * bbar : [
       *    {
       *       type     : 'button',
       *       ref      : 'addButton',
       *       text     : 'Add column',
       *       icon     : 'b-fa-plus',
       *       tooltip  : 'Add new column',
       *       onAction : ({ source }) => addColumn(source.element) // add new column
       *   },
       *   {
       *       type     : 'button',
       *       ref      : 'removeButton',
       *       text     : 'Remove last',
       *       icon     : 'b-fa-minus',
       *       tooltip  : 'Remove last column',
       *       onAction : () => grid.columns.count > 1 && grid.columns.last.remove() // remove last column
       *   }
       * ]
       *
       * // ToolbarConfig
       * bbar : {
       *     height : '4em',
       *     items  : {
       *         button1 : { text : 'A button', icon : 'b-fa b-fa-plus' },
       *         button2 : { text : 'Right button 1', icon : 'b-fa b-fa-trash', style : 'margin-left:auto' },
       *         button3 : { icon : 'b-fa b-fa-gear' }
       *     }
       * }
       * ```
       *
       * This creates a toolbar docked to the bottom of the panel immediately above the footer.
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @typings {Array<ContainerItemConfig|String>||ToolbarConfig||PagingToolbarConfig}
       * @category Content
       */
      bbar: null,
      role: "region"
    };
  }
  //endregion
  /**
   * A header {@link #config-tools tool} has been clicked.
   * @event toolClick
   * @param {Core.widget.Tool} source - This Panel.
   * @param {Core.widget.Tool} tool - The tool which is being clicked.
   */
  /**
   * Fires when a Panel is collapsed using the {@link Core.widget.Panel#config-collapsible} setting.
   * @event collapse
   * @param {Core.widget.Panel} source - This Panel.
   */
  /**
   * Fires when a Panel is expanded using the {@link Core.widget.Panel#config-collapsible} setting.
   * @event expand
   * @param {Core.widget.Panel} source - This Panel.
   */
  //region Composition
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (this.titleElement) {
      DomHelper.setAttributes(this.ariaElement, {
        "aria-describedby": this.titleElement.id
      });
    }
    return result;
  }
  changeFooter(footer) {
    if (footer) {
      if (footer.dock === "start") {
        footer.dock = "left";
      } else if (footer.dock === "end") {
        footer.dock = "right";
      }
    }
    return footer;
  }
  compose() {
    const me = this, { collapsible, focusable, hasItems, revealed, tools } = me, header = me.composeHeader(), horz = (header == null ? void 0 : header.class["b-dock-left"]) || (header == null ? void 0 : header.class["b-dock-right"]);
    let body = me.composeBody(), key = "bodyWrapElement";
    if (collapsible) {
      [key, body] = collapsible.wrapCollapser(key, body);
    }
    return {
      tabIndex: hasItems && focusable !== false || focusable ? 0 : null,
      class: {
        [`b-panel-collapsible-${collapsible == null ? void 0 : collapsible.type}`]: collapsible,
        [`b-panel-collapse-${collapsible == null ? void 0 : collapsible.collapseDir}`]: collapsible,
        [`b-${horz ? "h" : "v"}box`]: 1,
        "b-panel-collapsible": collapsible,
        "b-panel-has-header": header,
        "b-panel-has-tools": tools ? 1 : 0,
        "b-panel-overlay-revealed": revealed
      },
      children: {
        topFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1
          }
        },
        // Note: we always put header before bodyWrap since it is likely (though untested) to be better for
        // a11y. We use flexbox order to make the right/bottom docking appear correct but it is likely that
        // the DOM order of the <header> element vs (optional) <footer> is important to screen readers.
        headerElement: header,
        [key]: body,
        bottomFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1,
            "b-end-focus-trap": 1
          }
        }
      }
    };
  }
  composeBody() {
    var _a4, _b;
    const me = this, { bodyCls, bodyConfig, bodyWrapTag, footer, uiClassList } = me, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v == null ? void 0 : v.dock]).sort(me.byWeightSortFn), innermostStrips = {
      top: null,
      right: null,
      bottom: null,
      left: null
    };
    let bar, before, dock, i, name, vertical, wrap;
    if (footer) {
      dock = footer.dock || "bottom";
      strips.unshift({
        dock,
        element: {
          tag: "footer",
          reference: "footerElement",
          html: typeof footer === "string" ? footer : footer.html,
          class: {
            ...uiClassList,
            [`b-dock-${dock}`]: 1,
            [`${footer.cls || ""}`]: 1
          }
        }
      });
    }
    if (bodyCls) {
      if (!bodyConfig[name = "className"]) {
        name = "class";
      }
      bodyConfig[name] = new DomClassList(bodyConfig[name]).assign(bodyCls);
    }
    for (i = strips.length; i-- > 0; ) {
      bar = strips[i];
      [vertical, before] = dockDirection[bar.dock];
      if (!wrap) {
        wrap = wrapBody(bodyConfig, bodyWrapTag, vertical);
      } else if (wrap.vertical !== vertical) {
        wrap = wrapBody(finishBodyWrap(wrap, uiClassList), "", vertical);
      }
      wrap.children[before ? "unshift" : "push"](bar.element);
      innermostStrips[bar.dock] = bar;
    }
    setCls(innermostStrips.top, "b-innermost");
    setCls(innermostStrips.right, "b-innermost");
    setCls(innermostStrips.bottom, "b-innermost");
    setCls(innermostStrips.left, "b-innermost");
    const body = finishBodyWrap(wrap || wrapBody(bodyConfig, bodyWrapTag), uiClassList, true);
    body.class[`${(_a4 = me.layout) == null ? void 0 : _a4.containerCls}-panel`] = Boolean((_b = me.layout) == null ? void 0 : _b.containerCls);
    body.class["b-panel-body-wrap"] = 1;
    body.class[`b-${me.$$name.toLowerCase()}-body-wrap`] = 1;
    return body;
  }
  get hasHeader() {
    if (this.header === false) {
      return false;
    }
    const { header, title, tools, parent } = this, hasVisibleTools = this.maximizable || Object.values(tools || {}).some((tool) => !tool.hidden);
    return header || !(parent == null ? void 0 : parent.suppressChildHeaders) && (title || hasVisibleTools);
  }
  get rootUiClass() {
    return _Panel;
  }
  composeHeader(force) {
    var _a4;
    const me = this;
    if (!me.hasHeader && !force) {
      return;
    }
    const header = me.header || {}, dock = header.dock || "top", [before, after] = me.splitHeaderItems({ as: "element", dock }), classes = me.$meta.hierarchy, title = me.composeTitle(header), cls = new DomClassList({
      [`b-dock-${dock}`]: 1,
      ...me.uiClassList
    }, header.cls);
    let i, name;
    for (i = classes.indexOf(_Panel); i < classes.length; ++i) {
      name = classes[i].$$name;
      if (name !== "Grid") {
        cls[`b-${name.toLowerCase()}-header`] = 1;
      }
    }
    const headerConfig = {
      tag: "header",
      class: cls,
      children: [
        ...before,
        title,
        ...after
      ]
    };
    return ((_a4 = me.collapsible) == null ? void 0 : _a4.composeHeader(headerConfig)) || headerConfig;
  }
  composeTitle(header) {
    var _a4;
    const title = typeof header === "string" ? header : this.title || header.title, titleConfig = {
      reference: "titleElement",
      id: `${this.id}-panel-title`,
      html: title != null ? title : "\xA0",
      class: {
        [`b-align-${header.titleAlign || "start"}`]: 1,
        "b-header-title": 1,
        ...this.uiClassList
      }
    };
    if (ObjectHelper.isObject(title)) {
      delete titleConfig.html;
      ObjectHelper.merge(titleConfig, title);
    }
    return ((_a4 = this.collapsible) == null ? void 0 : _a4.composeTitle(titleConfig)) || titleConfig;
  }
  // Needed to make title go through recompose
  updateTitle() {
  }
  afterRecompose() {
    var _a4;
    super.afterRecompose();
    const me = this, { headerElement } = me;
    (_a4 = me._headerClickDetacher) == null ? void 0 : _a4.call(me);
    me._headerClickDetacher = headerElement && EventHelper.on({
      element: headerElement,
      // Click might have lead to panel being destroyed (clicking close tool with `hideAction : 'destroy'`)
      click: (ev) => {
        var _a5;
        return (_a5 = me.trigger) == null ? void 0 : _a5.call(me, "panelHeaderClick", { event: ev });
      }
    });
  }
  onPanelHeaderClick(info) {
    var _a4;
    (_a4 = this.collapsible) == null ? void 0 : _a4.onPanelHeaderClick(info);
  }
  onInternalPaint() {
    var _a4;
    super.onInternalPaint(...arguments);
    (_a4 = this.collapsible) == null ? void 0 : _a4.onPanelPaint(this);
  }
  splitHeaderItems({ as, dock, alt: alt2 } = emptyObject10) {
    var _a4, _b, _c, _d;
    const me = this, asElement = as === "element", { collapsed } = me, endTools = me.getEndTools({ alt: alt2 }), startTools = me.getStartTools({ alt: alt2 }), strips = ObjectHelper.values(
      me.strips,
      (k, v) => !headerDock[v == null ? void 0 : v.dock] && v.isCollapsified({ collapsed, alt: alt2 })
    );
    let ret = emptySplit, after, before, i;
    if (strips.length + endTools.length + startTools.length) {
      ret = [
        // the problem w/mixing tools and strips is the strip weight needs to do two jobs (one when docked
        // in the body and one when docked in the header)
        before = [
          ...startTools,
          ...strips.filter((e) => e.dock === "pre-header").sort(me.byWeightSortFn)
        ],
        after = [
          ...strips.filter((e) => e.dock === "header").sort(me.byWeightReverseSortFn),
          ...endTools
        ]
      ];
      for (i = 0; i < before.length; ++i) {
        dock && ((_b = (_a4 = before[i]).syncRotationToDock) == null ? void 0 : _b.call(_a4, dock));
        if (asElement) {
          before[i] = before[i].element;
        }
      }
      for (i = 0; i < after.length; ++i) {
        dock && ((_d = (_c = after[i]).syncRotationToDock) == null ? void 0 : _d.call(_c, dock));
        if (asElement) {
          after[i] = after[i].element;
        }
      }
    }
    return ret;
  }
  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }
  get bodyConfig() {
    const me = this, { bodyTag } = me, result = ObjectHelper.merge({
      reference: "bodyElement",
      className: {
        ...me.getStaticWidgetClasses(_Panel, "-content"),
        "b-box-center": 1,
        "b-text-content": me.textContent && me.hasNoChildren
      }
    }, me._bodyConfig);
    if (bodyTag) {
      result.tag = bodyTag;
    }
    return result;
  }
  //endregion
  //region Configs
  changeBodyCls(cls) {
    return DomClassList.from(cls);
  }
  changeTbar(bar) {
    this.getConfig("strips");
    this.strips = {
      tbar: bar
    };
    return this.strips.tbar;
  }
  changeBbar(bar) {
    this.getConfig("strips");
    this.strips = {
      bbar: bar
    };
    return this.strips.bbar;
  }
  // Override to iterate docked Toolbars in the correct order around contained widgets.
  get childItems() {
    var _a4;
    const me = this, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v == null ? void 0 : v.dock]).sort(me.byWeightSortFn), [before, after] = me.splitHeaderItems(), [before2, after2] = ((_a4 = me.collapsible) == null ? void 0 : _a4.splitHeaderItems()) || emptySplit;
    return [
      ...before,
      ...before2,
      ...after,
      ...after2,
      ...strips.filter((b) => dockDirection[b.dock][1]),
      // the "before" strips come before the items
      ...me._items || emptyArray8,
      ...strips.filter((b) => !dockDirection[b.dock][1]).reverse()
    ];
  }
  get childItemsOrderedByRelevance() {
    var _a4;
    const me = this, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v == null ? void 0 : v.dock]).sort(me.byWeightSortFn), [before, after] = me.splitHeaderItems(), [before2, after2] = ((_a4 = me.collapsible) == null ? void 0 : _a4.splitHeaderItems()) || emptySplit;
    return [
      ...me._items || emptyArray8,
      ...strips.filter((b) => !dockDirection[b.dock][1]).reverse(),
      ...before,
      ...before2,
      ...after,
      ...after2,
      ...strips.filter((b) => dockDirection[b.dock][1])
    ];
  }
  changeStrips(strips, oldStrips) {
    const me = this, manager = me.$strips || (me.$strips = new DynamicObject({
      configName: "strips",
      factory: Widget,
      inferType: false,
      // the name of a bar in the strips object is not its type
      owner: me,
      created(instance) {
        var _a4;
        const { dock } = instance;
        if (!headerDock[dock] && !dockDirection[dock]) {
          throw new Error(
            `Invalid dock value "${dock}"; must be: top, left, right, bottom, header, or pre-header`
          );
        }
        FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
          if (barConfigs[name]) {
            me.onConfigChange({
              name: "strips",
              value: manager.target
            });
          }
        });
        instance.innerItem = false;
        me.onChildAdd(instance);
        instance.parent = me;
        (_a4 = instance.layout) == null ? void 0 : _a4.renderChildren();
        if (instance.hasItems) {
          me.hasItems = true;
        }
      },
      setup(config, name) {
        config = ObjectHelper.merge(ObjectHelper.clone(me.stripDefaults["*"]), me.stripDefaults[name], config);
        config.parent = me;
        config.ref = name;
        return config;
      },
      transform(config) {
        if (Array.isArray(config)) {
          config = {
            items: config
          };
        }
        return config || null;
      }
    }));
    manager.update(strips);
    if (!oldStrips) {
      return manager.target;
    }
  }
  //endregion
  //region Collapse/Expand
  /**
   * This property is `true` if the panel is currently collapsing.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get collapsing() {
    var _a4;
    return (_a4 = this.collapsible) == null ? void 0 : _a4.collapsing;
  }
  /**
   * This property is `true` if the panel is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   * @category Layout
   */
  get collapsingExpanding() {
    var _a4;
    return (_a4 = this.collapsible) == null ? void 0 : _a4.collapsingExpanding;
  }
  /**
   * This property is `true` if the panel is currently expanding.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get expanding() {
    var _a4;
    return (_a4 = this.collapsible) == null ? void 0 : _a4.expanding;
  }
  changeCollapsed(value) {
    const me = this, { collapsible } = me;
    me.recompose.flush();
    value = Boolean(value);
    if (!collapsible || me.changingCollapse || !me.isPainted) {
      return value;
    }
    collapsible == null ? void 0 : collapsible.collapse({
      animation: null,
      collapsed: value
    });
  }
  changeCollapsible(collapsible, was) {
    const me = this;
    me.getConfig("tools");
    if (collapsible) {
      if (collapsible === true) {
        collapsible = {};
      } else if (typeof collapsible === "string") {
        collapsible = {
          [dockDirection[collapsible] ? "direction" : "type"]: collapsible
        };
      }
    }
    return PanelCollapser.reconfigure(was, collapsible, {
      owner: me,
      defaults: {
        panel: me
      },
      cleanup() {
        if (me.collapsed) {
          was.collapse({
            animation: null,
            collapsed: false
          });
          me._collapsed = 1;
        }
      }
    });
  }
  updateCollapsible(collapsible) {
    const me = this, tools = collapsible == null ? void 0 : collapsible.toolsConfig;
    me.tools = {
      collapse: (tools == null ? void 0 : tools.collapse) || null,
      recollapse: (tools == null ? void 0 : tools.recollapse) || null
    };
    if (collapsible && me.isPainted && me.collapsed) {
      me._collapsed = 1;
    }
    if (me.collapsed === 1) {
      me.collapsed = true;
    }
  }
  _collapse(collapsed, options) {
    var _a4;
    if (options !== true && options !== void 0) {
      if (options === false) {
        collapsed.collapsed = !collapsed.collapsed;
      } else if (typeof options === "number") {
        collapsed.animation = {
          duration: options
        };
      } else if (options === null) {
        collapsed.animation = options;
      } else if (options === true) {
      } else if ("animation" in options) {
        ObjectHelper.merge(collapsed, options);
      } else {
        collapsed.animation = options;
      }
    }
    return (_a4 = this.collapsible) == null ? void 0 : _a4.collapse(collapsed);
  }
  collapse(options) {
    return this._collapse({ collapsed: true }, options);
  }
  expand(options) {
    return this._collapse({ collapsed: false }, options);
  }
  /**
   * Toggles collapsed state of the panel.
   * Collapses an expanded or expands a collapsed panel.
   * @privateparam [options] options object with animation config (for internal use)
   * @returns {Boolean} `true` value for collapsed panel or `false` for expanded
   */
  toggleCollapsed(options) {
    return this.collapsed ? this.expand(options) : this.collapse(options);
  }
  //endregion
  //region Misc
  get expandedHeaderDock() {
    var _a4, _b, _c;
    return (_c = (_b = this._expandedHeaderDock) != null ? _b : (_a4 = this.initialConfig.header) == null ? void 0 : _a4.dock) != null ? _c : "top";
  }
  set expandedHeaderDock(v) {
    this._expandedHeaderDock = v == null ? void 0 : v.toLowerCase();
  }
  updateHeader(header) {
    if (!this.changingCollapse) {
      this.expandedHeaderDock = header == null ? void 0 : header.dock;
    }
  }
  updateTrapFocus(trapFocus) {
    var _a4;
    const me = this;
    me.element.classList[trapFocus ? "add" : "remove"]("b-focus-trapped");
    me.focusTrapListener = (_a4 = me.focusTrapListener) == null ? void 0 : _a4.call(me);
    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: "onFocusTrapped",
        delegate: ".b-focus-trap",
        thisObj: me
      });
      if (!me.treeWalker) {
        me.treeWalker = this.setupTreeWalker(me.element, DomHelper.NodeFilter.SHOW_ELEMENT, acceptNode);
      }
    }
  }
  setupTreeWalker(root, whatToShow, filter) {
    return document.createTreeWalker(root, whatToShow, filter);
  }
  onFocusTrapped(e) {
    const me = this, treeWalker = me.treeWalker;
    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    } else if (e.target === me.topFocusTrap) {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    } else {
      return;
    }
    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get focusElement() {
    return this.hasItems && (super.focusElement || this.element);
  }
  get contentElement() {
    return this.element && this.bodyElement;
  }
  get widgetClassList() {
    var _a4;
    const me = this, result = super.widgetClassList;
    if (me.hasHeader) {
      result.push("b-panel-has-header", `b-header-dock-${((_a4 = me.header) == null ? void 0 : _a4.dock) || "top"}`);
    }
    if (me.tbar) {
      result.push("b-panel-has-top-toolbar");
    }
    if (me.bbar) {
      result.push("b-panel-has-bottom-toolbar");
    }
    return result;
  }
};
//region Config
__publicField(_Panel, "$name", "Panel");
__publicField(_Panel, "type", "panel");
var Panel = _Panel;
Panel.initClass();
Panel._$name = "Panel";

// ../Core/lib/Core/widget/Popup.js
var _Popup = class _Popup extends Panel {
  static get configurable() {
    return {
      /**
       * Auto show flag for Popup.
       * If truthy then Popup is shown automatically upon hover.
       * @config {Boolean}
       * @default
       */
      autoShow: true,
      /**
       * By default, a Popup is transient, and will {@link #function-close} when the user clicks or
       * taps outside its owned widgets and when focus moves outside its owned widgets.
       *
       * **Note**: {@link #config-modal Modal} popups won't {@link #function-close} when focus moves outside even
       * if autoClose is `true`.
       *
       * Configure as `false` to make a Popup non-transient.
       * @config {Boolean}
       * @default
       */
      autoClose: true,
      /**
       * Show popup when user clicks the element that it is anchored to. Cannot be combined with showOnHover
       * @config {Boolean}
       * @default
       */
      showOnClick: false,
      /**
       * DOM element to attach popup.
       * @config {HTMLElement}
       */
      forElement: null,
      monitorResize: true,
      floating: true,
      hidden: true,
      axisLock: true,
      // Flip edges if align violates constrainTo
      hideAnimation: {
        opacity: {
          from: 1,
          to: 0,
          duration: ".3s",
          delay: "0s"
        }
      },
      showAnimation: {
        opacity: {
          from: 0,
          to: 1,
          duration: ".4s",
          delay: "0s"
        }
      },
      stripDefaults: {
        bbar: {
          layout: {
            justify: "flex-end"
          }
        }
      },
      testConfig: {
        hideAnimation: null,
        showAnimation: null
      },
      /**
       * The action to take when calling the {@link #function-close} method.
       * By default, the popup is hidden.
       *
       * This may be set to `'destroy'` to destroy the popup upon close.
       * @config {'hide'|'destroy'}
       * @default
       */
      closeAction: "hide",
      /**
       * By default, tabbing within a Popup is circular - that is it does not exit.
       * Configure this as `false` to allow tabbing out of the Popup.
       * @config {Boolean}
       * @default
       */
      trapFocus: true,
      /**
       * By default a Popup is focused when it is shown.
       * Configure this as `false` to prevent automatic focus on show.
       * @config {Boolean}
       * @default
       */
      focusOnToFront: true,
      /**
       * Show a tool in the header to close this Popup, and allow `ESC` close it.
       * The tool is available in the {@link Core.widget.mixin.Toolable#property-tools} object
       * under the name `close`. It uses the CSS class `b-popup-close` to apply a
       * default close icon. This may be customized with your own CSS rules.
       * @default false
       * @config {Boolean}
       */
      closable: null,
      /**
       * Show a tool in the header to maximize this popup
       * @config {Boolean}
       * @default false
       */
      maximizable: null,
      /**
       * Optionally show an opaque mask below this Popup when shown.
       * Configure this as `true` to show the mask.
       *
       * When a Popup is modal, it defaults to being {@link Core.widget.Widget#config-centered}.
       * Also, it won't {@link #function-close} when focus moves outside even if {@link #config-autoClose} is
       * `true`.
       *
       * The default action is to focus the popup.
       *
       * Usage:
       * ```javascript
       * new Popup({
       *     title  : 'I am modal',
       *     modal  : {
       *         closeOnMaskTap : true
       *     },
       *     height : 100,
       *     width  : 200
       * });
       * ```
       *
       * @default false
       * @config {Boolean|Object}
       * @property {Boolean} [closeOnMaskTap=false] Specify as `true` to close when mask is tapped.
       * @property {Boolean} [transparent=false] Specify as `true` to use a transparent mask.
       */
      modal: null,
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @member {Boolean} maximized
       * @category Float & align
       */
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      maximized: null,
      tools: {
        close: {
          cls: "b-popup-close",
          handler: "close",
          weight: -1e3,
          ariaLabel: "L{Popup.close}",
          hidden: true
          // shown when closable set to true
        },
        maximize: {
          cls: "b-popup-expand",
          handler: "toggleMaximized",
          weight: -999,
          hidden: true
          // shown when maximizable set to true
        }
      },
      highlightReturnedFocus: true,
      role: "dialog"
    };
  }
  //endregion
  //region Init & destroy
  finalizeInit() {
    const me = this, { forElement } = me;
    me.anchoredTo = forElement;
    me.initialAnchor = me.anchor;
    if (forElement && me.showOnClick) {
      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }
      EventHelper.on({
        element: forElement,
        click: "onElementUserAction",
        thisObj: me
      });
    }
    super.finalizeInit();
    if (me.autoShow && (!forElement || DomHelper.isVisible(forElement))) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a4;
    (_a4 = super.onInternalPaint) == null ? void 0 : _a4.call(this, ...arguments);
    const me = this;
    if (firstPaint && me.headerElement) {
      EventHelper.on({
        element: me.headerElement,
        dblclick: me.onHeaderDblClick,
        thisObj: me
      });
    }
  }
  doDestroy() {
    this.syncModalMask();
    super.doDestroy();
  }
  //endregion
  compose() {
    const { hasNoChildren, textContent } = this;
    return {
      class: {
        // Popup has extra CSS responsibilities at the top level.
        // The CSS needs to know whether it should impose a max-width.
        "b-text-popup": Boolean(textContent && hasNoChildren)
      }
    };
  }
  //region Show/hide
  /**
   * Performs the configured {@link #config-closeAction} upon this popup.
   * By default, the popup hides. The {@link #config-closeAction} may be
   * configured as `'destroy'`.
   * @fires beforeClose
   */
  close() {
    var _a4, _b;
    const me = this;
    if (!me._hidden && me.trigger("beforeClose") !== false || // we should destroy it even if it's hidden just omit beforeclose event
    me._hidden && me.closeAction === "destroy") {
      me.modal && me.closeAction === "destroy" && me.revertFocus();
      me.unmask();
      if (me.containsFocus && me.highlightReturnedFocus) {
        me.setTimeout(() => me.element.classList.add("b-using-keyboard"), 0);
      }
      const errorTip = me.items.length && ((_a4 = me.items.find((item) => item.errorTip)) == null ? void 0 : _a4.errorTip);
      if (errorTip) {
        (_b = errorTip.pointerOverOutDetacher) == null ? void 0 : _b.call(errorTip);
        errorTip.hide();
      }
      return me[me.closeAction]();
    }
  }
  toggleMaximized() {
    this.maximized = !this.maximized;
  }
  updateMaximized(value) {
    DomHelper.toggleClasses(this.element, ["b-maximized"], value);
  }
  //endregion
  //region Events
  onInternalKeyDown(event) {
    const me = this;
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      if (me.floating || me.positioned) {
        me.close(true);
      } else if (me.collapsible) {
        if (me.revealed) {
          me.collapsible.toggleReveal();
        } else {
          me.collapse();
        }
      }
    }
  }
  onDocumentMouseDown({ event }) {
    const me = this, { owner } = me, { target } = event;
    if (event.type !== "touchend" && (owner == null ? void 0 : owner.isButton) && owner._menu === me && owner.element.contains(target)) {
      event.preventDefault();
      return false;
    }
    if (me.modal && target === _Popup.modalMask) {
      event.preventDefault();
      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    } else if (!me.owns(target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }
  get isTopModal() {
    return DomHelper.isVisible(_Popup.modalMask) && this.element.previousElementSibling === _Popup.modalMask;
  }
  onFocusIn(e) {
    const activeEl = DomHelper.getActiveElement(this);
    super.onFocusIn(e);
    if (DomHelper.getActiveElement(this) === activeEl && e.target === this.element) {
      this.focus();
    }
  }
  onFocusOut(e) {
    const usingVirtualKeyboard = globalThis.visualViewport && globalThis.visualViewport.height < document.documentElement.clientHeight - 1;
    if (!usingVirtualKeyboard && !this.modal && this.autoClose) {
      this.close();
    }
    super.onFocusOut(e);
  }
  afterShow() {
    const me = this;
    if (me.autoClose || me.modal) {
      me.addDocumentMouseDownListener();
    }
    me.toFront();
    super.afterShow(...arguments);
  }
  toFront() {
    if (this.floating) {
      super.toFront();
      this.syncModalMask();
    }
    if (this.focusOnToFront) {
      this.focus();
    }
  }
  addDocumentMouseDownListener() {
    if (!this.mouseDownRemover) {
      this.mouseDownRemover = GlobalEvents_default.ion({
        globaltap: "onDocumentMouseDown",
        thisObj: this
      });
    }
  }
  updateModal(modal) {
    if (modal) {
      this.floating = true;
    }
  }
  syncModalMask() {
    const me = this, {
      modal,
      element
    } = me;
    element.setAttribute("aria-modal", Boolean(modal));
    if (modal && me.isVisible) {
      if (typeof me._x !== "number" && typeof me._y !== "number") {
        me.centered = true;
        me.anchor = false;
      }
      me.modalMask.classList.remove("b-hide-display");
      me.modalMask.classList.toggle("b-modal-transparent", Boolean(modal.transparent));
      element.classList.add("b-modal");
    } else if (me.isPainted) {
      element.classList.remove("b-modal");
      const remainingModals = me.floatRoot.querySelectorAll(".b-modal"), topModal = remainingModals.length ? _Popup.fromElement(remainingModals[remainingModals.length - 1], "popup") : null;
      if (topModal) {
        topModal.syncModalMask();
      } else {
        _Popup.modalMask.classList.add("b-hide-display");
      }
    }
  }
  afterHide() {
    var _a4;
    const me = this;
    super.afterHide(...arguments);
    (_a4 = me.mouseDownRemover) == null ? void 0 : _a4.call(me);
    me.mouseDownRemover = null;
    me.syncModalMask();
  }
  onElementUserAction() {
    this.show();
  }
  onHeaderDblClick() {
    if (this.maximizable) {
      this.toggleMaximized();
    }
  }
  //endregion
  updateClosable(closable) {
    this.tools.close.hidden = !closable;
  }
  updateMaximizable(maximizable) {
    this.tools.maximize.hidden = !maximizable;
  }
  /**
   * Returns the modal mask element for this Popup correctly positioned just below this Popup.
   * @internal
   */
  get modalMask() {
    const { modalMask } = _Popup;
    if (modalMask.nextElementSibling !== this.element) {
      this.floatRoot.insertBefore(modalMask, this.element);
    }
    return modalMask;
  }
  /**
   * Returns the modal mask element. It does NOT guarantee its placement in the DOM relative
   * to any Popup. To get the modal mask for a particular Popup, use the instance property.
   * @internal
   */
  static get modalMask() {
    if (!this._modalMask) {
      this._modalMask = DomHelper.createElement({
        className: "b-modal-mask b-hide-display"
      });
      EventHelper.on({
        element: this._modalMask,
        wheel: (e) => e.preventDefault()
      });
    }
    return this._modalMask;
  }
};
//region Config
__publicField(_Popup, "$name", "Popup");
__publicField(_Popup, "type", "popup");
var Popup = _Popup;
Popup.initClass();
Popup._$name = "Popup";

// ../Core/lib/Core/widget/MenuItem.js
var bIcon2 = /^b-icon-/;
var bFa2 = /^b-fa-/;
var MenuItem = class extends Widget {
  static get configurable() {
    return {
      /**
       * If configured with a `Boolean` value, a checkbox is displayed
       * as the start icon, and the {@link #event-toggle} event is fired
       * when the checked state changes.
       * @config {Boolean}
       */
      checked: null,
      /**
       * Set to `true` to display a border above this menu item, if there are other visible menu items before it.
       * @config {Boolean}
       * @default false
       */
      separator: null,
      /**
       * Indicates that this menu item is part of a group where only one can be checked. Assigning a value
       * also sets `toggleable` to `true`.
       * ```
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @prp {String}
       */
      toggleGroup: null,
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       * @readonly
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration
       * objects from which to create a submenu.
       *
       * Configuration object example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             menu : {
       *                 // Submenu items
       *                 firstItem : {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 secondItem : {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * Array of items example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the submenu.
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     type  : 'textfield',
       *                     label : 'Type here'
       *                 },
       *                 {
       *                     type : 'button',
       *                     text : 'Confirm'
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object<String,MenuItemConfig|ContainerItemConfig>|Array<MenuItemConfig|ContainerItemConfig>}
       */
      menu: {
        value: null,
        $config: ["lazy", "nullify"]
      },
      /**
       * Item icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @config {String}
       */
      icon: null,
      /**
       * The text to be displayed in the item. The text is automatically HTML encoded.
       * @prp {String} text
       */
      text: null,
      /**
       * By default, upon activate, non-checkbox menu items will collapse
       * the owning menu hierarchy.
       *
       * Configure this as `false` to cause the menu to persist after
       * activating an item
       * @config {Boolean}
       */
      closeParent: null,
      /**
       * If provided, turns the menu item into a link
       * @config {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @config {'_self'|'_blank'|'_parent'|'_top'|null}
       */
      target: null,
      localizableProperties: ["text"],
      role: "menuitem",
      openMenuDelay: 120
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (typeof this.checked === "boolean") {
      this.role = "menuitemcheckbox";
    }
    this.ariaHasPopup = this.hasMenu ? "menu" : false;
    return result;
  }
  compose() {
    var _a4;
    const me = this, { checked, href, hasMenu, separator, target, text, toggleGroup } = me, isCheckItem = typeof checked === "boolean", icon = me.icon || (isCheckItem ? "b-fw-icon" : ""), checkCls = `b-icon-${toggleGroup ? "radio-" : ""}`, hasCustomContent = typeof text === "object";
    return {
      tag: href ? "a" : "div",
      tabIndex: -1,
      href,
      target,
      class: {
        "b-has-submenu": hasMenu,
        "b-checked": checked,
        // Support both separator config and directly setting separator class
        "b-separator": separator || ((_a4 = me.cls) == null ? void 0 : _a4["b-separator"])
      },
      dataset: {
        group: me.toggleGroup
      },
      // Only set aria-checked if it's a check item
      [isCheckItem ? "aria-checked" : ""]: checked,
      // Only set expanded if there's a submenu to expand
      [hasMenu ? "aria-expanded" : ""]: false,
      children: {
        iconElement: icon && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fa": bFa2.test(icon),
            "b-icon": bIcon2.test(icon),
            "b-menuitem-icon": 1,
            [`${checkCls}checked`]: checked === true,
            [`${checkCls}unchecked`]: checked === false,
            ...DomClassList.normalize(icon, "object")
          }
        },
        textElement: {
          tag: "span",
          [hasCustomContent ? void 0 : "text"]: hasCustomContent ? void 0 : text,
          class: {
            "b-menu-text": 1,
            "b-menu-custom-content": hasCustomContent
          },
          children: hasCustomContent ? [text] : null
        },
        subMenuIcon: hasMenu && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fw-icon": 1,
            "b-icon-sub-menu": 1
          }
        }
      }
    };
  }
  /**
   * Actions this item. Fires the {@link #event-item} event, and if this is a {@link #config-checked} item, toggles
   * the checked state, firing the {@link #event-toggle} event.
   */
  doAction(event) {
    const item = this, menu = this.parent, itemEvent = { menu, item, element: item.element, bubbles: true, domEvent: event };
    if (typeof item.checked === "boolean") {
      const newCheckedState = !item.checked;
      if (!item.toggleGroup || newCheckedState) {
        item.checked = !item.checked;
      }
    } else if (item.href && event.key) {
      item.element.click();
    }
    item.trigger("beforeItem", itemEvent);
    item.trigger("item", itemEvent);
    if (item.closeParent && menu) {
      menu.rootMenu.close();
      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }
  get focusElement() {
    return this.element;
  }
  get contentElement() {
    return this.textElement;
  }
  get isFocusable() {
    const { focusElement } = this;
    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }
  get hasMenu() {
    return this.hasConfig("menu");
  }
  get childItems() {
    const { _menu } = this;
    return _menu ? [_menu] : [];
  }
  onFocusIn(e) {
    const { menu } = this;
    super.onFocusIn(e);
    if (!this.disabled && menu) {
      menu.clearTimeout(menu.closeTimer);
      this.delay("openMenu", menu.closeTimer ? 0 : this.openMenuDelay);
      menu.closeTimer = null;
    }
  }
  onFocusOut(e) {
    var _a4;
    const me = this;
    me.clearTimeout("openMenu");
    super.onFocusOut(e);
    const menu = me._menu;
    if (menu && !((_a4 = me.owner) == null ? void 0 : _a4.ignoreFocusOut)) {
      if (DomHelper.usingKeyboard) {
        me.closeMenu();
      } else {
        menu.clearTimeout(menu.closeTimer);
        menu.closeTimer = menu.setTimeout(() => me.closeMenu(), menu.closeMenuDelay);
      }
    }
  }
  openMenu(andFocus) {
    const { menu, parent } = this;
    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      parent.isMenu ? parent.openSubMenu(this.element, this) : menu.show();
    }
  }
  onChildShow(shown) {
    super.onChildShow(shown);
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  closeMenu() {
    if (this._menu.isWidget) {
      this.menu.close();
    }
    this.menu.closeTimer = null;
  }
  onChildHide(hidden) {
    super.onChildHide(hidden);
    this.ariaElement.setAttribute("aria-expanded", false);
  }
  changeToggleGroup(toggleGroup) {
    if (toggleGroup && typeof this.checked !== "boolean") {
      this.checked = false;
    }
    return toggleGroup;
  }
  /**
   * Get/sets the checked state of this `MenuItem` and fires the {@link #event-toggle}
   * event upon change.
   *
   * Note that this must be configured as a `Boolean` to enable the checkbox UI.
   * @member {Boolean} checked
   */
  changeChecked(checked, old) {
    if (this.isConfiguring || typeof old === "boolean") {
      return Boolean(checked);
    }
  }
  updateChecked(checked) {
    const me = this;
    if (!me.isConfiguring) {
      if (me.toggleGroup) {
        me.uncheckToggleGroupMembers();
      }
      me.element.setAttribute("aria-checked", checked);
      me.trigger("toggle", {
        menu: me.owner,
        item: me,
        element: me.element,
        bubbles: true,
        checked
      });
    }
  }
  getToggleGroupMembers() {
    const me = this, { checked, toggleGroup, element } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `[data-group=${toggleGroup}]`, (otherElement) => {
        if (otherElement !== element) {
          const partnerCheckItem = Widget.fromElement(otherElement);
          partnerCheckItem && result.push(partnerCheckItem);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  get closeParent() {
    const result = typeof this.checked === "boolean" ? this._closeParent : this._closeParent !== false;
    return result && !this.hasMenu;
  }
  changeMenu(config, existingMenu) {
    const me = this, { constrainTo, scrollAction } = me.owner;
    if (config && typeof config === "object" && !("items" in config) && !("widgets" in config) && !("html" in config)) {
      config = {
        lazyItems: config
      };
    }
    return Menu.reconfigure(existingMenu, config, {
      owner: me,
      defaults: {
        type: "menu",
        align: "s0-e0",
        anchor: true,
        autoClose: true,
        autoShow: false,
        cls: {
          "b-sub-menu": 1
          // Marks the widget as a submenu
        },
        forElement: me.element,
        owner: me,
        ariaLabel: me.text,
        constrainTo,
        scrollAction
      }
    });
  }
};
//region Config
__publicField(MenuItem, "$name", "MenuItem");
__publicField(MenuItem, "type", "menuitem");
MenuItem.initClass();
MenuItem._$name = "MenuItem";

// ../Core/lib/Core/widget/Menu.js
var validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};
var Menu = class extends Popup {
  /**
   * Currently open sub menu, if any
   * @member {Core.widget.Menu} currentSubMenu
   * @readonly
   */
  //endregion
  /**
   * A descendant menu item has been activated.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu} for convenience.
   * @event item
   * @param {Core.widget.MenuItem} item - The menu item which is being actioned.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   */
  /**
   * The checked state of a descendant menu item has changed.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu} for convenience.
   * @event toggle
   * @param {Core.widget.MenuItem} item - The menu item whose checked state changed.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   * @param {Boolean} checked - The _new_ checked state.
   */
  /* break doc comment */
  //region Init
  construct(config) {
    if (Array.isArray(config)) {
      config = {
        lazyItems: config
      };
    }
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: "onMouseClick",
      mouseover: "onMouseOver",
      mouseenter: "onMouseEnter",
      mouseleave: "onMouseLeave",
      thisObj: this
    });
  }
  afterShow() {
    const { items: items2, element } = this, hasSubmenu = items2.some((item) => item.hasConfig("menu"));
    if (hasSubmenu) {
      element.classList.add("b-menu-with-submenu");
    }
    const hasIcon = items2.some((item) => item.icon);
    if (hasIcon) {
      element.classList.add("b-menu-with-icon");
    }
    super.afterShow(...arguments);
  }
  createWidget(item) {
    if (typeof item === "string") {
      item = {
        text: item
      };
    }
    return super.createWidget(item);
  }
  get focusElement() {
    var _a4;
    const me = this, fromParentMenu = (_a4 = me.parentMenu) == null ? void 0 : _a4.element.contains(DomHelper.getActiveElement(me.parentMenu)), firstWidget = me.items[0];
    if (fromParentMenu || DomHelper.usingKeyboard || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }
    return me.element;
  }
  //endregion
  onDocumentMouseDown({ event }) {
    if (!this.parentMenu || !this.parentMenu.owns(event.target)) {
      return super.onDocumentMouseDown(...arguments);
    }
  }
  //region Show
  hide(animate) {
    var _a4, _b;
    const me = this;
    super.hide(animate);
    if (!me.isVisible) {
      (_b = (_a4 = me.currentSubMenu) == null ? void 0 : _a4.hide) == null ? void 0 : _b.call(_a4, animate);
      if (me.parentMenu) {
        me.parentMenu.currentSubMenu = null;
      }
    }
  }
  show() {
    const result = super.show(...arguments);
    const { parentMenu } = this;
    if (this.isVisible && parentMenu) {
      parentMenu.currentSubMenu = this;
    }
    return result;
  }
  //endregion
  //region Events
  /**
   * Activates a menu item if user clicks on it
   * @private
   */
  onMouseClick(event) {
    const menuItem = event.target.closest(".b-menuitem");
    if (menuItem) {
      this.triggerElement(menuItem, event);
    }
  }
  /**
   * Activates menu items on hover. On real mouse hover, not on a touchstart.
   * @private
   */
  onMouseOver(event) {
    var _a4;
    if (this.focusOnHover !== false) {
      const fromItemElement = (_a4 = event.relatedTarget) == null ? void 0 : _a4.closest(".b-widget"), toItemElement = event.target.closest(".b-widget"), overItem = Widget.fromElement(toItemElement);
      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        this.setTimeout({
          fn: "handleMouseOver",
          delay: 30,
          args: [overItem],
          cancelOutstanding: true
        });
      }
    }
  }
  handleMouseOver(overItem) {
    overItem.focus();
  }
  onMouseEnter() {
    this.clearTimeout(this.closeTimer);
    const { parentMenu } = this;
    if (parentMenu) {
      parentMenu.ignoreFocusOut = true;
      parentMenu.setTimeout(() => parentMenu.ignoreFocusOut = false, 500);
      parentMenu.clearTimeout(parentMenu.hideSubMenuTimer);
    }
  }
  // unselect any menu item if mouse leaves the menu element (unless it enters a child menu)
  onMouseLeave(event) {
    const me = this, { relatedTarget } = event, leavingToChild = relatedTarget && me.owns(relatedTarget);
    let targetCmp = relatedTarget instanceof HTMLElement && Widget.fromElement(relatedTarget), shouldHideMenu = !leavingToChild;
    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }
      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }
    if (!leavingToChild && shouldHideMenu) {
      if (me.currentSubMenu) {
        me.hideSubMenuTimer = me.setTimeout(() => {
          var _a4;
          return (_a4 = me.currentSubMenu) == null ? void 0 : _a4.hide();
        }, me.closeMenuDelay);
      }
      if (me.element.contains(DomHelper.getActiveElement(me)) && DomHelper.getActiveElement(me).matches(".b-menuitem")) {
        me.focusElement.focus();
      }
    }
  }
  /**
   * Keyboard navigation. Up/down, close with esc, activate with enter
   * @private
   */
  onInternalKeyDown(event) {
    const sourceWidget = Widget.fromElement(event), isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);
    if (event.key === "Escape") {
      (isFromWidget ? this : this.rootMenu).close();
      return;
    }
    super.onInternalKeyDown(event);
    if (isFromWidget) {
      return;
    }
    if (validKeys[event.key]) {
      event.preventDefault();
    }
    const el = this.element, active = DomHelper.getActiveElement(el);
    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }
  navigateFrom(active, key, event) {
    var _a4, _b;
    const me = this, { treeWalker } = me, item = active && me.getItem(active), enterSubMenu = me.rtl ? "ArrowLeft" : "ArrowRight", exitSubMenu = me.rtl ? "ArrowRight" : "ArrowLeft";
    let toActivate;
    switch (key) {
      case "ArrowUp":
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        (_a4 = item == null ? void 0 : item.menu) == null ? void 0 : _a4.hide(false);
        break;
      case "ArrowDown":
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        (_b = item == null ? void 0 : item.menu) == null ? void 0 : _b.hide(false);
        break;
      case " ":
        if (active && !active.classList.contains("b-disabled")) {
          if (item == null ? void 0 : item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }
        break;
      case enterSubMenu:
        if (active && (item == null ? void 0 : item.menu) && !active.classList.contains("b-disabled")) {
          const openedMenu = me.openSubMenu(active, item);
          openedMenu == null ? void 0 : openedMenu.focus();
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case exitSubMenu:
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case "Enter":
        if (active && !active.classList.contains("b-disabled")) {
          me.triggerElement(active, event);
        }
        break;
    }
    if (toActivate) {
      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, "ArrowUp", event);
      } else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, "ArrowDown", event);
      } else {
        toActivate.focus();
      }
    }
  }
  //endregion
  //region Activate menu item
  getItem(item) {
    if (item != null) {
      if (typeof item === "number") {
        return this.items[item];
      }
      if (item.nodeType === Element.ELEMENT_NODE) {
        return Widget.fromElement(item, "menuitem", this.contentElement);
      }
      return this.items.find((c) => c.id == item);
    }
  }
  /**
   * Activate a menu item (from its element)
   * @private
   * @fires item
   * @param menuItemElement
   */
  triggerElement(menuItemElement, event) {
    const item = this.getItem(menuItemElement);
    if (item && !item.disabled) {
      item.doAction(event);
    }
  }
  /**
   * Returns true if this menu is a sub menu.
   * To find out which menu is the parent, check {@link #property-parentMenu}.
   * @type {Boolean}
   * @readonly
   */
  get isSubMenu() {
    var _a4;
    return this === ((_a4 = this.owner) == null ? void 0 : _a4.menu);
  }
  /**
   * Opens a submenu anchored to a menu item
   * @private
   * @param element
   * @param item
   */
  openSubMenu(element, item) {
    var _a4;
    const me = this, subMenu = item.menu;
    if (subMenu) {
      if (!subMenu.isVisible) {
        const event = { item, element };
        if (me.trigger("beforeSubMenu", event) === false) {
          return;
        }
        if (((_a4 = item.onBeforeSubMenu) == null ? void 0 : _a4.call(item, event)) === false) {
          return;
        }
        subMenu.show();
        if (subMenu.isVisible && !subMenu.isMenu) {
          me.currentSubMenu = subMenu;
        }
      }
      return subMenu;
    }
  }
  /**
   * Get/set focused menu item.
   * Shows submenu if newly focused item has a menu and is not disabled.
   * @property {HTMLElement}
   */
  set selectedElement(element) {
    const me = this, lastSelected = me._selectedElement;
    if (lastSelected) {
      const lastItem = me.getItem(lastSelected), lastItemMenu = lastItem == null ? void 0 : lastItem.menu;
      lastItemMenu == null ? void 0 : lastItemMenu.hide();
      lastSelected.classList.remove("b-active");
    }
    me._selectedElement = element;
    if (element) {
      const doFocus = DomHelper.isFocusable(element);
      element.classList.add("b-active");
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }
  get selectedElement() {
    return this._selectedElement;
  }
  selectFirst() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();
    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  //endregion
  //region Close
  /**
   * Gets the parent Menu if this Menu is a submenu, or `undefined`.
   * @property {Core.widget.Menu}
   */
  get parentMenu() {
    var _a4;
    const result = this.owner;
    return result && (result.isMenu ? result : (_a4 = result.up) == null ? void 0 : _a4.call(result, "menu"));
  }
  /**
   * Gets this menus root menu, the very first menu shown in a sub menu hierarchy
   * @property {Core.widget.Menu}
   * @private
   */
  get rootMenu() {
    let menu = this;
    while (menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }
    return menu;
  }
  //endregion
};
//region Hidden configs
/**
 * @hideConfigs scrollable
 */
/**
 * @hideproperties scrollable
 */
//endregion
//region Config
__publicField(Menu, "$name", "Menu");
__publicField(Menu, "type", "menu");
__publicField(Menu, "configurable", {
  layout: "vbox",
  focusable: true,
  showAnimation: null,
  hideAnimation: {
    opacity: {
      from: 1,
      to: 0,
      duration: ".15s",
      delay: "0s"
    }
  },
  align: {
    align: "t-b"
  },
  scrollAction: "hide",
  /**
   * Specify false to prevent the menu from getting focus when hovering items
   * @default
   * @config {Boolean}
   */
  focusOnHover: null,
  // We do need a Scroller so that we can use its API to scroll around.
  // But the overflow flags default to false.
  scrollable: false,
  defaultType: "menuitem",
  tools: {
    // To get rid of the close tool from Popup
    close: false
  },
  role: "menu",
  ariaElement: "bodyElement",
  closeMenuDelay: 200
});
Menu.initClass();
Menu._$name = "Menu";

// ../Core/lib/Core/feature/base/ContextMenuBase.js
var contextMenuKeyEvent;
var ContextMenuBase = class extends InstancePlugin {
  static get $name() {
    return "ContextMenuBase";
  }
  //region Config
  static get configurable() {
    return {
      /**
       * This is a type of the context menu used to generate correct names for methods and events.
       * Should be in camel case. Required to be set in subclass.
       * @config {String}
       * @readonly
       */
      type: null,
      /**
       * Gets the Menu instance that this feature is using.
       * @member {Core.widget.Menu} menu
       * @readonly
       */
      /**
       * A config which will be applied when creating the Menu component.
       * @config {MenuConfig}
       */
      menu: {
        $config: ["lazy", "nullify"],
        value: {
          type: "menu",
          autoShow: false,
          closeAction: "hide",
          constrainTo: globalThis,
          scrollAction: null
        }
      },
      /**
       * {@link Core/widget/Menu} items object containing named child menu items to apply to the feature's
       * provided context menu.
       *
       * This may add extra items as below, but may also remove any of the default items by configuring the name
       * of the item as `null`.
       *
       * ```javascript
       * features : {
       *     cellMenu : {
       *         // This object is applied to the Feature's predefined default items
       *         items : {
       *             switchToDog : {
       *                 text : 'Dog',
       *                 icon : 'b-fa b-fa-fw b-fa-dog',
       *                 onItem({record}) {
       *                     record.dog = true;
       *                     record.cat = false;
       *                 },
       *                 weight : 500     // Make this second from end
       *             },
       *             switchToCat : {
       *                 text : 'Cat',
       *                 icon : 'b-fa b-fa-fw b-fa-cat',
       *                 onItem({record}) {
       *                     record.dog = false;
       *                     record.cat = true;
       *                 },
       *                 weight : 510     // Make this sink to end
       *             },
       *             add : null // We do not want the "Add" submenu to be available
       *         }
       *     }
       * }
       * ```
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>}
       */
      items: {},
      /**
       * Event which is used to show context menu.
       * Available options are: 'contextmenu', 'click' and 'dblclick'.
       * Default value is used from {@link Grid/view/GridBase#config-contextMenuTriggerEvent}
       * @config {'contextmenu'|'click'|'dblclick'|null}
       */
      triggerEvent: null,
      /**
       * A CSS selector targeting an element, such as an ellipsis icon that when
       * clicked will trigger the menu to show.
       * @config {String}
       */
      clickTriggerSelector: null,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>} keyMap
       */
      keyMap: {
        " ": { handler: "showContextMenuByKey", weight: 100 },
        "Ctrl+Space": "showContextMenuByKey"
      }
    };
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  // The contextmenu event is emulated from a taphold gesture on touch platforms.
  static get pluginConfig() {
    return {
      assign: ["showContextMenu"],
      chain: [
        "onElementContextMenu",
        "onElementClick",
        "onElementDblClick"
      ]
    };
  }
  //endregion
  //region Init
  construct(...args) {
    var _a4;
    super.construct(...args);
    if (!((_a4 = this.type) == null ? void 0 : _a4.length)) {
      throw new Error(`Config 'type' is required to be specified for context menu`);
    }
  }
  //endregion
  //region Events
  /**
   * This event fires on the owning widget when an item is selected in the context menu.
   * @event contextMenuItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   */
  /**
   * This event fires on the owning widget when a check item is toggled in the context menu.
   * @event contextMenuToggleItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Boolean} checked Checked or not
   */
  onElementContextMenu(event) {
    this.onElementEvent(event);
  }
  onElementClick(event) {
    this.onElementEvent(event);
  }
  onElementDblClick(event) {
    this.onElementEvent(event);
  }
  onElementEvent(event) {
    if (!event.handled && this.triggerEvent === event.type) {
      if (event.ctrlKey === true && !BrowserHelper.isMac) {
        event.preventDefault();
        return;
      }
      const originalEvent = event;
      if (contextMenuKeyEvent) {
        const { target } = contextMenuKeyEvent;
        event = EventHelper.fixEvent(new MouseEvent(event.type, event));
        Object.defineProperties(event, {
          target: { value: target },
          offsetX: { value: originalEvent.offsetX },
          offsetY: { value: originalEvent.offsetY }
        });
        event.preventDefault = function() {
          originalEvent.preventDefault();
          originalEvent.handled = true;
        };
      }
      this.internalShowContextMenu(event);
    } else if (event.type === "click" && this.clickTriggerSelector && event.target.matches(this.clickTriggerSelector)) {
      this.internalShowContextMenu(event, { align: "l-r", target: event.target });
    }
  }
  showContextMenuByKey(event) {
    if (!DomHelper.isEditable(event.target)) {
      const { target } = event;
      if (target) {
        contextMenuKeyEvent = event;
        DomHelper.triggerMouseEvent(target, this.triggerEvent);
        event.handled = true;
        event.preventDefault();
        event.stopImmediatePropagation();
        contextMenuKeyEvent = null;
        return true;
      }
    }
    return false;
  }
  //endregion
  //region Menu handlers
  internalShowContextMenu(domEvent, alignSpec) {
    const me = this;
    if (me.disabled) {
      return;
    }
    const data = me.getDataFromEvent(domEvent);
    if (!domEvent.handled && !domEvent.defaultPrevented && data && me.shouldShowMenu(data)) {
      if (domEvent.type === "contextmenu" && BrowserHelper.isSafari && domEvent.ctrlKey && !domEvent.metaKey) {
        EventHelper.on({
          element: domEvent.target,
          capture: true,
          once: true,
          thisObj: this,
          click(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        });
      }
      data.domEvent = domEvent;
      me.showContextMenu(data, alignSpec);
    }
  }
  getDataFromEvent(event) {
    return {
      feature: this,
      event,
      targetElement: this.getTargetElementFromEvent(event)
    };
  }
  getTargetElementFromEvent(event) {
    return event.target;
  }
  /**
   * Shows the context menu.
   * @param {Event} event The initiating event.
   * @param {AlignSpec|HTMLElement} [alignSpec] Menu alignment specification, or an element to align to
   * @on-owner
   */
  async showContextMenu(event, alignSpec) {
    var _a4, _b;
    const me = this, isDOMEvent = DomHelper.isDOMEvent(event), menuContext = isDOMEvent ? me.getDataFromEvent(event) : event, domEvent = isDOMEvent ? event : menuContext.domEvent;
    (_a4 = me._menu) == null ? void 0 : _a4.hide();
    if (me.disabled) {
      return;
    }
    me.menuContext = menuContext;
    const {
      type,
      client,
      processItems
    } = me, elCenter = DomHelper.isInView(menuContext.targetElement).center;
    Objects.assign(menuContext, {
      point: (domEvent == null ? void 0 : domEvent.clientX) ? [domEvent.clientX + 1, domEvent.clientY + 1] : [elCenter.x, elCenter.y],
      menu: me,
      items: {},
      selection: client.selectedRecords
    });
    me.callChainablePopulateMenuMethod(menuContext);
    Objects.merge(menuContext.items, me.baseItems);
    me.preventDefaultEvent(menuContext);
    if ((!processItems || await me.callback(processItems, client, [menuContext]) !== false) && me.hasActiveMenuItems(menuContext)) {
      me.populateItemsWithData(menuContext);
      if (me.beforeContextMenuShow(menuContext) !== false) {
        const { menu } = me, { featureItems } = menu, { items: items2 } = menuContext;
        let result = client.trigger(`${type}MenuBeforeShow`, menuContext);
        if (ObjectHelper.isPromise(result)) {
          domEvent.handled = true;
          result = await result;
        }
        if (result !== false) {
          if (featureItems) {
            menu.remove(featureItems);
            ArrayHelper.asArray(featureItems).forEach((i) => i.destroy());
          }
          menu.featureItems = menu.add(...Array.isArray(items2) ? items2 : menu.processItemsObject(items2));
          menu.showBy(alignSpec || {
            target: menuContext.domEvent,
            align: "s0-e100"
          });
          (_b = me.touchMoveDetacher) == null ? void 0 : _b.call(me);
          me.touchMoveDetacher = EventHelper.on({
            element: client.element,
            touchmove: () => menu.hide(),
            thisObj: menu,
            once: true
          });
          if (domEvent) {
            domEvent.preventDefault();
            domEvent.handled = true;
          }
        }
      }
    }
  }
  /**
   * Returns the base, configured-in menu items set from the configured items, taking into
   * account the namedItems the feature offers.
   * @property {Object[]}
   * @readonly
   * @internal
   */
  get baseItems() {
    if (!this._baseItems) {
      const me = this, { namedItems } = me, baseItems = me._baseItems = Objects.assign({}, me.items);
      for (const ref in baseItems) {
        const item = baseItems[ref];
        if (item) {
          if (namedItems && ref in namedItems) {
            baseItems[ref] = typeof item === "object" ? Objects.merge(Objects.clone(namedItems[ref]), item) : namedItems[ref];
          } else if (item === true) {
            delete baseItems[ref];
          }
        }
      }
    }
    return this._baseItems;
  }
  /**
   * Hides the context menu
   * @internal
   */
  hideContextMenu(animate) {
    var _a4;
    (_a4 = this.menu) == null ? void 0 : _a4.hide(animate);
  }
  callChainablePopulateMenuMethod(eventParams) {
    var _a4, _b;
    (_b = (_a4 = this.client)[`populate${StringHelper.capitalize(this.type)}Menu`]) == null ? void 0 : _b.call(_a4, eventParams);
  }
  hasActiveMenuItems(eventParams) {
    return Object.values(eventParams.items).some((item) => item && !item.hidden);
  }
  /**
   * Override this function and return `false` to prevent the context menu from being shown. Returns `true` by default.
   * @returns {Boolean}
   * @internal
   */
  shouldShowMenu() {
    return true;
  }
  beforeContextMenuShow(eventParams) {
  }
  populateItemsWithData(eventParams) {
  }
  preventDefaultEvent(eventParams) {
    var _a4;
    (_a4 = eventParams.event) == null ? void 0 : _a4.preventDefault();
  }
  //endregion
  //region Configurables
  get triggerEvent() {
    return this._triggerEvent || this.client.contextMenuTriggerEvent;
  }
  changeMenu(menu, oldMenu) {
    const me = this, {
      client,
      type
    } = me;
    if (menu) {
      return Menu.reconfigure(oldMenu, menu ? Menu.mergeConfigs({
        owner: client,
        rootElement: client.rootElement,
        onItem(itemEvent) {
          client.trigger(`${type}MenuItem`, itemEvent);
        },
        onToggle(itemEvent) {
          client.trigger(`${type}MenuToggleItem`, itemEvent);
        },
        onDestroy() {
          me.menu = null;
        },
        // Load up the item event with the contextual info
        onBeforeItem(itemEvent) {
          Object.assign(itemEvent, me.menuContext);
        },
        onShow({ source: menu2 }) {
          me.menuContext.menu = menu2;
          client.trigger(`${type}MenuShow`, me.menuContext);
        }
      }, menu) : null, me);
    } else if (oldMenu == null ? void 0 : oldMenu.isWidget) {
      oldMenu.destroy();
    }
  }
  //endregion
};
ContextMenuBase._$name = "ContextMenuBase";

// ../Core/lib/Core/helper/mixin/DragHelperContainer.js
var DragHelperContainer_default = (Target) => class DragHelperContainer extends (Target || Base) {
  static get $name() {
    return "DragHelperContainer";
  }
  //region Init
  /**
   * Initialize container drag mode.
   * @private
   */
  initContainerDrag() {
    const me = this;
    if (!me.mode) {
      me.mode = "container";
    }
    if (me.mode === "container" && !me.containers) {
      throw new Error("Container drag mode must specify containers");
    }
  }
  //endregion
  //region Grab, update, finish
  /**
   * Grab an element which can be dragged between containers.
   * @private
   * @param event
   * @returns {Boolean}
   */
  grabContainerDrag(event) {
    const me = this;
    if (!me.ignoreSelector || !event.target.closest(me.ignoreSelector)) {
      const element = DomHelper.getAncestor(event.target, me.containers, me.outerElement);
      if (element) {
        const box = element.getBoundingClientRect();
        me.context = {
          element,
          valid: true,
          action: "container",
          offsetX: event.pageX - box.left,
          offsetY: event.pageY - box.top,
          originalPosition: {
            parent: element.parentElement,
            prev: element.previousElementSibling,
            next: element.nextElementSibling
          }
        };
      }
      return true;
    }
    return false;
  }
  startContainerDrag(event) {
    var _a4;
    const me = this, { context, floatRootOwner } = me, { element: dragElement } = context, clonedNode = dragElement.cloneNode(true), outerWidgetEl = floatRootOwner == null ? void 0 : floatRootOwner.element.closest(".b-outer");
    clonedNode.classList.add(me.dragProxyCls, me.draggingCls);
    ((floatRootOwner == null ? void 0 : floatRootOwner.floatRoot) || DomHelper.getRootElement(dragElement)).appendChild(clonedNode);
    context.dragProxy = clonedNode;
    context.dragging = dragElement;
    dragElement.classList.add(me.dropPlaceholderCls);
    if ((_a4 = outerWidgetEl == null ? void 0 : outerWidgetEl.parentElement) == null ? void 0 : _a4.matches(".b-float-root")) {
      clonedNode.style.zIndex = floatRootOwner.floatRootMaxZIndex + 1;
    }
  }
  onContainerDragStarted(event) {
    const me = this, { context } = me, { element: dragElement, dragProxy } = context, box = dragElement.getBoundingClientRect();
    if (me.autoSizeClonedTarget) {
      dragProxy.style.width = box.width + "px";
      dragProxy.style.height = box.height + "px";
      DomHelper.setTranslateXY(context.dragProxy, box.left, box.top);
    } else {
      const proxyBox = dragProxy.getBoundingClientRect();
      Object.assign(context, {
        offsetX: proxyBox.width / 2,
        offsetY: proxyBox.height / 2
      });
      DomHelper.setTranslateXY(dragProxy, event.clientX, event.clientY);
    }
  }
  /**
   * Move the placeholder element into its new position on valid drag.
   * @private
   * @param event
   */
  updateContainerDrag(event) {
    var _a4;
    const me = this, { context } = me;
    if (!context.started || !context.targetElement) {
      return;
    }
    const containerElement = DomHelper.getAncestor(context.targetElement, me.containers, "b-gridbase"), willLoseFocus = (_a4 = context.dragging) == null ? void 0 : _a4.contains(DomHelper.getActiveElement(context.dragging));
    if (containerElement && DomHelper.isDescendant(context.element, containerElement)) {
      return;
    }
    if (willLoseFocus) {
      GlobalEvents_default.suspendFocusEvents();
    }
    if (containerElement && context.valid) {
      me.moveNextTo(containerElement, event);
    } else {
      me.revertPosition();
    }
    if (willLoseFocus) {
      GlobalEvents_default.resumeFocusEvents();
    }
    event.preventDefault();
  }
  /**
   * Finalize drag, fire drop.
   * @private
   * @param event
   * @fires drop
   */
  finishContainerDrag(event) {
    const me = this, { context } = me, { dragging, dragProxy, valid, draggedTo, insertBefore, originalPosition } = context;
    if (dragging) {
      context.valid = Boolean(valid && (draggedTo || me.externalDropTargetSelector && event.target.closest(me.externalDropTargetSelector)) && // no drop on self or parent
      (dragging !== insertBefore || originalPosition.parent !== draggedTo));
      context.finalize = (valid2 = context.valid) => {
        if (!valid2 && me.context) {
          me.revertPosition();
        }
        dragging.classList.remove(me.dropPlaceholderCls);
        dragProxy.remove();
        me.reset();
      };
      context.async = false;
      me.trigger("drop", { context, event });
      if (!context.async) {
        context.finalize();
      }
    }
  }
  /**
   * Aborts a drag operation.
   * @private
   * @param {Boolean} [invalid]
   * @param {Object} [event]
   * @param {Boolean} [silent]
   */
  abortContainerDrag(invalid = false, event = null, silent = false) {
    const me = this, { context } = me;
    if (context.dragging) {
      context.dragging.classList.remove(me.dropPlaceholderCls);
      context.dragProxy.remove();
      me.revertPosition();
    }
    if (!silent) {
      me.trigger(invalid ? "drop" : "abort", { context, event });
    }
    me.reset();
  }
  //endregion
  //region Helpers
  /**
   * Updates the drag proxy position.
   * @private
   * @param event
   */
  updateContainerProxy(event) {
    const me = this, { context } = me, proxy = context.dragProxy;
    let newX = event.pageX - context.offsetX, newY = event.pageY - context.offsetY;
    if (typeof me.minX === "number") {
      newX = Math.max(me.minX, newX);
    }
    if (typeof me.maxX === "number") {
      newX = Math.min(me.maxX - proxy.offsetWidth, newX);
    }
    if (typeof me.minY === "number") {
      newY = Math.max(me.minY, newY);
    }
    if (typeof me.maxY === "number") {
      newY = Math.min(me.maxY - proxy.offsetHeight, newY);
    }
    if (me.lockX) {
      DomHelper.setTranslateY(proxy, newY);
    } else if (me.lockY) {
      DomHelper.setTranslateX(proxy, newX);
    } else {
      DomHelper.setTranslateXY(proxy, newX, newY);
    }
    let targetElement;
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      targetElement = event.target;
    }
    context.targetElement = targetElement;
  }
  /**
   * Positions element being dragged in relation to targetElement.
   * @private
   * @param targetElement
   * @param event
   */
  moveNextTo(targetElement, event) {
    const { context } = this, dragElement = context.dragging, parent = targetElement.parentElement;
    if (targetElement !== dragElement) {
      const centerX = Rectangle.from(targetElement).center.x;
      if (this.isRTL && event.pageX > centerX || !this.isRTL && event.pageX < centerX) {
        parent.insertBefore(dragElement, targetElement);
        context.insertBefore = targetElement;
      } else {
        if (targetElement.nextElementSibling) {
          if (targetElement.nextElementSibling !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
            parent.insertBefore(dragElement, targetElement.nextElementSibling);
          } else if (!context.insertBefore && dragElement.parentElement.lastElementChild !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
          }
        } else {
          parent.appendChild(dragElement);
          context.insertBefore = null;
        }
      }
      context.draggedTo = parent;
    }
  }
  /**
   * Moves element being dragged back to its original position.
   * @private
   */
  revertPosition() {
    const { context } = this, { dragging } = context, { parent, next } = context.originalPosition;
    if (next) {
      const isNoop = next.previousSibling === dragging || !next && dragging === parent.lastChild;
      if (!isNoop) {
        parent.insertBefore(dragging, next);
      }
    } else {
      parent.appendChild(dragging);
    }
    context.draggedTo = null;
  }
  //endregion
};

// ../Core/lib/Core/helper/mixin/DragHelperTranslate.js
var noScroll = { pageXOffset: 0, pageYOffset: 0 };
var DragHelperTranslate_default = (Target) => class DragHelperTranslate extends Delayable_default(Target || Base) {
  static get $name() {
    return "DragHelperTranslate";
  }
  static get configurable() {
    return {
      positioning: null,
      // Private config that disables updating elements position, for when data is live updated during drag,
      // leading to element being redrawn
      skipUpdatingElement: null
    };
  }
  //region Init
  /**
   * Initialize translation drag mode.
   * @private
   */
  initTranslateDrag() {
    const me = this;
    if (!me.isElementDraggable && me.targetSelector) {
      me.isElementDraggable = (element) => element.closest(me.targetSelector);
    }
  }
  //endregion
  //region Grab, update, finish
  /**
   * Grab an element which can be moved using translation.
   * @private
   * @param event
   * @returns {Boolean}
   */
  grabTranslateDrag(event) {
    const element = this.getTarget(event);
    if (element) {
      this.context = {
        valid: true,
        element,
        startPageX: event.pageX,
        startPageY: event.pageY,
        startClientX: event.clientX,
        startClientY: event.clientY
      };
      return true;
    }
    return false;
  }
  getTarget(event) {
    return event.target.closest(this.targetSelector);
  }
  getX(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.left, 10);
    } else {
      return DomHelper.getTranslateX(element);
    }
  }
  getY(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.top, 10);
    } else {
      return DomHelper.getTranslateY(element);
    }
  }
  getXY(element) {
    if (this.positioning === "absolute") {
      return [element.offsetLeft, element.offsetTop];
    } else {
      return DomHelper.getTranslateXY(element);
    }
  }
  setXY(element, x, y) {
    if (this.skipUpdatingElement) {
      return;
    }
    if (this.positioning === "absolute") {
      element.style.left = x + "px";
      element.style.top = y + "px";
    } else {
      DomHelper.setTranslateXY(element, x, y);
    }
  }
  /**
   * Start translating, called on first mouse move after dragging
   * @private
   * @param event
   */
  startTranslateDrag(event) {
    const me = this, { context, outerElement, proxySelector } = me, dragWithin = me.dragWithin = me.dragWithin || me.cloneTarget && document.body;
    let element = context.dragProxy || context.element;
    const grabbed = element, grabbedParent = element.parentElement;
    if (me.cloneTarget) {
      const elementToClone = proxySelector ? element.querySelector(proxySelector) : element, { width, height, x: proxyX, y: proxyY } = Rectangle.from(elementToClone, Rectangle.outer(dragWithin));
      element = me.createProxy(element);
      let x = proxyX, y = proxyY;
      if (me.autoSizeClonedTarget) {
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
      }
      element.classList.add(me.dragProxyCls, me.draggingCls);
      element.classList.remove("b-hover", "b-selected", "b-focused");
      dragWithin.appendChild(element);
      if (!me.autoSizeClonedTarget || proxySelector) {
        const proxyRect = element.getBoundingClientRect(), { x: dragWithinX, y: dragWithinY } = dragWithin.getBoundingClientRect(), localX = event.clientX - dragWithinX, localY = event.clientY - dragWithinY + (dragWithin !== document.body ? document.body.getBoundingClientRect().y : 0);
        x = localX - proxyRect.width / 2;
        y = localY - proxyRect.height / 2;
        context.startPageX = event.pageX;
        context.startPageY = event.pageY;
      }
      me.setXY(element, x, y);
      grabbed.classList.add("b-drag-original");
      if (me.hideOriginalElement) {
        grabbed.classList.add("b-hidden");
      }
    }
    element.classList.add(me.draggingCls);
    Object.assign(context, {
      // The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
      element,
      // The original element upon which the mousedown event triggered a drag operation
      grabbed,
      // The parent of the original element where the pointerdown was detected - to be able to restore after an invalid drop
      grabbedParent,
      // The next sibling of the original element where the pointerdown was detected - to be able to restore after an invalid drop
      grabbedNextSibling: element.nextElementSibling,
      // elements position within parent element
      elementStartX: me.getX(element),
      elementStartY: me.getY(element),
      elementX: DomHelper.getOffsetX(element, dragWithin || outerElement),
      elementY: DomHelper.getOffsetY(element, dragWithin || outerElement),
      scrollX: 0,
      scrollY: 0,
      scrollManagerElementContainsDragProxy: !me.cloneTarget || dragWithin === outerElement
    });
    if (dragWithin) {
      context.parentElement = element.parentElement;
      if (dragWithin !== element.parentElement) {
        dragWithin.appendChild(element);
      }
      me.updateTranslateProxy(event);
    }
  }
  // When drag has started, create proxy versions (if applicable) and store original positions of all related elements
  // to be able to animate back to these positions in case of an aborted drag
  onTranslateDragStarted() {
    const me = this, { context } = me;
    let { relatedElements } = context;
    if (me.unifiedProxy) {
      context.element.classList.add("b-drag-main", "b-drag-unified-proxy");
    }
    if ((relatedElements == null ? void 0 : relatedElements.length) > 0) {
      context.relatedElStartPos = [];
      context.relatedElDragFromPos = [];
      const { proxySelector } = me;
      let [elementStartX, elementStartY] = [context.elementStartX, context.elementStartY];
      context.originalRelatedElements = relatedElements;
      relatedElements = context.relatedElements = relatedElements.map((relatedEl, i) => {
        const proxyTemplateElement = proxySelector ? relatedEl.querySelector(proxySelector) : relatedEl, { x, y, width, height } = Rectangle.from(proxyTemplateElement, me.dragWithin), relatedElementToDrag = me.cloneTarget ? me.createProxy(relatedEl) : relatedEl;
        relatedElementToDrag.classList.add(me.draggingCls);
        relatedElementToDrag.classList.remove("b-hover", "b-selected", "b-focused");
        if (me.cloneTarget) {
          me.setXY(relatedElementToDrag, x, y);
          me.dragWithin.appendChild(relatedElementToDrag);
          relatedElementToDrag.classList.add(me.dragProxyCls);
          if (me.autoSizeClonedTarget) {
            relatedElementToDrag.style.width = `${width}px`;
            relatedElementToDrag.style.height = `${height}px`;
          }
          if (me.hideOriginalElement) {
            relatedEl.classList.add("b-hidden");
          }
          relatedEl.classList.add("b-drag-original");
        }
        context.relatedElStartPos[i] = context.relatedElDragFromPos[i] = me.getXY(relatedElementToDrag);
        if (me.unifiedProxy) {
          relatedElementToDrag.classList.add("b-drag-unified-animation", "b-drag-unified-proxy");
          elementStartX += me.unifiedOffset;
          elementStartY += me.unifiedOffset;
          me.setXY(relatedElementToDrag, elementStartX, elementStartY);
          context.relatedElDragFromPos[i] = [elementStartX, elementStartY];
          relatedElementToDrag.style.zIndex = 100 - i;
        }
        return relatedElementToDrag;
      });
      if (me.unifiedProxy && relatedElements && relatedElements.length > 0) {
        EventHelper.onTransitionEnd({
          element: relatedElements[0],
          property: "transform",
          handler() {
            relatedElements.forEach((el) => el.classList.remove("b-drag-unified-animation"));
          },
          thisObj: me,
          once: true
        });
      }
    }
  }
  /**
   * Limit translation to outer bounds and specified constraints
   * @private
   * @param element
   * @param x
   * @param y
   * @returns {{constrainedX: *, constrainedY: *}}
   */
  applyConstraints(element, x, y) {
    const me = this, { constrain, dragWithin } = me, { pageXOffset, pageYOffset } = dragWithin === document.body ? globalThis : noScroll;
    if (dragWithin && constrain) {
      if (x < 0) {
        x = 0;
      }
      if (x + element.offsetWidth > dragWithin.scrollWidth) {
        x = dragWithin.scrollWidth - element.offsetWidth;
      }
      if (y < 0) {
        y = 0;
      }
      if (y + element.offsetHeight > dragWithin.scrollHeight) {
        y = dragWithin.scrollHeight - element.offsetHeight;
      }
    }
    if (typeof me.minX === "number") {
      x = Math.max(me.minX + pageXOffset, x);
    }
    if (typeof me.maxX === "number") {
      x = Math.min(me.maxX + pageXOffset, x);
    }
    if (typeof me.minY === "number") {
      y = Math.max(me.minY + pageYOffset, y);
    }
    if (typeof me.maxY === "number") {
      y = Math.min(me.maxY + pageYOffset, y);
    }
    return { constrainedX: x, constrainedY: y };
  }
  /**
   * Update elements translation on mouse move.
   * @private
   * @param {MouseEvent} event
   * @param {Object} scrollManagerConfig
   */
  updateTranslateProxy(event, scrollManagerConfig) {
    const me = this, { lockX, lockY, context } = me, element = context.dragProxy || context.element, { relatedElements, relatedElDragFromPos } = context;
    if (context.scrollManagerElementContainsDragProxy && scrollManagerConfig) {
      context.scrollX = scrollManagerConfig.getRelativeLeftScroll(element);
      context.scrollY = scrollManagerConfig.getRelativeTopScroll(element);
    }
    context.pageX = event.pageX;
    context.pageY = event.pageY;
    context.clientX = event.clientX;
    context.clientY = event.clientY;
    let newX = context.elementStartX + event.pageX - context.startPageX + context.scrollX, newY = context.elementStartY + event.pageY - context.startPageY + context.scrollY;
    if (me.snapCoordinates) {
      const snapped = me.snapCoordinates({ element, newX, newY });
      newX = snapped.x;
      newY = snapped.y;
    }
    const { constrainedX, constrainedY } = me.applyConstraints(element, newX, newY);
    if (context.started || constrainedX !== newX || constrainedY !== newY) {
      me.setXY(element, lockX ? void 0 : constrainedX, lockY ? void 0 : constrainedY);
    }
    if (relatedElements) {
      const deltaX = lockX ? 0 : constrainedX - context.elementStartX, deltaY = lockY ? 0 : constrainedY - context.elementStartY;
      relatedElements.forEach((r, i) => {
        const [x, y] = relatedElDragFromPos[i];
        me.setXY(r, x + deltaX, y + deltaY);
      });
    }
    context.newX = constrainedX;
    context.newY = constrainedY;
  }
  /**
   * Finalize drag, fire drop.
   * @private
   * @param event
   * @fires drop
   */
  async finishTranslateDrag(event) {
    const me = this, context = me.context, { target } = event, xChanged = !me.lockX && Math.round(context.newX) !== Math.round(context.elementStartX), yChanged = !me.lockY && Math.round(context.newY) !== Math.round(context.elementStartY), element = context.dragProxy || context.element, { relatedElements } = context;
    if (!me.ignoreSamePositionDrop || xChanged || yChanged) {
      if (context.valid === false) {
        await me.abortTranslateDrag(true, event);
      } else {
        const targetRect = !me.allowDropOutside && Rectangle.from(me.dragWithin || me.outerElement);
        if (targetRect && (typeof me.minX !== "number" && me.minX !== true && event.pageX < targetRect.left || typeof me.maxX !== "number" && me.maxX !== true && event.pageX > targetRect.right || typeof me.minY !== "number" && me.minY !== true && event.pageY < targetRect.top || typeof me.maxY !== "number" && me.maxY !== true && event.pageY > targetRect.bottom)) {
          await me.abortTranslateDrag(true, event);
        } else {
          context.finalize = async (valid = context.valid) => {
            if (context.finalized) {
              console.warn("DragHelper: Finalizing already finalized drag");
              return;
            }
            context.finalized = true;
            if (!valid && me.context) {
              await me.abortTranslateDrag(true, null, true);
            }
            if (!me.isDestroyed) {
              me.trigger("dropFinalized", { context, event, target });
              me.reset();
            }
            if (!me.cloneTarget && element.parentElement !== context.grabbedParent) {
              [element, ...relatedElements || []].forEach((el) => el.style.transform = "");
            }
          };
          context.async = false;
          await me.trigger("drop", { context, event, target });
          if (!context.async) {
            await context.finalize();
          }
        }
      }
    } else {
      me.abortTranslateDrag(false, event);
    }
  }
  /**
   * Abort translation
   * @private
   * @param invalid
   * @fires abort
   */
  async abortTranslateDrag(invalid = false, event = null, silent = false) {
    var _a4, _b;
    const me = this, {
      cloneTarget,
      context,
      proxySelector,
      dragWithin,
      draggingCls
    } = me, { relatedElements, relatedElStartPos, grabbed } = context, element = context.dragProxy || context.element;
    context.valid = false;
    (_a4 = me.scrollManager) == null ? void 0 : _a4.stopMonitoring();
    if (context.aborted) {
      console.warn("DragHelper: Aborting already aborted drag");
      return;
    }
    let { elementStartX, elementStartY } = context;
    const proxyMoved = elementStartX !== me.getX(element) || elementStartY !== me.getY(element);
    if (element && context.started) {
      if (!cloneTarget && dragWithin && dragWithin !== context.grabbedParent) {
        context.grabbedParent.insertBefore(element, context.grabbedNextSibling);
      }
      if (cloneTarget) {
        if (proxySelector) {
          const animateTo = grabbed.querySelector(proxySelector) || grabbed, { x, y } = Rectangle.from(animateTo);
          elementStartX = x;
          elementStartY = y;
        }
      }
      element.classList.add("b-aborting");
      me.setXY(element, elementStartX, elementStartY);
      relatedElements == null ? void 0 : relatedElements.forEach((element2, i) => {
        element2.classList.remove(draggingCls);
        element2.classList.add("b-aborting");
        me.setXY(element2, relatedElStartPos[i][0], relatedElStartPos[i][1]);
      });
      if (!silent) {
        me.trigger(invalid ? "drop" : "abort", { context, event });
      }
      if (element.isConnected && !me.isDestroying && proxyMoved) {
        await EventHelper.waitForTransitionEnd({
          element,
          property: DomHelper.getPropertyTransitionDuration(element, "transform") ? "transform" : "all",
          thisObj: me,
          once: true,
          timeout: 300,
          runOnDestroy: true
        });
      }
      if (!me.isDestroyed) {
        me.trigger("abortFinalized", { context, event });
      }
    }
    if ((_b = me.context) == null ? void 0 : _b.started) {
      me.reset();
    }
  }
  // Restore state of all mutated elements
  cleanUp() {
    const me = this, { context, cloneTarget, draggingCls, dragProxyCls } = me, element = context.dragProxy || context.element, { relatedElements, originalRelatedElements, grabbed } = context, removeClonedProxies = cloneTarget && (me.removeProxyAfterDrop || !context.valid), cssClassesToRemove = [draggingCls, "b-aborting", dragProxyCls, "b-drag-main", "b-drag-unified-proxy"];
    element.classList.remove(...cssClassesToRemove);
    if (removeClonedProxies) {
      element.remove();
    }
    relatedElements == null ? void 0 : relatedElements.forEach((element2) => {
      if (removeClonedProxies) {
        element2.remove();
      } else {
        element2.classList.remove(...cssClassesToRemove);
      }
    });
    grabbed.classList.remove("b-drag-original", "b-hidden");
    originalRelatedElements == null ? void 0 : originalRelatedElements.forEach((element2) => element2.classList.remove("b-hidden", "b-drag-original"));
  }
  //endregion
};

// ../Core/lib/Core/helper/DragHelper.js
var rootElementListeners = {
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: "onTouchStart",
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var DragHelper = class extends Base.mixin(Events_default, DragHelperContainer_default, DragHelperTranslate_default) {
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Drag proxy CSS class
       * @config {String}
       * @default
       * @private
       */
      dragProxyCls: "b-drag-proxy",
      /**
       * CSS class added when drag is invalid
       * @config {String}
       * @default
       */
      invalidCls: "b-drag-invalid",
      /**
       * CSS class added to the source element in Container drag
       * @config {String}
       * @default
       * @private
       */
      draggingCls: "b-dragging",
      /**
       * CSS class added to the source element in Container drag
       * @config {String}
       * @default
       * @private
       */
      dropPlaceholderCls: "b-drop-placeholder",
      /**
       * The amount of pixels to move mouse before it counts as a drag operation
       * @config {Number}
       * @default
       */
      dragThreshold: 5,
      /**
       * The outer element where the drag helper will operate (attach events to it and use as outer limit when looking for ancestors)
       * @config {HTMLElement}
       * @default
       */
      outerElement: document.body,
      /**
       * Outer element that limits where element can be dragged
       * @config {HTMLElement}
       */
      dragWithin: null,
      /**
       * Set to true to stack any related dragged elements below the main drag proxy element. Only applicable when
       * using translate {@link #config-mode} with {@link #config-cloneTarget}
       * @config {Boolean}
       */
      unifiedProxy: null,
      monitoringConfig: null,
      /**
       * Constrain translate drag to dragWithin elements bounds (set to false to allow it to "overlap" edges)
       * @config {Boolean}
       * @default
       */
      constrain: true,
      /**
       * Smallest allowed x when dragging horizontally.
       * @config {Number}
       */
      minX: null,
      /**
       * Largest allowed x when dragging horizontally.
       * @config {Number}
       */
      maxX: null,
      /**
       * Smallest allowed y when dragging horizontally.
       * @config {Number}
       */
      minY: null,
      /**
       * Largest allowed y when dragging horizontally.
       * @config {Number}
       */
      maxY: null,
      /**
       * Enabled dragging, specify mode:
       * <table>
       * <tr><td>container<td>Allows reordering elements within one and/or between multiple containers
       * <tr><td>translateXY<td>Allows dragging within a parent container
       * </table>
       * @config {'container'|'translateXY'}
       * @default
       */
      mode: "translateXY",
      /**
       * A function that determines if dragging an element is allowed. Gets called with the element as argument,
       * return `true` to allow dragging or `false` to prevent.
       * @config {Function}
       * @param {HTMLElement} element
       * @returns {Boolean}
       */
      isElementDraggable: null,
      /**
       * A CSS selector used to determine if dragging an element is allowed.
       * @config {String}
       */
      targetSelector: null,
      /**
       * A CSS selector used to determine if a drop is allowed at the current position.
       * @config {String}
       */
      dropTargetSelector: null,
      /**
       * A CSS selector added to each drop target element while dragging.
       * @config {String}
       */
      dropTargetCls: null,
      /**
       * A CSS selector used to target a child element of the mouse down element, to use as the drag proxy element.
       * Applies to translate {@link #config-mode mode} when using {@link #config-cloneTarget}.
       * @config {String}
       */
      proxySelector: null,
      /**
       * Set to `true` to clone the dragged target, and not move the actual target DOM node.
       * @config {Boolean}
       * @default
       */
      cloneTarget: false,
      /**
       * Set to `false` to not apply width/height of cloned drag proxy elements.
       * @config {Boolean}
       * @default
       */
      autoSizeClonedTarget: true,
      /**
       * Set to true to hide the original element while dragging (applicable when `cloneTarget` is true).
       * @config {Boolean}
       * @default
       */
      hideOriginalElement: false,
      /**
       * Containers whose elements can be rearranged (and moved between the containers). Used when
       * mode is set to "container".
       * @config {HTMLElement[]}
       */
      containers: null,
      /**
       * A CSS selector used to exclude elements when using container mode
       * @config {String}
       */
      ignoreSelector: null,
      startEvent: null,
      /**
       * Configure as `true` to disallow dragging in the `X` axis. The dragged element will only move vertically.
       * @config {Boolean}
       * @default
       */
      lockX: false,
      /**
       * Configure as `true` to disallow dragging in the `Y` axis. The dragged element will only move horizontally.
       * @config {Boolean}
       * @default
       */
      lockY: false,
      /**
       * The amount of milliseconds to wait after a touchstart, before a drag gesture will be allowed to start.
       * @config {Number}
       * @default
       */
      touchStartDelay: 300,
      /**
       * Scroll manager of the target. If specified, scrolling while dragging is supported.
       * @config {Core.util.ScrollManager}
       */
      scrollManager: null,
      /**
       * A method provided to snap coordinates to fixed points as you drag
       * @config {Function}
       * @internal
       */
      snapCoordinates: null,
      /**
       * When using {@link #config-unifiedProxy}, use this amount of pixels to offset each extra element when dragging multiple items
       * @config {Number}
       * @default
       */
      unifiedOffset: 5,
      /**
       * Configure as `false` to take ownership of the proxy element after a valid drop (advanced usage).
       * @config {Boolean}
       * @default
       */
      removeProxyAfterDrop: true,
      clickSwallowDuration: 50,
      ignoreSamePositionDrop: true,
      // true to allow drops outside the dragWithin element
      allowDropOutside: null,
      // for container mode
      floatRootOwner: null,
      mouseMoveListenerElement: document,
      externalDropTargetSelector: null,
      testConfig: {
        clickSwallowDuration: 50,
        touchStartDelay: 100
      },
      rtlSource: null,
      /**
       * Creates the proxy element to be dragged, when using {@link #config-cloneTarget}. Clones the original element by default.
       * Provide your custom {@link #function-createProxy} function to be used for creating drag proxy.
       * @param {HTMLElement} element The element from which the drag operation originated
       * @config {Function}
       * @returns {HTMLElement}
       */
      createProxy: null
    };
  }
  //endregion
  //region Events
  /**
   * Fired before dragging starts, return `false` to prevent the drag operation.
   * @preventable
   * @event beforeDragStart
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The original element upon which the mousedown event triggered a drag operation
   * @param {MouseEvent|TouchEvent} event
   */
  /**
   * Fired when dragging starts. The event includes a `context` object. If you want to drag additional elements you can
   * provide these as an array of elements assigned to the `relatedElements` property of the context object.
   * @event dragStart
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements Array of extra elements to include in the drag.
   * @param {MouseEvent|TouchEvent} event
   */
  /**
   * Fired while dragging, you can signal that the drop is valid or invalid by setting `context.valid = false;`
   * @event drag
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements An array of extra elements dragged with the main dragged element
   * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
   * @param {MouseEvent} event
   */
  /**
   * Fired after a drop at an invalid position
   * @event abort
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements An array of extra elements dragged with the main dragged element
   * @param {MouseEvent} event
   */
  /**
   * Fires after {@link #event-abort} and after drag proxy has animated back to its original position
   * @private
   * @event abortFinalized
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {MouseEvent} event
   */
  //endregion
  //region Init
  /**
   * Initializes a new DragHelper.
   * @param {DragHelperConfig} config Configuration object, accepts options specified under Configs above
   *
   * ```javascript
   * new DragHelper({
   *   containers: [div1, div2],
   *   isElementDraggable: element => element.className.contains('handle'),
   *   outerElement: topParent,
   *   listeners: {
   *     drop: onDrop,
   *     thisObj: this
   *   }
   * });
   * ```
   *
   * @function constructor
   */
  construct(config) {
    const me = this;
    super.construct(config);
    me.initListeners();
    if (me.isContainerDrag) {
      me.initContainerDrag();
    } else {
      me.initTranslateDrag();
    }
    me.onScrollManagerScrollCallback = me.onScrollManagerScrollCallback.bind(me);
  }
  doDestroy() {
    this.reset(true);
    super.doDestroy();
  }
  /**
   * Initialize listener
   * @private
   */
  initListeners() {
    const me = this, { outerElement } = me, dragStartListeners = {
      element: outerElement,
      pointerdown: "onPointerDown",
      thisObj: me
    };
    me.mouseMoveListenerElement = me.getMouseMoveListenerTarget(outerElement);
    EventHelper.on(dragStartListeners);
  }
  // Salesforce hook: we override this method to move listener from the body (which is default root node) to element
  // inside of LWC
  getMouseMoveListenerTarget(element) {
    const root = element.getRootNode();
    let result = this.mouseMoveListenerElement;
    if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE && root.mode === "closed") {
      result = element.closest(".b-outer") || result;
    }
    return result;
  }
  get isRTL() {
    var _a4;
    return Boolean((_a4 = this.rtlSource) == null ? void 0 : _a4.rtl);
  }
  //endregion
  //region Events
  /**
   * Fires after drop. For valid drops, it exposes `context.async` which you can set to true to signal that additional
   * processing is needed before finalizing the drop (such as showing some dialog). When that operation is done, call
   * `context.finalize(true/false)` with a boolean that determines the outcome of the drop.
   *
   * You can signal that the drop is valid or invalid by setting `context.valid = false;`
   *
   * For translate type drags with {@link #config-cloneTarget}, you can also set `transitionTo` if you want to animate
   * the dragged proxy to a position before finalizing the operation. See class intro text for example usage.
   *
   * @event drop
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements An array of extra elements dragged with the main dragged element
   * @param {Boolean} context.valid true if the drop position is valid
   */
  /**
   * Fires after {@link #event-drop} and after drag proxy has animated to its final position (if setting `transitionTo`
   * on the drag context object).
   * @private
   * @event dropFinalized
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   */
  onPointerDown(event) {
    const me = this;
    if (
      // Left button or touch allowed
      event.button !== 0 || // If a drag is ongoing already, finalize it and don't proceed with new drag (happens if pointerup happened
      // when current window wasn't focused - tab switch or window switch). Also handles the edge case of trying to
      // start a new drag while previous is awaiting finalization, in which case it just bails out.
      me.context
    ) {
      return;
    }
    if (me.isElementDraggable && !me.isElementDraggable(event.target, event)) {
      return;
    }
    me.startEvent = event;
    const handled = me.isContainerDrag ? me.grabContainerDrag(event) : me.grabTranslateDrag(event);
    if (handled) {
      me.blurDetacher = EventHelper.on({
        element: globalThis,
        blur: me.onWindowBlur,
        thisObj: me
      });
      const dragListeners = {
        element: me.mouseMoveListenerElement,
        thisObj: me,
        capture: true,
        keydown: rootElementListeners.keydown
      };
      if (event.pointerType === "touch") {
        me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
        dragListeners.touchmove = {
          handler: rootElementListeners.touchmove,
          passive: false
          // We need to be able to preventDefault on the touchmove
        };
        dragListeners.touchend = dragListeners.pointerup = rootElementListeners.touchend;
      } else {
        dragListeners.pointermove = rootElementListeners.move;
        dragListeners.pointerup = rootElementListeners.up;
      }
      me.dragListenersDetacher = EventHelper.on(dragListeners);
      if (me.dragWithin && me.dragWithin !== me.outerElement && me.outerElement.contains(me.dragWithin)) {
        const box = Rectangle.from(me.dragWithin, me.outerElement);
        me.minY = box.top;
        me.maxY = box.bottom;
        me.minX = box.left;
        me.maxX = box.right;
      }
    }
  }
  async internalMove(event) {
    var _a4, _b;
    if (event.scrollInitiated) {
      return;
    }
    const me = this, { context } = me, distance = EventHelper.getDistanceBetween(me.startEvent, event), abortTouchDrag = me.touchStartTimer && distance > me.dragThreshold;
    if (abortTouchDrag) {
      me.abort(true);
      return;
    }
    if (!me.touchStartTimer && (context == null ? void 0 : context.element) && (context.started || distance >= me.dragThreshold) && // Ignore text nodes
    ((_a4 = event.target) == null ? void 0 : _a4.nodeType) === Node.ELEMENT_NODE) {
      if (!context.started) {
        if (!context.beforeDragStartFired && me.trigger("beforeDragStart", { context, event }) === false) {
          return me.abort();
        }
        context.beforeDragStartFired = true;
        if (Math.abs(EventHelper.getDistanceBetween(me.startEvent, event, { x: me.lockY, y: me.lockX })) < me.dragThreshold) {
          return;
        }
        if (me.isContainerDrag) {
          me.startContainerDrag(event);
        } else {
          me.startTranslateDrag(event);
        }
        context.started = true;
        (_b = me.scrollManager) == null ? void 0 : _b.startMonitoring(ObjectHelper.merge({
          scrollables: [
            {
              element: me.dragWithin || me.outerElement
            }
          ],
          callback: me.onScrollManagerScrollCallback
        }, me.monitoringConfig));
        context.outermostEl = DomHelper.getOutermostElement(event.target);
        context.outermostEl.classList.add("b-draghelper-active");
        if (me.dropTargetSelector && me.dropTargetCls) {
          DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach(
            (el) => el.classList.add(me.dropTargetCls)
          );
        }
        const result = me.trigger("dragStart", { context, event });
        if (ObjectHelper.isPromise(result)) {
          await result;
        }
        context.moveUnblocked = true;
        if (me.isContainerDrag) {
          me.onContainerDragStarted(event);
        } else {
          me.onTranslateDragStarted(event);
        }
        me.trigger("afterDragStart", { context, event });
      }
      if (context.moveUnblocked) {
        if (me._cachedMouseEvent) {
          me.update(event);
          me.update(me._cachedMouseEvent);
          delete me._cachedMouseEvent;
        } else {
          me.update(event);
        }
      } else {
        me._cachedMouseEvent = event;
      }
      if (event.type === "touchmove") {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    }
  }
  onScrollManagerScrollCallback(config) {
    var _a4;
    const { lastMouseMoveEvent } = this;
    if (((_a4 = this.context) == null ? void 0 : _a4.element) && lastMouseMoveEvent) {
      lastMouseMoveEvent.isScroll = true;
      this.update(lastMouseMoveEvent, config);
    }
  }
  onTouchMove(event) {
    this.internalMove(event);
  }
  /**
   * Move drag element with mouse.
   * @param event
   * @fires beforeDragStart
   * @fires dragStart
   * @private
   */
  onMouseMove(event) {
    this.internalMove(event);
  }
  /**
   * Updates drag, called when an element is grabbed and mouse moves
   * @private
   * @fires drag
   */
  update(event, scrollManagerConfig) {
    const me = this, { context } = me, scrollingPageElement = document.scrollingElement || document.body;
    let target = me.getMouseMoveEventTarget(event);
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      target = DomHelper.elementFromPoint(touch.clientX + scrollingPageElement.scrollLeft, touch.clientY + scrollingPageElement.scrollTop);
    }
    context.target = target;
    let internallyValid = me.allowDropOutside || !me.dragWithin || me.dragWithin.contains(event.target);
    if (internallyValid && me.dropTargetSelector) {
      internallyValid = internallyValid && Boolean(target == null ? void 0 : target.closest(me.dropTargetSelector));
    }
    if (me.isContainerDrag) {
      me.updateContainerProxy(event, scrollManagerConfig);
    } else {
      me.updateTranslateProxy(event, scrollManagerConfig);
    }
    context.valid = internallyValid;
    me.trigger("drag", { context, event });
    if (me.isContainerDrag) {
      me.updateContainerDrag(event, scrollManagerConfig);
    }
    context.valid = context.valid && internallyValid;
    for (const element of me.draggedElements) {
      element.classList.toggle(me.invalidCls, !context.valid);
    }
    if (event) {
      me.lastMouseMoveEvent = event;
    }
  }
  get draggedElements() {
    var _a4;
    const { context } = this;
    return [context.dragProxy || context.element, ...(_a4 = context.relatedElements) != null ? _a4 : []];
  }
  /**
   * Abort dragging
   * @fires abort
   */
  async abort(silent = false) {
    var _a4, _b;
    const me = this, { context } = me;
    (_b = (_a4 = me.scrollManager) == null ? void 0 : _a4.stopMonitoring) == null ? void 0 : _b.call(_a4);
    me.removeListeners();
    if ((context == null ? void 0 : context.started) && !context.aborted) {
      context.element.getBoundingClientRect();
      context.valid = false;
      if (me.isContainerDrag) {
        me.abortContainerDrag(void 0, void 0, silent);
      } else {
        me.abortTranslateDrag(void 0, void 0, silent);
      }
      context.aborted = true;
    } else {
      me.reset(true);
    }
  }
  // Empty class implementation. If listeners *are* added, the detacher is added
  // as an instance property. So this is always callable.
  removeListeners() {
    var _a4, _b;
    (_a4 = this.dragListenersDetacher) == null ? void 0 : _a4.call(this);
    (_b = this.blurDetacher) == null ? void 0 : _b.call(this);
  }
  // Called when a drag operation is completed, or aborted
  // Removes DOM listeners and resets context
  reset(silent) {
    const me = this, { context } = me;
    if (context == null ? void 0 : context.started) {
      for (const element of me.draggedElements) {
        element.classList.remove(me.invalidCls);
      }
      context.outermostEl.classList.remove("b-draghelper-active");
      if (me.isContainerDrag) {
        context.dragProxy.remove();
      } else {
        me.cleanUp();
      }
      if (me.dropTargetSelector && me.dropTargetCls) {
        DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach(
          (el) => el.classList.remove(me.dropTargetCls)
        );
      }
    }
    me.removeListeners();
    if (!silent) {
      me.trigger("reset");
    }
    me.context = me.lastMouseMoveEvent = null;
  }
  onTouchEnd(event) {
    this.onMouseUp(event);
  }
  /**
   * This is a capture listener, only added during drag, which prevents a click gesture
   * propagating from the terminating mouseup gesture
   * @param {MouseEvent} event
   * @private
   */
  onDocumentClick(event) {
    event.stopPropagation();
  }
  /**
   * Drop on mouse up (if dropped on valid target).
   * @param event
   * @private
   */
  onMouseUp(event) {
    var _a4;
    const me = this, { context } = me;
    me.removeListeners();
    if (context) {
      (_a4 = me.scrollManager) == null ? void 0 : _a4.stopMonitoring();
      if (context.started) {
        if (context.moveUnblocked) {
          event.stopPropagation();
          context.finalizing = true;
          if (me.isContainerDrag) {
            me.finishContainerDrag(event);
          } else {
            me.finishTranslateDrag(event);
          }
          EventHelper.on({
            element: document,
            thisObj: me,
            click: rootElementListeners.docclick,
            capture: true,
            expires: me.clickSwallowDuration,
            // In case a click did not ensue, remove the listener
            once: true
          });
        } else {
          me.ion({
            drag() {
              me.onMouseUp(event);
            },
            once: true
          });
        }
      } else {
        me.reset(true);
      }
    }
  }
  /**
   * Cancel on ESC key
   * @param event
   * @private
   */
  onKeyDown(event) {
    var _a4;
    if (((_a4 = this.context) == null ? void 0 : _a4.started) && event.key === "Escape") {
      event.stopImmediatePropagation();
      this.abort();
    }
  }
  onWindowBlur() {
    if (this.context && !this.context.finalizing) {
      this.abort();
    }
  }
  /**
   * Creates the proxy element to be dragged, when using {@link #config-cloneTarget}. Clones the original element by default.
   * Override it to provide your own custom HTML element structure to be used as the drag proxy.
   * @param {HTMLElement} element The element from which the drag operation originated
   * @returns {HTMLElement}
   */
  createProxy(element) {
    if (this.proxySelector) {
      element = element.querySelector(this.proxySelector) || element;
    }
    const proxy = element.cloneNode(true);
    proxy.removeAttribute("id");
    return proxy;
  }
  //endregion
  get isContainerDrag() {
    return this.mode === "container";
  }
  /**
   * Animated the proxy element to be aligned with the passed element. Returns a Promise which resolves after the
   * DOM transition completes. Only applies to 'translateXY' mode.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The target element or a Rectangle
   * @param {AlignSpec} [alignSpec] An object describing how to the align drag proxy to the target element
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   */
  async animateProxyTo(targetElement, alignSpec = { align: "c-c" }) {
    const { context, draggedElements } = this, { element } = context, targetRect = targetElement.isRectangle ? targetElement : Rectangle.from(targetElement);
    draggedElements.forEach((el) => {
      el.classList.add("b-drag-final-transition");
      DomHelper.alignTo(el, targetRect, alignSpec);
    });
    await EventHelper.waitForTransitionEnd({
      element,
      property: "all",
      thisObj: this,
      once: true
    });
    draggedElements.forEach((el) => el.classList.remove("b-drag-final-transition"));
  }
  /**
   * Returns true if a drag operation is active
   * @property {Boolean}
   * @readonly
   */
  get isDragging() {
    var _a4;
    return Boolean((_a4 = this.context) == null ? void 0 : _a4.started);
  }
  //#region Salesforce hooks
  getMouseMoveEventTarget(event) {
    return !event.isScroll ? event.target : DomHelper.elementFromPoint(event.clientX, event.clientY);
  }
  //#endregion
};
DragHelper._$name = "DragHelper";

// ../Core/lib/Core/helper/ResizeHelper.js
var documentListeners = {
  down: "onMouseDown",
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: {
    handler: "onTouchStart",
    // We preventDefault touchstart so as not to scroll. Must not be passive.
    // https://developers.google.com/web/updates/2017/01/scrolling-intervention
    passive: false
  },
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var ResizeHelper = class extends Events_default(Base) {
  //region Config
  static get defaultConfig() {
    return {
      /**
       * CSS class added when resizing
       * @config {String}
       * @default
       */
      resizingCls: "b-resizing",
      /**
       * The amount of pixels to move mouse before it counts as a drag operation
       * @config {Number}
       * @default
       */
      dragThreshold: 5,
      /**
       * Resizing handle size
       * @config {Number}
       * @default
       */
      handleSize: 10,
      /**
       * Automatically shrink virtual handles when available space < handleSize. The virtual handles will
       * decrease towards width/height 1, reserving space between opposite handles to for example leave room for
       * dragging. To configure reserved space, see {@link #config-reservedSpace}.
       * @config {Boolean}
       * @default false
       */
      dynamicHandleSize: null,
      //
      /**
       * Room in px to leave unoccupied by handles when shrinking them dynamically (see
       * {@link #config-dynamicHandleSize}).
       * @config {Number}
       * @default
       */
      reservedSpace: 10,
      /**
       * Resizing handle size on touch devices
       * @config {Number}
       * @default
       */
      touchHandleSize: 30,
      /**
       * Minimum width when resizing
       * @config {Number}
       * @default
       */
      minWidth: 1,
      /**
       * Max width when resizing.
       * @config {Number}
       * @default
       */
      maxWidth: 0,
      /**
       * Minimum height when resizing
       * @config {Number}
       * @default
       */
      minHeight: 1,
      /**
       * Max height when resizing
       * @config {Number}
       * @default
       */
      maxHeight: 0,
      // outerElement, attach events to it and use as outer limit when looking for ancestors
      outerElement: document.body,
      /**
       * Optional scroller used to read scroll position. If unspecified, the outer element will be used.
       * @config {Core.helper.util.Scroller}
       */
      scroller: null,
      /**
       * Assign a function to determine if a hovered element can be resized or not.
       * Return `true` to allow resizing or `false` to prevent.
       * @config {Function}
       * @param {HTMLElement} element
       * @returns {Boolean}
       * @default
       */
      allowResize: null,
      /**
       * Outer element that limits where element can be dragged
       * @config {HTMLElement}
       * @default
       */
      dragWithin: null,
      /**
       * A function that determines if dragging an element is allowed. Gets called with the element as argument,
       * return `true` to allow dragging or `false` to prevent.
       * @config {Function}
       * @param {HTMLElement} element
       * @returns {Boolean}
       * @default
       */
      isElementResizable: null,
      /**
       * A CSS selector used to determine if resizing an element is allowed.
       * @config {String}
       * @default
       */
      targetSelector: null,
      /**
       * Use left handle when resizing. Only applies when `direction` is 'horizontal'
       * @config {Boolean}
       * @default
       */
      leftHandle: true,
      /**
       * Use right handle when resizing. Only applies when `direction` is 'horizontal'
       * @config {Boolean}
       * @default
       */
      rightHandle: true,
      /**
       * Use top handle when resizing. Only applies when `direction` is 'vertical'
       * @config {Boolean}
       * @default
       */
      topHandle: true,
      /**
       * Use bottom handle when resizing. Only applies when `direction` is 'vertical'
       * @config {Boolean}
       * @default
       */
      bottomHandle: true,
      /**
       * A CSS selector used to determine where handles should be "displayed" when resizing. Defaults to
       * targetSelector if unspecified
       * @config {String}
       */
      handleSelector: null,
      /**
       * A CSS selector used to determine which inner element contains handles.
       * @config {String}
       */
      handleContainerSelector: null,
      startEvent: null,
      /*
       * Optional config object, used by EventResize feature: it appends proxy and has to start resizing immediately
       * @config {Object}
       * @private
       */
      grab: null,
      /**
       * CSS class added when the resize state is invalid
       * @config {String}
       * @default
       */
      invalidCls: "b-resize-invalid",
      // A number that controls whether or not the element is wide enough for it to make sense to show resize handles
      // e.g. handle width is 10px, so doesn't make sense to show them unless handles on both sides fit
      handleVisibilityThreshold: null,
      // Private config that disables translation when resizing left edge. Useful for example in cases when element
      // being resized is part of a flex layout
      skipTranslate: false,
      /**
       * Direction to resize in, either 'horizontal' or 'vertical'
       * @config {'horizontal'|'vertical'}
       * @default
       */
      direction: "horizontal",
      clickSwallowDuration: 50,
      constrainToParent: true,
      rtlSource: null
    };
  }
  //endregion
  //region Events
  /**
   * Fired while dragging
   * @event resizing
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Resize context
   * @param {MouseEvent} event Browser event
   */
  /**
   * Fired when dragging starts.
   * @event resizeStart
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Resize context
   * @param {MouseEvent|TouchEvent} event Browser event
   */
  /**
   * Fires after resize, and allows for asynchronous finalization by setting 'async' to `true` on the context object.
   * @event resize
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Context about the resize operation. Set 'async' to `true` to indicate asynchronous
   * validation of the resize flow (for showing a confirmation dialog etc)
   */
  /**
   * Fires when a resize is canceled (width & height are reverted)
   * @event cancel
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Resize context
   * @param {MouseEvent|TouchEvent} event Browser event
   */
  //endregion
  //region Init
  construct(config) {
    const me = this;
    super.construct(config);
    if (!me.handleSelector && !BrowserHelper.isHoverableDevice) {
      me.handleSize = me.touchHandleSize;
    }
    me.handleVisibilityThreshold = me.handleVisibilityThreshold || 2 * me.handleSize;
    me.initListeners();
    me.initResize();
  }
  doDestroy() {
    this.abort(true);
    super.doDestroy();
  }
  updateSkipUpdatingElement(skip) {
    if (skip) {
      this.skipTranslate = true;
    }
  }
  /**
   * Initializes resizing
   * @private
   */
  initResize() {
    const me = this;
    if (!me.isElementResizable && me.targetSelector) {
      me.isElementResizable = (element) => element.closest(me.targetSelector);
    }
    if (me.grab) {
      const { edge, element, event } = me.grab;
      me.startEvent = event;
      const cursorOffset = me.getCursorOffsetToElementEdge(event, element, edge);
      me.context = {
        element,
        edge,
        valid: true,
        async: false,
        elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
        // extract x from translate
        elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
        // extract x from translate
        newX: DomHelper.getTranslateX(element) || element.offsetLeft,
        // No change yet on start, but info must be present
        newY: DomHelper.getTranslateY(element) || element.offsetTop,
        // No change yet on start, but info must be present
        elementWidth: element.offsetWidth,
        elementHeight: element.offsetHeight,
        cursorOffset,
        startX: event.clientX + cursorOffset.x + me.scrollLeft,
        startY: event.clientY + cursorOffset.y + me.scrollTop,
        finalize: () => {
          var _a4;
          return (_a4 = me.reset) == null ? void 0 : _a4.call(me);
        }
      };
      element.classList.add(me.resizingCls);
      me.internalStartResize(me.isTouch);
    }
  }
  /**
   * Initialize listeners
   * @private
   */
  initListeners() {
    const me = this, dragStartListeners = {
      element: me.outerElement,
      mousedown: documentListeners.down,
      touchstart: documentListeners.touchstart,
      thisObj: me
    };
    if (!me.handleSelector && BrowserHelper.isHoverableDevice) {
      dragStartListeners.mousemove = {
        handler: documentListeners.move,
        // Filter events for checkResizeHandles so we only get called if the mouse
        // is over one of our targets.
        delegate: me.targetSelector
      };
      dragStartListeners.mouseleave = {
        handler: "onMouseLeaveTarget",
        delegate: me.targetSelector,
        capture: true
      };
    }
    EventHelper.on(dragStartListeners);
  }
  get isRTL() {
    var _a4;
    return Boolean((_a4 = this.rtlSource) == null ? void 0 : _a4.rtl);
  }
  //endregion
  //region Scroll helpers
  get scrollLeft() {
    if (this.scroller) {
      return this.scroller.x;
    }
    return this.outerElement.scrollLeft;
  }
  get scrollTop() {
    if (this.scroller) {
      return this.scroller.y;
    }
    return this.outerElement.scrollTop;
  }
  //endregion
  //region Events
  internalStartResize(isTouch) {
    var _a4;
    const dragListeners = {
      element: document,
      keydown: documentListeners.keydown,
      thisObj: this
    };
    if (isTouch) {
      dragListeners.touchmove = documentListeners.touchmove;
      dragListeners.touchend = dragListeners.pointerup = documentListeners.touchend;
    } else {
      dragListeners.mousemove = documentListeners.move;
      dragListeners.mouseup = documentListeners.up;
    }
    this.removeDragListeners = EventHelper.on(dragListeners);
    (_a4 = this.onResizeHandlePointerDown) == null ? void 0 : _a4.call(this, this.startEvent);
  }
  // Empty class implementation. If listeners *are* added, the detacher is added
  // as an instance property. So this is always callable.
  removeDragListeners() {
  }
  reset() {
    var _a4;
    (_a4 = this.removeDragListeners) == null ? void 0 : _a4.call(this);
    this.context = null;
    this.trigger("reset");
  }
  canResize(element, event) {
    return !this.isElementResizable || this.isElementResizable(element, event);
  }
  onPointerDown(isTouch, event) {
    const me = this;
    me.startEvent = event;
    if (me.canResize(event.target, event) && me.grabResizeHandle(isTouch, event)) {
      event.stopImmediatePropagation();
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      me.internalStartResize(isTouch);
    }
  }
  onTouchStart(event) {
    if (event.touches.length > 1) {
      return;
    }
    this.onPointerDown(true, event);
  }
  /**
   * Grab draggable element on mouse down.
   * @private
   * @param {MouseEvent|PointerEvent} event
   */
  onMouseDown(event) {
    if (event.button !== 0) {
      return;
    }
    this.onPointerDown(false, event);
  }
  internalMove(isTouch, event) {
    var _a4;
    const me = this, { context, direction } = me;
    if ((context == null ? void 0 : context.element) && (context.started || EventHelper.getDistanceBetween(me.startEvent, event) >= me.dragThreshold)) {
      if (!context.started) {
        (_a4 = me.scrollManager) == null ? void 0 : _a4.startMonitoring(ObjectHelper.merge({
          scrollables: [
            {
              element: me.dragWithin || me.outerElement,
              direction
            }
          ],
          callback: (config) => {
            var _a5;
            return ((_a5 = me.context) == null ? void 0 : _a5.element) && me.lastMouseMoveEvent && me.update(me.lastMouseMoveEvent, config);
          }
        }, me.monitoringConfig));
        me.trigger("resizeStart", { context, event });
        context.started = true;
      }
      me.update(event);
    } else if (!isTouch && !me.handleSelector) {
      me.checkResizeHandles(event);
    }
  }
  onTouchMove(event) {
    this.internalMove(true, event);
  }
  /**
   * Move grabbed element with mouse.
   * @param {MouseEvent|PointerEvent} event
   * @fires resizestart
   * @private
   */
  onMouseMove(event) {
    this.internalMove(false, event);
  }
  onPointerUp(isTouch, event) {
    var _a4, _b, _c;
    const me = this, context = me.context;
    (_a4 = me.removeDragListeners) == null ? void 0 : _a4.call(me);
    if (context) {
      (_b = me.scrollManager) == null ? void 0 : _b.stopMonitoring();
      if (context.started) {
        EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners.docclick,
          expires: me.clickSwallowDuration,
          // In case a click did not ensue, remove the listener
          capture: true,
          once: true
        });
      }
      me.finishResize(event);
    } else {
      (_c = me.reset) == null ? void 0 : _c.call(me);
    }
  }
  onTouchEnd(event) {
    this.onPointerUp(true, event);
  }
  /**
   * Drop on mouse up (if dropped on valid target).
   * @param {MouseEvent|PointerEvent} event
   * @private
   */
  onMouseUp(event) {
    this.onPointerUp(false, event);
  }
  /**
   * This is a capture listener, only added during drag, which prevents a click gesture
   * propagating from the terminating mouseup gesture
   * @param {MouseEvent} event
   * @private
   */
  onDocumentClick(event) {
    event.stopPropagation();
  }
  /**
   * Cancel on ESC key
   * @param {KeyboardEvent} event
   * @private
   */
  onKeyDown(event) {
    if (event.key === "Escape") {
      this.abort();
    }
  }
  //endregion
  //region Grab, update, finish
  /**
   * Updates resize, called when an element is grabbed and mouse moves
   * @private
   * @fires resizing
   */
  update(event) {
    const me = this, { context, constrainToParent } = me, { element } = context;
    if (constrainToParent) {
      const parentRectangle = Rectangle.from(me.outerElement);
      context.currentX = Math.max(Math.min(event.clientX + context.cursorOffset.x, parentRectangle.right), parentRectangle.x) + me.scrollLeft;
      context.currentY = Math.max(Math.min(event.clientY + context.cursorOffset.y, parentRectangle.bottom), parentRectangle.y) + me.scrollTop;
    } else {
      context.currentX = event.clientX + context.cursorOffset.x + me.scrollLeft;
      context.currentY = event.clientY + context.cursorOffset.y + me.scrollTop;
    }
    element.classList.add(me.resizingCls);
    if (me.updateResize(event)) {
      me.trigger("resizing", { context, event });
      element.classList.toggle(me.invalidCls, context.valid === false);
    }
    me.lastMouseMoveEvent = event;
  }
  /**
   * Abort dragging
   */
  abort(silent = false) {
    var _a4, _b;
    const me = this;
    (_b = (_a4 = me.scrollManager) == null ? void 0 : _a4.stopMonitoring) == null ? void 0 : _b.call(_a4);
    if (me.context) {
      me.abortResize(null, silent);
    } else if (!me.isDestroyed) {
      me.reset();
    }
  }
  /**
   * Starts resizing, updates ResizeHelper#context with relevant info.
   * @private
   * @param {Boolean} isTouch
   * @param {MouseEvent} event
   * @returns {Boolean} True if handled, false if not
   */
  grabResizeHandle(isTouch, event) {
    var _a4;
    const me = this;
    if (me.allowResize && !me.allowResize(event.target, event)) {
      return false;
    }
    const handleSelector = me.handleSelector, coordsFrom = event.type === "touchstart" ? event.changedTouches[0] : event, clientX = coordsFrom.clientX, clientY = coordsFrom.clientY;
    let element = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (element) {
      let edge;
      if (handleSelector) {
        if (event.target.matches(handleSelector)) {
          if (me.direction === "horizontal") {
            if (event.pageX < DomHelper.getPageX(element) + element.offsetWidth / 2) {
              edge = me.isRTL ? "right" : "left";
            } else {
              edge = me.isRTL ? "left" : "right";
            }
          } else {
            if (event.pageY < DomHelper.getPageY(element) + element.offsetHeight / 2) {
              edge = "top";
            } else {
              edge = "bottom";
            }
          }
        } else {
          return false;
        }
      } else {
        if (me.direction === "horizontal") {
          if (me.overLeftHandle(event, element)) {
            edge = me.isRTL ? "right" : "left";
          } else if (me.overRightHandle(event, element)) {
            edge = me.isRTL ? "left" : "right";
          }
        } else {
          if (me.overTopHandle(event, element)) {
            edge = "top";
          } else if (me.overBottomHandle(event, element)) {
            edge = "bottom";
          }
        }
        if (!edge) {
          me.context = null;
          return false;
        }
      }
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      const cursorOffset = me.getCursorOffsetToElementEdge(coordsFrom, element, edge), mutatedContext = (_a4 = me.internalBeforeStart) == null ? void 0 : _a4.call(me, { element, edge });
      if (mutatedContext) {
        element = mutatedContext.element;
        edge = mutatedContext.edge;
      }
      if (me.trigger("beforeResizeStart", { element, event }) !== false) {
        me.context = {
          element,
          edge,
          isTouch,
          valid: true,
          async: false,
          direction: me.direction,
          elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
          // extract x from translate
          elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
          // extract y from translate
          newX: DomHelper.getTranslateX(element) || element.offsetLeft,
          // No change yet on start, but info must be present
          newY: DomHelper.getTranslateY(element) || element.offsetTop,
          // No change yet on start, but info must be present
          elementWidth: element.offsetWidth,
          elementHeight: element.offsetHeight,
          cursorOffset,
          startX: clientX + cursorOffset.x + me.scrollLeft,
          startY: clientY + cursorOffset.y + me.scrollTop,
          finalize: () => {
            var _a5;
            return (_a5 = me.reset) == null ? void 0 : _a5.call(me);
          }
        };
        element.classList.add(me.resizingCls);
        return true;
      }
    }
    return false;
  }
  getCursorOffsetToElementEdge(event, element, edge) {
    const rectEl = Rectangle.from(element);
    let x = 0, y = 0;
    switch (edge) {
      case "left":
        x = rectEl.x - (this.isRTL ? rectEl.width : 0) - event.clientX;
        break;
      case "right":
        x = rectEl.x + (this.isRTL ? 0 : rectEl.width) - event.clientX;
        break;
      case "top":
        y = rectEl.y - event.clientY;
        break;
      case "bottom":
        y = rectEl.y + rectEl.height - event.clientY;
        break;
    }
    return { x, y };
  }
  /**
   * Check if mouse is over a resize handle (virtual). If so, highlight.
   * @private
   * @param {MouseEvent} event
   */
  checkResizeHandles(event) {
    const me = this, target = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (target && (!me.allowResize || me.allowResize(event.target, event))) {
      me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
      if (me.currentElement) {
        let over;
        if (me.direction === "horizontal") {
          over = me.overLeftHandle(event, target) || me.overRightHandle(event, target);
        } else {
          over = me.overTopHandle(event, target) || me.overBottomHandle(event, target);
        }
        if (over) {
          me.highlightHandle();
        } else {
          me.unHighlightHandle();
        }
      }
    } else if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  onMouseLeaveTarget(event) {
    const me = this;
    me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
    if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  /**
   * Updates size of target (on mouse move).
   * @private
   * @param {MouseEvent|PointerEvent} event
   */
  updateResize(event) {
    const me = this, {
      context,
      allowEdgeSwitch,
      skipTranslate,
      skipUpdatingElement
    } = me;
    let updated;
    if (allowEdgeSwitch) {
      if (me.direction === "horizontal") {
        context.edge = context.currentX > context.startX ? "right" : "left";
      } else {
        context.edge = context.currentY > context.startY ? "bottom" : "top";
      }
    }
    const {
      element,
      elementStartX,
      elementStartY,
      elementWidth,
      elementHeight,
      edge
    } = context, { style } = element, deltaX = context.currentX - context.startX, deltaY = context.currentY - context.startY, minWidth = DomHelper.getExtremalSizePX(element, "minWidth") || me.minWidth, maxWidth = DomHelper.getExtremalSizePX(element, "maxWidth") || me.maxWidth, minHeight = DomHelper.getExtremalSizePX(element, "minHeight") || me.minHeight, maxHeight = DomHelper.getExtremalSizePX(element, "maxHeight") || me.maxHeight, sign = edge === "right" && !me.isRTL || edge === "bottom" ? 1 : -1, newWidth = elementWidth + deltaX * sign, newHeight = elementHeight + deltaY * sign;
    let width = Math.max(minWidth, newWidth), height = Math.max(minHeight, newHeight);
    if (maxWidth > 0) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight > 0) {
      height = Math.min(height, maxHeight);
    }
    if (me.direction === "horizontal" && elementWidth !== width) {
      if (!skipUpdatingElement) {
        style.flex = "";
        style.width = Math.abs(width) + "px";
      }
      context.newWidth = width;
      if (edge === "left" || width < 0) {
        const newX = Math.max(Math.min(elementStartX + elementWidth - me.minWidth, elementStartX + deltaX), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateX(element, Math.round(newX));
        }
        context.newX = newX;
      } else if (edge === "right" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateX(element, elementStartX);
      }
      updated = true;
    } else if (me.direction === "vertical" && elementHeight !== newHeight) {
      if (!skipUpdatingElement) {
        style.flex = "";
        style.height = Math.abs(height) + "px";
      }
      context.newHeight = height;
      if (edge === "top" || height < 0) {
        context.newY = Math.max(Math.min(elementStartY + elementHeight - me.minHeight, elementStartY + deltaY), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateY(element, context.newY);
        }
      } else if (edge === "bottom" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateY(element, elementStartY);
      }
      updated = true;
    }
    return updated;
  }
  /**
   * Finalizes resize, fires drop.
   * @private
   * @param {MouseEvent|PointerEvent} event
   * @fires resize
   * @fires cancel
   */
  finishResize(event) {
    var _a4;
    const me = this, context = me.context, eventObject = { context, event };
    context.element.classList.remove(me.resizingCls);
    if (context.started) {
      let changed = false;
      if (me.direction === "horizontal") {
        changed = context.newWidth && context.newWidth !== context.elementWidth;
      } else {
        changed = context.newHeight && context.newHeight !== context.elementHeight;
      }
      me.trigger(changed ? "resize" : "cancel", eventObject);
      if (!context.async) {
        context.finalize();
      }
    } else {
      (_a4 = me.reset) == null ? void 0 : _a4.call(me);
    }
  }
  /**
   * Abort resizing
   * @private
   * @fires cancel
   */
  abortResize(event = null, silent = false) {
    const me = this, context = me.context;
    context.element.classList.remove(me.resizingCls);
    if (me.direction === "horizontal") {
      if (context.edge === "left" || context.allowEdgeSwitch && !context.skipTranslate) {
        DomHelper.setTranslateX(context.element, context.elementStartX);
      }
      context.element.style.width = context.elementWidth + "px";
    } else {
      DomHelper.setTranslateY(context.element, context.elementStartY);
      context.element.style.height = context.elementHeight + "px";
    }
    !silent && me.trigger("cancel", { context, event });
    if (!me.isDestroyed) {
      me.reset();
    }
  }
  //endregion
  //region Handles
  /**
   * Highlights handles (applies css that changes cursor).
   * @private
   */
  highlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    me.currentElement.classList.add("b-resize-handle");
    target.classList.add("b-over-resize-handle");
  }
  /**
   * Unhighlight handles (removes css).
   * @private
   */
  unHighlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    target && target.classList.remove("b-over-resize-handle");
    me.currentElement.classList.remove("b-resize-handle");
    me.currentElement = null;
  }
  overAnyHandle(event, target) {
    return this.overStartHandle(event, target) || this.overEndHandle(event, target);
  }
  overStartHandle(event, target) {
    return this.direction === "horizontal" ? this.overLeftHandle(event, target) : this.overTopHandle(event, target);
  }
  overEndHandle(event, target) {
    return this.direction === "horizontal" ? this.overRightHandle(event, target) : this.overBottomHandle(event, target);
  }
  getDynamicHandleSize(opposite, offsetWidth) {
    const handleCount = opposite ? 2 : 1, { handleSize } = this;
    if (this.dynamicHandleSize && handleSize * handleCount > offsetWidth - this.reservedSpace) {
      return Math.max(Math.floor((offsetWidth - this.reservedSpace) / handleCount), 0);
    }
    return handleSize;
  }
  /**
   * Check if over left handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
   */
  overLeftHandle(event, target) {
    const me = this, { offsetWidth } = target;
    if (me.leftHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const leftHandle = Rectangle.from(target);
      leftHandle.width = me.getDynamicHandleSize(me.rightHandle, offsetWidth);
      return leftHandle.width > 0 && leftHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  /**
   * Check if over right handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
   */
  overRightHandle(event, target) {
    const me = this, { offsetWidth } = target;
    if (me.rightHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const rightHandle = Rectangle.from(target);
      rightHandle.x = rightHandle.right - me.getDynamicHandleSize(me.leftHandle, offsetWidth);
      return rightHandle.width > 0 && rightHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  /**
   * Check if over top handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over top handle, otherwise false
   */
  overTopHandle(event, target) {
    const me = this, { offsetHeight } = target;
    if (me.topHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const topHandle = Rectangle.from(target);
      topHandle.height = me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return topHandle.height > 0 && topHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  /**
   * Check if over bottom handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over bottom handle, otherwise false
   */
  overBottomHandle(event, target) {
    const me = this, { offsetHeight } = target;
    if (me.bottomHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const bottomHandle = Rectangle.from(target);
      bottomHandle.y = bottomHandle.bottom - me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return bottomHandle.height > 0 && bottomHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  //endregion
};
__publicField(ResizeHelper, "configurable", {
  // Private config that disables updating elements width and position, for when data is live updated during
  // resize, leading to element being redrawn
  skipUpdatingElement: null
});
ResizeHelper._$name = "ResizeHelper";

// ../Core/lib/Core/helper/TemplateHelper.js
var tagSpaceRe = />[ \t\r\n]+</g;
var multiSpaceRe = /\s\s+/g;
var TemplateHelper = class _TemplateHelper {
  /**
   * Tag function for template literals that does some basic cleanup
   * @private
   */
  static tpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").replace(multiSpaceRe, " ").trim();
  }
  /**
   * Tag function for template literals that does some basic cleanup. Version for docs that do not remove blank space,
   * to keep code snippets formatting intact.
   * @private
   */
  static docsTpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").trim();
  }
  static repeat(times) {
    return function(...args) {
      return _TemplateHelper.tpl(...args).repeat(times);
    };
  }
  static loop(times) {
  }
};
TemplateHelper._$name = "TemplateHelper";

// ../Core/lib/Core/helper/TimeZoneHelper.js
var TimeZoneOffsetInfo = class extends Array {
  constructor(timeZone, year) {
    super();
    this.timeZone = timeZone;
    this.year = year;
  }
};
var TimeZoneDate = class {
  constructor(asString, timeZone) {
    this.asString = asString;
    this.timeZone = timeZone;
    this.asArray = parseStringDate(asString);
  }
  // Lazy, used in TZH.toTimeZone
  get asLocalDate() {
    if (!this._asLocalDate) {
      this._asLocalDate = new Date(...this.asArray);
    }
    return this._asLocalDate;
  }
  // Lazy, used when finding offsets
  get asTicksUtc() {
    if (!this._asTicksUtc) {
      this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();
    }
    return this._asTicksUtc;
  }
};
var toTimeZoneInternal = (date, timeZone) => {
  const tzDateString = date.toLocaleString("sv-SE", { timeZone });
  return new TimeZoneDate(tzDateString, timeZone);
};
var getOffsetUtc = (ticks, timeZone) => {
  const { asTicksUtc, asString } = toTimeZoneInternal(new Date(ticks), timeZone);
  return { offset: (ticks - asTicksUtc) / 6e4, tzTicksUtc: asTicksUtc, tzString: asString };
};
var parseStringDate = (stringDate) => {
  const parsed = stringDate.split(/[\s-:]/).map((i) => i * 1);
  parsed[1] -= 1;
  return parsed;
};
var min = -6e4;
var hour = 36e5;
var day = -864e5;
var month = 2592e6;
var findOffsetDates = (timeZone, year) => {
  const cached = offsetDateCache.get(timeZone, year);
  if (cached) {
    return cached;
  }
  const offsets = new TimeZoneOffsetInfo(timeZone, year), startUtcTicks = new Date(Date.UTC(year, 0, 1)).getTime();
  let ticks = startUtcTicks, incr = month, monthIndex = 0, previousOffset = [], currentOffset = null, tzTicksUtc, tzString, offset, done;
  while (!done) {
    ({ offset, tzTicksUtc, tzString } = getOffsetUtc(ticks, timeZone));
    if (currentOffset == null) {
      currentOffset = offset;
      offsets.push({ offset });
    } else if (incr > 0 && offset !== currentOffset) {
      incr = incr === month ? day : min;
    } else if (incr < 0 && offset === currentOffset) {
      if (incr === day) {
        incr = hour;
      } else {
        if (offsets.length === 1) {
          offsets.push(previousOffset);
          currentOffset = previousOffset.offset;
        } else {
          offsets[0].startTicks = previousOffset.startTicks;
          offsets[0].startDateString = previousOffset.startDateString;
          done = true;
        }
        incr = month;
      }
    }
    previousOffset = { offset, startDateString: tzString, startTicks: tzTicksUtc };
    if (incr === month) {
      ticks = startUtcTicks;
      ticks += monthIndex * month;
      monthIndex += 1;
    }
    ticks += incr;
    if (monthIndex > 11) {
      done = true;
    }
  }
  offsetDateCache.set(offsets);
  return offsets;
};
var offsetDateCache = {
  _cache: {},
  get(timeZone, year) {
    var _a4;
    return (_a4 = this._cache[timeZone]) == null ? void 0 : _a4[year];
  },
  set(offsetInfo) {
    const { timeZone } = offsetInfo, { _cache } = this;
    if (!_cache[timeZone]) {
      _cache[timeZone] = {};
    }
    _cache[timeZone][offsetInfo.year] = offsetInfo;
  }
};
var TimeZoneHelper = class {
  static get $name() {
    return "TimeZoneHelper";
  }
  /**
   * Adjusts the time of the specified date to match the specified time zone. i.e. "what time is it now in this
   * timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a local date to a
   * string in a given time zone and then converting the string back into a date. If browsers time zone information
   * or interpretation is inaccurate or lacks data, the conversion will probably be inaccurate as well.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2 ('Europe/Stockholm')
   * const cstDate   = TimeZoneHelper.toTimezone(localDate, 'America/Chicago'); // 2020, 7, 31, 0 (still UTC+2, but
   * // appear as UTC-6)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by `Intl.DateFormat` or a UTC offset in minutes
   * @returns {Date}
   */
  static toTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.toUtcOffset(date, timeZone);
    }
    const tzDate = toTimeZoneInternal(date, timeZone);
    if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {
      console.warn("Incorrect time zone conversion due to local DST-switch detected");
    }
    return tzDate.asLocalDate;
  }
  /**
   * Adjusts the time of the specified date to match local system time zone in the specified time zone. i.e. "what
   * time in my timezone would match time in this timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a date from a given
   * timezone into a local date by calculating specified time zone UTC offsets and using those to perform the date
   * conversion. If browsers time zone information or interpretation is inaccurate or lacks data, the conversion will
   * probably be inaccurate as well.
   *
   * ```javascript
   * const cstDate   = new Date(2022, 8, 27, 4); // CST 'America/Chicago'
   * const localDate = TimeZoneHelper.fromTimeZone(cstDate, 'America/Chicago'); // 2022, 8, 27, 11 (UTC+2 Europe/Stockholm)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by Intl.DateFormat or a UTC offset in minutes
   * @returns {Date}
   */
  static fromTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.fromUtcOffset(date, timeZone);
    }
    const dateArr = this.dateAsArray(date), offsetDates = findOffsetDates(timeZone, date.getUTCFullYear());
    let useOffset = offsetDates[0].offset;
    if (offsetDates.length === 2) {
      const utcTicks = Date.UTC(...dateArr);
      if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {
        useOffset = offsetDates[1].offset;
      }
    }
    dateArr[4] += useOffset;
    return new Date(Date.UTC(...dateArr));
  }
  /**
   * Adjusts the time of the specified date with provided UTC offset in minutes
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2
   * const utcDate   = TimeZoneHelper.toUtcOffset(localDate, 0); // 2020, 7, 31, 5 (still UTC+2, but appear as UTC+0)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static toUtcOffset(date, utcOffset) {
    const offset = date.getTimezoneOffset() + utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  /**
   * Adjusts the time of the specified date by removing the provided UTC offset in minutes.
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const utcDate = new Date(2020, 7, 31, 7); // UTC
   * const utcDate = TimeZoneHelper.fromUtcOffset(localDate, 0); // 2020, 7, 31, 9 (matches 2020-08-31 07:00+00:00)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static fromUtcOffset(date, utcOffset) {
    const offset = -date.getTimezoneOffset() - utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  // Converts a date into an array of its parts ([year, month, day, etc.]).
  // Convenient as a date info bearer which is not affected by local time zone
  static dateAsArray(date) {
    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
  }
};
TimeZoneHelper.findOffsetDates = findOffsetDates;
TimeZoneHelper._$name = "TimeZoneHelper";

// ../Core/lib/Core/widget/Toast.js
var _Toast = class _Toast extends Widget {
  static get configurable() {
    return {
      testConfig: {
        destroyTimeout: 1,
        timeout: 1e3
      },
      floating: true,
      /**
       * Timeout (in ms) until the toast is automatically dismissed. Set to 0 to never hide.
       * @config {Number}
       * @default
       */
      timeout: 2500,
      autoDestroy: null,
      // How long to wait after hide before destruction
      destroyTimeout: 200,
      /**
       * Show a progress bar indicating the time remaining until the toast is dismissed.
       * @config {Boolean}
       * @default
       */
      showProgress: true,
      /**
       * Toast color (should have match in toast.scss or your custom styling).
       * Valid values in Bryntum themes are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       *
       * ```
       * new Toast({
       *    color : 'b-blue'
       * });
       * ```
       *
       * @config {String}
       */
      color: null,
      sideMargin: 20,
      /**
       * Which side to show the toast at, `'top'` or `'bottom'`. Defaults to `'bottom'`.
       *
       * May also define the inline edge to show at, by using `'top-start'`, or `'top-end'` etc.
       *
       * By default, toasts are shown at the bottom at the inline-end edge.
       * @config {'top'|'bottom'|'start'|'end'|'top-start'|'top-end'|'bottom-start'|'bottom-end'} side
       * @default
       */
      side: "bottom",
      role: "alert"
    };
  }
  changeSide(side) {
    if (side == "top" || side == "bottom") {
      side += "-end";
    } else if (side === "start" || side == "end") {
      side = "bottom-" + side;
    }
    return side;
  }
  compose() {
    const { appendTo, color, html, showProgress, style, timeout, side } = this;
    return {
      parent: appendTo || this.floatRoot,
      class: {
        ...DomClassList.normalize(color, "object"),
        [`b-side-${side}`]: 1,
        "b-toast-hide": 1
        // toasts start hidden so we can animate them into view
      },
      html,
      style: {
        ...DomHelper.parseStyle(style),
        "--side": side.split("-")[0]
      },
      children: {
        progressElement: showProgress && {
          style: `animation-duration:${timeout / 1e3}s;`,
          class: {
            "b-toast-progress": 1
          }
        }
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "hide"
      }
    };
  }
  doDestroy() {
    this.untoast();
    super.doDestroy();
  }
  getNextInset(side) {
    const { sideMargin, element } = this;
    return parseInt(element.style[side], 10) + element.offsetHeight + sideMargin;
  }
  /**
   * Show the toast
   */
  async show() {
    var _a4, _b;
    await super.show(...arguments);
    const me = this, { element, side } = me, toasts = _Toast.toasts[side], s = side.split("-")[0];
    if (!toasts.includes(me)) {
      element.style[s] = ((_b = (_a4 = toasts[0]) == null ? void 0 : _a4.getNextInset(s)) != null ? _b : me.sideMargin) + "px";
      toasts.unshift(me);
      element.getBoundingClientRect();
      element.classList.remove("b-toast-hide");
      if (me.timeout > 0) {
        me.hideTimeout = me.setTimeout("hide", me.timeout);
      }
      DomHelper.addAttributeValue(document.body, "aria-describedby", me.id);
    }
  }
  /**
   * Hide the toast
   */
  async hide() {
    const me = this;
    me.untoast();
    me.element.classList.add("b-toast-hide");
    if (me.autoDestroy && !me.destroyTimer) {
      me.destroyTimer = me.setTimeout("destroy", me.destroyTimeout);
    }
  }
  untoast() {
    const toasts = _Toast.toasts[this.side];
    if (toasts.includes(this)) {
      toasts.splice(toasts.indexOf(this), 1);
    }
    DomHelper.removeAttributeValue(document.body, "aria-describedby", this.id);
  }
  /**
   * Hide all visible toasts
   */
  static hideAll() {
    Object.keys(_Toast.toasts).forEach((k) => _Toast.toasts[k].slice().reverse().forEach((toast) => toast.hide()));
  }
  /**
   * Easiest way to show a toast
   *
   * ```javascript
   * Toast.show('Hi');
   *
   * Toast.show({
   *   html   : 'Read quickly, please',
   *   timeout: 1000
   * });
   * ```
   *
   * @param {String|ToastConfig} config Message or toast config object
   * @returns {Core.widget.Toast}
   */
  static show(config) {
    const toast = _Toast.new({
      autoDestroy: true,
      rootElement: document.body
    }, typeof config === "string" ? { html: config } : config);
    toast.show();
    return toast;
  }
};
__publicField(_Toast, "$name", "Toast");
__publicField(_Toast, "type", "toast");
__publicField(_Toast, "toasts", {
  "top-start": [],
  "top-end": [],
  "bottom-start": [],
  "bottom-end": []
});
var Toast = _Toast;
Toast.initClass();
Toast._$name = "Toast";

// ../Core/lib/Core/helper/WidgetHelper.js
var WidgetHelper = class {
  //region Querying
  /**
   * Returns the widget with the specified id.
   * @param {String} id Id of widget to find
   * @returns {Core.widget.Widget} The widget if any
   * @category Querying
   */
  static getById(id) {
    return Widget.getById(id);
  }
  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget.
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at.
   * @returns {Core.widget.Widget} The found Widget or null.
   * @category Querying
   */
  static fromElement(element, type, limit) {
    return Widget.fromElement(element, type, limit);
  }
  //endregion
  //region Widgets
  /**
   * Create a widget.
   *
   * ```javascript
   * WidgetHelper.createWidget({
   *   type: 'button',
   *   icon: 'user',
   *   text: 'Edit user'
   * });
   * ```
   *
   * @param {ContainerItemConfig} config Widget config
   * @returns {Core.widget.Widget} The widget
   * @category Widgets
   */
  static createWidget(config = {}) {
    return config.isWidget ? config : Widget.create(config);
  }
  /**
   * Appends a widget (array of widgets) to the DOM tree. If config is empty, widgets are appended to the DOM. To
   * append widget to certain position you can pass HTMLElement or its id as config, or as a config, that will be
   * applied to all passed widgets.
   *
   * Usage:
   *
   * ```javascript
   * // Will append button as last item to element with id 'container'
   * let [button] = WidgetHelper.append({ type : 'button' }, 'container');
   *
   * // Same as above, but will add two buttons
   * let [button1, button2] = WidgetHelper.append([
   *     { type : 'button' },
   *     { type : 'button' }
   *     ], { appendTo : 'container' });
   *
   * // Will append two buttons before element with id 'someElement'. Order will be preserved and all widgets will have
   * // additional class 'my-cls'
   * let [button1, button2] = WidgetHelper.append([
   *     { type : 'button' },
   *     { type : 'button' }
   *     ], {
   *         insertBefore : 'someElement',
   *         cls          : 'my-cls'
   *     });
   * ```
   *
   * @param {ContainerItemConfig|ContainerItemConfig[]} widget Widget config or array of such configs
   * @param {HTMLElement|String|Object} [config] Element (or element id) to which to append the widget or config to
   * apply to all passed widgets
   * @returns {Core.widget.Widget[]} Array or widgets
   * @category Widgets
   */
  static append(widget, config) {
    widget = Array.isArray(widget) && widget || [widget];
    if (config instanceof HTMLElement || typeof config === "string") {
      config = {
        appendTo: config
      };
    }
    if (config.insertFirst) {
      const target = typeof config.insertFirst === "string" ? document.getElementById(config.insertFirst) : config.insertFirst;
      if (target.firstChild) {
        config.insertBefore = target.firstChild;
      } else {
        config.appendTo = target;
      }
    }
    return widget.map((item) => Widget.create(ObjectHelper.assign({}, config || {}, item)));
  }
  //endregion
  //region Popups
  /**
   * Shows a popup (~tooltip) containing widgets connected to specified element.
   *
   * ```javascript
   * WidgetHelper.openPopup(element, {
   *   position: 'bottom center',
   *   items: [
   *      { widgetConfig }
   *   ]
   * });
   * ```
   *
   * @param {HTMLElement} element Element to connect popup to
   * @param {PopupConfig} config Config object, or string to use as html in popup
   * @returns {*|{close, widgets}}
   * @category Popups
   */
  static openPopup(element, config) {
    return Widget.create(ObjectHelper.assign({
      forElement: element
    }, typeof config === "string" ? {
      html: config
    } : config), "popup");
  }
  /**
   * Shows a context menu connected to the specified element.
   *
   * ```javascript
   * WidgetHelper.showContextMenu(element, {
   *   items: [
   *      { id: 'addItem', icon: 'add', text: 'Add' },
   *      ...
   *   ],
   *   onItem: item => alert('Clicked ' + item.text)
   * });
   * ```
   *
   * @param {HTMLElement|Number[]} element Element (or a coordinate) to show the context menu for
   * @param {MenuItemConfig} config Context menu config, see example
   * @returns {Core.widget.Menu}
   * @category Popups
   */
  static showContextMenu(element, config) {
    const me = this;
    if (me.currentContextMenu) {
      me.currentContextMenu.destroy();
    }
    if (element instanceof HTMLElement) {
      config.forElement = element;
    } else {
      config.forElement = document.body;
      if (Array.isArray(element)) {
        element = new Point(...element);
      }
      if (element instanceof Point) {
        config.align = {
          position: element
        };
      }
    }
    config.internalListeners = { destroy: me.currentContextMenu = null };
    return me.currentContextMenu = Widget.create(config, "menu");
  }
  /**
   * Attached a tooltip to the specified element.
   *
   * ```javascript
   * WidgetHelper.attachTooltip(element, {
   *   text: 'Useful information goes here'
   * });
   * ```
   *
   * @param {HTMLElement} element Element to attach tooltip for
   * @param {String|TooltipConfig} configOrText Tooltip config or tooltip string, see example and source
   * @returns {HTMLElement} The passed element
   * @category Popups
   */
  static attachTooltip(element, configOrText) {
    return Widget.attachTooltip(element, configOrText);
  }
  /**
   * Checks if element has tooltip attached
   *
   * @param {HTMLElement} element Element to check
   * @returns {Boolean}
   * @category Popups
   */
  static hasTooltipAttached(element) {
    return Widget.resolveType("tooltip").hasTooltipAttached(element);
  }
  /**
   * Destroys any tooltip attached to an element, removes it from the DOM and unregisters any tip related listeners
   * on the element.
   *
   * @param {HTMLElement} element Element to remove tooltip from
   * @category Popups
   */
  static destroyTooltipAttached(element) {
    return Widget.resolveType("tooltip").destroyTooltipAttached(element);
  }
  //endregion
  //region Mask
  /**
   * Masks the specified element, showing a message in the mask.
   * @param {HTMLElement} element Element to mask
   * @param {String} msg Message to show in the mask
   * @returns {Core.widget.Mask}
   * @category Mask
   */
  static mask(element, msg = "Loading") {
    if (element) {
      if (element instanceof HTMLElement) {
        element = {
          target: element,
          text: msg
        };
      }
      return Mask.mask(element, element.target);
    }
  }
  /**
   * Unmask the specified element.
   * @param {HTMLElement} element
   * @category Mask
   */
  static unmask(element, close = true) {
    if (element.mask) {
      if (close) {
        element.mask.close();
      } else {
        element.mask.hide();
      }
    }
  }
  //endregion
  //region Toast
  /**
   * Show a toast
   * @param {String} msg message to show in the toast
   * @category Mask
   */
  static toast(msg) {
    return Toast.show(msg);
  }
  //endregion
};
WidgetHelper._$name = "WidgetHelper";

// ../Core/lib/Core/helper/XMLHelper.js
var XMLHelper = class {
  /**
   * Convert a JavaScript object to an XML string.
   *
   * From:
   * ```javascript
   * {
   *     name : 'Task 1',
   *     data : [
   *         {
   *             text : 'foo 1',
   *             ref  : 'fooItem 1'
   *         },
   *         {
   *             text : 'foo 2',
   *             ref  : 'fooItem 2'
   *         }
   *     ]
   * }
   * ```
   *
   * To:
   * ```xml
   * <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   * <root>
   *     <name>Task 1</name>
   *     <data>
   *         <element>
   *             <text>foo 1</text>
   *             <ref>fooItem 1</ref>
   *         </element>
   *         <element>
   *             <text>foo 2</text>
   *             <ref>fooItem 2</ref>
   *         </element>
   *     </data>
   * </root>
   * ```
   *
   * @param {Object} obj Object to convert.
   * @param {Object} [options] Convert options.
   * @param {String} [options.rootName] Root name for the XML. `root` by default.
   * @param {String} [options.elementName] Element name for each node of the XML. `element` by default.
   * @param {String} [options.xmlns] Add value for xmlns property for the root tag of the XML.
   * @param {Boolean} [options.includeHeader] `false` to not include the header `<?xml version="1.0" encoding="UTF-8"?>` on top of the XML.
   * @param {Boolean} [options.rootElementForArray] `false` to not include a root element for array of items. e.g. for the above example:
   * ```xml
   * <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   * <root>
   *     <name>Task 1</name>
   *     <element>
   *         <text>foo 1</text>
   *         <ref>fooItem 1</ref>
   *     </element>
   *     <element>
   *         <text>foo 2</text>
   *         <ref>fooItem 2</ref>
   *     </element>
   * </root>
   * ```
   * @returns {String} the XML
   */
  static convertFromObject(obj, options = {}) {
    Objects.assignIf(options, {
      rootName: "root",
      elementName: "element",
      includeHeader: true,
      rootElementForArray: true
    });
    const { rootName, elementName, includeHeader, rootElementForArray } = options;
    let { xmlns } = options;
    xmlns = xmlns ? ` xmlns="${xmlns}"` : "";
    const header = includeHeader ? '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' : "";
    const converter = (o) => {
      const xmlItems = [];
      for (const key in o) {
        const item = o[key];
        if (Array.isArray(item)) {
          if (rootElementForArray) {
            xmlItems.push(`<${key}>`);
          }
          for (const subItem of item) {
            if (elementName.length) {
              xmlItems.push(`<${elementName}>`);
            } else {
              xmlItems.push(`<${key}>`);
            }
            xmlItems.push(converter(subItem));
            if (elementName.length) {
              xmlItems.push(`</${elementName}>`);
            } else {
              xmlItems.push(`</${key}>`);
            }
          }
          if (rootElementForArray) {
            xmlItems.push(`</${key}>`);
          }
        } else if (Objects.isObject(item)) {
          xmlItems.push(`<${key}>${converter(item)}</${key}>`);
        } else {
          if (item == null) {
            xmlItems.push(`<${key}/>`);
          } else {
            xmlItems.push(`<${key}>${StringHelper.encodeHtml(item)}</${key}>`);
          }
        }
      }
      return xmlItems.join("");
    };
    return `${header}<${rootName}${xmlns}>${converter(obj)}</${rootName}>`;
  }
};
XMLHelper._$name = "XMLHelper";

// ../Core/lib/Core/helper/util/RandomGenerator.js
var RandomGenerator = class {
  constructor() {
    this.random100 = [46, 2, 36, 46, 54, 59, 18, 20, 71, 55, 88, 98, 13, 61, 61, 40, 2, 15, 3, 32, 51, 45, 64, 25, 81, 85, 54, 13, 57, 49, 64, 22, 81, 94, 0, 62, 17, 7, 11, 2, 33, 99, 85, 26, 83, 83, 96, 26, 20, 89, 91, 38, 26, 13, 11, 79, 32, 30, 5, 51, 70, 7, 5, 56, 58, 77, 37, 89, 40, 80, 78, 59, 26, 36, 8, 51, 60, 23, 86, 5, 11, 96, 64, 94, 87, 64, 4, 78, 17, 85, 35, 0, 90, 86, 23, 55, 53, 9, 35, 59, 29, 2, 64, 42, 8, 49, 43, 73, 6, 53, 38, 9, 39, 31, 32, 40, 49, 13, 78, 68, 20, 99, 24, 78, 35, 91, 73, 46, 67, 76, 89, 69, 30, 69, 25, 3, 4, 55, 1, 65, 66, 76, 83, 19, 67, 1, 95, 24, 54, 45, 56, 40, 67, 92, 72, 4, 69, 8, 47, 50, 27, 2, 38, 9, 14, 83, 12, 14, 62, 95, 22, 47, 35, 18, 38, 14, 86, 64, 68, 61, 52, 69, 39, 93, 20, 73, 32, 52, 74, 6, 56, 68, 99, 29, 24, 92, 40, 67, 6, 72, 31, 41, 91, 53, 80, 55, 33, 97, 97, 99, 18, 20, 5, 27, 82, 84, 61, 78, 27, 67, 7, 42, 75, 95, 91, 25, 63, 21, 70, 36, 46, 0, 1, 45, 84, 6, 86, 15, 10, 62, 96, 94, 10, 23, 93, 83, 94, 47, 5, 29, 29, 52, 51, 37, 77, 96, 43, 72, 43, 14, 54, 14, 72, 52, 4, 39, 15, 26, 68, 28, 25, 76, 60, 50, 22, 40, 72, 74, 68, 58, 8, 48, 40, 62, 52, 24, 9, 26, 47, 44, 49, 96, 7, 77, 90, 45, 76, 47, 5, 86, 1, 36, 18, 42, 19, 90, 34, 23, 70, 32, 69, 79, 0, 99, 57, 80, 72, 21, 19, 72, 85, 68, 4, 40, 86, 62, 0, 63, 4, 11, 69, 31, 78, 31, 21, 78, 29, 84, 13, 53, 57, 10, 26, 50, 24, 30, 90, 42, 51, 96, 93, 21, 99, 23, 81, 0, 89, 43, 86, 63, 93, 19, 54, 71, 92, 36, 4, 95, 37, 99, 60, 29, 23, 50, 68, 95, 57, 95, 77, 53, 99, 78, 75, 12, 92, 47, 23, 14, 0, 41, 98, 11, 34, 64, 26, 90, 50, 23, 38, 31, 74, 76, 16, 76, 66, 23, 22, 72, 48, 50, 20, 36, 37, 58, 5, 43, 49, 64, 81, 30, 8, 21, 98, 75, 60, 17, 50, 42, 27, 38, 90, 74, 45, 68, 67, 27, 31, 15, 58, 76, 41, 99, 23, 98, 53, 98, 56, 19, 79, 2, 4, 38, 96, 24, 65, 51, 43, 42, 41, 60, 46, 7, 90, 65, 3, 27, 63, 99, 51, 44, 86, 1, 54, 40, 15, 74, 3, 81, 51, 63, 87, 79, 84, 72, 22, 38, 96, 95, 33, 41, 21, 99, 21, 69, 7, 49, 40, 52, 41, 6, 91, 19, 76, 40, 54, 17, 33, 11, 11, 0, 1, 32, 94, 33, 13, 18, 45, 7, 85, 61, 42, 54, 45, 72, 78, 96, 17, 9, 80, 87, 41, 96, 66, 0, 8, 59, 18, 21, 2, 28, 64, 75, 97, 32, 80, 86, 97, 97, 55, 2, 73, 75, 11, 89, 67, 58, 70, 76, 12, 46, 64, 17, 22, 97, 25, 35, 93, 57, 82, 46, 57, 61, 31, 74, 27, 4, 32, 85, 53, 86, 53, 53, 42, 5, 28, 50, 65, 63, 70, 61, 73, 37, 13, 80, 7, 34, 22, 3, 26, 6, 62, 78, 12, 56, 87, 41, 58, 64, 31, 27, 45, 35, 18, 66, 62, 43, 89, 69, 94, 93, 33, 74, 2, 43, 85, 37, 82, 41, 74, 9, 15, 44, 33, 42, 65, 19, 1, 49, 78, 12, 29, 9, 78, 7, 55, 12, 45, 40, 33, 16, 86, 14, 52, 16, 73, 76, 0, 98, 75, 91, 78, 46, 99, 95, 90, 69, 78, 45, 62, 55, 37, 88, 49, 77, 27, 83, 38, 73, 39, 1, 75, 40, 65, 83, 54, 95, 7, 73, 4, 30, 26, 36, 89, 21, 5, 95, 11, 14, 87, 45, 36, 21, 77, 55, 5, 66, 51, 98, 48, 62, 74, 58, 23, 82, 30, 28, 19, 53, 89, 76, 98, 8, 34, 70, 28, 54, 16, 52, 35, 93, 54, 54, 72, 49, 18, 93, 72, 90, 71, 73, 15, 60, 38, 80, 76, 53, 70, 39, 69, 25, 5, 31, 61, 46, 6, 54, 34, 31, 52, 33, 36, 79, 76, 44, 29, 28, 38, 1, 66, 2, 90, 91, 1, 76, 78, 31, 55, 37, 71, 2, 3, 38, 85, 0, 95, 42, 2, 39, 57, 87, 61, 77, 98, 2, 24, 80, 48, 27, 47, 71, 15, 7, 49, 60, 86, 3, 2, 29, 38, 54, 36, 59, 83, 27, 47, 9, 36, 42, 8, 73, 85, 9, 16, 73, 60, 39, 12, 43, 25, 23, 29, 28, 47, 40, 77, 20, 89, 22, 30, 41, 59, 96, 19, 56, 20, 76, 73, 39, 46, 72, 40, 47, 37, 52, 29, 79, 37, 39, 50, 41, 87, 66, 17, 75, 31, 45, 26, 88, 70, 11, 90, 40, 74, 9, 32, 65, 72, 61, 6, 93, 54, 15, 84, 22, 99, 47, 10, 96, 4, 84, 19, 85, 73, 45, 25, 16, 8, 94, 99, 39, 28, 26, 68, 87, 48, 1, 65, 86, 46, 86, 7, 60, 82, 45, 75, 38, 56, 41, 35, 30, 86, 91, 97, 85, 45, 5, 14, 69, 85, 96, 37, 18, 26, 16, 38, 16, 1, 44, 94, 85, 58, 60, 20, 5, 47, 52, 41, 50, 71, 43, 42, 67, 64, 38, 65, 83, 99, 78, 96, 33, 20, 98, 24, 6, 2, 25, 16, 16, 44, 63, 24, 68, 56, 49, 91, 15, 59, 99, 27, 43, 34, 28, 36, 45, 1, 10, 19, 54, 26, 75, 17, 88, 96, 63, 24, 71, 93, 72, 97, 66, 87, 18, 86];
    this.randomCache = {};
    this.rndIndex = 0;
  }
  /**
   * Returns next pseudo random integer number from sequence between 0 and max parameter value (99 is maximum value)
   * ```javascript
   * const rand = new RandomGenerator();
   * const randomNumber = rand.nextRandom(50);
   * ```
   *
   * @param {Number} max max value
   * @returns {Number}
   */
  nextRandom(max) {
    const { randomCache } = this;
    let randomNumbers;
    if (randomCache[max]) {
      randomNumbers = randomCache[max];
    } else {
      randomNumbers = this.random100.filter((num) => num < max);
      randomCache[max] = randomNumbers;
    }
    return randomNumbers[this.rndIndex++ % randomNumbers.length];
  }
  /**
   * Resets sequence to initial number
   */
  reset() {
    this.rndIndex = 0;
  }
  /**
   * Returns pseudo random array element
   * ```javascript
   * const rand = new RandomGenerator();
   * const cities = ['New York', 'London', 'Tokyo', 'Paris' ];
   * const randomCity = rand.fromArray(cities);
   * ```
   *
   * @param {Array} array Input array
   * @returns {*} A pseudo random element from the array
   */
  fromArray(array) {
    return array[this.nextRandom(array.length)];
  }
  /**
   * Creates a random array from a larger array of possibilities.
   * ```javascript
   * const rand = new RandomGenerator();
   * const cities = [
   * 'New York', 'London', 'Tokyo', 'Paris', 'Los Angeles',
   * 'Berlin', 'Sydney', 'Singapore', 'Rome', 'Toronto',
   * 'Hong Kong', 'Amsterdam', 'Barcelona', 'Dubai', 'Chicago',
   * 'Mumbai', 'Bangkok', 'Moscow', 'San Francisco', 'Madrid' ];
   * const randomCities = rand.randomArray(cities, 5);
   * ```
   *
   * @param {Array} array Input array
   * @param {Number} max Max length
   * @returns {Array}
   */
  randomArray(array, maxLength) {
    const result = [], length = this.nextRandom(maxLength + 1), used = {};
    for (let i = 0, index = this.nextRandom(array.length); i < length; i++) {
      while (used[index]) {
        index = this.nextRandom(array.length);
      }
      used[index] = true;
      result.push(array[index]);
    }
    return result;
  }
};
RandomGenerator._$name = "RandomGenerator";

// ../Core/lib/Core/helper/util/DataGenerator.js
var lorem = [
  "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
  "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.",
  "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.",
  "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
  "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.",
  "Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui atione voluptatem sequi nesciunt.",
  "Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.",
  "Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?",
  "Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
];
var _DataGenerator = class _DataGenerator {
  //region Random
  static reset() {
    this.rnd.reset();
    this.rndTime.reset();
    this.rndRating.reset();
  }
  //region Data arrays
  /**
   * Array with available city values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get cities() {
    return [
      "Stockholm",
      "Barcelona",
      "Paris",
      "Dubai",
      "New York",
      "San Francisco",
      "Washington",
      "Moscow"
    ];
  }
  /**
   * Array with available first name values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get firstNames() {
    return [
      "Mike",
      "Linda",
      "Don",
      "Karen",
      "Doug",
      "Jenny",
      "Daniel",
      "Melissa",
      "John",
      "Jane",
      "Theo",
      "Lisa",
      "Adam",
      "Mary",
      "Barbara",
      "James",
      "David"
    ];
  }
  /**
   * Array with available sur name values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get surNames() {
    return [
      "McGregor",
      "Ewans",
      "Scott",
      "Smith",
      "Johnson",
      "Adams",
      "Williams",
      "Brown",
      "Jones",
      "Miller",
      "Davis",
      "More",
      "Wilson",
      "Taylor",
      "Anderson",
      "Thomas",
      "Jackson"
    ];
  }
  /**
   * Array with available team values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get teams() {
    return [
      "Lions",
      "Eagles",
      "Tigers",
      "Horses",
      "Dogs",
      "Cats",
      "Panthers",
      "Rats",
      "Ducks",
      "Cougars",
      "Hens",
      "Roosters"
    ];
  }
  /**
   * Array with available food values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get foods() {
    return [
      "Pancake",
      "Burger",
      "Fish n chips",
      "Carbonara",
      "Taco",
      "Salad",
      "Bolognese",
      "Mac n cheese",
      "Waffles"
    ];
  }
  /**
   * Array with available color values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get colors() {
    return [
      "Blue",
      "Green",
      "Red",
      "Yellow",
      "Pink",
      "Purple",
      "Orange",
      "Teal",
      "Black"
    ];
  }
  /**
   * Array with available skill values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get skills() {
    return [
      "JavaScript",
      "CSS",
      "TypeScript",
      "React",
      "Vue",
      "Angular",
      "Java",
      "PHP",
      "Python",
      "C#",
      "C++",
      "BASIC",
      "COBOL",
      "FORTRAN",
      "PASCAL",
      "SQL"
    ];
  }
  /**
   * Array with available task values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get tasks() {
    return [
      "Meetings",
      "Documentation",
      "Email communication",
      "Project management",
      "Budgeting",
      "Marketing and advertising",
      "Customer service",
      "Research and analysis",
      "Data entry",
      "IT support",
      "Employee management",
      "Sales and business development",
      "Event planning",
      "Graphic design",
      "Writing and editing",
      "Presentation",
      "Travel arrangements and expense management",
      "Training and development",
      "Quality assurance",
      "Customer support",
      "Technical writing",
      "Social media management",
      "Translation",
      "Legal research",
      "Data analysis and visualization",
      "Video editing and production",
      "Network admin",
      "Content creation",
      "Market research",
      "Public relations",
      "Teaching and training",
      "Recruiting",
      "Product development"
    ];
  }
  //endregion
  //region Generate data
  /**
   * Generates an array of objects with specified properties.
   *
   * @param {Number} count The number of objects to generate or an options object.
   * @privateparam {Boolean|Number} [randomHeight=false] If `true`, assigns random heights to objects. If a number is provided, it sets the maximum height.
   * @privateparam {Number} [initialId=1] The initial ID for the generated objects.
   * @yields {Object} An object representing a generated item with various properties.
   * @generator
   * @static
   */
  static *generate(count, randomHeight = false, initialId = 1) {
    var _a4;
    let addSkills, rowCallback;
    if (typeof count === "object") {
      randomHeight = count.randomHeight;
      initialId = (_a4 = count.initialId) != null ? _a4 : 1;
      addSkills = count.addSkills;
      rowCallback = count.rowCallback;
      count = count.count;
    }
    const me = this, {
      rnd,
      rndTime,
      rndRating,
      rndText,
      firstNames,
      surNames,
      teams,
      foods,
      colors,
      cities,
      skills
    } = me;
    for (let i = 0; i < count; i++) {
      const firstName = rnd.fromArray(firstNames), surName = rnd.fromArray(surNames), name = `${firstName} ${String.fromCharCode(65 + i % 25)} ${surName}`, startDay = rnd.nextRandom(60) + 1, start = new Date(2019, 0, startDay), finish = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2), row = {
        id: initialId > -1 ? i + initialId : void 0,
        title: "Row " + i,
        name,
        firstName,
        surName,
        city: rnd.fromArray(cities),
        team: rnd.fromArray(cities) + " " + rnd.fromArray(teams),
        age: 10 + rnd.nextRandom(80),
        food: rnd.fromArray(foods),
        color: rnd.fromArray(colors),
        score: rnd.nextRandom(100) * 10,
        rank: rnd.nextRandom(100) + 1,
        start,
        finish,
        time: DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
        percent: rnd.nextRandom(100),
        done: rnd.nextRandom(100) < 50,
        rating: rndRating.nextRandom(5),
        active: startDay > 30,
        relatedTo: Math.min(count - 1, i + initialId + rnd.nextRandom(10)),
        notes: lorem[rndText.nextRandom(7) + 1]
      };
      if (addSkills) {
        row.skills = rnd.randomArray(skills, typeof addSkills === "number" ? addSkills : 7);
      }
      const additionalData = rowCallback == null ? void 0 : rowCallback(row);
      additionalData && Object.assign(row, additionalData);
      if (randomHeight) {
        row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
      }
      yield row;
    }
  }
  /**
   * Generates a pseudo random dataset. Used in Grid examples.
   * @param {Number|Object} count number of records, or an object with properties:
   * @param {Boolean} [count.randomHeight] Generate random row height
   * @param {Boolean} [count.initialId] Row initial id. Set -1 to disable Id generation. Defaults to 1.
   * @param {Boolean} [count.reset] Set true to ensure we get the same dataset on consecutive calls. Defaults to true
   * @param {Boolean} [count.rowCallback] A callback called for each row to allow appending extra data, returned data in
   * object form will be applied to the generated data
   * @param {Boolean} [count.addSkills] Add skills to the dataset
   * @param {Boolean} [randomHeight] Generate random row height
   * @param {Number} [initialId] Row initial id. Set -1 to disable Id generation. Defaults to 1.
   * @param {Boolean} [reset] Set true to ensure we get the same dataset on consecutive calls. Defaults to true
   * @returns {Object[]} Generated rows array
   */
  static generateData(count, randomHeight = false, initialId = 1, reset = true) {
    let args = count;
    if (typeof count !== "object") {
      args = {
        count,
        randomHeight,
        initialId,
        reset
      };
    }
    args.reset !== false && this.reset();
    if (_DataGenerator.overrideRowCount) {
      args.count = _DataGenerator.overrideRowCount;
    }
    const rows = [], generator = this.generate(args);
    for (let i = 0; i < args.count; i++) {
      rows.push(generator.next().value);
    }
    return rows;
  }
  /**
   * Generates a dataset of events
   * @returns {Object[]}
   */
  static generateEvents({
    viewStartDate,
    viewEndDate,
    nbrResources = 50,
    nbrEvents = 5,
    dependencies,
    tickUnit = "days",
    minDuration = 2,
    maxDuration = 10,
    gap = 1,
    eventCallback
  }) {
    const resources = this.generateData(nbrResources), events = [];
    let startDate, endDate;
    dependencies = [];
    for (let i = 0; i <= nbrResources; i++) {
      for (let j = 0; j <= nbrEvents; j++) {
        const duration = Math.round(Math.random() * (maxDuration - 1 - minDuration)) + minDuration, eventId = events.length + 1;
        startDate = j === 0 ? DateHelper.add(viewStartDate, Math.round(Math.random() * 3) * gap, tickUnit) : DateHelper.add(endDate, gap, tickUnit);
        endDate = DateHelper.add(startDate, duration, tickUnit);
        events.push({
          id: eventId,
          name: this.tasks[(i + j) % (this.tasks.length - 1)],
          startDate,
          duration,
          endDate,
          resourceId: i
        });
        eventCallback == null ? void 0 : eventCallback(events[events.length - 1]);
        if (dependencies && i > 0) {
          dependencies.push({
            id: dependencies.length + 1,
            from: eventId - 1,
            to: eventId
          });
        }
      }
    }
    return {
      resources,
      events,
      dependencies
    };
  }
  /**
   * Generates a pseudo random dataset with one scheduled event per resource & date tick.
   * @param {Object} data
   * @param {Boolean} [data.startDate] Start date of the first generated event
   * @param {Boolean} [data.endDate] End date of the last generated event
   * @param {Boolean} [data.nbrResources] Number of resources
   * @param {Boolean} [data.tickUnit] The tick unit for the time axis, defaults to `days`
   * @returns {Object[]} Generated rows array
   */
  static generateOneEventPerTickAndResource({
    startDate,
    endDate,
    nbrResources = 50,
    tickUnit = "days"
  }) {
    const resources = this.generateData(nbrResources), events = [], visibleTicks = DateHelper.getDurationInUnit(startDate, endDate, tickUnit);
    for (let i = 0; i <= nbrResources; i++) {
      for (let j = 0; j < visibleTicks; j++) {
        events.push({
          id: events.length + 1,
          resourceId: i,
          name: this.tasks[(i + j) % (this.tasks.length - 1)],
          startDate: DateHelper.add(startDate, j, tickUnit),
          duration: 1,
          durationUnit: tickUnit
        });
      }
    }
    return {
      resources,
      events
    };
  }
  /**
   * Generates pseudo random data for a Grid row.
   * @returns {Object} Generated row
   */
  static generateRow() {
    return _DataGenerator.generateData(1, false, -1, false)[0];
  }
  //endregion
};
//endregion
__publicField(_DataGenerator, "rnd", new RandomGenerator());
__publicField(_DataGenerator, "rndTime", new RandomGenerator());
__publicField(_DataGenerator, "rndRating", new RandomGenerator());
__publicField(_DataGenerator, "rndText", new RandomGenerator());
var DataGenerator = _DataGenerator;
DataGenerator._$name = "DataGenerator";

// ../Core/lib/Core/helper/util/DemoBot.js
var knownProps = [
  "action",
  "target",
  "to",
  "deltaX",
  "deltaY",
  "x",
  "y",
  "text"
];
var DemoBot = class extends Events_default(Delayable_default()) {
  static get defaultConfig() {
    return {
      repeat: true,
      outerElement: document.body,
      callOnFunctions: true
    };
  }
  // expects an outer element (grid.element/scheduler.element) and an array of steps similar to chain steps in siesta
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.widget) {
      me.outerElement = me.widget.element;
      me.widget.playingDemo = true;
    }
    EventHelper.playingDemo = true;
    Object.assign(me, {
      prevTarget: null,
      currentStep: 0,
      mouse: DomHelper.createElement({
        parent: me.outerElement,
        tag: "div",
        className: "simulated-mouse"
      }),
      timeoutId: null,
      innerIntervalId: null,
      mouseOutElements: []
    });
    me.intervalId = me.setInterval(me.nextStep.bind(me), 1e3);
    me.outerElement.classList.add("b-playing-demo");
    me.outerElement.addEventListener("click", (event) => {
      if (event.isTrusted) {
        me.abort();
      }
    });
  }
  doDestroy() {
    this.abort();
  }
  // stops the bot
  abort(atEnd = false) {
    const me = this;
    me.mouse.style.top = "-100px";
    me.clearInterval(me.intervalId);
    me.timeoutId && me.clearTimeout(me.timeoutId);
    me.innerIntervalId && me.clearInterval(me.innerIntervalId);
    me.outerElement.classList.remove("b-playing-demo");
    if (me.widget) {
      me.widget.playingDemo = false;
    }
    EventHelper.playingDemo = false;
    me.trigger(atEnd ? "done" : "abort");
  }
  // triggers a synthetic event
  triggerEvent(element, type, data) {
    if (!element)
      return null;
    let event;
    if (type.startsWith("mouse")) {
      const box = this.mouse.getBoundingClientRect();
      event = new MouseEvent(type, Object.assign({
        view: globalThis,
        bubbles: true,
        cancelable: true,
        clientX: box.left,
        clientY: box.top
      }, data || {}));
    } else {
      event = document.createEvent("Event");
      event.initEvent(type, true, false);
    }
    element.dispatchEvent(event);
    return event;
  }
  // moves mouse to target in 10 steps, with animated transition between steps
  handleMouseMove(step, target) {
    const me = this, mouse = me.mouse;
    mouse.classList.add("quick");
    if (me.mouseDown)
      mouse.classList.add("drag");
    const mouseBox = Rectangle.from(mouse, me.outerElement), x = mouseBox.x, y = mouseBox.y;
    let deltaX = 0, deltaY = 0;
    if (step.to) {
      if (typeof step.to === "string") {
        const toElement = me.outerElement.querySelector(step.to);
        if (toElement) {
          const rect = Rectangle.from(toElement, me.outerElement), toX = rect.x + rect.width / 2, toY = rect.y + rect.height / 2;
          deltaX = (toX - x) / 10;
          deltaY = (toY - y) / 10;
        }
      } else if (step.to.x) {
        deltaX = (step.to.x - x) / 10;
      } else {
        deltaX = step.to[0] / 10;
        deltaY = step.to[1] / 10;
      }
    } else if (step.deltaX) {
      deltaX = step.deltaX / 10;
    } else if (step.x) {
      deltaX = (step.x - x) / 10;
    }
    if (step.deltaY) {
      deltaY = step.deltaY / 10;
    }
    let i = 0;
    me.innerIntervalId = me.setInterval(() => {
      if (me.shouldPause) {
        return;
      }
      if (i++ === 9) {
        clearInterval(me.innerIntervalId);
        if (step.then) {
          step.then();
        }
      }
      const mouseX = x + deltaX * i, mouseY = y + deltaY * i;
      mouse.style.left = mouseX + "px";
      mouse.style.top = mouseY + "px";
      const mouseBounds = mouse.getBoundingClientRect(), clientX = mouseBounds.left, clientY = mouseBounds.top, eventTarget = DomHelper.elementFromPoint(clientX, clientY);
      if (eventTarget !== me.prevTarget) {
        if (me.prevTarget) {
          me.mouseOutElements.push(me.prevTarget);
          if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
            me.mouseOutElements.forEach((element) => me.triggerEvent(element, "mouseout"));
            me.mouseOutElements.length = 0;
          }
        }
        me.prevTarget = eventTarget;
        me.triggerEvent(eventTarget, "mouseover");
      }
      me.triggerEvent(eventTarget, step.action, {
        clientX,
        clientY
      });
    }, 50);
  }
  // target can be a string selector, a function or blank to use last target or outerElement if first time
  getTarget(step) {
    const me = this, target = step.target;
    if (!target) {
      return me.prevTarget || me.outerElement;
    }
    if (typeof target === "function") {
      return target(step);
    }
    return document.querySelector(target);
  }
  // action can be a function, a string or extracted from a property by scanning for unknown names
  normalizeStep(step) {
    if (step.action) {
      if (typeof step.action === "function") {
        return step.action(step);
      }
      return step;
    }
    if (typeof step === "function") {
      step();
      return step;
    }
    for (const prop in step) {
      if (Object.hasOwnProperty.call(step, prop) && !knownProps.includes(prop)) {
        step.action = prop.toLowerCase();
        step.to = step[prop];
      }
    }
    if (!step.target && (typeof step.to === "string" || typeof step.to === "function"))
      step.target = step.to;
    return step;
  }
  get isScrolling() {
    const me = this, box = me.outerElement.getBoundingClientRect(), scrolled = me.lastTop && box.top !== me.lastTop;
    me.lastTop = box.top;
    return scrolled;
  }
  get isInView() {
    const box = this.outerElement.getBoundingClientRect();
    return box.top < globalThis.innerHeight && box.bottom > 0;
  }
  get shouldPause() {
    return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
  }
  // process the next step
  nextStep() {
    const me = this;
    if (me.shouldPause) {
      return;
    }
    if (me.currentStep === me.steps.length) {
      if (me.repeat) {
        me.currentStep = 0;
      } else {
        return me.abort(true);
      }
    }
    if (me.currentStep === 0) {
      me.trigger("initialize");
    }
    const mouse = me.mouse, step = me.normalizeStep(me.steps[me.currentStep++]), target = me.getTarget(step), action = step.action;
    if (target && action) {
      mouse.className = "simulated-mouse";
      if (action === "mousemove") {
        me.handleMouseMove(step, target);
      } else {
        if (target !== me.prevTarget) {
          const rect = Rectangle.from(target, me.outerElement);
          mouse.style.left = rect.x + rect.width / 2 + "px";
          mouse.style.top = rect.y + rect.height / 2 + "px";
        }
        if (action === "mousedown") {
          me.mouseDown = true;
        }
        if (action === "mouseup") {
          me.mouseDown = false;
        }
        me.timeoutId = me.setTimeout(() => {
          me.prevTarget = target;
          mouse.classList.add(action);
          if (action === "type") {
            const field = Widget.fromElement(target), parts = step.text.split("|");
            field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
          } else {
            me.triggerEvent(target, action);
          }
        }, action === "type" ? 100 : 550);
      }
    }
  }
};
DemoBot._$name = "DemoBot";

// ../Core/lib/Core/helper/util/Navigator.js
var Navigator = class extends Base.mixin(Events_default, Factoryable_default) {
  static get $name() {
    return "Navigator";
  }
  // Factoryable type name
  static get type() {
    return "navigator";
  }
  static get configurable() {
    return {
      /**
       * The owning Widget which is using this Navigator.
       * @config {Core.widget.Widget}
       */
      ownerCmp: null,
      /**
       * If the items in the owning widget are naturally tabbable, then the Navigator does not
       * need to listen for navigation keys and move focus. It just reacts to natural focus
       * movement.
       * @config {Boolean}
       */
      itemsTabbable: null,
      /**
       * The encapsulating element in which navigation takes place.
       * @config {HTMLElement}
       */
      target: null,
      /**
       * The element which provides key events for navigation. Optional. Defaults to the {@link #config-target} element.
       * @config {HTMLElement}
       */
      keyEventTarget: null,
      /**
       * An optional key event processor which may preprocess the key event. Returning `null` prevents processing of the event.
       * @param {KeyboardEvent} event
       * @returns {Boolean|null}
       * @config {Function}
       */
      processEvent: null,
      /**
       * A query selector which identifies descendant elements within the {@link #config-target} which are navigable.
       * @config {String}
       */
      itemSelector: null,
      /**
       * The currently focused element within the {@link #config-target}.
       * @config {HTMLElement}
       */
      activeItem: null,
      /**
       * A CSS class name to add to focused elements.
       * @config {String}
       * @default
       */
      focusCls: "b-active",
      /**
       * An object containing key definitions keyed by the key name eg:
       *
       * ```javascript
       *  keys : {
       *      "CTRL+Space" : 'onCtrlSpace',
       *      Enter        : 'onEnterKey'
       *  }
       * ```
       *
       * The {@link #config-ownerCmp} is used as the `this` reference and to resolve string method names.
       *
       * Modified key names must be created prepending one or more `'CTRL+'`, `'SHIFT+'`, `'ALT+'`
       * in that order, for example `"CTRL+SHIFT+Enter" : 'showMenu'`
       * @config {Object<String,String>}
       * @default
       */
      keys: null,
      /**
       * Configure as `true` to also navigate when the `CTRL` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowCtrlKey: null,
      /**
       * Configure as `true` to also navigate when the `SHIFT` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowShiftKey: null,
      scrollDuration: 50,
      /**
       * Configure as, or set to `true` to disable the processing of keys.
       * @config {Boolean}
       */
      disabled: null,
      datasetIdProperty: "id",
      testConfig: {
        scrollDuration: 1
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "navigator"
    };
  }
  get activeItem() {
    const { _activeItem } = this;
    if (this.target.contains(_activeItem)) {
      return _activeItem;
    }
    this._activeItem = null;
  }
  updateOwnerCmp(ownerCmp) {
    if (!this.itemSelector) {
      this.itemSelector = `.${this.ownerCmp.itemCls}`;
    }
    DomHelper.setAttributes(this.keyEventTarget, {
      "aria-activedescendant": `${this.owner.id}-active-descendant`
    });
  }
  set navigationEvent(navigationEvent) {
    const { owner } = this;
    this._navigationEvent = owner.navigationEvent = navigationEvent;
    if (navigationEvent) {
      Promise.resolve(1).then(() => this.navigationEvent = null);
    }
  }
  get navigationEvent() {
    return this._navigationEvent;
  }
  static getComposedKeyName(keyEvent) {
    const keyName = (keyEvent.key || "").trim() || keyEvent.code;
    return `${keyEvent.ctrlKey ? "CTRL+" : ""}${keyEvent.shiftKey ? "SHIFT+" : ""}${keyEvent.altKey ? "ALT+" : ""}${keyName}`;
  }
  onKeyDown(keyEvent) {
    var _a4;
    const me = this, {
      ownerCmp,
      itemSelector,
      activeItem,
      itemsTabbable
    } = me, { target } = keyEvent, firstItem = me.target.querySelector(itemSelector), keyName = (keyEvent.key || "").trim() || keyEvent.code, composedKeyName = me.constructor.getComposedKeyName(keyEvent), validTarget = target.matches(itemSelector) || target === me.keyEventTarget;
    if (!me.disabled && me.processEvent) {
      keyEvent = me.processEvent.call(ownerCmp, keyEvent);
    }
    if (keyEvent && !me.disabled && firstItem && me.target.offsetParent && validTarget) {
      if (!itemsTabbable) {
        if (me.inlineFlow == null) {
          const itemContainer = firstItem.parentNode, itemPositionStyle = DomHelper.getStyleValue(firstItem, "position"), itemDisplayStyle = DomHelper.getStyleValue(firstItem, "display"), itemFloatStyle = DomHelper.getStyleValue(firstItem, "float");
          me.inlineFlow = itemPositionStyle === "absolute" || itemDisplayStyle === "inline" || itemDisplayStyle === "inline-block" || itemFloatStyle === "left" || itemFloatStyle === "right" || DomHelper.getStyleValue(itemContainer, "display") === "flex" && DomHelper.getStyleValue(itemContainer, "flex-direction") === "row";
        }
        if (!me.prevKey) {
          if (me.inlineFlow) {
            me.prevKey = "ArrowLeft";
            me.nextKey = "ArrowRight";
          } else {
            me.prevKey = "ArrowUp";
            me.nextKey = "ArrowDown";
          }
        }
      }
      me.navigationEvent = keyEvent;
      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigatePrevious(keyEvent);
            break;
          case me.nextKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigateNext(keyEvent);
            break;
          default: {
            const keyHandler = (_a4 = me.keys) == null ? void 0 : _a4[composedKeyName];
            if (keyHandler && !me.disabled) {
              if (me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]) === false) {
                return;
              }
            } else if (ownerCmp.onInternalKeyDown) {
              ownerCmp.onInternalKeyDown(keyEvent);
            }
            if (DomHelper.getActiveElement(target) !== target) {
              keyEvent.preventDefault();
            }
            if (itemsTabbable) {
              return;
            }
          }
        }
      } else {
        if (itemsTabbable) {
          return;
        }
        if (keyName === me.nextKey || keyName === me.prevKey) {
          me.activeItem = me.getDefaultNavigationItem(keyEvent);
        }
      }
      if (me.activeItem !== activeItem) {
        me.triggerNavigate(keyEvent);
      }
    }
  }
  getDefaultNavigationItem(keyEvent) {
    const { target, itemSelector, prevKey, nextKey } = this;
    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }
    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }
  navigatePrevious(keyEvent) {
    const me = this, previous = me.previous;
    keyEvent.preventDefault();
    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, { animate: me.scrollDuration }).then(() => {
        me.activeItem = previous;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  navigateNext(keyEvent) {
    const me = this, next = me.next;
    keyEvent.preventDefault();
    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, { animate: me.scrollDuration }).then(() => {
        me.activeItem = next;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  get owner() {
    return this.ownerCmp;
  }
  get previous() {
    return this.getAdjacent(-1);
  }
  get next() {
    return this.getAdjacent(1);
  }
  /**
   * Returns the next or previous navigable element starting from the passed `from` element,
   * navigating in the passed direction.
   * @param {HTMLElement} [from] The start point. Defaults to the current {@link #config-activeItem}
   * @param {Number} [direction=1] The direction. -1 for backwards, else forwards.
   */
  getAdjacent(direction = 1, from = this.activeItem) {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = from;
    treeWalker[direction < 0 ? "previousNode" : "nextNode"]();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }
  onTargetFocusIn(focusInEvent) {
    var _a4;
    const me = this, {
      target,
      relatedTarget
    } = focusInEvent, {
      owner,
      itemsTabbable,
      skipScrollIntoView,
      previousActiveItem
    } = me;
    if (!target.matches(".b-focus-trap")) {
      if (target.matches(me.itemSelector)) {
        me.skipScrollIntoView = true;
        me.activeItem = target;
        me.skipScrollIntoView = skipScrollIntoView;
        if (me.activeItem && itemsTabbable) {
          me.triggerNavigate(focusInEvent);
        }
      } else if (target === me.target) {
        const fromWhere = relatedTarget ? target.compareDocumentPosition(relatedTarget) : 0;
        if (fromWhere & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          (_a4 = owner.previousSibling) == null ? void 0 : _a4.focus();
        } else {
          me.activeItem = previousActiveItem && me.target.contains(previousActiveItem) ? previousActiveItem : 0;
        }
      }
    }
  }
  onTargetFocusOut(focusOutEvent) {
    const me = this, { relatedTarget } = focusOutEvent;
    if (!(relatedTarget == null ? void 0 : relatedTarget.matches(".b-focus-trap"))) {
      if (!relatedTarget || !me.target.contains(relatedTarget) || !relatedTarget.matches(me.itemSelector)) {
        if (me.activeItem) {
          me.activeItem = null;
          if (me.itemsTabbable) {
            me.triggerNavigate(focusOutEvent);
          }
        }
      }
    }
  }
  onTargetMouseDown(mouseDownEvent) {
    const me = this, target = mouseDownEvent.target.closest(me.itemSelector);
    me.navigationEvent = mouseDownEvent;
    if (me.itemsTabbable) {
      if (target === me.activeItem) {
        me.triggerNavigate(mouseDownEvent);
      }
    } else if (me.ownerCmp.itemsFocusable === false) {
      me.onFocusGesture(mouseDownEvent);
    } else if (target) {
      mouseDownEvent.preventDefault();
      target.focus({ preventScroll: true });
    }
  }
  onTargetClick(clickEvent) {
    var _a4;
    const me = this, { skipScrollIntoView } = me;
    if (me.skipNextClick || ((_a4 = me.navigationEvent) == null ? void 0 : _a4.ignoreNavigation)) {
      me.skipNextClick = false;
      return;
    }
    if (me.disabled) {
      return;
    }
    me.skipScrollIntoView = true;
    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }
    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.triggerNavigate(clickEvent);
    }
    me.skipScrollIntoView = skipScrollIntoView;
  }
  // We have to prevent focus moving from eg, an input field when we mousedown
  // or touchtap a non focusable item when ownerCmp has itemsFocusable: false.
  // If the event was not on an item, we must allow it through to allow Lists
  // to contain other widgets.
  onFocusGesture(event) {
    if (event.target === this.ownerCmp.contentElement || event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false) {
      event.preventDefault();
    }
  }
  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
  }
  changeActiveItem(activeItem) {
    if (activeItem != null) {
      if (this.ownerCmp.getItem) {
        activeItem = this.ownerCmp.getItem(activeItem);
      }
    }
    return activeItem;
  }
  updateActiveItem(activeItem, oldActiveItem) {
    var _a4;
    const me = this, { ownerCmp } = me, isActive = oldActiveItem && me.target.contains(oldActiveItem), needsFocus = activeItem && DomHelper.isFocusable(activeItem) && activeItem !== DomHelper.getActiveElement(activeItem);
    if (isActive) {
      me.previousActiveItem = oldActiveItem;
    }
    if (oldActiveItem) {
      oldActiveItem.classList.remove(me.focusCls);
      oldActiveItem.removeAttribute("id");
    }
    if (activeItem != null) {
      if (me.skipScrollIntoView) {
        if (needsFocus) {
          activeItem.focus({ preventScroll: true });
        }
      } else {
        (_a4 = ownerCmp.scrollable) == null ? void 0 : _a4.scrollIntoView(activeItem, {
          block: "nearest",
          focus: needsFocus,
          silent: me.scrollSilently
        });
      }
      if (activeItem === oldActiveItem && isActive) {
        return;
      }
      activeItem.classList.add(me.focusCls);
      activeItem.id = `${me.owner.id}-active-descendant`;
      me._activeItem = activeItem;
    } else {
      me._activeItem = null;
      if (oldActiveItem === DomHelper.getActiveElement(oldActiveItem)) {
        ownerCmp.revertFocus();
      }
    }
  }
  updateTarget(target, oldTarget) {
    const me = this, listeners = {
      element: target,
      thisObj: me,
      focusin: "onTargetFocusIn",
      focusout: "onTargetFocusOut",
      // If items are tabbable the mousedown handler will not force the issue by focusing
      // the closest item. We just need to trigger the method so that it is hookable
      mousedown: {
        handler: "onTargetMouseDown",
        delegate: me.itemSelector
      }
    };
    if (!me.itemsTabbable && !me.itemsFocusable) {
      listeners.click = "onTargetClick";
    }
    if (!Object.prototype.hasOwnProperty.call(me, "acceptNode")) {
      me.acceptNode = me.acceptNode.bind(me);
      me.acceptNode.acceptNode = me.acceptNode;
    }
    EventHelper.on(listeners);
    me.treeWalker = me.setupTreeWalker(target, DomHelper.NodeFilter.SHOW_ELEMENT, me.acceptNode);
    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }
    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true,
      subtree: true
    });
  }
  setupTreeWalker(root, whatToShow, filter) {
    return document.createTreeWalker(root, whatToShow, filter);
  }
  onTargetChildListChange() {
    var _a4;
    const me = this, {
      activeItem,
      datasetIdProperty
    } = me;
    if (activeItem) {
      if (me.target.contains(activeItem)) {
        if (!activeItem.classList.contains(me.focusCls)) {
          activeItem.classList.add(me.focusCls);
        }
      } else {
        me.activeItem = me.target.querySelector(`${me.itemSelector}.${me.focusCls}[data-${StringHelper.hyphenate(datasetIdProperty)}="${activeItem.dataset[datasetIdProperty]}"]`) || ((_a4 = me.target.querySelector(`${me.itemSelector}.${me.focusCls}`)) == null ? void 0 : _a4[activeItem.dataset.index]) || null;
      }
    }
  }
  changeKeyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;
    EventHelper.on({
      element: keyEventTarget,
      keydown: "onKeyDown",
      thisObj: this
    });
  }
  triggerNavigate(event, item = this.activeItem) {
    var _a4;
    const navEvent = {
      event,
      item,
      oldItem: this.previousActiveItem
    };
    this.trigger("navigate", navEvent);
    (_a4 = this.ownerCmp) == null ? void 0 : _a4.trigger("navigate", navEvent);
  }
};
Navigator._$name = "Navigator";

// ../Core/lib/Core/util/WebSocketManager.js
var WebSocketManager = class extends Events_default(Base) {
  construct(config = {}) {
    const me = this;
    super.construct(config);
    me.onWsOpen = me.onWsOpen.bind(me);
    me.onWsClose = me.onWsClose.bind(me);
    me.onWsMessage = me.onWsMessage.bind(me);
    me.onWsError = me.onWsError.bind(me);
    if (me.autoConnect && me.address) {
      me.open();
    }
  }
  doDestroy() {
    const me = this;
    if (me.connector) {
      me.detachSocketListeners(me.connector);
      me.connector.close();
      me.connector = null;
    }
    super.doDestroy();
  }
  //#region Websocket state
  get isConnecting() {
    var _a4;
    return ((_a4 = this.connector) == null ? void 0 : _a4.readyState) === this.constructor.webSocketImplementation.CONNECTING;
  }
  get isOpened() {
    var _a4;
    return ((_a4 = this.connector) == null ? void 0 : _a4.readyState) === this.constructor.webSocketImplementation.OPEN;
  }
  get isClosing() {
    var _a4;
    return ((_a4 = this.connector) == null ? void 0 : _a4.readyState) === this.constructor.webSocketImplementation.CLOSING;
  }
  get isClosed() {
    var _a4;
    return ((_a4 = this.connector) == null ? void 0 : _a4.readyState) === this.constructor.webSocketImplementation.CLOSED;
  }
  //#endregion
  //#region Websocket init
  createWebSocketConnector() {
    const connector = this.connector = new this.constructor.webSocketImplementation(this.address);
    this.attachSocketListeners(connector);
  }
  destroyWebSocketConnector() {
    this.detachSocketListeners(this.connector);
    this.connector.close();
    this.connector = null;
  }
  attachSocketListeners(connector) {
    const me = this;
    connector.addEventListener("open", me.onWsOpen);
    connector.addEventListener("close", me.onWsClose);
    connector.addEventListener("message", me.onWsMessage);
    connector.addEventListener("error", me.onWsError);
  }
  detachSocketListeners(connector) {
    const me = this;
    connector.removeEventListener("open", me.onWsOpen);
    connector.removeEventListener("close", me.onWsClose);
    connector.removeEventListener("message", me.onWsMessage);
    connector.removeEventListener("error", me.onWsError);
  }
  //#endregion
  //#region Websocket methods
  /**
   * Connect to the server and start listening for messages
   * @returns {Promise} Returns true if connection was successful and false otherwise
   */
  async open() {
    const me = this;
    if (me._openPromise) {
      return me._openPromise;
    }
    if (!me.address) {
      console.warn("Server me.address cannot be empty");
      return;
    }
    if (me.isOpened) {
      return true;
    }
    me.createWebSocketConnector();
    let detacher2;
    me._openPromise = new Promise((resolve) => {
      detacher2 = me.ion({
        open() {
          resolve(true);
        },
        error() {
          resolve(false);
        }
      });
    }).then((value) => {
      detacher2();
      me._openPromise = null;
      if (!value) {
        me.destroyWebSocketConnector();
      }
      return value;
    }).catch(() => {
      me._openPromise = null;
      me.destroyWebSocketConnector();
    });
    return me._openPromise;
  }
  /**
   * Close socket and disconnect from the server
   */
  close() {
    if (this.connector) {
      this.destroyWebSocketConnector();
      this.trigger("close");
    }
  }
  /**
   * Send data to the websocket server
   * @param {String} command
   * @param {*} data
   */
  send(command, data = {}) {
    var _a4;
    (_a4 = this.connector) == null ? void 0 : _a4.send(JSON.stringify({ command, ...data }));
  }
  //#endregion
  //#region websocket event listeners
  onWsOpen(event) {
    this.trigger("open", { event });
  }
  onWsClose(event) {
    this.trigger("close", { event });
  }
  onWsMessage(message) {
    try {
      const data = JSON.parse(message.data);
      this.trigger("message", { data });
    } catch (error) {
      this.trigger("error", { error });
    }
  }
  onWsError(error) {
    this.trigger("error", { error });
  }
  //#endregion
};
// This allows to hook into for testing purposes
__publicField(WebSocketManager, "webSocketImplementation", typeof WebSocket === "undefined" ? null : WebSocket);
__publicField(WebSocketManager, "configurable", {
  /**
   * WebSocket server address
   * @config {String}
   */
  address: "",
  /**
   * User name allowing to identify client
   * @config {String}
   */
  userName: "User",
  /**
   * Connect to websocket server immediately after instantiation
   * @config {Boolean}
   */
  autoConnect: true
});
WebSocketManager._$name = "WebSocketManager";

// ../Core/lib/Core/mixin/Clipboardable.js
var Clipboard = class extends Base.mixin(Events_default) {
  constructor() {
    super(...arguments);
    // Defaults to true, so to set this lazy on first read/write
    __publicField(this, "hasNativeAccess", true);
    __publicField(this, "_content", null);
  }
  /**
   * Write to the native Clipboard API or a local clipboard as a fallback.
   * @param {String} text Only allows string values
   * @param {Boolean} allowNative `true` will try writing to the Clipboard API once
   * @private
   */
  async writeText(text, allowNative) {
    const me = this, { _content } = me;
    if (allowNative && me.hasNativeAccess) {
      try {
        await navigator.clipboard.writeText(text);
      } catch (e) {
        me.hasNativeAccess = false;
      }
    }
    if (_content !== text) {
      me._content = text;
      me.triggerContentChange(_content, false, true);
    }
  }
  /**
   * Reads from the native Clipboard API or a local clipboard as a fallback.
   * @param {Boolean} allowNative `true` will try reading from the Clipboard API once
   * @private
   */
  async readText(allowNative) {
    const me = this, { _content } = me;
    if (allowNative && me.hasNativeAccess) {
      try {
        const text = await navigator.clipboard.readText();
        if (_content !== text) {
          me._content = text;
          me.triggerContentChange(_content, true);
        }
        return text;
      } catch (e) {
        me.hasNativeAccess = false;
      }
    }
    return _content;
  }
  /**
   * Call this to let other instances know that data has been pasted
   * @param {Object} source
   */
  triggerPaste(source) {
    this.trigger("paste", { source, text: this._content });
  }
  triggerContentChange(oldText, fromRead = false, fromWrite = false) {
    this.trigger("contentChange", { fromRead, fromWrite, oldText, newText: this._content });
  }
  async clear(allowNative) {
    await this.writeText("", allowNative);
  }
};
var Clipboardable_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    construct(...args) {
      super.construct(...args);
      if (!globalThis.bryntum.clipboard) {
        globalThis.bryntum.clipboard = new Clipboard();
      }
      globalThis.bryntum.clipboard.ion({
        paste: "onClipboardPaste",
        contentChange: "onClipboardContentChange",
        thisObj: this
      });
    }
    /**
     * Gets the current shared Clipboard instance
     * @private
     */
    get clipboard() {
      return globalThis.bryntum.clipboard;
    }
    // Called when someone triggers a paste event on the shared Clipboard
    onClipboardPaste({ text, source }) {
      var _a5;
      const me = this, { clipboardText, isCut } = me, isOwn = me.compareClipboardText(clipboardText, text);
      if (isOwn && isCut) {
        (_a5 = me.handleCutData) == null ? void 0 : _a5.call(me, { text, source });
        me.isCut = false;
        me.cutData = null;
      } else if (!isOwn) {
        me.clearClipboard(false);
      }
    }
    // Calls when the shared clipboard writes or reads a new string value
    onClipboardContentChange({ newText }) {
      if (!this.compareClipboardText(this.clipboardText, newText)) {
        this.clearClipboard(false);
      }
    }
    // When a cut is done, or a cut is deactivated
    set cutData(data) {
      var _a5, _b;
      const me = this;
      (_a5 = me._cutData) == null ? void 0 : _a5.forEach((r) => me.setIsCut(r, false));
      me._cutData = ArrayHelper.asArray(data);
      (_b = me._cutData) == null ? void 0 : _b.forEach((r) => me.setIsCut(r, true));
    }
    get cutData() {
      return this._cutData;
    }
    setIsCut() {
    }
    /**
     * Writes string data to the shared/native clipboard. Also saves a local copy of the string and the unconverted
     * data.
     *
     * But firstly, it will call beforeCopy function and wait for a response. If false, the copy will be prevented.
     *
     * @param {Object} data
     * @param {Boolean} isCut
     * @param {Object} [params] Will be passed to beforeCopy function
     * @returns {String} String data that was written to the clipboard
     * @private
     */
    async writeToClipboard(data, isCut, params = {}) {
      if (await this.beforeCopy({ data, isCut, ...params }) === false) {
        return;
      }
      const me = this, isString = typeof data === "string", stringData = isString ? data : me.stringConverter ? me.stringConverter(data) : StringHelper.safeJsonStringify(data);
      me.clipboardText = stringData;
      await me.clipboard.writeText(stringData, me.useNativeClipboard);
      me.clipboardData = data;
      me.isCut = isCut;
      me.cutData = isCut && !isString ? data : null;
      return stringData;
    }
    /**
     * Reads string data from the shared/native clipboard. If string matches current instance local clipboard data, a
     * non-modified version will be return. Otherwise, a stringParser function will be called.
     *
     * But firstly, it will call beforePaste function and wait for a response. If false, the paste will be prevented.
     *
     * This function will also trigger a paste event on the clipboard instance.
     *
     * @param {Object} [params] Will be passed to beforePaste function
     * @param {Boolean} [skipPasteTrigger] Set to `true` not trigger a paste when paste completes
     * @returns {Object}
     * @private
     */
    async readFromClipboard(params = {}, skipPasteTrigger = false) {
      var _a5;
      const me = this, { clipboard } = me, text = await clipboard.readText(me.useNativeClipboard), { isOwn, data } = me.transformClipboardText(text), isCut = text && isOwn && me.isCut;
      if (data == null || Array.isArray(data) && data.length == 0 || // Hook to trigger event or something like that
      await ((_a5 = me.beforePaste) == null ? void 0 : _a5.call(me, { data, text, ...params, isCut })) === false) {
        return;
      }
      if (!isOwn) {
        me.clearClipboard(false);
      }
      skipPasteTrigger || clipboard.triggerPaste(me);
      return data;
    }
    /**
     * Clears the clipboard data
     * @privateparam {Boolean} [clearShared] Set to `false` not to clear the internally shared and native clipboard
     * @category Common
     */
    async clearClipboard(clearShared = true) {
      const me = this;
      me.clipboardData = me.clipboardText = me.cutData = null;
      me.isCut = false;
      if (clearShared) {
        await me.clipboard.clear(me.useNativeClipboard);
      }
    }
    compareClipboardText(a, b) {
      const regex = /\r\n|(?!\r\n)[\n-\r\x85\u2028\u2029]/g;
      return (a == null ? void 0 : a.replace(regex, "\n")) === (b == null ? void 0 : b.replace(regex, "\n"));
    }
    /**
     * Takes a clipboard text and returns an object with an `isOwn` property and the parsed `data`
     * @param {String} text The text string that was read from the clipboard
     * @returns {Object}
     * @private
     */
    transformClipboardText(text) {
      const me = this, isOwn = me.compareClipboardText(me.clipboardText, text), data = isOwn ? me.clipboardData : me.stringParser && text ? me.stringParser(text) : text;
      return {
        isOwn,
        data
      };
    }
    /**
     * Checks local clipboard if there is clipboard data present. If native clipboard API is available, this function
     * will return `undefined`
     * @returns {Object}
     * @private
     */
    hasClipboardData() {
      const { clipboard } = this, { _content } = clipboard;
      if (this.useNativeClipboard && clipboard.hasNativeAccess) {
        return;
      }
      return Boolean(_content && this.transformClipboardText(_content).data);
    }
  }, __publicField(_a4, "$name", "Clipboardable"), __publicField(_a4, "configurable", {
    /**
     * Set this to `true` to use native Clipboard API if it is available
     * @config {Boolean}
     * @default
     * @private
     */
    useNativeClipboard: false
  }), _a4;
};

// ../Core/lib/Core/mixin/Finalizable.js
var Finalizable_default = (Target) => class Finalizable extends (Target || Base) {
  static get $name() {
    return "Finalizable";
  }
  construct(...args) {
    super.construct(...args);
    this.finalizer = null;
    this.finalizing = null;
    this.isFinalized = false;
    this.isFinalizing = false;
  }
  /**
   * This template method is called at the end of {@link #function-finalize}. By default it calls `destroy()`, but
   * can be replaced by the derived class. This can be useful if it is not the `Finalizable` instance that awaits
   * the {@link #function-finalize} method.
   */
  doFinalize() {
    this.destroy();
  }
  /**
   * This method is called (typically by this instance or its owner) to cleanup this instance while possibly first
   * waiting for the {@link #property-finalizer} promise to settle. Once settled, the {@link #function-doFinalize}
   * method is called.
   * @async
   */
  finalize() {
    const me = this;
    let ret = me.finalizing;
    if (!ret && !me.isFinalized) {
      me.isFinalizing = true;
      me.finalizing = ret = me._awaitFinalizer();
    }
    return ret;
  }
  async _awaitFinalizer() {
    const me = this;
    try {
      await me.finalizer;
    } finally {
      me.finalizing = null;
      me.isFinalized = true;
      me.doFinalize();
    }
  }
};

// ../Core/lib/Core/util/drag/DragContext.js
var ABORTED = Symbol("dragAbort");
var INIT = Symbol("dragInit");
var DRAGGING = Symbol("dragDrag");
var DROPPED = Symbol("dragDrop");
var lockDirections = {
  x: "horizontal",
  y: "vertical"
};
var DragContext = class extends Base.mixin(Finalizable_default, Delayable_default, Identifiable_default) {
  static get configurable() {
    return {
      /**
       * The element that will have the {@link Core.mixin.Draggable#property-draggingItemCls}. This element is
       * determined by the {@link Core.mixin.Draggable#config-dragItemSelector}.
       * @config {HTMLElement}
       */
      itemElement: null,
      /**
       * The `ScrollManager` instance to use for scrolling while dragging.
       * @config {Core.util.ScrollManager}
       * @private
       */
      scrollManager: null,
      /**
       * Config for `startMonitoring` call.
       * @config {Object}
       * @private
       */
      monitoringConfig: null,
      /**
       * The source of the drag operation.
       * @config {Core.mixin.Draggable}
       * @default
       * @readonly
       * @private
       */
      source: null,
      /**
       * The current target of the drag.
       * @member {Core.mixin.Droppable}
       * @readonly
       * @private
       */
      target: null,
      /**
       * The current target element of the drag.
       * @member {HTMLElement}
       * @private
       */
      targetElement: null,
      /**
       * The minimum distance from the touchstart/mousedown/pointerdown that must be moved to actually start a
       * drag operation.
       * @config {Number}
       * @default
       * @readonly
       */
      threshold: 5,
      /**
       * The minimum amount of time a touch must be maintained before it will initiate a drag. Movement prior to
       * this time will cancel the drag in order to allow touch scrolling.
       * @config {Number}
       * @default
       */
      touchStartDelay: 300
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * The current DOM event being processed.
   * @member {Event} event
   * @readonly
   */
  construct(...args) {
    super.construct(...args);
    const me = this, { event } = me;
    Object.assign(me, {
      /**
       * This property holds the `altKey` state of the most recent event.
       * @member {Boolean}
       */
      altKey: null,
      /**
       * An array of functions to call when cleaning up the context instance.
       * @member {Function[]}
       * @private
       */
      cleaners: [],
      /**
       * This property holds the `ctrlKey` state of the most recent event.
       * @member {Boolean}
       */
      ctrlKey: null,
      /**
       * Container for data associated with the drag. Data items are added by the {@link Core.mixin.Draggable}
       * when the drag starts.
       * @member {Map}
       * @private
       */
      data: /* @__PURE__ */ new Map(),
      /**
       * The element from which the drag operation started.
       * @member {HTMLElement}
       * @readonly
       */
      element: event.target,
      /**
       * The event that completed the drag (a `mouseup`, `pointerup` or `touchend`).
       * @member {Event}
       * @readonly
       */
      endEvent: null,
      /**
       * The most recent `mousemove`, `pointermove` or `touchmove` event.
       * @member {Event}
       * @private
       */
      lastMoveEvent: null,
      /**
       * This property holds the `metaKey` state of the most recent event.
       * @member {Boolean}
       */
      metaKey: null,
      /**
       * The previous {@link #property-target} of the drag.
       * @member {Core.mixin.Droppable}
       * @readonly
       * @private
       */
      previousTarget: null,
      /**
       * The scroll actions reported by the {@link #config-scrollManager}.
       * @member {Object}
       * @private
       */
      scrollerAction: null,
      /**
       * This property holds the `shiftKey` state of the most recent event.
       * @member {Boolean}
       */
      shiftKey: null,
      /**
       * This property holds the current state of the drag process.
       *
       * This will be one of the following values:
       *
       *  - `DragContext.STATE.INIT` - The button is down but there is insufficient movement to start the drag.
       *  - `DragContext.STATE.DRAGGING` - The button is down and movement has started the drag.
       *  - `DragContext.STATE.DROPPED` - The button has been released and drop has occurred.
       *  - `DragContext.STATE.ABORTED` - The drag has been aborted (this happens if the user presses the `ESC`
       *    key or if the {@link #function-abort} method is called).
       *
       * @member {Symbol}
       * @readonly
       * @internal
       */
      state: INIT,
      /**
       * The event that started the drag operation.
       * @member {Event}
       * @readonly
       */
      startEvent: event,
      /**
       * The timer that fires when a touch pointermove is allowed to start the drag. A touch pointermove event
       * prior to this will `abort()` the drag to allow touch scrolling.
       * @member {Number}
       * @private
       */
      touchStartTimer: null,
      /**
       * Stores the value from writes to the {@link #property-valid} property.
       * @member {Boolean}
       * @private
       */
      _valid: true
    });
    if ("touches" in event && me.touchStartDelay) {
      me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
    }
    EventHelper.on({
      element: globalThis,
      blur: "onWindowBlur",
      thisObj: me,
      autoDetach: true
    });
  }
  doDestroy() {
    const me = this, { source, target } = me;
    me.cleanup();
    if ((target == null ? void 0 : target.dropping) === me) {
      target.dropping = null;
    }
    if ((source == null ? void 0 : source.dragging) === me) {
      source.dragging = null;
    }
    super.doDestroy();
  }
  onWindowBlur() {
    if (this.started && !this.completed) {
      this.abort();
    }
  }
  /**
   * This property is `true` if the {@link #function-abort} method was called and `false` otherwise. This
   * is typically because the user pressed the ESC key, however, a drag can be aborted for other reasons.
   * @property {Boolean}
   * @readonly
   */
  get aborted() {
    return this.state === ABORTED;
  }
  /**
   * Returns `true` if the drag has completed either by mouse/pointerup or the {@link #function-abort} method.
   * @property {Boolean}
   * @readonly
   */
  get completed() {
    return this.isDestroying || this.aborted || this.endEvent !== null;
  }
  /**
   * This property is `true` if the drag {@link #config-threshold} has not yet been reached.
   * @property {Boolean}
   * @readonly
   */
  get pending() {
    return this.state === INIT;
  }
  /**
   * This property is `true` if the drag {@link #config-threshold} has been reached and the drag operation is active.
   * @property {Boolean}
   * @readonly
   */
  get started() {
    return this.state !== INIT && !this.aborted;
  }
  /**
   * This property is `true` when the drag is in a valid drop state. This can be set to `false` to indicate the drop
   * is invalid. Setting to `true` does not ensure that the property will be `true` when next read due to other factors
   * that are required to make the drop valid. For example, setting `valid = true` will still return `false` if called
   * before the drag {@link #config-threshold} has not been reached or if the {@link #function-abort} method has been
   * called.
   * @property {Boolean}
   */
  get valid() {
    return this.started && this.targetElement != null && this._valid;
  }
  set valid(v) {
    this._valid = v;
  }
  //region Data Access
  /**
   * Retrieves a data item from the drag source. This method can only be called after the drag has completed.
   * @param {String|String[]} name The name of the data item.
   * @returns {*}
   */
  async get(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (!this.completed) {
      throw new Error("Data is not available until drag completion");
    }
    if (Array.isArray(name)) {
      return Promise.all(name.map((s) => this.get(s)));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = await value();
      this.data.set(name, value);
    }
    return value;
  }
  /**
   * Returns `true` if the named data item is present.
   * @param {String} name The name of the data item.
   * @returns {Boolean}
   */
  has(name) {
    return this.data.has(name);
  }
  /**
   * Retrieves a data item from the drag source if it is available. This will return `true` for an item that was
   * {@link #function-set} using a renderer function.
   * @param {String|String[]} name The name of the data item.
   * @returns {*}
   */
  peek(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (Array.isArray(name)) {
      return name.map((s) => this.peek(s));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = true;
    }
    return value;
  }
  /**
   * Sets a data item for the drag. If a function is passed, it is called to render the data only if that data is
   * actually requested via the {@link #function-get} method. A data renderer function can be `async`.
   * @param {String} name The name of the data item.
   * @param {*} value The value of the data item.
   */
  set(name, value) {
    this.data.set(name, value);
  }
  //endregion
  //region Configs
  changeTarget(target, was) {
    if (target !== was) {
      const me = this;
      me._target = target;
      me.previousTarget = was;
      if (was) {
        was.dropping = null;
      }
      if (target) {
        target.dropping = me;
        if (target.dropping !== me) {
          target = null;
          me.valid = false;
        }
      }
      me._target = was;
    }
    return target;
  }
  updateTarget(target, was) {
    const me = this;
    if (was) {
      me.source.dragLeaveTarget(me, was);
    }
    if (target) {
      me.valid = true;
      target.dragMove(me);
      me.source.dragEnterTarget(me);
    }
  }
  updateTargetElement(targetElement) {
    let droppable, droppables, droppableSelector, i, t;
    for (t = targetElement; t; t = t.parentElement) {
      droppables = DomDataStore.get(t, "droppables");
      if (droppables) {
        for (i = 0; i < droppables.length; ++i) {
          droppable = droppables[i];
          if (droppable.dropRootElement.contains(targetElement)) {
            droppableSelector = droppable.droppableSelector;
            if (!droppableSelector || targetElement.closest(`#${DomHelper.getId(droppable.dropRootElement)} ${droppableSelector}`)) {
              this.target = droppable;
              if (this.target === droppable) {
                return;
              }
            }
          }
        }
      }
    }
  }
  //endregion
  //region Operations
  /**
   * Aborts the drag. After calling this method, {@link #property-aborted} will be `true`, {@link #property-valid}
   * will be `false` and {@link #property-completed} will be `true`.
   */
  abort() {
    const me = this, { element, source } = me;
    element == null ? void 0 : element.getBoundingClientRect();
    if (me.state !== DROPPED) {
      me.state = ABORTED;
      me.cleanup();
    }
    source == null ? void 0 : source.endDrag(me);
  }
  begin() {
    const me = this, { source } = me, ret = source.beforeDrag(me);
    if (ret !== false) {
      source.dragging = me;
    }
    return ret;
  }
  cleanup() {
    let cleaner;
    while (cleaner = this.cleaners.pop()) {
      cleaner();
    }
  }
  end(event) {
    const me = this, { lastMoveEvent: lastEvent, target } = me, { dragSwallowClickTime } = me.source;
    me.event = me.domEvent = me.endEvent = event;
    me.syncFlags();
    if (me.started) {
      if ((lastEvent == null ? void 0 : lastEvent.clientX) !== event.clientX || (lastEvent == null ? void 0 : lastEvent.clientY) !== event.clientY || (lastEvent == null ? void 0 : lastEvent.target) !== event.target) {
        me.track();
      }
      if (dragSwallowClickTime) {
        EventHelper.on({
          element: document,
          capture: true,
          expires: dragSwallowClickTime,
          // In case a click did not ensue, remove the listener
          once: true,
          click(event2) {
            event2.stopPropagation();
          }
        });
      }
      me.state = DROPPED;
      if (target !== me.source) {
        target == null ? void 0 : target.dragDrop(me);
      }
    }
  }
  fakeKey(event, down) {
    const me = this, { lastMoveEvent } = me;
    if (lastMoveEvent && me.element) {
      let changed;
      lastMoveEvent.isKey = true;
      if (event.key === "Alt") {
        if (me.altKey !== down) {
          me.altKey = down;
          changed = true;
        }
      } else if (event.key === "Control") {
        if (me.ctrlKey !== down) {
          me.ctrlKey = down;
          changed = true;
        }
      }
      if (changed) {
        me.event = me.domEvent = lastMoveEvent;
        me.track();
      }
    }
  }
  keyDown(event) {
    if (!this.completed) {
      if (event.key === "Escape") {
        this.abort();
      } else if (this.isDragToggleKey(event.key)) {
        this.fakeKey(event, true);
      }
    }
  }
  keyUp(event) {
    if (!this.completed && this.isDragToggleKey(event.key)) {
      this.fakeKey(event, false);
    }
  }
  getDistance(event) {
    return EventHelper.getDistanceBetween(this.startEvent, event);
  }
  isDragToggleKey(key) {
    return key === "Control" || key === "Alt";
  }
  move(event) {
    const me = this, { target } = event, distance = me.getDistance(event), significant = distance >= me.threshold;
    me.syncFlags();
    if (me.touchStartTimer) {
      if (significant) {
        me.abort();
      }
      return;
    }
    if (target && target.nodeType === Node.ELEMENT_NODE) {
      if (significant && !me.started) {
        me.event = me.domEvent = event;
        if (me.start() === false) {
          me.abort();
          return;
        }
      }
      if (event.touches) {
        me.startEvent.preventDefault();
        event.preventDefault();
        event.cancelBubble = true;
      }
      if (me.started && !me.completed) {
        me.lastMoveEvent = me.event = me.domEvent = event;
        if (event.type === "touchmove") {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
        me.track();
      }
    }
  }
  start() {
    const me = this, { scrollManager, monitoringConfig, source } = me, { draggingBodyCls: activeCls, dragLock } = source, element = (
      /* source.dragWithin || */
      source.dragRootElement
    );
    me.state = DRAGGING;
    if (scrollManager) {
      const detacher2 = scrollManager.startMonitoring(Objects.merge({
        scrollables: [{
          element
        }],
        direction: lockDirections[dragLock] || dragLock || "both",
        callback(scrollerAction) {
          const { lastMoveEvent } = me;
          if (lastMoveEvent && me.element) {
            lastMoveEvent.isScroll = true;
            me.event = me.domEvent = lastMoveEvent;
            me.scrollerAction = scrollerAction;
            me.track();
            me.scrollerAction = null;
          }
        }
      }, monitoringConfig));
      me.cleaners.push(detacher2);
    }
    const rootEl = source.dragRootElement.closest(".b-outer") || document.body;
    rootEl.classList.add(activeCls);
    me.cleaners.push(() => rootEl.classList.remove(activeCls));
    if (source.startDrag(me) === false) {
      me.cleanup();
      return false;
    }
  }
  syncFlags() {
    const me = this, { event } = me;
    me.altKey = event.altKey;
    me.ctrlKey = event.ctrlKey || event.metaKey;
    me.metaKey = event.metaKey;
    me.shiftKey = event.shiftKey;
  }
  track() {
    const me = this, { event, source, target } = me;
    let targetElement = event.target, touch;
    if (event.type === "touchmove") {
      touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    }
    me.targetElement = targetElement;
    if (target === me.target) {
      target == null ? void 0 : target.dragMove(me);
    }
    source.trackDrag(me);
  }
  //endregion
};
__publicField(DragContext, "$name", "DragContext");
DragContext.prototype.STATE = DragContext.STATE = Object.freeze({
  ABORTED,
  INIT,
  DRAGGING,
  DROPPED
});
DragContext._$name = "DragContext";

// ../Core/lib/Core/util/drag/DragProxy.js
var DragProxy = class _DragProxy extends Base.mixin(Factoryable_default) {
  static get type() {
    return "default";
  }
  static get configurable() {
    return {
      /**
       * The currently active `DragContext`. This context will be active prior to be passed to the proxy. This
       * config is set by {@link #function-dragStart} and cleared by {@link #function-dragEnd}.
       * @config {Core.util.drag.DragContext}
       */
      dragging: null
    };
  }
  static get factoryable() {
    return {
      defaultType: _DragProxy
    };
  }
  /**
   * The `Draggable` instance that owns this drag proxy.
   * @member {Core.mixin.Draggable} owner
   * @readonly
   */
  //region Configs
  updateDragging(drag, was) {
    if (was) {
      this.close(was);
    }
    if (drag) {
      this.open(drag);
    }
  }
  //endregion
  //region Operations
  /**
   * This template method is called when {@link #config-dragging} is reset to `null`.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  close(drag) {
  }
  /**
   * This template method is called when {@link #config-dragging} is set to a non-`null` value.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  open(drag) {
  }
  //endregion
  //region Drag Processing
  /**
   * This template method is called by the `Draggable` instance when the drag officially starts.
   * This sets the {@link #config-dragging} config to `drag`, which triggers the call to {@link #function-open}.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  dragStart(drag) {
    this.dragging = drag;
  }
  /**
   * This template method is called by the `Draggable` instance as drag movement occurs.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  dragMove(drag) {
  }
  /**
   * This template method is called by the `Draggable` instance when the drag completes.
   *
   * This sets the {@link #config-dragging} config to `null`, which triggers the call to {@link #function-close}.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  dragEnd(drag) {
    this.dragging = null;
  }
  //endregion
};
DragProxy.initClass();
DragProxy._$name = "DragProxy";

// ../Core/lib/Core/mixin/Draggable.js
var Draggable_default = (Target) => class Draggable extends (Target || Base) {
  static get $name() {
    return "Draggable";
  }
  //region Configs
  static get configurable() {
    return {
      /**
       * The current `DragContext`. This is created immediately on pointerdown but does not become active until
       * some movement occurs. This {@link #config-dragThreshold threshold} is configurable.
       * @member {Core.util.drag.DragContext}
       * @readonly
       */
      dragging: {
        $config: "nullify",
        value: null
      },
      /**
       * A CSS selector to use to ascend from the {@link #config-dragRootElement} to find the element that will
       * gain the {@link #property-draggingCls} and {@link #property-draggingStartedCls} CSS classes.
       * @config {String}
       */
      draggingClsSelector: null,
      /**
       * The listeners to add to the `document` during a drag.
       * @config {Object}
       * @private
       */
      dragDocumentListeners: {
        element: document,
        keydown: "onDragKeyDown",
        keyup: "onDragKeyUp",
        // On mobile, a long-press will (sometimes) trigger a context menu, so we suppress it:
        contextmenu: "onDragContextMenu",
        // We don't use pointermove/up because they get snared in the "touch-action" vs "pan-x/y" trap and we
        // cannot prevent panning (aka scrolling) in response to move events if we go that way:
        mousemove: "onDragPointerMove",
        mouseup: "onDragPointerUp",
        // Touch desktops don't fire touchend event when touch has ended, instead pointerup is fired. iOS does
        // fire touchend:
        pointerup: "onDragPointerUp",
        touchend: "onDragPointerUp",
        touchmove: {
          handler: "onDragPointerMove",
          passive: false
          // We need to be able to preventDefault on the touchmove
        }
      },
      /**
       * A CSS selector to use to ascend from the drag element to find the element that will gain the
       * {@link #property-draggingItemCls} CSS class. If not supplied, the drag element will gain this CSS
       * class.
       * @config {String}
       */
      dragItemSelector: null,
      /**
       * A CSS class to add to items identified by the {@link #config-dragItemSelector} when the mouse
       * enters.
       * @config {String}
       */
      dragItemOverCls: null,
      /**
       * A function to call when the pointer enters a {@link #config-dragItemSelector}.
       * @config {Function} onDragItemMouseEnter
       * @param {MouseEvent} event Pointer event
       * @param {HTMLElement} element Over element
       * @returns {void}
       */
      /**
       * A function to call when the pointer moves inside a {@link #config-dragItemSelector}.
       * @config {Function} onDragItemMouseMove
       * @param {MouseEvent} event Pointer event
       * @param {HTMLElement} element Over element
       * @returns {void}
       */
      /**
       * A function to call when the pointer leaves a {@link #config-dragItemSelector}.
       * @config {Function} onDragItemMouseLeave
       * @param {MouseEvent} event Pointer event
       * @param {HTMLElement} element Over element
       * @returns {void}
       */
      /**
       * Configure as `'x'` to lock dragging to the `X` axis (the drag will only move horizontally) or `'y'`
       * to lock dragging to the `Y` axis (the drag will only move vertically).
       * @config {'x'|'y'|null}
       */
      dragLock: null,
      /**
       * The minimum distance a drag must move to be considered a drop and not
       * {@link Core.util.drag.DragContext#property-aborted}.
       * @config {Number}
       * @default
       */
      dragMinDistance: 1,
      /**
       * The {@link Core.util.drag.DragProxy drag proxy} is a helper object that can be used to display feedback
       * during a drag.
       * @config {DragProxyConfig|Core.util.drag.DragProxy}
       */
      dragProxy: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * The outer element where dragging will operate (attach events to it and use as root limit when looking
       * for ancestors).
       * @config {HTMLElement}
       */
      dragRootElement: {
        $config: "nullify",
        value: null
      },
      /**
       * Set to `true` to allow a drag to drop on to the same element from which the drag started.
       * @config {Boolean}
       * @default
       */
      dragSameTargetDrop: false,
      /**
       * A CSS selector used to determine which element(s) can be dragged.
       * @config {String}
       * @default
       */
      dragSelector: null,
      /**
       * A CSS selector used to identify child element(s) that should not trigger drag.
       * @config {String}
       */
      ignoreSelector: null,
      /**
       * The number of milliseconds after a pointerup to ignore click events on the document. This
       * is used to avoid the "up" event itself generating a `click` on the target.
       * @config {Number}
       * @default
       */
      dragSwallowClickTime: 50,
      /**
       * The amount of pixels to move pointer/mouse before it counts as a drag operation.
       * @config {Number}
       * @default
       */
      dragThreshold: 5,
      /**
       * The number of milliseconds that must elapse after a `touchstart` event before it is considered a drag. If
       * movement occurs before this time, the drag is aborted. This is to allow touch swipes and scroll gestures.
       * @config {Number}
       * @default
       */
      dragTouchStartDelay: 300,
      /**
       * The CSS selector to use to identify the closest valid target from the event target.
       * @config {String}
       */
      dropTargetSelector: null,
      /**
       * The {@link #config-dragSelector} item the mouse is currently over.
       * @member {HTMLElement} overItem
       * @readonly
       */
      overItem: null,
      testConfig: {
        dragSwallowClickTime: 50
      }
    };
  }
  static get properties() {
    return {
      /**
       * The CSS class to add to the {@link #config-dragRootElement} (or {@link #config-draggingClsSelector} from
       * there) as soon as the pointerdown event occurs.
       * @member {String}
       * @readonly
       */
      draggingCls: "b-draggable-active",
      /**
       * The CSS class to add to the `body` element as soon as the {@link #config-dragThreshold} is reached and
       * an actual drag is in progress.
       * @member {String}
       * @readonly
       */
      draggingBodyCls: "b-draghelper-active",
      // match DragHelper since we need the same treatment
      /**
       * The CSS class to add to the element being dragged as soon as the pointerdown event occurs.
       * @member {String}
       * @readonly
       */
      draggingItemCls: "b-dragging-item",
      /**
       * The CSS class to add to the {@link #config-dragRootElement} (or {@link #config-draggingClsSelector} from
       * there) as soon as the {@link #config-dragThreshold} is reached and an actual drag is in progress.
       * @member {String}
       * @readonly
       */
      draggingStartedCls: "b-draggable-started",
      /**
       * The CSS class that is added to the {@link #config-dragRootElement}, i.e., `'b-draggable'`.
       * @property {String}
       * @readonly
       */
      draggableCls: "b-draggable"
    };
  }
  //endregion
  //region Drag Processing
  // These template methods are implemented by derived classes as desired. There is only one overlap with Droppable's
  // template methods (dragDrop) so that a class can easily mixin both Draggable and Droppable and always distinguish
  // whether it is acting as the source, the target, or both.
  /**
   * This template method is called when the mousedown of a potential drag operation occurs. This happens before the
   * gesture is known to be a drag, meaning the {@link #config-dragThreshold} has not been reached. This method
   * should initialize the {@link Core.util.drag.DragContext} using the {@link Core.util.drag.DragContext#function-set}
   * method. Alternatively, this method may return `false` to prevent the drag operation.
   *
   * *Important:* Because no drag has occurred at the time this method is called, only minimal processing should be
   * done (such as initializing the {@link Core.util.drag.DragContext}). Anything more should be done in the
   * {@link #function-dragStart} method or in response to the {@link #event-dragStart} event which happen only if
   * the user drags the mouse before releasing the mouse button.
   * @param {Core.util.drag.DragContext} drag
   */
  beforeDrag(drag) {
    const { dragRootElement, dragSelector, ignoreSelector } = this, target = dragSelector && drag.element.closest(dragSelector);
    return !dragSelector || Boolean(
      target && target === dragRootElement || dragRootElement.contains(target) && (!ignoreSelector || !drag.element.matches(ignoreSelector))
    );
  }
  /**
   * This template method is called when the drag operation starts. This occurs when the {@link #config-dragThreshold}
   * has been reached.
   * Your implementation may return `false` to prevent the startup of the drag operation.
   * @param {Core.util.drag.DragContext} drag
   */
  dragStart(drag) {
  }
  /**
   * This template method is called as the drag moves. This occurs on each mouse/pointer/touchmove event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragOver(drag) {
  }
  /**
   * This template method is called when the drag enters a {@link Core.mixin.Droppable target}.
   * @param {Core.util.drag.DragContext} drag
   */
  dragEnterTarget(drag) {
  }
  /**
   * This template method is called when the drag leaves a {@link Core.mixin.Droppable target}.
   * @param {Core.util.drag.DragContext} drag
   * @param {Core.mixin.Droppable} oldTarget The previous value of `drag.target`.
   */
  dragLeaveTarget(drag, oldTarget) {
  }
  /**
   * This template method is called when the drag operation completes. This occurs on the pointerup event.
   *
   * This method is not called if the drag is {@link Core.util.drag.DragContext#property-aborted}.
   * @param {Core.util.drag.DragContext} drag
   */
  dragDrop(drag) {
  }
  /**
   * This template method is called when the drag operation completes. This occurs on the pointerup event or perhaps
   * a keypress event.
   *
   * This method is always called, even if the drag is {@link Core.util.drag.DragContext#property-aborted}.
   * @param {Core.util.drag.DragContext} drag
   */
  dragEnd(drag) {
  }
  //endregion
  //region Drag Management
  // These methods are called by the DragContext and generally manage element updates (adding/removing classes) or
  // event firing. In most cases these methods then call a corresponding Drag Processing template method intended
  // for derived classes to implement.
  get activeDrag() {
    const { dragging: drag } = this;
    return (drag == null ? void 0 : drag.started) && !drag.completed ? drag : null;
  }
  /**
   * Return the `Events` instance from which drag events are fired.
   * @internal
   * @property {Core.mixin.Events}
   */
  get dragEventer() {
    return this.trigger ? this : null;
  }
  get draggingClassElement() {
    const { draggingClsSelector, dragRootElement } = this;
    return draggingClsSelector ? dragRootElement == null ? void 0 : dragRootElement.closest(draggingClsSelector) : dragRootElement;
  }
  beginDrag(drag) {
    const { draggingCls, draggingClassElement } = this;
    if (draggingCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingCls));
    }
  }
  async endDrag(drag) {
    const me = this, { dragEventer, dragProxy } = me;
    if (drag.valid) {
      await me.dragDrop(drag);
    }
    if (me.isDestroyed) {
      return;
    }
    if (drag.pending) {
      drag.destroy();
    } else {
      me.dragEnd(drag);
      dragProxy == null ? void 0 : dragProxy.dragEnd(drag);
      dragEventer == null ? void 0 : dragEventer.trigger(drag.valid ? "drop" : "dragCancel", { drag, event: drag.event });
      me.finalizeDrag(drag);
    }
  }
  async finalizeDrag(drag) {
    var _a4;
    await ((_a4 = drag.finalize) == null ? void 0 : _a4.call(drag));
  }
  moveDrag(drag) {
    if (this.dragOver(drag) !== false) {
      const { dragEventer, dragProxy } = this;
      dragProxy == null ? void 0 : dragProxy.dragMove(drag);
      dragEventer == null ? void 0 : dragEventer.trigger("drag", { drag, event: drag.event });
    }
  }
  setupDragContext(event) {
    const me = this, { dragItemSelector, id } = me, { target } = event;
    return {
      event,
      id: id ? `${id}-drag-${me._nextDragId = (me._nextDragId || 0) + 1}` : null,
      itemElement: dragItemSelector ? target.closest(dragItemSelector) : target,
      touchStartDelay: me.dragTouchStartDelay,
      source: me,
      threshold: me.dragThreshold
    };
  }
  startDrag(drag) {
    const { draggingStartedCls, draggingClassElement, draggingItemCls, dragEventer, dragProxy } = this, { itemElement } = drag;
    if ((dragEventer == null ? void 0 : dragEventer.trigger("beforeDragStart", { drag, event: drag.event })) === false) {
      return false;
    }
    if (draggingStartedCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingStartedCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingStartedCls));
    }
    if (draggingItemCls && itemElement) {
      itemElement.classList.add(draggingItemCls);
      drag.cleaners.push(() => itemElement.classList.remove(draggingItemCls));
    }
    dragProxy == null ? void 0 : dragProxy.dragStart(drag);
    const result = this.dragStart(drag);
    if (result !== false) {
      dragEventer == null ? void 0 : dragEventer.trigger("dragStart", { drag, event: drag.event });
    }
    return result;
  }
  trackDrag(drag) {
    var _a4;
    const { dropTargetSelector } = this;
    drag.valid = !(dropTargetSelector && !((_a4 = drag.targetElement) == null ? void 0 : _a4.closest(dropTargetSelector)));
    this.moveDrag(drag);
  }
  //endregion
  //region Configs
  configureListeners(drag) {
    const me = this, listeners = ObjectHelper.assign({
      thisObj: me
    }, me.dragDocumentListeners);
    if ("touches" in drag.startEvent) {
      delete listeners.mousemove;
      delete listeners.mouseup;
    } else {
      delete listeners.contextmenu;
      delete listeners.touchmove;
      delete listeners.touchend;
      delete listeners.pointerup;
    }
    return listeners;
  }
  //endregion
  //region Configs
  updateDragging(drag, old) {
    const me = this;
    if (drag) {
      const listeners = me.configureListeners(drag);
      drag.cleaners.push(EventHelper.on(listeners));
      me.beginDrag(drag);
    } else if (old) {
      old.destroy();
    }
  }
  changeDragProxy(config, existing) {
    return DragProxy.reconfigure(existing, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  updateDragRootElement(rootEl, was) {
    var _a4;
    const me = this, {
      draggableCls,
      dragItemSelector,
      onDragItemMouseMove
    } = me;
    was == null ? void 0 : was.classList.remove(draggableCls);
    (_a4 = me._dragRootDetacher) == null ? void 0 : _a4.call(me);
    if (rootEl) {
      const listeners = {
        thisObj: me,
        element: rootEl,
        mousedown: "onDragMouseDown",
        // We have touchstart listener in place since Siesta/Chrome can send these events even on non-touch
        // devices:
        touchstart: "onDragTouchStart",
        // On iOS, because we use pointerup to represent the drop gesture,
        // the initiating pointerdown event is captured, and its target is
        // the original start target. We must always release pointer capture.
        // https://github.com/bryntum/support/issues/4111
        pointerdown: (e) => {
          var _a5, _b;
          return e.pointerId && ((_b = (_a5 = e.target).releasePointerCapture) == null ? void 0 : _b.call(_a5, e.pointerId));
        }
      };
      if (onDragItemMouseMove) {
        listeners.mousemove = {
          delegate: dragItemSelector,
          handler: "onDragItemMouseMove"
        };
      }
      if (me.dragItemOverCls || onDragItemMouseMove || me.onDragItemMouseEnter || me.onDragItemMouseLeave) {
        Object.assign(listeners, {
          mouseover: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOver"
          },
          mouseout: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOut"
          }
        });
      }
      rootEl.classList.add(draggableCls);
      me._dragRootDetacher = EventHelper.on(listeners);
    }
  }
  //endregion
  //region Events
  onDragItemMouseOver(event) {
    this.overItem = event;
  }
  onDragItemMouseOut(event) {
    if (!this.dragging) {
      this.overItem = event;
    }
  }
  changeOverItem(event) {
    var _a4;
    this.enterLeaveEvent = event;
    if (event.type === "mouseout") {
      return ((_a4 = event.relatedTarget) == null ? void 0 : _a4.closest(this.dragItemSelector)) || null;
    } else {
      return event.target.closest(this.dragItemSelector);
    }
  }
  updateOverItem(overItem, oldOverItem) {
    var _a4, _b;
    const me = this, { dragItemOverCls } = me;
    if (oldOverItem) {
      dragItemOverCls && oldOverItem.classList.remove(dragItemOverCls);
      (_a4 = me.onDragItemMouseLeave) == null ? void 0 : _a4.call(me, me.enterLeaveEvent, oldOverItem);
    }
    if (overItem) {
      dragItemOverCls && overItem.classList.add(dragItemOverCls);
      (_b = me.onDragItemMouseEnter) == null ? void 0 : _b.call(me, me.enterLeaveEvent, overItem);
    }
  }
  onDragContextMenu(event) {
    event.preventDefault();
  }
  onDragKeyDown(event) {
    this.dragging.keyDown(event);
  }
  onDragKeyUp(event) {
    this.dragging.keyUp(event);
  }
  /**
   * Grab draggable element on mouse down.
   * @param {Event} event
   * @private
   */
  onDragMouseDown(event) {
    if (event.button === 0) {
      this.onDragPointerDown(event);
    }
  }
  /**
   * Grab draggable element on pointerdown.
   * @param {Event} event
   * @private
   */
  onDragPointerDown(event) {
    let { dragging: drag } = this;
    if (!drag) {
      drag = this.setupDragContext(event);
      if (drag) {
        drag = new DragContext(drag);
        if (drag.begin() === false) {
          drag.destroy();
        }
      }
    } else if (!drag.isFinalizing) {
      drag.abort();
    }
  }
  // Set by the DragContext in its begin method, and auto-nullified at destruction.
  changeDragging(value, was) {
    was == null ? void 0 : was.destroy();
    return value;
  }
  onDragPointerMove(event) {
    const { dragging: drag } = this;
    if (drag && !drag.completed) {
      drag == null ? void 0 : drag.move(event);
    }
  }
  onDragPointerUp(event) {
    const { dragging: drag } = this;
    if (drag && !drag.completed) {
      drag.end(event);
      this.endDrag(drag);
    }
  }
  /**
   * @param {Event} event
   * @private
   */
  onDragTouchStart(event) {
    if (event.touches.length === 1) {
      this.onDragPointerDown(event);
    }
  }
  //endregion
};

// ../Core/lib/Core/mixin/Droppable.js
var Droppable_default = (Target) => class Droppable extends (Target || Base) {
  static get $name() {
    return "Droppable";
  }
  //region Configs
  static get configurable() {
    return {
      /**
       * A selector, which, if specified, narrows the dropability to child elements of the
       * {@link #config-dropRootElement} which match this selector.
       * @config {String}
       */
      droppableSelector: null,
      /**
       * The current `DragContext`. This is set when a drag enters this target. Changing this config causes the
       * {@link #function-dragEnter} and {@link #function-dragLeave} methods to be called. If `dragEnter` returns
       * `false` for a drag, this value will be set to `null`.
       * @member {Core.util.drag.DragContext}
       * @readonly
       */
      dropping: null,
      /**
       * Set this config to the element where drops should be received. When set, the `b-droppable` CSS class is
       * added to the element and the `Droppable` instance is associated with that element so that it can be
       * found by {@link Core.mixin.Draggable draggables}.
       * @config {HTMLElement}
       */
      dropRootElement: {
        $config: "nullify",
        value: null
      }
    };
  }
  /**
   * Return the `Events` instance from which drop events are fired.
   * @internal
   * @property {Core.mixin.Events}
   */
  get dropEventer() {
    return this.trigger ? this : null;
  }
  /**
   * Returns the CSS class that is added to the {@link #config-dropRootElement}, i.e., `'b-droppable'`.
   * @property {String}
   * @readonly
   */
  get droppableCls() {
    return "b-droppable";
  }
  //endregion
  //region Drop Management
  /**
   * This method is called when a drag enters this droppable's `dropRootElement`. In many cases, this method is used
   * to create some sort of drop indicator to provide user feedback.
   *
   * If this method does not return `false`, the {@link #property-dropping} config will retain the given `drag` context
   * which was set prior to this method being called.
   *
   * If this method returns `false`, the drop will not be accepted. Neither {@link #function-dragDrop} nor
   * {@link #function-dragLeave} will be called for this drop. If the drag leaves this target and re-enters, this
   * method will be called again. While `dropping` will already be updated before this method is called, it will be
   * reset to `null` in this case.
   *
   * The base class implementation of this method fires the {@link #event-dragEnter} event.
   * @param {Core.util.drag.DragContext} drag
   * @returns {Boolean}
   */
  dragEnter(drag) {
    var _a4;
    return (_a4 = this.dropEventer) == null ? void 0 : _a4.trigger("dragEnter", { drag, event: drag.event });
  }
  /**
   * This method is called when the drag that was previously announced via {@link #function-dragEnter} moves to a new
   * position. This is typically where drop indicators are updated to reflect the new position.
   *
   * The base class implementation of this method fires the {@link #event-dragMove} event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragMove(drag) {
    var _a4;
    return (_a4 = this.dropEventer) == null ? void 0 : _a4.trigger("dragMove", { drag, event: drag.event });
  }
  /**
   * This method is called when the drag that was previously announced via {@link #function-dragEnter} has ended with
   * a drop. In addition to any cleanup (since {@link #function-dragLeave} will not be called), this method handles
   * any updates associated with the data from the drag context and the position of the drop.
   *
   * The base class implementation of this method fires the {@link #event-drop} event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragDrop(drag) {
    var _a4;
    return (_a4 = this.dropEventer) == null ? void 0 : _a4.trigger("drop", { drag, event: drag.event });
  }
  /**
   * This method is called when the drag that was previously announced via {@link #function-dragEnter} leaves this
   * droppable's `dropRootElement`, or the drag is {@link Core.util.drag.DragContext#property-aborted} by the user
   * pressing the `ESC` key, or the {@link Core.util.drag.DragContext#function-abort} method is called.
   *
   * This is the time to cleanup anything created by `dragEnter`.
   *
   * The base class implementation of this method fires the {@link #event-dragLeave} event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragLeave(drag) {
    var _a4;
    return (_a4 = this.dropEventer) == null ? void 0 : _a4.trigger("dragLeave", { drag, event: drag.event });
  }
  //endregion
  //region Configs
  changeDropping(dropping, was) {
    if (dropping !== was) {
      const me = this;
      if (was) {
        if (was.aborted || !was.completed) {
          me.dragLeave(was);
        }
      }
      if (dropping) {
        me._dropping = dropping;
        if (me.dragEnter(dropping) === false) {
          dropping = null;
        }
        me._dropping = was;
      }
    }
    return dropping;
  }
  updateDropRootElement(rootEl, was) {
    const me = this, { droppableCls } = me;
    let droppables, i, removeCls;
    if (was) {
      droppables = DomDataStore.get(was, "droppables");
      removeCls = true;
      if (Array.isArray(droppables) && (i = droppables.indexOf(me)) > -1) {
        if (droppables.length < 2) {
          DomDataStore.remove(was, "droppables");
        } else {
          droppables.splice(i, 1);
          droppables.forEach((d) => {
            if (droppableCls === d.droppableCls) {
              removeCls = false;
            }
          });
        }
      }
      removeCls && was.classList.remove(droppableCls);
    }
    if (rootEl) {
      droppables = DomDataStore.get(rootEl, "droppables");
      if (droppables) {
        droppables.push(me);
      } else {
        DomDataStore.set(rootEl, "droppables", [me]);
      }
      rootEl.classList.add(droppableCls);
    }
  }
  //endregion
};

// ../Core/lib/Core/mixin/Featureable.js
var Featureable_default = (Target) => class Featureable extends (Target || Base) {
  static get $name() {
    return "Featureable";
  }
  static get configurable() {
    return {
      /**
       * Specifies the features to create and associate with the instance. The keys of this object are the names
       * of features. The values are config objects for those feature instances.
       *
       * After construction, this property can be used to access the feature instances and even reconfigure them.
       *
       * For example:
       * ```
       *  instance.features.amazing = {
       *      // reconfigure this feature
       *  }
       * ```
       * This can also be done in bulk:
       * ```
       *  instance.features = {
       *      amazing : {
       *          // reconfigure this feature
       *      },
       *      // reconfigure other features
       *  }
       * ```
       * @config {Object}
       */
      features: null
    };
  }
  static get declarable() {
    return [
      /**
       * This property getter returns options that control feature management for the derived class. This
       * property getter must be defined by the class that mixes in `Featureable` in order to initialize the
       * class properly.
       * ```
       *  class SuperWidget extends Widget.mixin(Featureable) {
       *      static get featureable() {
       *          return {
       *              factory : SuperWidgetFeature
       *          };
       *      }
       *      ...
       *  }
       * ```
       * @static
       * @member {Object} featureable
       * @property {Core.mixin.Factoryable} featureable.factory The factoryable class (not one of its instances)
       * that will be used to create feature instances.
       * @property {String} [featureable.ownerName='client'] The config or property to assign on each feature as
       * a reference to its creator, the `Featureable` instance.
       * @internal
       */
      "featureable"
    ];
  }
  static setupFeatureable(cls) {
    const featureable = {
      ownerName: "client",
      ...cls.featureable
    };
    featureable.factory.initClass();
    Reflect.defineProperty(cls, "featureable", {
      get() {
        return featureable;
      }
    });
  }
  doDestroy() {
    var _a4;
    const features = this.features;
    super.doDestroy();
    for (const name in features) {
      const feature = features[name];
      (_a4 = feature.destroy) == null ? void 0 : _a4.call(feature);
    }
  }
  /**
   * Returns `true` if the specified feature is active for this instance and `false` otherwise.
   * @param {String} name The feature name
   * @returns {Boolean}
   */
  hasFeature(name) {
    var _a4;
    return Boolean((_a4 = this.features) == null ? void 0 : _a4[name]);
  }
  changeFeatures(features, was) {
    if (this.isDestroying) {
      return;
    }
    const me = this, { featureable } = me.constructor, manager = me.$features || (me.$features = new DynamicObject({
      configName: "features",
      factory: featureable.factory,
      owner: me,
      ownerName: featureable.ownerName
    }));
    manager.update(features);
    if (!was) {
      return manager.target;
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement this.
  get widgetClass() {
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), { features } = result;
    if (features) {
      for (const featureName in features) {
        if (Object.keys(features[featureName]).length === 0) {
          features[featureName] = true;
        }
      }
    }
    return result;
  }
};

// ../Core/lib/Core/mixin/Hoverable.js
var EDGES = {
  e: "b-hover-edge",
  t: "b-hover-top",
  r: "b-hover-right",
  b: "b-hover-bottom",
  l: "b-hover-left"
};
var EDGE_CLASSES = {
  [EDGES.e]: 1,
  [EDGES.t]: 1,
  [EDGES.r]: 1,
  [EDGES.b]: 1,
  [EDGES.l]: 1
};
var ZONES = {
  t: [EDGES.e, EDGES.t],
  r: [EDGES.e, EDGES.r],
  b: [EDGES.e, EDGES.b],
  l: [EDGES.e, EDGES.l],
  tr: [EDGES.e, EDGES.t, EDGES.r],
  bl: [EDGES.e, EDGES.b, EDGES.l],
  tl: [EDGES.e, EDGES.t, EDGES.l],
  br: [EDGES.e, EDGES.b, EDGES.r]
};
var Hoverable_default = (Target) => class Hoverable extends Target.mixin(Delayable_default) {
  static get $name() {
    return "Hoverable";
  }
  //region Configs
  static get configurable() {
    return {
      /**
       * A CSS class to add to the {@link #config-hoverTarget target} element.
       * @config {String}
       */
      hoverCls: null,
      /**
       * A CSS class to add to the {@link #config-hoverTarget target} element to enable CSS animations. This class
       * is added after calling {@link #function-hoverEnter}.
       * @config {String}
       */
      hoverAnimationCls: null,
      /**
       * A CSS class to add to the {@link #config-hoverRootElement root} element.
       * @config {String}
       */
      hoverRootCls: null,
      /**
       * A CSS class to add to the {@link #config-hoverRootElement root} element when there is an active
       * {@link #config-hoverTarget target}.
       * @config {String}
       */
      hoverRootActiveCls: null,
      /**
       * The number of milliseconds to delay notification of changes in the {@link #config-hoverTarget}.
       * @config {Number}
       */
      hoverDelay: null,
      /**
       * The current element that the cursor is inside as determined by `mouseover` and `mouseout`. Changes in
       * this config trigger re-evaluation of the {@link #config-hoverSelector} to determine if there is a
       * {@link #config-hoverTarget}.
       * @config {HTMLElement}
       * @private
       */
      hoverElement: null,
      /**
       * An element to ignore. Mouse entry into this element will not trigger a change in either of the
       * {@link #config-hoverElement} or {@link #config-hoverTarget} values.
       * @config {HTMLElement}
       */
      hoverIgnoreElement: null,
      /**
       * This property is a string containing one character for each edge that is hoverable. For example, a
       * value of "tb" indicates that the top and bottom edges are hoverable.
       * @config {String}
       */
      hoverEdges: null,
      /**
       * When {@link #config-hoverEdges} is used, this value determines the size (in pixels) of the edge. When
       * the cursor is within this number of pixels of an edge listed in `hoverEdges`, the appropriate CSS class
       * is added to the {@link #config-hoverTarget}:
       *
       *  - `b-hover-top`
       *  - `b-hover-right`
       *  - `b-hover-bottom`
       *  - `b-hover-left`
       *
       * Depending on the values of `hoverEdges`, it is possible to have at most two of these classes present at
       * any one time (when the cursor is in a corner).
       * @config {Number}
       * @default
       */
      hoverEdgeSize: 10,
      /**
       * The outer element where hover tracking will operate (attach events to it and use as root limit when
       * looking for ancestors).
       *
       * A common choice for this will be `document.body`.
       * @config {HTMLElement}
       */
      hoverRootElement: {
        $config: "nullify",
        value: null
      },
      /**
       * A selector for the [closest](https://developer.mozilla.org/en-US/docs/Web/API/Element/closest) API to
       * determine the actual element of interest. This selector is used to process changes to the
       * {@link #config-hoverElement} to determine the {@link #config-hoverTarget}.
       * @config {String}
       */
      hoverSelector: null,
      /**
       * The currently active hover target. This will be the same as {@link #config-hoverElement} unless there is
       * a {@link #config-hoverSelector}.
       * @config {HTMLElement}
       */
      hoverTarget: {
        $config: "nullify",
        value: null
      },
      /**
       * Set to `true` to include tracking of `mousemove` events for the active {@link #config-hoverTarget}. This
       * is required for the {@link #function-hoverMove} method to be called.
       * @config {Boolean}
       * @default false
       */
      hoverTrack: null,
      /**
       * A string value containing one character per active edge (e.g., "tr").
       * @config {String}
       * @private
       */
      hoverZone: null
    };
  }
  static get delayable() {
    return {
      setHoverTarget: 0
    };
  }
  //endregion
  //region State Handling
  /**
   * This method is called when the cursor enters the {@link #config-hoverTarget}. The `hoverTarget` will not be
   * `null`.
   * @param {HTMLElement} leaving The element that was previously the `hoverTarget`. This value may be null.
   */
  hoverEnter(leaving) {
  }
  /**
   * This method should return true if the given `element` should be ignored. By default, this is `true` if the
   * `element` is contained inside the {@link #config-hoverIgnoreElement}.
   * @param {HTMLElement} element
   * @returns {Boolean}
   * @protected
   */
  hoverIgnore(element) {
    var _a4;
    return (_a4 = this.hoverIgnoreElement) == null ? void 0 : _a4.contains(element);
  }
  /**
   * This method is called when the cursor leaves the {@link #config-hoverTarget}. The `hoverTarget` may be `null`
   * or refer to the new `hoverTarget`
   * @param {HTMLElement} leaving The element that was previously the `hoverTarget`. This value will not be null.
   */
  hoverLeave(leaving) {
  }
  /**
   * This method is called when the mouse moves within a {@link #config-hoverTarget}, but only if enabled by the
   * {@link #config-hoverTrack} config.
   * @param {Event} event
   */
  hoverMove(event) {
  }
  //endregion
  //region Events
  onHoverMouseMove(event) {
    const me = this, { hoverEdges, hoverEdgeSize, hoverTarget } = me;
    if (hoverTarget) {
      if (hoverEdges) {
        const { top, left, width, height, right, bottom } = hoverTarget.getBoundingClientRect(), { clientX, clientY } = event, centerX = left + width / 2, centerY = top + height / 2, t = clientY < (hoverEdgeSize ? top + hoverEdgeSize : centerY), r = clientX >= (hoverEdgeSize ? right - hoverEdgeSize : centerX), b = clientY >= (hoverEdgeSize ? bottom - hoverEdgeSize : centerY), l = clientX < (hoverEdgeSize ? left + hoverEdgeSize : centerX), tb = t || b ? t ? "t" : "b" : "", rl = r || l ? r ? "r" : "l" : "";
        me.hoverZone = (hoverEdges.includes(tb) ? tb : "") + (hoverEdges.includes(rl) ? rl : "");
      }
      me.hoverEvent = event;
      me.hoverTrack && me.hoverMove(event);
    }
  }
  onHoverMouseOver(event) {
    this.hoverEvent = event;
    this.hoverElement = event.target;
  }
  onHoverMouseOut(event) {
    this.hoverEvent = event;
    this.hoverElement = event.relatedTarget;
  }
  //endregion
  //region Configs
  // hoverDelay
  updateHoverDelay(delay) {
    this.setHoverTarget.delay = delay;
  }
  // hoverEdges
  changeHoverEdges(edges) {
    return edges === true ? "trbl" : (edges || "").replace("v", "tb").replace("h", "lr");
  }
  updateHoverEdges() {
    this.syncHoverListeners();
  }
  // hoverElement
  changeHoverElement(element) {
    if (!this.hoverIgnore(element)) {
      return element;
    }
  }
  updateHoverElement(hoverEl) {
    const { hoverSelector } = this;
    if (hoverSelector) {
      hoverEl = hoverEl == null ? void 0 : hoverEl.closest(hoverSelector);
    }
    this.setHoverTarget(hoverEl);
  }
  // hoverRootElement
  updateHoverRootElement(rootEl, was) {
    const { hoverRootCls } = this;
    if (hoverRootCls) {
      was == null ? void 0 : was.classList.remove(hoverRootCls);
      rootEl == null ? void 0 : rootEl.classList.add(hoverRootCls);
    }
    this.syncHoverListeners();
  }
  // hoverTarget
  changeHoverTarget(hoverEl, was) {
    if (was) {
      this.hoverZone = null;
    }
    return hoverEl;
  }
  updateHoverTarget(hoverEl, was) {
    const me = this, { hoverCls, hoverAnimationCls, hoverRootActiveCls, hoverRootElement } = me;
    if (hoverRootActiveCls) {
      hoverRootElement == null ? void 0 : hoverRootElement.classList[hoverEl ? "add" : "remove"](hoverRootActiveCls);
    }
    if (was) {
      hoverCls && was.classList.remove(hoverCls);
      hoverAnimationCls && was.classList.remove(hoverAnimationCls);
      me.hoverLeave(was);
    }
    if (hoverEl) {
      hoverCls && hoverEl.classList.add(hoverCls);
      me.hoverEnter(was);
      if (me.hoverTrack) {
        me.hoverMove(me.hoverEvent);
      }
      if (hoverAnimationCls) {
        hoverEl.getBoundingClientRect();
        hoverEl.classList.add(hoverAnimationCls);
      }
    }
  }
  // hoverTrack
  updateHoverTrack() {
    this.syncHoverListeners();
  }
  // hoverZone
  updateHoverZone(zone) {
    const { hoverAnimationCls, hoverTarget } = this;
    if (hoverTarget) {
      const { className } = hoverTarget, cls = DomClassList.change(
        className,
        /* add= */
        zone ? ZONES[zone] : null,
        /* remove= */
        EDGE_CLASSES
      );
      if (className !== cls) {
        hoverTarget.className = cls;
        if (zone && hoverAnimationCls) {
          hoverTarget.classList.remove(hoverAnimationCls);
          hoverTarget.getBoundingClientRect();
          hoverTarget.classList.add(hoverAnimationCls);
        }
      }
    }
  }
  //endregion
  //region Misc
  setHoverTarget(target) {
    this.hoverTarget = target;
  }
  syncHoverListeners() {
    var _a4;
    const me = this, element = me.hoverRootElement, listeners = {
      element,
      thisObj: me,
      mouseover: "onHoverMouseOver",
      mouseout: "onHoverMouseOut"
    };
    if (me.hoverTrack || me.hoverEdges) {
      listeners.mousemove = "onHoverMouseMove";
    }
    (_a4 = me._hoverRootDetacher) == null ? void 0 : _a4.call(me);
    me._hoverRootDetacher = element && EventHelper.on(listeners);
  }
  //endregion
};

// ../Core/lib/Core/mixin/LoadMaskable.js
var LoadMaskable_default = (Target) => {
  var _a4;
  return _a4 = class extends Target {
    static get configurable() {
      return {
        /**
         * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
         * when data is loading. The message and optional configuration from the
         * {@link Core.mixin.LoadMaskable#config-loadMask} config take priority over these options, just as they do
         * for `maskDefaults`, respectively.
         *
         * The final mask configuration for a load mask is as if the following were applied:
         *
         * ```
         *  Object.assign({},
         *      widget.maskDefaults,
         *      widget.loadMaskDefaults,
         *      widget.loadMask);
         * ```
         * @config {MaskConfig}
         * @category Masking
         */
        loadMaskDefaults: {
          useTransition: true,
          showDelay: 1e3
        },
        /**
         * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
         * when an error occurs loading data.
         *
         * Set to `false` to disable showing data loading error mask.
         *
         * The final mask configuration for an error mask is as if the following were applied:
         *
         * ```
         *  Object.assign({},
         *      widget.maskDefaults,
         *      widget.loadMaskDefaults,
         *      widget.loadMaskError,
         *      errorMessage);
         * ```
         * @config {MaskConfig|Core.widget.Mask|Boolean}
         * @category Masking
         */
        loadMaskError: {
          icon: "b-icon b-icon-warning",
          autoClose: 3e3,
          showDelay: 0
        },
        /**
         * A {@link Core.widget.Mask} config object, or a message to be shown when a store is performing a remote
         * operation, or Crud Manager is loading data from the sever. Set to `null` to disable default load mask.
         *
         * @config {String|MaskConfig|null}
         * @default "Loading..."
         * @category Masking
         */
        loadMask: {
          text: "L{GridBase.loadMask}"
        },
        /**
         * A {@link Core.widget.Mask} config object, or a message to be shown when Crud Manager
         * is persisting changes on the server. Set to `null` to disable default sync mask.
         *
         * This config is similar to {@link Core.mixin.LoadMaskable#config-loadMask} but designed for saving data.
         *
         * To create a custom sync mask need to subscribe to the Crud Manager events and show
         * {@link Core.widget.Mask Mask} on `beforeSend` and hide it on `requestDone` and `requestFail`.
         *
         * To create a custom sync mask, set this config to `null` and subscribe to the CrudManager's events to
         * show or hide the {@link Core.widget.Widget#config-masked mask} as desired.
         *
         * ```javascript
         *  widget.crudManager.on({
         *      loadStart() {
         *          widget.masked = {
         *              text : 'Data is loading...'
         *          };
         *      },
         *      load() {
         *          widget.masked = null;
         *      },
         *      loadCanceled() {
         *          widget.masked = null;
         *      },
         *      syncStart() {
         *          widget.masked = null;
         *      },
         *      sync() {
         *          widget.masked = null;
         *      },
         *      syncCanceled() {
         *          widget.masked = null;
         *      },
         *      requestFail({ response }) {
         *          widget.masked.error = response.message || 'Sync failed';
         *      }
         *  });
         *
         *  store.load();
         * ```
         *
         * @config {String|MaskConfig|null}
         * @default "Saving changes, please wait..."
         * @category Masking
         */
        syncMask: {
          text: "L{GridBase.syncMask}"
        },
        localizableProperties: ["loadMask.text", "syncMask.text"],
        testConfig: {
          loadMaskError: {
            icon: "b-icon b-icon-warning",
            autoClose: 500,
            showDelay: 0
          }
        }
      };
    }
    /**
     * Applies the {@link Core.mixin.LoadMaskable#config-loadMask} as the {@link Core.widget.Widget#config-masked mask}
     * for this widget.
     * @returns {Core.widget.Mask}
     * @internal
     */
    applyLoadMask() {
      const me = this, { loadMask } = me;
      if (loadMask) {
        me.masked = Mask.mergeConfigs(me.loadMaskDefaults, loadMask);
      }
      return me.masked;
    }
    /**
     * Updates the current {@link Core.widget.Widget#config-masked mask} for this widget to present the specified
     * `error`.
     * @param {String} error The error message to display in the mask.
     * @returns {Core.widget.Mask}
     * @internal
     */
    applyMaskError(error) {
      const { loadMaskError, masked } = this;
      if (loadMaskError === false) {
        masked.hide();
      } else if (masked) {
        ObjectHelper.assign(masked.errorDefaults, loadMaskError);
        masked.error = error;
      }
      return masked;
    }
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {
    }
  }, __publicField(_a4, "$name", "LoadMaskable"), _a4;
};

// ../Core/lib/Core/mixin/Override.js
var excludedPropNames = {
  constructor: 1,
  prototype: 1,
  name: 1,
  length: 1,
  arguments: 1,
  caller: 1,
  callee: 1,
  __proto__: 1
};
var Override = class {
  /**
   * Apply override. We strongly suggest that you at least specify a maxVersion for your overrides.
   * ```
   * class OriginalOverride {
   *     static get target() {
   *         return {
   *             class      : Original,
   *             product    : 'grid',
   *             minVersion : '1.0',
   *             maxVersion : '1.5'
   *         }
   *     }
   * }
   * ```
   * @param {Object} override An override class definition
   */
  static apply(override) {
    if (!override.target)
      throw new Error("Override must specify what it overrides, using static getter target");
    if (!override.target.class)
      throw new Error("Override must specify which class it overrides, using target.class");
    if (!this.shouldApplyOverride(override))
      return false;
    const staticKeys = Object.getOwnPropertyNames(override), instanceKeys = Object.getOwnPropertyNames(override.prototype);
    staticKeys.splice(staticKeys.indexOf("target"), 1);
    this.internalOverrideAll(override.target.class, staticKeys, override);
    this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);
    return true;
  }
  static internalOverrideAll(targetClass, properties, overrideDefinition) {
    Reflect.ownKeys(overrideDefinition).forEach((key) => {
      if (properties.includes(key) && !excludedPropNames[key]) {
        const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);
        let currentTargetClass = targetClass;
        let targetProperty = null;
        while (!targetProperty && currentTargetClass) {
          targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);
          if (!targetProperty) {
            currentTargetClass = Object.getPrototypeOf(currentTargetClass);
          }
        }
        if (targetProperty) {
          this.internalOverride(currentTargetClass, key, desc, targetProperty);
        }
      }
    });
  }
  static internalOverride(target, key, desc, targetDesc) {
    const overrides = target._overridden = target._overridden || {};
    overrides[key] = target[key];
    if (targetDesc.get) {
      Object.defineProperty(target, key, {
        enumerable: false,
        configurable: true,
        get: desc.get
      });
    } else {
      target[key] = desc.value;
    }
  }
  /**
   * Checks versions if an override should be applied. Specify version in your overrides target config
   *
   * ```javascript
   * class OriginalOverride {
   *     static get target() {
   *         return {
   *             class      : Original,
   *             product    : 'grid',
   *             minVersion : '1.0',
   *             maxVersion : '1.5'
   *         }
   *     }
   * }
   * ```
   *
   * @param override
   * @returns {Boolean}
   * @private
   */
  static shouldApplyOverride(override) {
    const config = override.target;
    if (!config.maxVersion && !config.minVersion)
      return true;
    if (!config.product)
      throw new Error("Override must specify product when using versioning");
    if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {
      return false;
    }
    if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {
      return false;
    }
    return true;
  }
};
Override._$name = "Override";

// ../Core/lib/Core/mixin/Fencible.js
var { defineProperty: defineProperty8 } = Object;
var { hasOwn: hasOwn6 } = ObjectHelper;
var fencibleSymbol = Symbol("fencible");
var NONE = [];
var distinct = (array) => Array.from(new Set(array));
var parseNames = (names) => names ? distinct(StringHelper.split(names)) : NONE;
var fenceMethod = (target, name, options) => {
  if (options === true) {
    options = name;
  }
  if (!ObjectHelper.isObject(options)) {
    options = {
      all: options
    };
  }
  let any = parseNames(options.any);
  const all = parseNames(options.all), lock = options.lock ? parseNames(options.lock) : distinct(all.concat(any)), implName = name + "Impl", fence = function(...params) {
    const me = this, fences = hasOwn6(me, fencibleSymbol) ? me[fencibleSymbol] : me[fencibleSymbol] = {}, isFree = (key) => !fences[key];
    if (all.every(isFree) && (!any || any.some(isFree))) {
      try {
        lock.forEach((key) => fences[key] = (fences[key] || 0) + 1);
        return me[implName](...params);
      } finally {
        lock.forEach((key) => --fences[key]);
      }
    }
  };
  any = any.length ? any : null;
  !target[implName] && defineProperty8(target, implName, {
    configurable: true,
    value: target[name]
  });
  defineProperty8(target, name, {
    configurable: true,
    value: fence
  });
};
var Fencible_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static setupFenced(cls) {
      let { fenced } = cls;
      const statics = fenced.static, pairs = [];
      if (statics) {
        fenced = { ...fenced };
        delete fenced.static;
        pairs.push([statics, cls]);
      }
      pairs.push([fenced, cls.prototype]);
      for (const [methods, target] of pairs) {
        for (const methodName in methods) {
          fenceMethod(target, methodName, methods[methodName]);
        }
      }
    }
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {
    }
  }, __publicField(_a4, "$name", "Fencible"), __publicField(_a4, "declarable", [
    /**
     * This class property returns an object that specifies methods to be wrapped to prevent reentrancy.
     *
     * It is used like so:
     * ```javascript
     *  class Foo extends Base.mixin(Fencible) {
     *      static fenced = {
     *          reentrantMethod : true
     *      };
     *
     *      reentrantMethod() {
     *          // things() may cause reentrantMethod() to be called...
     *          // but we won't be allowed to reenter this method since we are already inside it
     *          this.things();
     *      }
     *  }
     * ```
     *
     * This can also be used to protect mutually reentrant method groups:
     *
     * ```javascript
     *  class Foo extends Base.mixin(Fencible) {
     *      static fenced = {
     *          foo : 'foobar'
     *          bar : 'foobar'
     *      };
     *
     *      foo() {
     *          console.log('foo');
     *          this.bar();
     *      }
     *
     *      bar() {
     *          console.log('bar');
     *          this.foo();
     *      }
     *  }
     *
     *  instance = new Foo();
     *  instance.foo();
     *  >> foo
     *  instance.bar();
     *  >> bar
     * ```
     *
     * The value for a fenced method value can be `true`, a string, an array of strings, or a
     * {@link #typedef-MethodFence} options object.
     *
     * Internally these methods are protected by assigning a wrapper function in their place. The original function
     * is moved to a new named property by appending 'Impl' to the original name. For example, in the above code,
     * `foo` and `bar` are wrapper functions that apply reentrancy protection and call `fooImpl` and `barImpl`,
     * respectively. This is important for inheritance and `super` calling because the new name must be used in
     * order to retain the guard function implementations.
     *
     * @static
     * @member {Object} fenced
     * @internal
     */
    "fenced"
  ]), _a4;
};

// ../Core/lib/Core/util/DayTime.js
var MILLIS_PER_MINUTE = 60 * 1e3;
var MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;
var MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;
var timeRe = /(\d+)?:?(\d*)/;
var DayTime = class _DayTime {
  /**
   * Returns a string of "HH:MM" for a given time of day in milliseconds.
   * @param {Number} timeOfDay The time of day in milliseconds.
   * @returns {String}
   * @private
   */
  static format(timeOfDay) {
    const h = Math.floor(timeOfDay / MILLIS_PER_HOUR), m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;
    return `${h}:${m < 10 ? "0" : ""}${m}`;
  }
  /**
   * Parses a time of day which may be a number (0-24 for the hour of the day) or a string in "H:MM" format and
   * returns the time of day as a number of milliseconds.
   *
   * If `time` is a `Date` instance, its time of day is returned.
   * @param {Date|Number|String} time
   * @returns {Number}
   * @private
   */
  static parse(time) {
    const type = typeof time;
    if (type === "string") {
      const match = timeRe.exec(time);
      time = Number(match[1] || 0) * MILLIS_PER_HOUR + Number(match[2] || 0) * MILLIS_PER_MINUTE;
    } else if (type !== "number") {
      time = DateHelper.getTimeOfDay(time);
    } else if (time <= 24) {
      time *= MILLIS_PER_HOUR;
    }
    return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY);
  }
  constructor(config) {
    let startShift = 0, startTime, endTime;
    if (config == null ? void 0 : config.isDayView) {
      startShift = config.dayStartShift;
      startTime = config.dayStartTime;
      endTime = config.dayEndTime;
    } else if (typeof config === "number") {
      startShift = startTime = endTime = config;
    } else if (config) {
      startShift = config.startShift;
      startTime = config.timeStart;
      endTime = config.timeEnd;
    }
    this.startShift = startShift = _DayTime.parse(startShift || 0);
    this.timeEnd = (endTime == null ? (startShift + MILLIS_PER_DAY) % MILLIS_PER_DAY : _DayTime.parse(endTime)) || MILLIS_PER_DAY;
    this.timeStart = startTime == null ? startShift : _DayTime.parse(startTime);
  }
  get startHour() {
    return Math.floor(this.timeStart / MILLIS_PER_HOUR);
  }
  get endHour() {
    return Math.floor(this.timeEnd / MILLIS_PER_HOUR);
  }
  /**
   * The number of milliseconds from the day's `startShift` to its `timeStart`.
   * @member {Number}
   */
  get startTimeOffsetMs() {
    const { startShift, timeStart } = this;
    return timeStart < startShift ? MILLIS_PER_DAY - startShift + timeStart : timeStart - startShift;
  }
  /**
   * The `Date` object for the most recently started, shifted day. The time of this `Date` will be the `startShift`.
   * It is possible for this date to be yesterday on a midnight-based calendar. For example, if the `startShift` is
   * 6PM and the current time is 6AM on May 20, this value will be 6PM of May 19 (the most recently started day).
   * @member {Date}
   */
  get today() {
    return this.startOfDay(/* @__PURE__ */ new Date());
  }
  /**
   * Returns `Date` object for the nearest (shifted) day ending after the given `date`. The time of this `Date` will
   * be the `startShift`.
   *
   * It is possible for this date to be in the next day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 7PM on May 20, this method will return 6PM of May 21 (the nearest day ending).
   * @param {Date} date The date for which to find the nearest day ending.
   * @returns {Date}
   */
  ceil(date) {
    const ret = this.startOfDay(date);
    if (ret < date) {
      ret.setDate(ret.getDate() + 1);
    }
    return ret;
  }
  /**
   * Returns `true` if the time of day for the given `date` is between `timeStart` and `timeEnd`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Boolean}
   */
  contains(date) {
    return !this.outside(date);
  }
  /**
   * Returns a "YYYY-MM-DD" string for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior date otherwise.
   * @param {Date|Number} date The date from which to compute the 'YYYY-MM-DD' key.
   * @returns {String}
   */
  dateKey(date) {
    date = this.shiftDate(date, -1);
    return DateHelper.makeKey(date);
  }
  /**
   * Returns a `Date` instance with `startShift` as the time of day and the Y/M/D of the given `date`.
   * @param {Date} date The date's year, month, and day values.
   * @returns {Date}
   */
  dayOfDate(date) {
    return this.shiftDate(DateHelper.clearTime(date));
  }
  /**
   * Returns the day of week (0-8) for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior day otherwise.
   * @param {Date|Number} date The date from which to compute the day of week.
   * @returns {Number}
   */
  dayOfWeek(date) {
    date = this.shiftDate(date, -1);
    return date.getDay();
  }
  /**
   * Returns the difference between the time of day of the given `date` and `timeStart` in the specified time `unit`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  delta(date, unit = "ms") {
    const { timeStart } = this, time = _DayTime.parse(date), t = (this.startShift && time < timeStart ? time + MILLIS_PER_DAY : time) - timeStart;
    return unit === "ms" ? t : DateHelper.as(unit, t, "ms");
  }
  /**
   * Returns the duration of the visible day (between `timeStart` and `timeEnd`) in the specified time `unit`.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  duration(unit = "ms") {
    const { timeStart, timeEnd } = this, millis = timeStart < timeEnd ? timeEnd - timeStart : MILLIS_PER_DAY - timeStart + timeEnd;
    return unit === "ms" ? millis : DateHelper.as(unit, millis, "ms");
  }
  /**
   * Returns `true` if this instance describes the same day as the `other`.
   * @param {Core.util.DayTime} other The other instance to which `this` instance should be tested for equality.
   * @returns {Boolean}
   */
  equals(other) {
    return this.startShift === (other == null ? void 0 : other.startShift) && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;
  }
  /**
   * Returns `true` if the times of day described by `startDate` and `endDate` intersect the visible time of this day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  intersects(startDate, endDate) {
    const me = this, { timeStart, timeEnd } = me, [date0, date1] = me._dateRangeArgs(startDate, endDate), [start, end] = me.timeRange(date0, date1);
    if (timeStart < timeEnd) {
      if (start < end) {
        return start < timeEnd && timeStart <= end;
      }
      return start < timeEnd || timeStart <= end;
    }
    return !(start < end) || start < timeEnd || timeStart <= end;
  }
  /**
   * Returns `true` if the given date range is contained within one day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isIntraDay(startDate, endDate) {
    const me = this, [date0, date1] = me._dateRangeArgs(startDate, endDate), dayStart = me.startOfDay(date0), diff = MILLIS_PER_DAY - DateHelper.diff(dayStart, date1, "ms");
    if (diff < 0) {
      return false;
    }
    return diff > 0 || dayStart < date0;
  }
  /**
   * Returns `true` if the given date range or event crosses the day boundary.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isInterDay(timeSpan) {
    return timeSpan.allDay || !this.isIntraDay(...arguments);
  }
  /**
   * Returns -1, 0, or 1 based on whether the time of day for the given `date` is before `timeStart` (-1), or after
   * `timeEnd` (1), or between these times (0).
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Number}
   */
  outside(date) {
    const { startShift, timeStart, timeEnd } = this, time = _DayTime.parse(date);
    if (timeStart < timeEnd) {
      if (time < timeStart) {
        return time < startShift ? 1 : -1;
      }
      if (time < timeEnd) {
        return 0;
      }
      return time < startShift ? -1 : 1;
    }
    if (time < timeEnd || time >= timeStart) {
      return 0;
    }
    return time < startShift ? 1 : -1;
  }
  parseKey(key) {
    return this.dayOfDate(DateHelper.parseKey(key));
  }
  /**
   * Returns the given `date` shifted forward (`direction` > 0) or backward (`direction` < 0) by the `startShift`.
   * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch.
   * @param {Number} direction A value > 0 to shift `date` forward, or < 0 to shift it backwards.
   * @returns {Date}
   */
  shiftDate(date, direction = 1) {
    const { startShift } = this, type = typeof date;
    date = type === "number" ? new Date(date) : type === "string" ? DateHelper.parse(date) : new Date(date.getTime());
    if (direction && startShift) {
      date.setMilliseconds(direction > 0 ? startShift : -startShift);
    }
    return date;
  }
  /**
   * Sorts the given set of `events` by the maximum of `startDate` and `startOfDay` for the given `date`, followed
   * by `duration` in case of a tie.
   * @param {Date} date The day for which events are to be sorted.
   * @param {Object[]} events The events to sort, typically an `Scheduler.model.EventModel[]` but any objects with
   * both `startDate` and `endDate` fields are acceptable.
   * @returns {Object[]} The passed `events` array.
   * @internal
   */
  sortEvents(date, events) {
    const startOfDay = this.startOfDay(date);
    return events == null ? void 0 : events.sort((event1, event2) => {
      event1 = event1.eventRecord || event1;
      event2 = event2.eventRecord || event2;
      let { startDate: start1 } = event1, { startDate: start2 } = event2;
      if (!start1) {
        return -1;
      }
      if (!start2) {
        return 1;
      }
      start1 = start1 < startOfDay ? startOfDay : start1;
      start2 = start2 < startOfDay ? startOfDay : start2;
      return start1 - start2 || event2.endDate - start2 - (event1.endDate - start1);
    });
  }
  /**
   * Returns `Date` object for the nearest started (shifted) day prior to the given `date`. The time of this `Date`
   * will be the `startShift`.
   *
   * It is possible for this date to be in the prior day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 6AM on May 20, this method will return 6PM of May 19 (the nearest started day).
   * @param {Date} date The date for which to find the nearest started day.
   * @returns {Date}
   */
  startOfDay(date) {
    date = this.shiftDate(date, -1);
    date = DateHelper.clearTime(date);
    date = this.shiftDate(date);
    return date;
  }
  /**
   * Returns a range of {@link Core.helper.DateHelper#function-getTimeOfDay-static times of day} for the given
   * date range.
   * @param {Date} startDate The start date of the date range or an event record containing both `startDate` and `endDate` fields
   * @param {Date} [endDate] The end date if `startDate` is not an event record
   * @returns {Number[]}
   */
  timeRange(startDate, endDate) {
    const [start, end] = this._dateRangeArgs(startDate, endDate);
    return [DateHelper.getTimeOfDay(start), DateHelper.getTimeOfDay(end)];
  }
  toString() {
    const { startShift, timeEnd, timeStart } = this, suffix = startShift ? `@${_DayTime.format(startShift)}` : "", prefix = _DayTime.format(timeStart);
    if (timeStart === timeEnd) {
      return startShift ? suffix : prefix;
    }
    return `${prefix}-${_DayTime.format(timeEnd)}${suffix}`;
  }
  /**
   * Decodes the arguments and returns a pair of `Date` objects for the start and end of the date range.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Date[]}
   * @private
   */
  _dateRangeArgs(startDate, endDate) {
    return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];
  }
};
DayTime.MIDNIGHT = new DayTime({
  startShift: 0,
  timeStart: 0,
  timeEnd: 24
});
DayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;
DayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR;
DayTime.MILLIS_PER_DAY = MILLIS_PER_DAY;
DayTime._$name = "DayTime";

// ../Core/lib/Core/util/Month.js
var _Month = class _Month extends Events_default(Base) {
  static get configurable() {
    return {
      /**
       * The date which the month should encapsulate. May be a `Date` object, or a
       * `YYYY-MM-DD` format string.
       *
       * Mutating a passed `Date` after initializing a `Month` object has no effect on
       * the `Month` object.
       * @config {Date|String}
       */
      date: {
        $config: {
          equal: "date"
        },
        value: DateHelper.clearTime(/* @__PURE__ */ new Date())
      },
      month: null,
      year: null,
      /**
       * The week start day, 0 meaning Sunday, 6 meaning Saturday.
       * Defaults to {@link Core.helper.DateHelper#property-weekStartDay-static}.
       * @config {Number}
       */
      weekStartDay: null,
      /**
       * Configure as `true` to have the visibleDayColumnIndex and visibleColumnCount properties
       * respect the configured {@link #config-nonWorkingDays}.
       * @config {Boolean}
       */
      hideNonWorkingDays: null,
      /**
       * Non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
       * Defaults to {@link Core.helper.DateHelper#property-nonWorkingDays-static}.
       * @config {Object<String,Boolean>}
       */
      nonWorkingDays: null,
      /**
       * Configure as `true` to always have the month encapsulate six weeks.
       * This is useful for UIs which must be a fixed height.
       * @prp {Boolean}
       */
      sixWeeks: null
    };
  }
  //region events
  /**
   * Fired when setting the {@link #config-date} property causes the encapsulated date to change
   * in **any** way, date, week, month or year.
   * @event dateChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  /**
   * Fired when setting the {@link #config-date} property causes a change of week. Note that
   * weeks are calculated in the ISO standard form such that if there are fewer than four
   * days in the first week of a year, then that week is owned by the previous year.
   *
   * The {@link #config-weekStartDay} is honoured when making this calculation and this is a
   * locale-specific value which defaults to the ISO standard of 1 (Monday) in provided European
   * locales and 0 (Sunday) in the provided US English locale.
   * @event weekChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  /**
   * Fired when setting the {@link #config-date} property causes a change of month. This
   * will fire when changing to the same month in a different year.
   * @event monthChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  /**
   * Fired when setting the {@link #config-date} property causes a change of year.
   * @event yearChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  //endRegion
  /**
   * For use when this Month's `weekStartDay` is non-zero.
   *
   * An array to map the days of the week 0-6 of this Calendar to the canonical day numbers
   * used by the Javascript [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) object.
   * @member {Number[]} canonicalDayNumbers
   * @readonly
   */
  /**
   * An array to map a canonical day number to a *visible* column index.
   * For example, if we have `weekStartDay` as Monday which is 1, and non working days as
   * Wednesday, and `hideNonWorkingDays : true`, then the calendar would look like
   *
   *```
   * ┌────┬────┬────┬────┬────┬────┐
   * | Mo | Tu | Th | Fr | Sa | Su |
   * └────┴────┴────┴────┴────┴────┘
   *```
   *
   * So we'd need this array: `[ 5, 0, 1, undefined, 2, 3, 4]`
   * @member {Number[]} visibleDayColumnIndex
   * @readonly
   */
  /**
   * An array to map a canonical day number to a 0-6 column index.
   * For example, if we have `weekStartDay` as Monday which is 1, then the calendar would look like
   *
   *```
   * ┌────┬────┬────┬────┬────┬────┬────┐
   * | Mo | Tu | We | Th | Fr | Sa | Su |
   * └────┴────┴────┴────┴────┴────┴────┘
   *```
   *
   * So we'd need this array: `[ 6, 0, 1, 2, 3, 4, 5]`
   * @member {Number[]} dayColumnIndex
   * @readonly
   */
  /**
   * The number of visible days in the week as defined by the `nonWorkingDays` and
   * `hideNonWorkingDays` options.
   * @member {Number} weekLength
   * @readonly
   */
  configure(config) {
    super.configure(config);
    this.updateDayNumbers();
    if (config.date) {
      this.date = config.date;
    }
    this.generation = 0;
  }
  changeDate(date) {
    if (this.isConfiguring) {
      return;
    }
    date = typeof date === "string" ? DateHelper.parse(date, "YYYY-MM-DD") : new Date(date);
    if (isNaN(date)) {
      throw new Error("Month date ingestion must be passed a Date, or a valid YYYY-MM-DD date string");
    }
    return date;
  }
  updateDate(newDate, oldDate) {
    const me = this, {
      dayColumnIndex,
      weekCount
    } = me, monthStart = DateHelper.getFirstDateOfMonth(newDate), monthEnd = DateHelper.getLastDateOfMonth(monthStart), startWeekDay = dayColumnIndex[monthStart.getDay()], endWeekDay = dayColumnIndex[monthEnd.getDay()], yearChanged = !oldDate || newDate.getFullYear() !== oldDate.getFullYear(), monthChanged = !oldDate || newDate.getMonth() !== oldDate.getMonth(), changes = me.eventListeners && (oldDate ? newDate.getDate() !== oldDate.getDate() | (me.getWeekId(newDate) !== me.getWeekId(oldDate)) << 1 | monthChanged << 2 | yearChanged << 3 : 15);
    me._year = newDate.getFullYear();
    me._month = newDate.getMonth();
    me.startDayOfMonth = 1 - startWeekDay;
    me.endDayOfMonth = monthEnd.getDate() + (6 - endWeekDay);
    if (me.sixWeeks) {
      me.endDayOfMonth += (6 - me.weekCount) * 7;
    }
    if (!me.weekBase || yearChanged) {
      me.calculateWeekBase();
    }
    if (monthChanged || yearChanged) {
      me.generation++;
    }
    if (changes) {
      const event = {
        newDate,
        oldDate,
        changes: {
          d: true,
          w: Boolean(changes & 2),
          m: Boolean(changes & 12),
          y: Boolean(changes & 8),
          r: me.weekCount !== weekCount
        }
      };
      me.trigger("dateChange", event);
      if (changes & 2) {
        me.trigger("weekChange", event);
      }
      if (changes & 12) {
        me.trigger("monthChange", event);
      }
      if (changes & 8) {
        me.trigger("yearChange", event);
      }
    }
  }
  calculateWeekBase() {
    const me = this, {
      dayColumnIndex
    } = me, jan1 = new Date(me.year, 0, 1), dec31 = new Date(me.year, 11, 31), january = me.month ? me.getOtherMonth(jan1) : me;
    if (me.dayColumnIndex[jan1.getDay()] > 3) {
      me.weekBase = january.startDate;
    } else {
      me.weekBase = new Date(me.year, 0, january.startDayOfMonth - 7);
    }
    const dec31Week = Math.floor(DateHelper.diff(me.weekBase, dec31, "day") / 7);
    me.has53weeks = dec31Week === 53 && dayColumnIndex[dec31.getDay()] > 2;
  }
  /**
   * Returns the week start date, based on the configured {@link #config-weekStartDay} of the
   * passed week.
   * @param {Number| Number[]} week The week number in the current year, or an array containing
   * `[year, weekOfYear]` for any year.
   *
   * Week numbers greater than the number of weeks in the year just wrap into the following year.
   */
  getWeekStart(week) {
    if (typeof week === "number") {
      return DateHelper.add(this.weekBase, Math.max(week, 1) * 7, "day");
    }
    const me = this, [year, weekOfYear] = week;
    if (year === me.year) {
      return me.getWeekStart(weekOfYear);
    }
    return me.getOtherMonth(new Date(year, 0, 1)).getWeekStart(weekOfYear);
  }
  getOtherMonth(date) {
    const me = this, result = me === otherMonth ? new _Month(null) : otherMonth;
    result.configure({
      weekBase: null,
      weekStartDay: me.weekStartDay,
      nonWorkingDays: me.nonWorkingDays,
      hideNonWorkingDays: me.hideNonWorkingDays,
      sixWeeks: me.sixWeeks,
      date: new Date(date.getFullYear(), 0, 1)
      // Make it easy to calculate its own weekBase
    });
    result.date = date;
    result.updateDate(result.date, result.date);
    return result;
  }
  changeYear(year) {
    const newDate = new Date(this.date);
    newDate.setFullYear(year);
    this.date = newDate;
  }
  changeMonth(month2) {
    const newDate = new Date(this.date);
    newDate.setMonth(month2);
    this.date = newDate;
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay() {
    const me = this;
    me.updateDayNumbers();
    if (!me.isConfiguring && me.date) {
      me.weekBase = null;
      me.updateDate(me.date, me.date);
    }
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || DateHelper.nonWorkingDays;
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateHideNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateSixWeeks() {
    if (!this.isConfiguring) {
      this.updateDate(this.date, this.date);
    }
  }
  /**
   * The number of days in the calendar for this month. This will always be
   * a multiple of 7, because this represents the number of calendar cells
   * occupied by this month.
   * @property {Number}
   * @readonly
   */
  get dayCount() {
    return this.endDayOfMonth + 1 - this.startDayOfMonth;
  }
  /**
   * The number of weeks in the calendar for this month.
   * @property {Number}
   * @readonly
   */
  get weekCount() {
    return this.dayCount / 7;
  }
  /**
   * The date of the first cell in the calendar view of this month.
   * @property {Date}
   * @readonly
   */
  get startDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.startDayOfMonth);
    }
  }
  /**
   * The date of the last cell in the calendar view of this month.
   * @property {Date}
   * @readonly
   */
  get endDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.endDayOfMonth);
    }
  }
  /**
   * Iterates through all calendar cells in this month, calling the passed function for each date.
   * @param {Function} fn The function to call.
   * @param {Date} fn.date The date for the cell.
   */
  eachDay(fn) {
    for (let dayOfMonth = this.startDayOfMonth; dayOfMonth <= this.endDayOfMonth; dayOfMonth++) {
      fn(new Date(this.year, this.month, dayOfMonth));
    }
  }
  /**
   * Iterates through all weeks in this month, calling the passed function
   * for each week.
   * @param {Function} fn The function to call.
   * @param {Number[]} fn.week An array containing `[year, weekNumber]`
   * @param {Date[]} fn.dates The dates for the week.
   */
  eachWeek(fn) {
    const me = this, { weekCount } = me;
    for (let dayOfMonth = me.startDayOfMonth, week = 0; week < weekCount; week++) {
      const weekDates = [], weekOfYear = me.getWeekNumber(new Date(me.year, me.month, dayOfMonth));
      for (let day2 = 0; day2 < 7; day2++, dayOfMonth++) {
        weekDates.push(new Date(me.year, me.month, dayOfMonth));
      }
      fn(weekOfYear, weekDates);
    }
  }
  /**
   * Returns the week of the year for the passed date. This returns an array containing *two* values,
   * the year **and** the week number are returned.
   *
   * The week number is calculated according to ISO rules, meaning that if the first week of the year
   * contains less than four days, it is considered to be the last week of the preceding year.
   *
   * The configured {@link #config-weekStartDay} is honoured in this calculation. So if the weekStartDay
   * is **NOT** the ISO standard of `1`, (Monday), then the weeks do not coincide with ISO weeks.
   * @param {Date} date The date to calculate the week for.
   * @returns {Number[]} A numeric array: `[year, week]`
   */
  getWeekNumber(date) {
    const me = this;
    date = DateHelper.clearTime(date);
    if (date.getFullYear() !== me.year) {
      return me.getOtherMonth(new Date(date.getFullYear(), 0, 1)).getWeekNumber(date);
    }
    let weekNo = Math.floor(DateHelper.diff(me.weekBase, date, "day") / 7), year = date.getFullYear();
    if (!weekNo) {
      return me.getOtherMonth(new Date(me.year - 1, 0, 1)).getWeekNumber(new Date(me.year, 0, 0));
    } else if (weekNo === 53 && !me.has53weeks) {
      weekNo = 1;
      year++;
    } else if (weekNo > 53) {
      weekNo = weekNo % 52;
    }
    return [year, weekNo];
  }
  getWeekId(date) {
    const week = this.getWeekNumber(date);
    return week[0] * 100 + week[1];
  }
  getCellData(date, ownerMonth, dayTime = DayTime.MIDNIGHT) {
    const me = this, day2 = date.getDay(), visibleColumnIndex = me.visibleDayColumnIndex[day2], isNonWorking = me.nonWorkingDays[day2], isHiddenDay = me.hideNonWorkingDays && isNonWorking;
    if (date < me.startDate || date > me.endDate) {
      me.month = date.getMonth();
    }
    return {
      day: day2,
      dayTime,
      visibleColumnIndex,
      isNonWorking,
      week: me.getOtherMonth(date).getWeekNumber(date),
      key: DateHelper.format(date, "YYYY-MM-DD"),
      columnIndex: me.dayColumnIndex[day2],
      date: new Date(date),
      dayEnd: dayTime.duration("s"),
      tomorrow: dayTime.dayOfDate(DateHelper.add(date, 1, "day")),
      // These two properties are only significant when used by a CalendarPanel which encapsulates
      // a single month.
      isOtherMonth: Math.sign(date.getMonth() + date.getFullYear() * 12 - (ownerMonth.month + ownerMonth.year * 12)),
      visible: !isHiddenDay && (date >= ownerMonth.startDate && date < DateHelper.add(ownerMonth.endDate, 1, "day")),
      isRowStart: visibleColumnIndex === 0,
      isRowEnd: visibleColumnIndex === me.visibleColumnCount - 1
    };
  }
  updateDayNumbers() {
    const me = this, {
      weekStartDay,
      nonWorkingDays,
      hideNonWorkingDays
    } = me, dayColumnIndex = me.dayColumnIndex = [], canonicalDayNumbers = me.canonicalDayNumbers = [], visibleDayColumnIndex = me.visibleDayColumnIndex = [];
    let visibleColumnIndex = 0;
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const canonicalDay = (weekStartDay + columnIndex) % 7;
      canonicalDayNumbers[columnIndex] = canonicalDay;
      dayColumnIndex[canonicalDay] = columnIndex;
      if (!hideNonWorkingDays || !nonWorkingDays[canonicalDay]) {
        visibleDayColumnIndex[canonicalDay] = visibleColumnIndex++;
      }
    }
    me.visibleColumnCount = visibleColumnIndex;
    me.weekLength = hideNonWorkingDays ? 7 - ObjectHelper.keys(nonWorkingDays).length : 7;
  }
};
__publicField(_Month, "$name", "Month");
var Month = _Month;
var otherMonth = new Month(null);
Month._$name = "Month";

// ../Core/lib/Core/util/Parser.js
var nextObjectIdentity = 0;
var objectIdentityMap = /* @__PURE__ */ new WeakMap();
var argsToCacheKey = (...args) => args.map((arg) => {
  let result;
  if (arg && typeof arg == "object" || typeof arg == "function") {
    result = objectIdentityMap.get(arg);
    if (result === void 0) {
      result = ++nextObjectIdentity;
      objectIdentityMap.set(arg, result);
    }
  } else {
    result = String(arg);
  }
  return result;
}).join("-");
var memo = (fn) => {
  const mlist = /* @__PURE__ */ new Map();
  return (...args) => {
    const mkey = argsToCacheKey(args);
    let result = mlist.get(mkey);
    if (result === void 0) {
      result = fn(...args);
      mlist.set(mkey, result);
    }
    return result;
  };
};
var memoCps = (fn) => {
  const table = /* @__PURE__ */ new Map(), entryContinuations = (entry) => entry[0], entryResults = (entry) => entry[1], pushContinuation = (entry, cont) => entryContinuations(entry).push(cont), pushResult = (entry, result) => entryResults(entry).push(result), isResultSubsumed = (entry, result) => entryResults(entry).some((r) => ObjectHelper.isEqual(r, result)), makeEntry = () => [[], []], isEmptyEntry = (entry) => !entryResults(entry).length && !entryContinuations(entry).length, tableRef = (str) => {
    let entry = table.get(str);
    if (entry === void 0) {
      entry = makeEntry();
      table.set(str, entry);
    }
    return entry;
  };
  return (str, cont) => {
    const entry = tableRef(str);
    if (isEmptyEntry(entry)) {
      pushContinuation(entry, cont);
      fn(str, (result) => {
        if (!isResultSubsumed(entry, result)) {
          pushResult(entry, result);
          entryContinuations(entry).forEach((cont2) => cont2(result));
        }
      });
    } else {
      pushContinuation(entry, cont);
      entryResults(entry).forEach((result) => cont(result));
    }
  };
};
var SUCCESS = Symbol("success");
var FAILURE = Symbol("failure");
var success = (val, rest) => [SUCCESS, val, rest];
var failure = (rest) => [FAILURE, rest];
var isSuccess = (result) => result.length && result[0] === SUCCESS;
var resolveParser = (p) => typeof p === "function" && !p.length ? p() : p;
var succeed = memo(
  (val) => memoCps(
    (str, cont) => cont(success(val, str))
  )
);
var string = memo(
  (match) => memoCps(
    (str, cont) => {
      const len = Math.min(match.length, str.length), head = str.substr(0, len), tail = str.substr(len);
      cont(head === match ? success(head, tail) : failure(tail));
    }
  )
);
var bind = (p, fn) => (str, cont) => resolveParser(p)(str, (result) => {
  if (isSuccess(result)) {
    const [, val, rest] = result;
    fn(val)(rest, cont);
  } else {
    cont(result);
  }
});
var seq = memo(
  (...parsers2) => {
    const seq2 = memo(
      (a, b) => memoCps(
        bind(
          a,
          (x) => bind(
            b,
            (y) => succeed([].concat(x, y))
          )
        )
      )
    );
    return parsers2.reduce(seq2, succeed([]));
  }
);
var alt = memo(
  (...parsers2) => memoCps(
    (str, cont) => parsers2.forEach((p) => resolveParser(p)(str, cont))
  )
);
var regexp = memo(
  (pattern) => (str, cont) => {
    const rexp = new RegExp(`^${pattern}`), match = rexp.exec(str);
    if (match) {
      const head = match[0], tail = str.substr(head.length);
      cont(success(head, tail));
    } else {
      cont(failure(str));
    }
  }
);
var red = memo(
  (p, fn) => bind(
    p,
    (...val) => succeed(fn(...[].concat.apply([], val)))
  )
);
var runParser = (body, str) => {
  const results = [];
  body(str, (result) => {
    if (isSuccess(result)) {
      const [, , left] = result;
      if (left === "") {
        results.push(result);
      }
    }
  });
  return results;
};
var defineParser = (body) => (str, cont) => cont ? resolveParser(body)(str, cont) : runParser(resolveParser(body), str);
var Parser_default = {
  memo,
  memoCps,
  success,
  failure,
  isSuccess,
  resolveParser,
  succeed,
  string,
  bind,
  seq,
  alt,
  regexp,
  red,
  runParser,
  defineParser
};

// ../Core/lib/Core/util/ScrollManager.js
var ScrollManager = class extends Base.mixin(Delayable_default, Events_default) {
  //region Default config
  static get configurable() {
    return {
      /**
       * Default element to use for scrolling. Can be overridden in calls to `startMonitoring()`.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * Width in pixels of the area at the edges of an element where scrolling should be triggered
       * @config {Number}
       * @default
       */
      zoneWidth: 50,
      /**
       * Scroll speed, higher number is slower. Calculated as "distance from zone edge / scrollSpeed"
       * @config {Number}
       * @default
       */
      scrollSpeed: 5,
      /**
       * The direction(s) to scroll ('horizontal', 'vertical' or 'both')
       * @config {'horizontal'|'vertical'|'both'}
       * @default
       */
      direction: "both",
      /**
       * Number of milliseconds to wait before scroll starts when the mouse is moved close to an edge monitored by this scroll manager
       * @config {Number}
       * @default
       */
      startScrollDelay: 500,
      /**
       * Set to true to stop scrolling when pointing device leaves the scrollable element.
       * @config {Boolean}
       * @default
       */
      // https://github.com/bryntum/support/issues/394
      stopScrollWhenPointerOut: false,
      testConfig: {
        scrollSpeed: 2,
        startScrollDelay: 100
      },
      activeScroll: {
        $config: ["lazy"],
        value: {}
      },
      monitoring: {
        $config: ["lazy", "nullify"],
        value: true
      },
      owner: null
    };
  }
  changeMonitoring(value, was) {
    was == null ? void 0 : was.clear();
    return /* @__PURE__ */ new Map();
  }
  //endregion
  doDestroy() {
    this.stopMonitoring();
    super.doDestroy();
  }
  /**
   * Returns true if some of the monitored elements is being scrolled at the moment.
   * @property {Boolean}
   * @readonly
   */
  get isScrolling() {
    return Object.keys(this.activeScroll).length !== 0;
  }
  get rtl() {
    var _a4;
    return (_a4 = this.owner) == null ? void 0 : _a4.rtl;
  }
  //region Start/stop monitoring
  /**
   * Starts monitoring an element. It will be scrolled if mouse is pressed and within `zoneWidth` pixels from element
   * edge. Supports monitoring multiple elements using `scrollables` option:
   *
   * ```javascript
   * new ScrollManager({ element : '.item' }).startMonitoring({
   *     scrollables : [
   *         {
   *             // Applies config to all elements matching `.item .child-item`
   *             // selector
   *             element : '.child-item',
   *             // Only manage vertical scroll
   *             direction : 'vertical',
   *             // Specific callback for this scrollable. Shared callback is
   *             // ignored.
   *             callback : () => console.log('Specific callback')
   *         },
   *         {
   *             // Instance can be used
   *             element : document.querySelector('.item .child2')
   *             // Direction and callback are not provided, so element will
   *             // be scrollable in horizontal direction and will use shared
   *             // callback
   *         }
   *     ],
   *     direction : 'horizontal',
   *     callback  : () => console.log('Shared callback')
   * })
   * ```
   *
   * @param {Object} config Element which might be scrolled or config { element, callback, thisObj }
   * @param {'horizontal'|'vertical'|'both'} [config.direction] Direction to scroll. Overrides default scroll direction
   * @param {Function} [config.callback] Callback to execute on every scroll of the target element.
   *
   * ```javascript
   * startMonitoring({
   *     callback(monitor) {
   *         // Current left and top scroll of the monitored element
   *         console.log(monitor.scrollLeft)
   *         console.log(monitor.scrollTop)
   *         // Scroll position relative to the initial position
   *         console.log(monitor.relativeScrollLeft)
   *         console.log(monitor.relativeScrollTop)
   *     }
   * })
   * ```
   *
   * @param {Object} [config.thisObj] Scope for the callback.
   * @param {Object[]} [config.scrollables] Array of configs if multiple elements should be monitored.
   * @param {HTMLElement|String} [config.scrollables.0.element] Element or selector.
   * @param {'horizontal'|'vertical'|'both'} [config.scrollables.0.direction] Direction to scroll. Overrides upper config object direction.
   * @param {Function} [config.scrollables.0.callback] Callback to execute on every scroll of the target element.
   * Overrides upper config object callback.
   * @returns {Function} Returns function to cleanup instantiated monitors
   * ```javascript
   * const detacher = new ScrollManager({ element }).startMonitoring({ ... });
   * detacher(); // All monitors setup by the previous call are removed
   * ```
   */
  startMonitoring(config = {}) {
    const me = this, {
      element,
      direction: defaultDirection
    } = me, {
      scrollables = [],
      direction = defaultDirection,
      callback
    } = config, attachedElements = [];
    if (!scrollables.length) {
      scrollables.push({ element });
    }
    scrollables.forEach((scrollable) => {
      const target = scrollable.element;
      if (typeof target === "string") {
        DomHelper.forEachSelector(element, target, (element2) => {
          me.createMonitor(element2, scrollable.direction || direction, scrollable.callback || callback);
          attachedElements.push(element2);
        });
      } else {
        me.createMonitor(target, scrollable.direction || direction, scrollable.callback || callback);
        attachedElements.push(target);
      }
    });
    return function detacher2() {
      var _a4;
      (_a4 = me.stopMonitoring) == null ? void 0 : _a4.call(me, attachedElements);
    };
  }
  createMonitor(element, direction, callback) {
    const { monitoring } = this;
    if (!monitoring.has(element)) {
      monitoring.set(element, new ScrollManagerMonitor({
        scrollManager: this,
        element,
        direction,
        callback
      }));
    }
  }
  /**
   * Stops monitoring an element. If no particular element is given, stop monitoring everything.
   * @param {HTMLElement|HTMLElement[]} [element] Element or array of elements for which monitoring is not desired any
   * more and should stop as soon as possible.
   */
  stopMonitoring(element) {
    const me = this, { monitoring } = me;
    element = ArrayHelper.asArray(element);
    if (monitoring) {
      if (!element) {
        monitoring.forEach((monitor) => me.stopMonitoring(monitor.element));
        return;
      }
      element.forEach((element2) => {
        const monitor = monitoring.get(element2);
        element2.classList.remove("b-scrolling");
        if (monitor) {
          monitor.destroy();
          monitoring.delete(element2);
        }
      });
    }
  }
  //endregion
  /*
   * Attempts to reserve given scrolling direction for the given monitor.
   * @param {String} direction 'horizontal' or 'vertical'
   * @param {Object} monitor
   * @returns {Boolean} Returns true in case scroll direction was reserved for given monitor. False otherwise.
   * @private
   */
  requestScroll(direction, monitor) {
    const { activeScroll } = this;
    if (direction in activeScroll && activeScroll[direction] !== monitor) {
      return false;
    } else {
      activeScroll[direction] = monitor;
      return true;
    }
  }
  /*
   * Releases all scroll directions, blocked by given monitor
   * @param {Object} monitor
   * @private
   */
  releaseScroll(monitor) {
    const { activeScroll = {} } = this;
    Object.keys(activeScroll).forEach((key) => {
      if (activeScroll[key] === monitor) {
        delete activeScroll[key];
      }
    });
  }
  //#region Scroll position
  getRelativeScroll(element, direction = "left") {
    let result = 0;
    this.monitoring.forEach((monitor, monitoredElement) => {
      if (DomHelper.isDescendant(monitoredElement, element)) {
        result += direction === "left" ? monitor.scrollRelativeLeft : monitor.scrollRelativeTop;
      }
    });
    return result;
  }
  //#endregion
};
var ScrollManagerMonitor = class extends Base {
  construct(config) {
    const me = this, { element } = config, startScrollLeft = element.scrollLeft, startScrollTop = element.scrollTop;
    Object.assign(config, { startScrollLeft, startScrollTop });
    super.construct(config);
    EventHelper.on({
      element,
      scroll: "onElementScroll",
      pointermove: "onMouseMove",
      // Capture pointermove events early to start scrolling from top elements
      capture: true,
      thisObj: me
    });
    EventHelper.on({
      element,
      pointerleave: "onPointerLeave",
      thisObj: me
    });
  }
  doDestroy() {
    this.stopScroll(true);
    super.doDestroy();
  }
  /**
   * Starts scrolling (see #performScroll). Called from onMouseMove.
   * @private
   */
  startScroll() {
    const me = this;
    if (me.pendingScrollFinalize) {
      me.scrollManager.releaseScroll(me);
      me.pendingScrollFinalize = false;
    }
    me.scrolling = true;
    me.performScroll();
  }
  /**
   * Stops scrolling. Called from onMouseMove.
   * @private
   */
  stopScroll(force = null) {
    const me = this, finalize = () => {
      me.pendingScrollFinalize = false;
      if (!me.isDestroyed) {
        me.scrollManager.releaseScroll(me);
        me.scrolling = false;
      }
    };
    if (me.scrollRequested) {
      me.scrollManager.cancelAnimationFrame(me.frameId);
      me.scrollRequested = false;
    }
    me.scrollManager.clearTimeout(me.scrollTimeout);
    me.scrollTimeout = null;
    if (!force && (me.ongoingScrollTop || me.ongoingScrollLeft)) {
      me.pendingScrollFinalize = true;
      Promise.all([me.ongoingScrollTop, me.ongoingScrollLeft].filter(Boolean)).then(() => me.pendingScrollFinalize && finalize());
    } else {
      me.ongoingScrollTop = me.ongoingScrollLeft = null;
      finalize();
    }
  }
  onPointerLeave() {
    this.scrollManager.stopScrollWhenPointerOut && this.stopScroll();
  }
  /**
   * Listener for mouse move on monitored element. Determines if scrolling is needed, and if so how fast to scroll.
   * See #zoneWidth & #scrollSpeed configs.
   * @private
   * @param {MouseEvent} event
   */
  onMouseMove(event) {
    const me = this, {
      scrollManager
    } = me, box = me.element.getBoundingClientRect(), width = scrollManager.zoneWidth, speed = scrollManager.scrollSpeed;
    me.scrollDeltaX = me.scrollDeltaY = 0;
    if (me.direction !== "vertical") {
      const { scrollLeft, scrollWidth, clientWidth } = me.element;
      if (scrollManager.rtl) {
        if (event.clientX < box.left + width && scrollWidth + scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        } else if (event.clientX > box.right - width && scrollLeft < 0) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        }
      } else {
        if (event.clientX > box.right - width && scrollWidth - scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        } else if (event.clientX < box.left + width && scrollLeft > 0) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        }
      }
    }
    if (me.direction !== "horizontal") {
      const { scrollTop, scrollHeight, clientHeight } = me.element;
      if (event.clientY > box.bottom - width && scrollHeight - scrollTop - clientHeight >= 1) {
        me.scrollDeltaY = Math.round((width - (box.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < box.top + width && scrollTop > 0) {
        me.scrollDeltaY = -Math.round((width + (box.top - event.clientY)) / speed) - 1;
      }
    }
    if (me.scrollDeltaX !== 0 && !scrollManager.requestScroll("horizontal", me)) {
      me.scrollDeltaX = 0;
    }
    if (me.scrollDeltaY !== 0 && !scrollManager.requestScroll("vertical", me)) {
      me.scrollDeltaY = 0;
    }
    if (me.scrollDeltaX === 0 && me.scrollDeltaY === 0) {
      me.scrolling && me.stopScroll();
    } else if (!me.scrollTimeout) {
      me.scrollTimeout = scrollManager.setTimeout(() => me.startScroll(), scrollManager.startScrollDelay);
    }
  }
  /**
   * Scrolls by an amount determined by config.scrollDeltaX/Y on each frame. Start/stop by calling #startScroll and
   * #stopScroll.
   * @private
   */
  performScroll() {
    const me = this, { element, scrollManager } = me;
    if (me.scrolling && !me.scrollRequested) {
      if (me.scrollDeltaX !== 0) {
        const oldScrollLeft = element.scrollLeft, newScrollLeft = Math.min(oldScrollLeft + me.scrollDeltaX, element.scrollWidth - element.clientWidth);
        element.scrollLeft = newScrollLeft;
        if (element.scrollLeft !== oldScrollLeft) {
          me.ongoingScrollLeft = new Promise((resolve) => element.addEventListener("scroll", (event) => {
            var _a4;
            (_a4 = scrollManager.trigger) == null ? void 0 : _a4.call(scrollManager, "scroll", { event, deltaY: me.scrollDeltaY, deltaX: me.scrollDeltaX });
            resolve();
          }, { once: true }));
        } else {
          me.ongoingScrollLeft = null;
          me.scrollDeltaX = 0;
        }
      }
      if (me.scrollDeltaY !== 0) {
        const oldScrollTop = element.scrollTop, newScrollTop = Math.min(oldScrollTop + me.scrollDeltaY, element.scrollHeight - element.clientHeight);
        element.scrollTop = newScrollTop;
        if (element.scrollTop !== oldScrollTop) {
          me.ongoingScrollTop = new Promise((resolve) => element.addEventListener("scroll", (event) => {
            var _a4;
            (_a4 = scrollManager.trigger) == null ? void 0 : _a4.call(scrollManager, "scroll", { event, deltaY: me.scrollDeltaY, deltaX: me.scrollDeltaX });
            resolve();
          }, { once: true }));
        } else {
          me.ongoingScrollTop = null;
          me.scrollDeltaY = 0;
        }
      }
      if (me.scrollDeltaX !== 0 || me.scrollDeltaY !== 0) {
        me.scrollRequested = true;
        me.frameId = me.scrollManager.requestAnimationFrame(() => {
          me.scrollRequested = false;
          me.performScroll(me);
        });
      } else {
        me.stopScroll();
      }
    }
  }
  onElementScroll() {
    var _a4, _b;
    (_b = (_a4 = this.config) == null ? void 0 : _a4.callback) == null ? void 0 : _b.call(this.thisObj || this.scrollManager, this);
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  get scrollTop() {
    return this.verticalElement ? this.verticalElement.scrollTop : this.element.scrollTop;
  }
  get scrollRelativeLeft() {
    return this.scrollLeft - this.startScrollLeft;
  }
  get scrollRelativeTop() {
    return this.scrollTop - this.startScrollTop;
  }
  // There could be several scrollables controlling different axes. If we want to calculate combined scroll from all
  // those monitors (e.g. for the case when we drag scheduler event in both directions), we should ask scroll manager
  // to iterate over monitored elements and aggregate scroll.
  getRelativeLeftScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "left");
  }
  getRelativeTopScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "top");
  }
};
ScrollManager._$name = "ScrollManager";

// ../Core/lib/Core/widget/Tooltip.js
var realignTransitions = {
  left: true,
  right: true,
  top: true,
  bottom: true,
  transform: true
};
var isBoolean = {
  true: 1,
  false: 1
};
var immediatePromise4 = Promise.resolve();
var _Tooltip = class _Tooltip extends Popup {
  /**
   * Triggered before tooltip widget is shown. Return `false` to prevent the action.
   * @preventable
   * @async
   * @event beforeShow
   * @param {Core.widget.Tooltip} source The Tooltip
   * @param {Event} source.triggeredByEvent The event that triggered this Tooltip to show.
   */
  static get configurable() {
    return {
      /**
       * By default, a Tooltip is transient, and will {@link #function-hide} when the mouse exits the target
       * element. Configure as `false` to make a Tooltip non-transient.
       * @config {Boolean}
       * @default
       */
      autoHide: true,
      /**
       * By default, a Tooltip is transient, and will {@link #function-hide} when the user clicks or
       * taps outside its widget. Configure as `false` to make a Tooltip non-transient when user clicks outside it.
       *
       * If you would like the Tooltip to stay visible when mouse leaves the Tooltip target, please see
       * {#config-autoHide}.
       *
       * @config {Boolean} autoClose
       * @default true
       */
      /**
       * Horizontal offset from mouse when {@link #config-anchorToTarget} is `false`.
       *
       * Direction independent, the value is internally flipped (by multiplying it with -1) for RTL.
       *
       * @config {Number}
       * @default
       */
      mouseOffsetX: 15,
      /**
       * Vertical offset from mouse when {@link #config-anchorToTarget} is `false`
       * @config {Number}
       * @default
       */
      mouseOffsetY: 15,
      html: {
        // Ensure the html setter can never veto the operation as a no-change.
        // Because of beforeShow listeners augmenting the content.
        $config: {
          equals: () => false
        }
      },
      /**
       * A method, or the *name* of a method called to update the tooltip's content when the
       * cursor is moved over a target. It receives one argument containing context about the
       * tooltip and show operation. The function should return a string, or a Promise yielding
       * a string.
       *
       * ```javascript
       * new Grid({
       *     title    : 'Client list',
       *     appendTo : myElement,
       *     store    : myStore,
       *     columns  : myColumns,
       *     tbar     : {
       *         items : {
       *             text : 'Reload,
       *             tooltip : {
       *                 // Will look in ownership hierarchy for the method
       *                 // which will be found on the grid.
       *                 getHtml : 'up.getReloadButtonTip'
       *             }
       *         }
       *     },
       *     getReloadButtonTip() {
       *         return `Reload ${this.title}`;
       *     }
       * });
       * ```
       *
       * @config {Function|String}
       * @param {Object} context
       * @param {Core.widget.Tooltip} context.tip The tooltip instance
       * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement
       * @param {HTMLElement} context.activeTarget The target element that triggered the show
       * @param {Event} context.event The raw DOM event
       * @returns {String|Promise}
       */
      getHtml: null,
      /**
       * DOM element to attach tooltip to. By default, the mouse entering this element will kick off a timer
       * (see {@link #config-hoverDelay}) to show itself.
       *
       * If the {@link #config-forSelector} is specified, then mouse entering matching elements within the `forElement`
       * will trigger the show timer to start.
       *
       * Note that when moving from matching element to matching element within the `forElement`, the tooltip
       * will remain visible for {@link #config-hideDelay} milliseconds after exiting one element, so that rapidly
       * entering another matching element will not cause hide+show flicker. To prevent this behaviour configure
       * with `hideDelay: 0`.
       * @config {HTMLElement}
       */
      forElement: null,
      /**
       * By default, once a tooltip is shown aligned as requested, it stays put.
       *
       * Setting this to `true` causes the tooltip to be aligned by the mouse,
       * offset by `[{@link #config-mouseOffsetX}, {@link #config-mouseOffsetY}]` and
       * keeps the tooltip aligned to the mouse maintaining the configured offsets
       * as the mouse moves within its activating element.
       * @config {Boolean}
       * @default false
       */
      trackMouse: null,
      /**
       * By default, a tooltip displays static content. In the Scheduler however, there are
       * plenty of uses cases when the tip content is based on the current mouse position (dragging events, resizing events, schedule hover tip, drag creation of events etc). Set
       * to `true` to update contents on mouse movement.
       * @config {Boolean}
       * @private
       * @default
       */
      updateContentOnMouseMove: false,
      /**
       * A CSS selector which targets child elements of the {@link #config-forElement} that should produce a
       * tooltip when hovered over.
       * @config {String}
       */
      forSelector: null,
      /**
       * By default, when moving rapidly from target to target, if, when mouseovering
       * a new target, the tip is still visible, the tooltip does not hide, it remains
       * visible, but updates its content however it is configured to do so.
       *
       * Configure `hideOnDelegateChange : true` to have the tip hide, and then trigger
       * a new show delay upon entry of a new target while still visible.
       * @config {Boolean}
       * @default false
       */
      hideOnDelegateChange: null,
      /**
       * Set to true to anchor tooltip to the triggering target. If set to `false`, the tooltip
       * will align to the mouse position. When set to `false`, it will also set `anchor: false`
       * to hide anchor arrow.
       * @config {Boolean}
       * @default
       */
      anchorToTarget: true,
      /**
       * Show on hover
       * @config {Boolean}
       * @default false
       */
      showOnHover: null,
      /**
       * The amount of time to hover before showing
       * @prp {Number}
       * @default
       */
      hoverDelay: 500,
      /**
       * Show immediately when created
       * @config {Boolean}
       * @default
       */
      autoShow: false,
      /**
       * The time (in milliseconds) that the Tooltip should stay visible for when it shows over its
       * target. If the tooltip is anchored to its target, then moving the mouse during this time
       * resets the timer so that the tooltip will remain visible.
       *
       * Defaults to `0` which means the Tooltip will persist until the mouse leaves the target.
       * @config {Number}
       * @default
       */
      dismissDelay: 0,
      /**
       * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.
       *
       * May be configured as `false` to persist visible after the mouse exits the target element. Configure it
       * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`
       * @config {Number|Boolean}
       * @default
       */
      hideDelay: 500,
      /**
       * The message to show while an async tooltip is fetching its content.
       * @config {String}
       * @default
       */
      loadingMsg: "Loading...",
      /**
       * Keep the tooltip open if user moves the mouse over it.
       *
       * If this is *not* explicitly configured as `false`, then this is automatically set
       * when there are any visible, interactive child items added such as {@link #config-tools}, or
       * {@link #config-items} which are interactive such as buttons or input fields.
       * @config {Boolean}
       * @default false
       */
      allowOver: null,
      anchor: true,
      align: {
        align: "b-t",
        // This signals to the align code that this widget is prepared to shrink
        // in height in order to comply with alignTo specifications.
        // Without a minHeight, it is assumed that the height of the widget
        // is inviolable.
        minHeight: 300
      },
      axisLock: true,
      /**
       * The HTML element that triggered this Tooltip to show
       * @readonly
       * @member {HTMLElement} activeTarget
       */
      activeTarget: {
        $config: {
          // Any nullish is equal, so setting to null when undefined is no-change
          equal: (t1, t2) => t1 == null && t2 == null || t1 === t2
        },
        value: null
      },
      testConfig: {
        hideDelay: 100,
        hoverDelay: 100,
        showAnimation: null,
        hideAnimation: null
      },
      role: "tooltip",
      // Private for accessibility. If the activeTarget contains the current activeElement, the
      // describedElement is set to that activeElement while that activeTarget remains active.
      // This is so that it can have the aria-describedby property set to reference this tooltip.
      describedElement: null
    };
  }
  //endregion
  //region Events
  /**
   * Triggered when a mouseover event is detected on a potential target element.
   * Return false to prevent the action
   * @event pointerOver
   * @param {Core.widget.Tooltip} sourceThe tooltip instance.
   * @param {Event} event The mouseover event.
   * @preventable
   */
  //endregion
  //region Properties
  //endregion
  //region Init & destroy
  afterConfigure() {
    const me = this, { forSelector } = me;
    if (forSelector) {
      me.showOnHover = me.showOnHover !== false;
      if (!me.forElement) {
        if (!me.anchorToTarget) {
          me.trackMouse = true;
        }
        me.forElement = me.rootElement.host || me.rootElement;
      }
    }
    super.afterConfigure();
    if (me.forElement && me.showOnHover) {
      me.pointerOverOutDetacher = EventHelper.on({
        element: me.forElement,
        // Using pointerover/pointerout since mouseover events are not fired in Chrome when the native `disabled`
        // attribute is present https://github.com/bryntum/support/issues/3179
        pointerover: "internalOnPointerOver",
        pointerout: "internalOnPointerOut",
        thisObj: me
      });
    }
  }
  doDestroy() {
    var _a4;
    (_a4 = this.pointerOverOutDetacher) == null ? void 0 : _a4.call(this);
    super.doDestroy();
  }
  set focusOnToFront(focusOnToFront) {
    super.focusOnToFront = focusOnToFront;
  }
  get focusOnToFront() {
    var _a4;
    return ((_a4 = this.triggeredByEvent) == null ? void 0 : _a4.pointerType) === "focus" ? false : super.focusOnToFront && DomHelper.usingKeyboard;
  }
  get focusElement() {
    const result = super.focusElement;
    if (result !== this.element) {
      return result;
    }
  }
  get anchorToTarget() {
    return this._anchorToTarget && !this.trackMouse;
  }
  get anchor() {
    return super.anchor && !this.trackMouse;
  }
  set anchor(anchor) {
    super.anchor = anchor;
  }
  //endregion
  //region Hovering, show and hide
  onDocumentMouseDown({ event }) {
    const me = this, { triggeredByEvent } = me;
    if (triggeredByEvent && DomHelper.isTouchEvent) {
      if (event.pageX === triggeredByEvent.pageX && event.pageY === triggeredByEvent.pageY && me.activeTarget.contains(event.target) && performance.now() - triggeredByEvent.timeStamp < 500) {
        return;
      }
    }
    me.abortDelayedShow();
    super.onDocumentMouseDown({ event });
  }
  internalOnPointerOver(event) {
    const me = this, { target, relatedTarget } = event, { forElement, forSelector, activeTarget } = me;
    let newTarget;
    if (me.disabled || me.owner && !me.owner.showTooltipWhenDisabled && me.owner.disabled) {
      return;
    }
    if (me.allowOver && me.element.contains(target)) {
      return;
    }
    if (forSelector) {
      const autoTipElement = event.target.closest("[data-btip]");
      if (autoTipElement && !autoTipElement.matches(forSelector)) {
        if (activeTarget) {
          me.handleForElementOut();
        }
        return;
      }
      ;
      newTarget = me.filterTarget(target);
      if ((activeTarget == null ? void 0 : activeTarget.contains(target)) && activeTarget.contains(relatedTarget) && newTarget === activeTarget) {
        return;
      }
      if (newTarget && (relatedTarget == null ? void 0 : relatedTarget.closest(forSelector)) === newTarget && !relatedTarget.dataset.btip) {
        return;
      }
    } else if (!forElement.contains(relatedTarget)) {
      newTarget = forElement;
    } else {
      return;
    }
    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    } else if (activeTarget) {
      me.handleForElementOut();
    }
  }
  filterTarget(element) {
    return element.closest(this.forSelector);
  }
  // Handle a transitioned reposition when the activeTarget moved beneath the pointer.
  // When it comes to an end, if the mouseout has not hidden, then realign at the new position
  // if the activeTarget is still beneath the pointer.
  realignOnTransitionEnd(event) {
    var _a4;
    const me = this, { currentOverElement: currentOverElement2 } = _Tooltip;
    if (realignTransitions[event.propertyName]) {
      if (me.allowOver && me.element.contains(currentOverElement2)) {
        return;
      }
      if (((_a4 = me.activeTarget) == null ? void 0 : _a4.contains(currentOverElement2)) && !me.trackMouse) {
        me.realign();
      }
    }
  }
  async handleForElementOver(event, newTarget) {
    const me = this, {
      activeTarget,
      hideOnDelegateChange,
      anchorToTarget
    } = me, isNewTarget = newTarget !== activeTarget, needsHide = isNewTarget && hideOnDelegateChange;
    if (me.trigger("pointerOver", { event, target: newTarget }) === false) {
      me.internalOnPointerOut(event);
    } else {
      me.triggeredByEvent = event;
      if (me.hasTimeout("hide")) {
        me.abortDelayedHide();
        if (!isNewTarget) {
          return;
        }
      }
      if (!hideOnDelegateChange && me.element.classList.contains("b-hiding")) {
        me.cancelHideShowAnimation();
      }
      if (!me._hidden && needsHide) {
        me.hide(false);
      }
      if (me.activeTarget && me.hasTimeout("show")) {
        me.clearTimeout("show");
      }
      me.activeTarget = newTarget;
      if (me.isVisible) {
        me.lastAlignSpec = null;
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        if (me.trigger("beforeShow") === false) {
          return me.hide();
        }
        me.alignTo({
          [anchorToTarget ? "target" : "position"]: anchorToTarget ? newTarget : "mouse",
          overlap: !(anchorToTarget && me.anchor)
        });
        me.trigger("show");
        me.afterShowByTarget();
      } else {
        me.activeTarget = newTarget;
        me.delayShow(newTarget);
      }
    }
  }
  async delayShow(target) {
    var _a4;
    const me = this;
    if ((_a4 = me.currentAnimation) == null ? void 0 : _a4.showing) {
      me.cancelHideShowAnimation();
    }
    if (!me.isVisible && !me.hasTimeout("show")) {
      if (!me.hoverDelay || me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        me.showByTarget(target);
      } else {
        me.addDocumentMouseDownListener();
        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: me.rootElement,
            mousemove: "onMouseMove",
            thisObj: me
          });
        }
        me.setTimeout(async () => {
          if (me.activeTarget === target && target.isConnected) {
            const result = me.updateContent();
            if (Objects.isPromise(result) && !me.loadingMsg) {
              await result;
            }
            me.showByTarget(target);
          }
        }, !me.triggeredByEvent || me.triggeredByEvent.type === "pointerover" ? me.hoverDelay : 0, "show", true);
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }
  changeAllowOver(allowOver) {
    if (!this.inAfterShow) {
      this.configuredAllowOver = allowOver;
    }
    return allowOver;
  }
  updateAllowOver(allowOver) {
    var _a4;
    const me = this, { element } = me;
    element.classList.toggle("b-allow-over", Boolean(allowOver));
    if (allowOver) {
      me.allowOverlisteners = EventHelper.on({
        element,
        mouseenter: "onOwnElementMouseEnter",
        mouseleave: "internalOnPointerOut",
        thisObj: me
      });
    } else {
      (_a4 = me.allowOverlisteners) == null ? void 0 : _a4.call(me);
    }
  }
  updateContent() {
    const me = this;
    if (me.getHtml) {
      const result = me.callback(me.getHtml, me, [{
        tip: me,
        element: me.element,
        activeTarget: me.activeTarget,
        event: me.triggeredByEvent
      }]);
      me.html = result;
      return result;
    }
  }
  // There are 3 possible scenarios:
  // - Static content
  // - Remote content being loaded (meaning we (possibly) set a loading message as the `html`
  // - Tooltip acts as a Container
  get hasContent() {
    return Boolean(DomHelper.isReactElement(this._html) || (this._html !== "" && (typeof this.html === "string" && this.html.length) || this.items.length));
  }
  internalBeforeShow() {
    return (this.updateContentOnMouseMove || this.hasContent) && !this.disabled;
  }
  /**
   * Shows a spinner and a message to indicate an async flow is ongoing
   * @param {String} message The message, defaults to {@link #config-loadingMsg}
   */
  showAsyncMessage(message = this.optionalL(this.loadingMsg)) {
    if (message) {
      this.html = `
                <div class="b-tooltip-loading">
                    <i class="b-icon b-icon-spinner"></i>
                    ${StringHelper.encodeHtml(message)}
                </div>
            `;
    }
  }
  showByTarget(target) {
    var _a4;
    const me = this, { anchorToTarget } = me;
    me.mouseMoveRemover = (_a4 = me.mouseMoveRemover) == null ? void 0 : _a4.call(me);
    me.showBy({
      [anchorToTarget ? "target" : "position"]: anchorToTarget ? target : "mouse",
      overlap: !(anchorToTarget && me.anchor)
    });
  }
  afterShowByTarget() {
    const me = this, { dismissDelay } = me;
    me.abortDelayedShow();
    if (dismissDelay) {
      me.setTimeout("hide", dismissDelay);
    }
    if (me.element.parentNode) {
      me.toFront();
    }
    if (!me.mouseMoveRemover && (me.trackMouse || me.updateContentOnMouseMove)) {
      me.mouseMoveRemover = EventHelper.on({
        element: me.rootElement,
        pointermove: "onMouseMove",
        thisObj: me
      });
    }
    me.inAfterShow = true;
    me.allowOver = me.allowOver || me.configuredAllowOver != false && me.childItems.some((w) => w.isVisible && !w.disabled && w.focusElement);
    me.inAfterShow = false;
  }
  updateActiveTarget(newTarget, lastTarget) {
    const me = this, activeElement = DomHelper.getActiveElement(newTarget);
    if (newTarget) {
      if (!me.isConfiguring) {
        me.trigger("overTarget", { newTarget, lastTarget });
      }
      me.describedElement = newTarget.contains(activeElement) ? activeElement : null;
    } else {
      me.trigger("targetOut", { lastTarget });
      me.describedElement = null;
    }
  }
  updateDescribedElement(describedElement, oldDescribedElement) {
    if (describedElement) {
      DomHelper.addAttributeValue(describedElement, "aria-describedby", this.id);
    }
    if (oldDescribedElement) {
      DomHelper.removeAttributeValue(oldDescribedElement, "aria-describedby", this.id);
    }
  }
  internalOnPointerOut(event) {
    var _a4;
    const me = this, toElement = event.relatedTarget;
    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }
    if (me.element.contains(event.target) && ((_a4 = me.activeTarget) == null ? void 0 : _a4.contains(toElement))) {
      return;
    }
    if (me.activeTarget && !me.activeTarget.contains(toElement)) {
      me.handleForElementOut();
    }
  }
  handleForElementOut() {
    const me = this, { hideDelay } = me;
    if (me.trigger("pointerOut") === false) {
      me.activeTarget = null;
      return true;
    }
    me.abortDelayedShow();
    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();
      if (hideDelay > 0) {
        me.setTimeout("hide", hideDelay);
      } else {
        me.hide();
      }
    }
  }
  show(spec) {
    const me = this;
    if (!spec && me.forElement && me.anchorToTarget && !me.forSelector) {
      me.showByTarget(me.forElement);
    } else {
      super.show(...arguments);
    }
    if (me.isVisible) {
      me.afterShowByTarget();
    } else {
      me.activeTarget = null;
    }
  }
  get hoverDelay() {
    var _a4;
    return ((_a4 = this.triggeredByEvent) == null ? void 0 : _a4.pointerType) === "focus" ? 0 : this._hoverDelay;
  }
  get hideDelay() {
    var _a4;
    return ((_a4 = this.triggeredByEvent) == null ? void 0 : _a4.pointerType) === "focus" ? 0 : this.autoHide ? this._hideDelay : false;
  }
  hide() {
    var _a4, _b;
    const me = this;
    me.abortDelayedShow();
    if (!me._hidden) {
      me.abortDelayedHide();
      const result = super.hide(...arguments);
      me.lastHidden = Date.now();
      me.activeTarget = null;
      (_a4 = me.mouseMoveRemover) == null ? void 0 : _a4.call(me);
      me.mouseMoveRemover = null;
      (_b = me.transitionEndDetacher) == null ? void 0 : _b.call(me);
      me.transitionEndDetacher = null;
      return result;
    } else {
      return immediatePromise4;
    }
  }
  abortDelayedShow() {
    var _a4, _b, _c;
    const me = this;
    if (me.hasTimeout("show")) {
      (_a4 = me.mouseDownRemover) == null ? void 0 : _a4.call(me);
      me.mouseDownRemover = null;
      me.clearTimeout("show");
      (_b = me.mouseMoveRemover) == null ? void 0 : _b.call(me);
      me.mouseMoveRemover = null;
      (_c = me.transitionEndDetacher) == null ? void 0 : _c.call(me);
      me.transitionEndDetacher = null;
    }
  }
  /**
   * Stops both timers which may hide this tooltip, the one which counts down from mouseout
   * and the one which counts down from mouseover show for dismissDelay ms
   * @private
   */
  abortDelayedHide() {
    this.clearTimeout("hide");
  }
  realign() {
    const me = this, spec = me.lastAlignSpec;
    if (!me.isConfiguring && !me.isVisible && (spec == null ? void 0 : spec.targetOutOfView)) {
      if (spec.allowTargetOut || DomHelper.isInView(spec.target, false, me)) {
        me.show();
        spec.targetOutOfView = false;
      }
    }
    super.realign();
  }
  alignTo(spec) {
    const me = this, mouseOffsetX = (me.mouseOffsetX || 1) * (me.rtl ? -1 : 1), mouseOffsetY = me.mouseOffsetY || 1, xMargin = Math.max(Math.min(mouseOffsetX, 5), 0), yMargin = Math.max(Math.min(mouseOffsetY, 5), 0);
    if (!me.isVisible) {
      return;
    }
    let mousePosition;
    if (!me.anchorToTarget && spec.position === "mouse") {
      mousePosition = new Point(
        me.triggeredByEvent.pageX - globalThis.scrollX,
        me.triggeredByEvent.pageY - globalThis.scrollY
      );
      spec.position = new Point(
        mousePosition.x + (mouseOffsetX || 1) - (mouseOffsetX < 0 ? me.width : 0),
        mousePosition.y + (mouseOffsetY || 1) - (mouseOffsetY < 0 ? me.height : 0)
      );
    }
    if (spec && !(me.triggeredByEvent && me.element.contains(me.triggeredByEvent.target))) {
      if (spec.nodeType === Node.ELEMENT_NODE) {
        spec = {
          target: spec
        };
      }
    }
    super.alignTo(spec);
    if (mousePosition && me.lastAlignSpec.result.inflate(yMargin, xMargin).contains(mousePosition)) {
      me.lastAlignSpec.position = "mouse";
      me.mouseOffsetY = -mouseOffsetY;
      me.mouseOffsetX = -mouseOffsetX;
      me.realign();
      me.mouseOffsetY = mouseOffsetY;
      me.mouseOffsetX = mouseOffsetX;
    }
  }
  //endregion
  //region Tooltip contents
  /**
   * Get/set the HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
   * classList, to allow targeted styling. To create async tooltip and show the {@link #config-loadingMsg}, see code below:
   * For example:
   *
   * ```javascript
   * new Tooltip({
   *     listeners : {
   *         beforeShow : ({ source : tip }) => {
   *             tip.showAsyncMessage();
   *             AjaxHelper.get('someurl').then(response => tip.html = 'Done!');
   *         }
   *     }
   * });
   * ```
   *
   * @member {String} html
   * @category DOM
   */
  set html(html) {
    super.html = html;
    if (this.isVisible) {
      this.realign();
    }
  }
  get html() {
    return super.html;
  }
  changeHtml(htmlOrPromise) {
    const me = this;
    if (Objects.isPromise(htmlOrPromise)) {
      me.showAsyncMessage();
      htmlOrPromise.target = me.activeTarget;
      htmlOrPromise.then((html) => {
        if (htmlOrPromise.target === me.activeTarget) {
          me.html = html;
        }
      });
      return;
    }
    if (typeof htmlOrPromise !== "object") {
      htmlOrPromise = htmlOrPromise != null ? me.optionalL(String(htmlOrPromise)) : "";
    }
    return htmlOrPromise;
  }
  updateHtml(value, was) {
    const me = this;
    let empty2 = value === "";
    if (!empty2) {
      super.updateHtml(value, was);
      if (me.hasContent) {
        if (!Objects.isPromise(value)) {
          me.trigger("innerHtmlUpdate", { value });
        }
      } else {
        empty2 = true;
      }
    }
    if (empty2) {
      me.hide();
    }
  }
  //endregion
  //region Events
  /**
   * Mouse move event listener which updates tooltip
   * @private
   */
  onMouseMove(event) {
    const me = this, {
      forElement,
      activeTarget
    } = me, isHiding = me.hasTimeout("hide"), target = event.target;
    me.triggeredByEvent = event;
    if (!me._hidden) {
      let hideVetoed;
      const isWithinTarget = activeTarget == null ? void 0 : activeTarget.contains(target), isElementOut = !isWithinTarget && me.forSelector && activeTarget && !isHiding && target.nodeType === Node.ELEMENT_NODE && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target)), containingElement = (forElement == null ? void 0 : forElement.document) ? forElement.document.documentElement : forElement, forElementContainsTarget = containingElement && (containingElement.contains ? containingElement.contains(target) : containingElement.compareDocumentPosition(target) & 16);
      if (isElementOut) {
        hideVetoed = me.handleForElementOut();
      }
      if (hideVetoed || !isHiding || forElementContainsTarget) {
        if (me.dismissDelay && !isHiding) {
          me.setTimeout("hide", me.dismissDelay);
        }
        if (me.updateContentOnMouseMove && me.getHtml) {
          me.html = me.callback(me.getHtml, me, [{
            tip: me,
            element: me.element,
            forElement: activeTarget,
            event
          }]);
          if (!me.html) {
            me.hide();
            return;
          }
        }
        if (me.trackMouse) {
          me.alignTo({
            position: "mouse",
            ignorePageScroll: true
          });
        }
      }
    }
  }
  // Handle if implementer has defined "showOnClick"
  onElementUserAction(event) {
    this.internalOnPointerOver(event);
  }
  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }
  //endregion
  // rootElement = where to find the float root
  // forElement = where to set up listeners
  // Can be different when using a shadowRoot not part of a webcomponent
  static getSharedTooltip(rootElement, forElement, skipCreating) {
    var _a4, _b, _c;
    let sharedTooltip = (_b = (_a4 = forElement.bryntum) == null ? void 0 : _a4.tooltip) == null ? void 0 : _b.get(_Tooltip);
    if (!sharedTooltip && !skipCreating) {
      if (!((_c = forElement.bryntum) == null ? void 0 : _c.tooltip)) {
        ObjectHelper.setPath(forElement, "bryntum.tooltip", /* @__PURE__ */ new Map());
      }
      const map = forElement.bryntum.tooltip;
      map.set(_Tooltip, true);
      sharedTooltip = new _Tooltip({
        forElement,
        rootElement,
        forSelector: "[data-btip]",
        resetCfg: {},
        isSharedTooltip: true,
        cls: "b-tooltip-shared",
        internalListeners: {
          // Reconfigure on pointerOver
          pointerOver({ source: me, target }) {
            for (const key in me.resetCfg) {
              if (key === "listeners") {
                me.un(me.resetCfg[key].set);
              } else if (key !== "html") {
                me[key] = me.resetCfg[key].was;
              }
            }
            me.resetCfg = {};
            const forComponent = Widget.getById(target.id), config = (forComponent == null ? void 0 : forComponent.tipConfig) || me.gatherDataConfigs(target.dataset);
            if (forComponent && forComponent.element !== target || !forComponent && target.matches(".b-widget") || // Respect our forComponent's wish to not show when it's disabled
            (forComponent == null ? void 0 : forComponent.disabled) && !forComponent.showTooltipWhenDisabled) {
              return false;
            }
            me._owner = forComponent;
            for (const key in config) {
              me.resetCfg[key] = {
                set: config[key],
                was: me[key]
              };
              if (key === "listeners") {
                me.ion(config[key]);
              } else {
                me[key] = config[key];
              }
            }
          },
          hide({ source: me }) {
            me.owner = null;
          }
        },
        gatherDataConfigs(dataset) {
          const me = this, config = {};
          for (const key in dataset) {
            if (key.startsWith("btip")) {
              if (key.length > 4) {
                const configProp = StringHelper.uncapitalize(key.substr(4));
                if (configProp in me.getDefaultConfiguration()) {
                  const value = dataset[key];
                  config[configProp] = isBoolean[value] ? value === "true" : isNaN(value) ? value : parseInt(value, 10);
                }
              } else {
                config.html = dataset[key];
              }
            }
          }
          return config;
        },
        filterTarget(element) {
          const target = element.closest(this.forSelector);
          if (target) {
            return target;
          }
          if (_Tooltip.showOverflow && element.closest(".b-widget")) {
            while ((element == null ? void 0 : element.nodeType) === Element.ELEMENT_NODE) {
              if (DomHelper.getStyleValue(element, "text-overflow") === "ellipsis" && element.clientWidth < element.scrollWidth) {
                this.html = StringHelper.encodeHtml(element.textContent);
                return element;
              }
              element = element.parentNode;
            }
          }
        }
      });
      EventHelper.on({
        element: forElement,
        mouseenter: (event) => _Tooltip.currentOverElement = event.target,
        // If mouse is not used for editing cell then Tooltip has no `currentOverElement` and no error tooltip is shown. We use keydown event.target for this
        keydown: (event) => _Tooltip.currentOverElement = event.target,
        capture: true,
        thisObj: sharedTooltip
      });
      map.set(_Tooltip, sharedTooltip);
    }
    return sharedTooltip;
  }
  static encodeConfig(tooltip) {
    const dataset = {};
    if (typeof tooltip === "string") {
      dataset.btip = tooltip;
    } else {
      for (const config in tooltip) {
        dataset[`btip${config === "html" ? "" : StringHelper.capitalize(config)}`] = tooltip[config];
      }
    }
    return dataset;
  }
};
//region Default config
__publicField(_Tooltip, "$name", "Tooltip");
__publicField(_Tooltip, "type", "tooltip");
var Tooltip = _Tooltip;
Tooltip.initClass();
Object.defineProperty(Widget, "tooltip", {
  get() {
    return Tooltip.getSharedTooltip(document.body, document.body);
  }
});
Widget.Tooltip = Tooltip;
Tooltip._$name = "Tooltip";

// ../Core/lib/Core/util/drag/DragTipProxy.js
var DragTipProxy = class extends DragProxy {
  static get type() {
    return "tip";
  }
  static get configurable() {
    return {
      /**
       * Controls how the tooltip will be aligned to the current drag position.
       *
       * See {@link Core.helper.util.Rectangle#function-alignTo} for details.
       * @config {String}
       * @default
       */
      align: "t10-b50",
      /**
       * The number of pixels to offset from the drag position.
       * @config {Number}
       * @default
       */
      offset: 20,
      /**
       * The tooltip to be shown, hidden and repositioned to track the drag position.
       * @config {Core.widget.Tooltip}
       */
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip"
        }
      }
    };
  }
  open() {
    this.getConfig("tooltip");
  }
  close() {
    var _a4;
    (_a4 = this.tooltip) == null ? void 0 : _a4.hide();
  }
  dragMove(drag) {
    const { offset, tooltip } = this, { event } = drag;
    if (tooltip) {
      if (!tooltip.isVisible) {
        tooltip.show();
      }
      tooltip.alignTo({
        align: this.align,
        target: new Rectangle(event.clientX - offset, event.clientY - offset, offset * 2, offset * 2)
      });
    }
  }
  changeTooltip(config, existing) {
    return Widget.reconfigure(
      existing,
      config,
      /* owner = */
      this
    );
  }
};
DragTipProxy.initClass();
DragTipProxy._$name = "DragTipProxy";

// ../Core/lib/Core/widget/mixin/Labelable.js
var Labelable_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Get/set fields label. Please note that the Field needs to have a label specified from start for this to
         * work, otherwise no element is created.
         * @member {String} label
         */
        /**
         * Label, prepended to field
         * @config {String}
         * @category Label
         */
        label: null,
        /**
         * Label position, either 'before' the field or 'above' the field
         * @config {'before'|'above'}
         * @default
         * @category Label
         */
        labelPosition: "before",
        /**
         * CSS class name or class names to add to any configured {@link #config-label}
         * @config {String|Object}
         * @category Label
         */
        labelCls: null,
        /**
         * The width to apply to the `<label>` element. If a number is specified, `px` will be used.
         * @config {String|Number}
         * @localizable
         * @category Label
         */
        labelWidth: {
          value: null,
          $config: {
            localeKey: "L{labelWidth}"
          }
        }
      };
    }
    get hasLabel() {
      return Boolean(this.label);
    }
    compose() {
      const { hasLabel, labelPosition } = this;
      return {
        class: {
          [`b-label-${labelPosition}`]: hasLabel,
          "b-has-label": hasLabel
        }
      };
    }
    changeLabel(label) {
      return label || "";
    }
    setupLabel(lbl) {
      return ObjectHelper.assign({
        tag: "label",
        for: `${this.id}-input`,
        class: `b-label b-align-${lbl.align || "start"}`
      }, lbl);
    }
    updateLabelWidth(newValue) {
      if (this.labelElement) {
        this.labelElement.style.flex = `0 0 ${DomHelper.setLength(newValue)}`;
        this.inputWrap.style.flexBasis = newValue == null ? "" : "auto";
      }
    }
    //endregion
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {
    }
  }, //region Config
  __publicField(_a4, "$name", "Labelable"), _a4;
};

// ../Core/lib/Core/widget/FieldContainer.js
var FieldContainer = class extends Container {
  static get configurable() {
    return {
      /**
       * An animation config object to use when expanding or collapsing the field's
       * {@link Core.widget.Field#config-container}.
       * @config {Object} animation
       * @property {Number} [animation.duration=300] The duration of the animation (in milliseconds).
       * @internal
       */
      animation: {
        duration: 300
      },
      /**
       * Controls whether the field is collapsed (that is, the field's {@link Core.widget.Field#config-container}
       * is hidden).
       * @config {Boolean}
       * @default false
       */
      collapsed: null,
      /**
       * The animator performing the field's currently running expand or collapse animation.
       * @config {Core.util.Animator}
       * @private
       */
      collapser: {
        value: null,
        $config: "nullify"
        // to abort animations on destroy
      },
      /**
       * A mapping object for config properties of the items in the {@link Core.widget.Field#config-container}.
       * The keys are the config names and the values are functions that compute the config value when passed
       * the field instance.
       *
       * For example, this is the default:
       * ```javascript
       *      syncableConfigs : {
       *          disabled : field => field.disabled
       *      }
       * ```
       * This indicates that the config property named with the key ('disabled') should be assigned to the result
       * of the function assigned to that key (`field => field.disabled`). In other words, when the field is
       * {@link Core.widget.Field#config-disabled}, all of the field's items should also be disabled.
       *
       * @config {Object}
       * @internal
       */
      syncableConfigs: null,
      /**
       * This object holds truthy values for each config property that, when modified, should trigger a sync of
       * this field's items as defined in {@link #config-syncableConfigs}.
       * @config {Object}
       * @internal
       */
      syncConfigTriggers: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      testConfig: {
        animation: {
          duration: 10
        }
      }
    };
  }
  static get delayable() {
    return {
      syncChildConfigs: "raf"
    };
  }
  get inline() {
    var _a4;
    return (_a4 = this.owner.inline) != null ? _a4 : this.ensureItems().count === 1;
  }
  changeCollapsed(collapsed) {
    if (this.togglingCollapse) {
      this.togglingCollapse = false;
      return collapsed;
    }
    this.toggleCollapse(Boolean(collapsed));
  }
  updateCollapsed(collapsed) {
    var _a4;
    this.collapser = (_a4 = this.collapser) == null ? void 0 : _a4.destroy();
    this.setCollapsedCls(collapsed);
  }
  updateCollapser(collapser, was) {
    if (was && was.completed == null) {
      if (!was.reverting || !collapser) {
        was.destroy();
      }
    }
    this.setOwnerCls("b-collapsing", collapser);
  }
  //endregion
  /**
   * This property is `true` if the field container is currently collapsing.
   * @property {Boolean}
   * @readonly
   */
  get collapsing() {
    const { collapser } = this;
    return collapser != null && collapser.collapsed;
  }
  /**
   * This property is `true` if the field container is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get collapsingExpanding() {
    return this.collapser != null;
  }
  /**
   * This property is `true` if the field container is currently expanding.
   * @property {Boolean}
   * @readonly
   */
  get expanding() {
    const { collapser } = this;
    return collapser != null && !collapser.collapsed;
  }
  collapse(animation) {
    this.toggleCollapse(true, animation);
  }
  expand(animation) {
    this.toggleCollapse(false, animation);
  }
  setCollapsedCls(collapsed) {
    this.setOwnerCls("b-collapsed", collapsed);
  }
  setOwnerCls(cls, state) {
    var _a4, _b;
    (_b = (_a4 = this.owner) == null ? void 0 : _a4.element) == null ? void 0 : _b.classList[state ? "add" : "remove"](cls);
  }
  syncChildConfigs() {
    const me = this, { owner, syncableConfigs } = me;
    if (syncableConfigs) {
      let destProp, val;
      for (destProp in syncableConfigs) {
        val = syncableConfigs[destProp](owner);
        me.eachWidget(
          (item) => {
            item[destProp] = val;
          },
          /* deep = */
          false
        );
      }
    }
    owner.afterSyncChildConfigs(me);
  }
  syncContainer() {
    const { inline, layout } = this;
    if (this.autoLayout) {
      layout.horizontal = inline;
      layout.justify = inline ? "center" : "stretch";
    }
  }
  toggleCollapse(collapsed, animation) {
    const me = this, { animation: collapseAnimation, collapser, inline } = me, { containerWrapElement } = me.owner, finalize = (complete) => {
      if (complete) {
        me.element.style.height = "";
        me.togglingCollapse = true;
        me.collapsed = collapsed;
        me.collapser = null;
      }
    };
    if (collapsed == null) {
      collapsed = !me.collapsed;
    }
    if (animation !== false && animation !== null) {
      if (!containerWrapElement || !me.isVisible) {
        animation = null;
      } else {
        if (animation === true) {
          animation = {};
        } else if (typeof animation === "number") {
          animation = {
            duration: animation
          };
        }
        animation = collapseAnimation || animation ? ObjectHelper.merge({}, collapseAnimation, animation) : null;
      }
    }
    if (!animation) {
      me.togglingCollapse = true;
      me.collapsed = collapsed;
    } else if (collapser && collapsed !== collapser.collapsed) {
      me.collapser = collapser.revert({ finalize });
      me.collapser.collapsed = collapsed;
    } else if (!collapser && collapsed !== me.collapsed) {
      !collapsed && me.setCollapsedCls(false);
      const { element } = me, { height } = element.getBoundingClientRect(), expanded = inline ? 1 : height;
      !collapsed && me.setCollapsedCls(true);
      element.style.height = `${height}px`;
      me.collapser = Animator.run(ObjectHelper.merge({
        finalize,
        element: containerWrapElement,
        [inline ? "opacity" : "height"]: {
          from: collapsed ? expanded : 0,
          to: collapsed ? 0 : expanded
        }
      }, animation));
      me.collapser.collapsed = collapsed;
    }
  }
};
//region Config
__publicField(FieldContainer, "$name", "FieldContainer");
__publicField(FieldContainer, "type", "fieldcontainer");
FieldContainer.initClass();
FieldContainer._$name = "FieldContainer";

// ../Core/lib/Core/widget/Field.js
var byWeight = (l, r) => (l.weight || 0) - (r.weight || 0);
var byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);
var emptyArray9 = [];
var triggerConfigs = {
  align: true,
  weight: true
};
var _Field = class _Field extends Widget.mixin(Badge_default, Labelable_default) {
  static get configurable() {
    return {
      defaultBindProperty: "value",
      /**
       * @hideconfigs htmlCls, content, tag, scrollable, html
       */
      /**
       * Text to display in empty field.
       * @config {String} placeholder
       */
      placeholder: null,
      /**
       * Gets or sets the value. The returned type will depend upon the Field subclass.
       *
       * `TextField` returns a `String`.
       *
       * `NumberField` returns a `Number`.
       *
       * `DateField` and `TimeField` return a `Date` object, and `null` if the field is empty.
       *
       * `Combo` will return a `String` if configured with `items` as a simple string array.
       * Otherwise it will return the {@link Core.widget.Combo#config-valueField} value from the
       * selected record, or `null` if no selection has been made.
       * @member {*} value
       */
      /**
       * Default value
       * @config {String}
       */
      value: "",
      /**
       * Name of the field which is used as a key to get/set values from/to the field.
       * Used prior to {@link Core.widget.Widget#config-ref ref} and {@link Core.widget.Widget#config-id id} in
       * {@link Core.widget.Container#property-values Container.values}.
       *
       * The config is useful when the field is used in EventEditor or TaskEditor to load/save values automatically.
       * @config {String}
       */
      name: null,
      /**
       * The labels to add either before or after the input field.
       * Each label may have the following properties:
       * * `html` The label text.
       * * `align` `'start'` or `'end'` which end of the field the label should go.
       * @config {Object[]}
       * @property {String} html Label text
       * @property {'start'|'end'} align Which end of the file the label should go
       * @category Label
       */
      labels: null,
      /**
       * Configure as `true` to indicate that a `null` field value is to be marked as invalid.
       * @config {Boolean}
       * @default false
       */
      required: null,
      /**
       * Show a trigger to clear field, and allow `SHIFT+BACKSPACE` key to clear field if this field is
       * not {@link #config-readOnly}. The trigger is available in the {@link #property-triggers} object
       * under the name `clear`. May also be an object which configures the `clear`
       * {@link #property-triggers trigger}.
       * @config {Boolean|FieldTriggerConfig}
       * @default false
       */
      clearable: null,
      /**
       * If this field is not {@link #config-readOnly}, then setting this option means that pressing
       * the `ESCAPE` key after editing the field will revert the field to the value it had when
       * the user focused the field. If the field is _not_ changed from when focused, the {@link #config-clearable}
       * behaviour will be activated.
       * @config {Boolean}
       * @default false
       */
      revertOnEscape: null,
      /**
       * An optional string to display inside the input field as an overlay. This can be useful for displaying
       * a field's units.
       *
       * This config is ignored if {@link #config-hintHtml} is set.
       *
       * For example:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Temperature',
       *      hint  : '°C'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hint` text:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Duration',
       *      hint  : ({ value }) => (value === 1) ? 'Day' : 'Days'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hint` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @param {Object} data A data object
       * @param {Core.widget.Field} data.source A reference to the field instance
       * @param {*} data.value The current value of the field
       * @returns {String}
       * @category Label
       */
      hint: null,
      /**
       * This config is similar to {@link #config-hint} except that this config is used to display HTML content.
       * Since this can allow malicious content to be executed, be sure not to include user-entered data or to
       * encode such data (see {@link Core.helper.StringHelper#function-encodeHtml-static}).
       *
       * If this config is set, {@link #config-hint} is ignored.
       *
       * For example:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Temperature',
       *      hintHtml : '<i>°C</i>'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hintHtml` text:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Duration',
       *      hintHtml : ({ value }) => (value === 1) ? '<i>Day</i>' : '<i>Days</i>'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hintHtml` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @param {Object} data A data object
       * @param {Core.widget.Field} data.source A reference to the field instance
       * @param {*} data.value The current value of the field
       * @returns {String}
       * @category Label
       */
      hintHtml: null,
      /**
       * The width to apply to the `<input>` element. If a number is specified, `px` will be used.
       * @config {String|Number}
       * @category Input element
       */
      inputWidth: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before triggering a change event.
       * Set to 0 to not trigger change events from keystrokes (listen for input event instead to have
       * immediate feedback, change will still be triggered on blur).
       *
       * If the field is {@link #config-clearable}, the change event fires immediately on receiving
       * the clear gesture.
       * @config {Number}
       * @default
       */
      keyStrokeChangeDelay: 0,
      /**
       * Makes the field unmodifiable by user action. The input area is not editable, and triggers
       * are unresponsive.
       *
       * This is a wider-acting setting than {@link #config-editable} which *only* sets the
       * `readOnly` attribute of the `<input>` field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       * @prp {Boolean}
       */
      readOnly: null,
      /**
       * Set to false to prevent user from editing the field. For TextFields it is basically the same as setting
       * {@link #config-readOnly}, but for PickerFields there is a distinction where it allows you to pick a value
       * but not to type one in the field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       *
       * On mobile devices, {@link Core.widget.PickerField}s are set to `editable : false` by
       * default so that the user must select a value from the dropdown picker rather than having
       * to type a value which will cause a display of the virtual keyboard.
       *
       * If typing is essential to the functioning of the field, configuring the field
       * with `editable : true` will override this behaviour.
       * @prp {Boolean}
       * @default true
       */
      editable: true,
      defaultAction: "change",
      /**
       * The trigger Widgets as specified by the {@link #config-triggers} configuration and the
       * {@link #config-clearable} configuration. Each is a {@link Core.widget.Widget} instance which may
       * be hidden, shown and observed and styled just like any other widget.
       * @member {Object<String,Core.widget.Widget>} triggers
       */
      /**
       * The triggers to add either before or after the input field. Each property name is the reference by which
       * an instantiated Trigger Widget may be retrieved from the live `{@link #property-triggers}` property.
       *
       * Each trigger may have the following properties:
       * * `cls` The CSS class to apply.
       * * `handler` A method in the field to call upon click
       * * `align` `'start'` or `'end'` which end of the field the trigger should go.
       * * `weight` (Optional) Higher weighted triggers gravitate towards the input field.
       *
       * ```javascript
       * const textField = new TextField({
       *   triggers : {
       *       check : {
       *           cls : 'b-fa b-fa-check',
       *           handler() {
       *               ...
       *           }
       *       },
       *       ...
       *   }
       * })
       * ```
       *
       * @config {Object<String,FieldTriggerConfig>}
       */
      triggers: null,
      /**
       * Specify `false` to prevent field from being highlighted when on external value changes
       * @config {Boolean}
       */
      highlightExternalChange: true,
      localizableProperties: ["label", "title", "placeholder", "labelWidth"],
      /**
       * Specify `true` to auto select field contents on focus
       * @config {Boolean}
       * @default
       */
      autoSelect: false,
      /**
       * Sets the native `autocomplete` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)
       * @config {String}
       * @default
       * @category Input element
       */
      autoComplete: "off",
      /**
       * Sets the native `spellcheck` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/spellcheck)
       * @config {Boolean}
       * @category Input element
       */
      spellCheck: null,
      /**
       * Set to `false` to not highlight a field as invalid while typing, to instead show it on ENTER key press
       * or similar.
       * @config {Boolean}
       * @category Input element
       */
      validateOnInput: true,
      /**
       * Sets custom attributes of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)
       * @config {Object<String,String>}
       * @default
       * @category Input element
       */
      inputAttributes: null,
      /**
       * Sets the `type` attribute of the underlying input element (password, hidden, date, color, etc.).
       * @config {String}
       * @category Input element
       */
      inputType: "text",
      /**
       * Text alignment for the input field.
       * @config {String}
       * @category Input element
       */
      inputAlign: null,
      /**
       * A list of property names to be set in the underlying input element from properties
       * by the same name in this Field object if the value is not `== null`.
       * @private
       * @category Input element
       */
      attributes: {
        value: [
          "placeholder",
          "autoComplete",
          "spellCheck",
          "minLength",
          "maxLength",
          "pattern",
          "tabIndex",
          "min",
          "max"
        ],
        $config: {
          merge: "distinct"
        }
      },
      nullValue: {
        $config: null,
        value: null,
        default: null
        // store _value=null on prototype
      },
      updatedClsDuration: 500,
      inputReadOnly: false,
      ariaElement: "input",
      /**
       * The configuration for additional items associated to this field. This is typically used to add contextual
       * fields related to a {@link Core.widget.Checkbox checkbox} or {@link Core.widget.Radio radio button}. See
       * these classes for examples of nested fields.
       *
       * This config can be provided as an array of widget config objects, an object with named widgets (see
       * {@link Core.widget.FieldContainer#config-namedItems}, or a config object for the whole
       * {@link Core.widget.FieldContainer field container}.
       *
       * To determine if the object is a `namedItems` object or a {@link Core.widget.FieldContainer field container}
       * config, the object is checked for either a `type` or an `items` property. If it has either of these
       * properties, it is a field container config object. Configuring the container is useful for applying
       * {@link Core.widget.FieldContainer#config-cls classes} or {@link Core.widget.FieldContainer#config-style styles}
       * to the container as a whole.
       *
       * For example, to add named items:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          address1 : {
       *              type : 'textfield'
       *          },
       *          address2 : {
       *              type : 'textfield'
       *          }
       *      }
       *  });
       * ```
       *
       * To style the container as well, move the items to the `items` property and add `cls`:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          cls   : 'address-form',
       *          items : {
       *              address1 : {
       *                  type : 'textfield'
       *              },
       *              address2 : {
       *                  type : 'textfield'
       *              }
       *          }
       *      }
       *  });
       * ```
       *
       * @config {Core.widget.FieldContainer}
       * @accepts {Object<string,ContainerItemConfig>|ContainerItemConfig[]|FieldContainerConfig}
       * @category Container
       */
      container: {
        $config: "nullify",
        value: null
      },
      /**
       * The default configuration for the {@link #config-container}.
       * @config {Core.widget.FieldContainer}
       * @accepts {Core.widget.FieldContainer|FieldContainerConfig}
       * @category Container
       * @internal
       */
      containerDefaults: {
        type: "fieldcontainer",
        syncableConfigs: {
          disabled: (field) => field.disabled
        },
        syncConfigTriggers: {
          disabled: 1
        }
      },
      /**
       * The config controls how the value of nested items are handled when a parent container gets or sets its
       * {@link Core.widget.Container#property-values}.
       *
       * The valid values for this config are:
       *  - `null` (the default) will include the values of this field's items if this field stores its own value.
       *  - `true` to always include the values of this field's items.
       *  - `false` to never include the values of this field's items.
       *  - `'nested'` to include the values of this field's items as a nested object under the field's `name`.
       *    This field's `value` is stored as the `'value'` property of that object.
       *  - Any other string is treated as the name of a property on this field. When truthy, the values of this
       *    field's items will be included.
       *  - A function can be supplied that must return a value given this field as its sole argument. If that
       *    value is truthy, this field's items will be included.
       *
       * @config {Boolean|String|Function}
       * @param {Core.widget.Field} field Field instance
       * @returns {Boolean}
       * @category Container
       */
      containValues: null,
      /**
       * Set this config to `true` to always display items horizontally along with this field. This assigns an
       * {@link Core.widget.layout.Box hbox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * Alternatively, set this config to `false` to wrap this field's items below. This assigns a
       * {@link Core.widget.layout.VBox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * This config defaults to `true` if there is exactly one item, and `false` otherwise.
       * @config {Boolean}
       * @category Container
       */
      inline: null,
      testConfig: {
        updatedClsDuration: 10
      },
      keyMap: {}
    };
  }
  static get delayable() {
    return {
      highlightChanged: "raf"
    };
  }
  doDestroy() {
    var _a4, _b, _c;
    const me = this, { triggers } = me, errorTip = me.isPainted && _Field.getSharedErrorTooltip(me.rootElement, true);
    (_a4 = me.inputListenerRemover) == null ? void 0 : _a4.call(me);
    (_b = me.keyListenerRemover) == null ? void 0 : _b.call(me);
    (_c = me.container) == null ? void 0 : _c.destroy();
    super.doDestroy();
    if (triggers) {
      for (const t of Object.values(triggers)) {
        t.destroy();
      }
    }
    if ((errorTip == null ? void 0 : errorTip.field) === me) {
      errorTip.hide();
    }
  }
  get childItems() {
    const { container, triggers } = this, ret = triggers ? Object.values(triggers) : [];
    return container ? [...ret, ...container.childItems] : ret;
  }
  get invalidValueError() {
    return "L{invalidValue}";
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   * @member {Core.widget.Tooltip}
   * @readonly
   */
  get errorTip() {
    return this.constructor.getSharedErrorTooltip(this.rootElement);
  }
  static getSharedErrorTooltip(rootElement, doNotCreate) {
    var _a4;
    let sharedErrorTooltip = (_a4 = rootElement.bryntum) == null ? void 0 : _a4.errorTooltip;
    if (!sharedErrorTooltip && !doNotCreate) {
      rootElement.bryntum = rootElement.bryntum || {};
      sharedErrorTooltip = new Tooltip({
        cls: "b-field-error-tip",
        forSelector: ".b-field.b-invalid .b-field-inner",
        align: {
          align: "l-r",
          axisLock: "flexible",
          monitorTargetMutation: true
        },
        scrollAction: "realign",
        trapFocus: false,
        role: "alert",
        rootElement,
        onBeforeShow() {
          const tip = this, field = Widget.fromElement(tip.activeTarget);
          if (field) {
            const errors = field.getErrors();
            if (errors) {
              tip.html = errors.join("<br>");
              tip.field = field;
              return true;
            }
          }
          return false;
        }
      });
      rootElement.bryntum.errorTooltip = sharedErrorTooltip;
    }
    return sharedErrorTooltip;
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   *
   * Please note: Not applicable when using widgets inside a shadow root
   * @member {Core.widget.Tooltip}
   * @readonly
   * @static
   */
  static get errorTip() {
    return this.getSharedErrorTooltip(document.body);
  }
  //endregion
  //region Event
  /**
   * Fired when the user types into this field.
   * @event input
   * @param {Core.widget.Field} source This field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {Event} event - The triggering DOM event
   */
  /**
   * Fired when this field's value changes.
   * @event change
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {String} oldValue - This field's previous value
   * @typings oldValue -> {String||Number||Boolean||any}
   * @param {Boolean} valid - True if this field is in a valid state
   * @param {Event} event - The triggering DOM event if any
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   *
   * @typings checked -> {Boolean} // Used for compatibility with Checkbox event
   */
  /**
   * User performed default action (typed into this field).
   * @event action
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {String} oldValue - This field's previous value
   * @typings oldValue -> {String||Number||Boolean||any}
   * @param {Boolean} valid - True if this field is in a valid state
   * @param {Event} event - The triggering DOM event if any
   * @param {Core.data.Model} record Selected record. Available for fields with records selection functionality
   * @param {Core.data.Model[]} records Selected records as an array. Available for fields with records selection functionality
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   *
   * @typings checked -> {Boolean} // Used for compatibility with Checkbox event
   */
  /**
   * Fired when this field is {@link #function-clear cleared}.
   *
   * This will be triggered when a user clicks this field's clear {@link #property-triggers trigger}
   * @event clear
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   */
  /**
   * User clicked one of this field's {@link #property-triggers}
   * @event trigger
   * @param {Core.widget.Field} source This field
   * @typings source -> {Core.widget.Field||any}
   * @param {Core.widget.Widget} trigger The trigger activated by click or touch tap.
   */
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }
  // Adding triggers keymap to field keymap with prefix 'triggerName.';
  changeKeyMap(keyMap) {
    var _a4;
    const me = this;
    let mergedKeyMap = {};
    if (keyMap) {
      if (!me._fieldKeyMap) {
        me._fieldKeyMap = keyMap;
        ObjectHelper.assign(mergedKeyMap, keyMap);
      } else {
        ObjectHelper.assign(mergedKeyMap, me._fieldKeyMap);
      }
    }
    for (const triggerName in me.triggers) {
      if ((_a4 = me.triggers[triggerName]) == null ? void 0 : _a4.keyMap) {
        mergedKeyMap = me.mergeKeyMaps(mergedKeyMap, me.triggers[triggerName].keyMap, triggerName);
      }
    }
    return mergedKeyMap;
  }
  get keyMapSubComponents() {
    return this.triggers;
  }
  onFocusIn(e) {
    const me = this;
    me.valueOnFocus = ObjectHelper.clone(me.value);
    me.validOnFocus = !(me.errors && Object.keys(me.errors).length);
    super.onFocusIn(e);
    me.focusing = true;
    me.syncInvalid();
    me.focusing = false;
  }
  onFocusOut(e) {
    super.onFocusOut(e);
    this.syncRequired();
    this.onEditComplete();
  }
  /**
   * Template function which may be implemented by subclasses to synchronize
   * input state and validity state upon completion of the edit.
   * @internal
   */
  onEditComplete() {
  }
  get rootUiClass() {
    return _Field;
  }
  compose() {
    this.getConfig("clearable");
    const me = this, { container, innerElements, label, labels, labelCls, readOnly, triggers } = me, triggerInstances = ObjectHelper.values(triggers, (k, v) => !v), startTriggers = triggerInstances.filter((t) => t.align === "start").sort(byWeight), endTriggers = triggerInstances.filter((t) => t.align !== "start").sort(byWeightReverse), setupLabel = me.setupLabel.bind(me), innerChildren = [
      ...startTriggers.map((t) => t.element),
      ...innerElements,
      ...endTriggers.map((t) => t.element)
    ];
    return {
      class: {
        "b-has-start-trigger": startTriggers.length,
        "b-no-input": !innerElements.length,
        "b-readonly": readOnly,
        "b-field-container": Boolean(container),
        "b-field-container-inline": container == null ? void 0 : container.inline
      },
      children: [
        ...(labels || emptyArray9).filter((t) => t && t.align !== "end").map(setupLabel),
        (label || null) && setupLabel({
          reference: "labelElement",
          class: `b-label b-align-start ${labelCls || ""}`,
          html: label
        }),
        innerChildren.length ? {
          class: "b-field-inner",
          reference: "inputWrap",
          children: innerChildren
        } : null,
        ...(labels || emptyArray9).filter((t) => (t == null ? void 0 : t.align) === "end").map(setupLabel),
        ...container ? [{
          reference: "containerWrapElement",
          children: [container.element],
          class: {
            "b-field-container-wrap": 1
          }
        }] : emptyArray9
      ]
    };
  }
  updateElement(element, was) {
    var _a4;
    const me = this, value = me.initialConfig.value, { input } = me;
    super.updateElement(element, was);
    if (value != null) {
      me.value = value;
    }
    me.syncEmpty();
    me.updateInputReadOnly(me.inputReadOnly);
    me.syncInvalid();
    const keyEventElement = input || me.focusElement;
    (_a4 = me.keyListenerRemover) == null ? void 0 : _a4.call(me);
    me.keyListenerRemover = keyEventElement && EventHelper.on({
      element: keyEventElement,
      thisObj: me,
      keydown: "internalOnKeyEvent",
      keypress: "internalOnKeyEvent",
      keyup: "internalOnKeyEvent"
    });
  }
  // Subclasses may implement this.
  // Needed because Checkbox produces an array of two elements as its innerElements
  get innerElements() {
    return [this.inputElement];
  }
  /**
   * The input element at the heart if this field
   * @member {HTMLElement} input
   */
  get inputElement() {
    const { attributes, inputAttributes, id, inputCls, inputType, name } = this, domConfig = ObjectHelper.assign({
      reference: "input",
      tag: "input",
      type: inputType,
      name: name || id,
      id: `${id}-input`,
      retainElement: true
      // allow the input to be transplanted as in combo/chipView
    }, inputAttributes);
    if (inputCls) {
      domConfig.class = inputCls;
    }
    for (let key, value, i = attributes.length; i-- > 0; ) {
      key = attributes[i];
      value = this[key];
      if (value != null) {
        domConfig[key] = value;
      }
    }
    return domConfig;
  }
  //endregion
  //region Focus & select
  get caretPos() {
    return this.textSelection[0];
  }
  set caretPos(value) {
    this.textSelection = value;
  }
  get focusElement() {
    return this.input;
  }
  get textSelection() {
    var _a4;
    const input = this.input;
    let ret;
    try {
      ret = [input.selectionStart, input.selectionEnd, input.selectionDirection];
    } catch (e) {
      ret = ((_a4 = input.value) == null ? void 0 : _a4.length) || 0;
      ret = [ret, ret];
    }
    return ret;
  }
  set textSelection(value) {
    if (typeof value === "number") {
      this.select(value, value);
    } else {
      this.select(...value);
    }
  }
  get hasTextSelection() {
    const [selectionStart, selectionEnd] = this.textSelection;
    return selectionStart && selectionEnd - selectionStart > 0;
  }
  /**
   * Returns the input value for this field's input element that will be present if
   * the event carrying the given text is allowed to proceed.
   * @param {String} text
   * @returns {String}
   * @private
   */
  getAfterValue(text) {
    const [begin, end] = this.textSelection, value = this.input.value;
    return `${value.substr(0, begin)}${text}${value.substr(end || begin)}`;
  }
  /**
   * Selects the field contents. Optionally may be passed a start and end.
   * @param {Number} [start] The start index from which to select the input.
   * @param {Number} [end] The index at which to end the selection of the input.
   */
  select(start, end) {
    const input = this.focusElement;
    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }
      if (!this.supportsTextSelection) {
        return;
      }
      input.setSelectionRange(start, end);
    }
  }
  moveCaretToEnd() {
    const input = this.input;
    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {
      this.select(input.value.length, input.value.length);
    }
  }
  selectAll() {
    this.focusElement.select();
  }
  // called on value changes to update styling of empty vs non-empty field
  syncEmpty() {
    var _a4;
    const { isEmptyInput, isEmpty, element } = this, clear = (_a4 = this.triggers) == null ? void 0 : _a4.clear, empty2 = isEmptyInput && isEmpty;
    if (element) {
      if (clear) {
        clear[empty2 ? "hide" : "show"]();
      }
      element.classList.toggle("b-empty", empty2);
    }
  }
  updateHint() {
    this.syncHint();
  }
  updateHintHtml() {
    this.syncHint();
  }
  syncHint() {
    const me = this, { input, hint, hintHtml } = me, parent = input == null ? void 0 : input.parentElement;
    if (input) {
      let hintValue = hintHtml || hint;
      const hintElement = me.hintElement || hintValue && (me.hintElement = DomHelper.createElement({
        parent,
        className: "b-field-hint",
        nextSibling: input.nextSibling,
        children: [{
          className: "b-field-hint-content"
        }]
      }));
      if (hintElement) {
        if (typeof hintValue === "function") {
          hintValue = hintValue({ source: me, value: me.value });
        }
        hintElement.firstChild[hintHtml ? "innerHTML" : "textContent"] = hintValue || "";
      }
      me.element.classList[hintValue ? "remove" : "add"]("b-field-no-hint");
    }
  }
  syncInvalid() {
    const me = this, { isPainted } = me;
    me.updatingInvalid = true;
    if (isPainted) {
      const { isValid, element, inputWrap } = me;
      element.classList[isValid ? "remove" : "add"]("b-invalid");
      if (isValid) {
        const errorTip = me.constructor.getSharedErrorTooltip(me.rootElement, true);
        if ((errorTip == null ? void 0 : errorTip.isVisible) && errorTip.field === me) {
          errorTip.hide();
        }
        me.syncRequired();
      } else {
        const errorTip = me.errorTip;
        if (errorTip && (me.containsFocus || me.isVisible && inputWrap.contains(Tooltip.currentOverElement))) {
          if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
            errorTip.onBeforeShow();
          } else {
            errorTip.activeTarget = inputWrap;
            errorTip.showBy(inputWrap);
          }
        }
      }
    }
    me.updatingInvalid = false;
  }
  //endregion
  //region Getters/setters
  updateEditable() {
    this.syncInputReadOnly();
  }
  syncInputReadOnly() {
    this.getConfig("readOnly");
    this.inputReadOnly = this._readOnly || this.editable === false;
  }
  updateInputReadOnly(readOnly) {
    const me = this, { input, inputListenerRemover } = me;
    if (input) {
      input.readOnly = readOnly ? "readOnly" : null;
      if (readOnly) {
        me.inputListenerRemover = inputListenerRemover == null ? void 0 : inputListenerRemover();
      } else if (!inputListenerRemover) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: "internalOnInputFocus",
          change: "internalOnChange",
          input: "internalOnInput"
        });
      }
    }
  }
  changeReadOnly(value) {
    return Boolean(value);
  }
  updateReadOnly(readOnly) {
    this.syncInputReadOnly();
  }
  updateClearable(clearable) {
    const me = this;
    me.getConfig("triggers");
    me.triggers = {
      clear: clearable && ObjectHelper.assign({
        cls: "b-icon-remove",
        weight: 1e3,
        key: "Shift+backspace",
        handler() {
          me._isUserAction = true;
          me.clear(...arguments);
          me._isUserAction = false;
        }
      }, clearable) || null
    };
  }
  changeTriggers(triggers, was) {
    const me = this, manager = me.$triggers || (me.$triggers = new DynamicObject({
      configName: "triggers",
      factory: _Field.Trigger,
      inferType: false,
      // the name of a trigger in the triggers object is not its type
      owner: me,
      created(instance) {
        FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
          if (triggerConfigs[name]) {
            me.onConfigChange({
              name: "triggers",
              value: manager.target
            });
          }
        });
      },
      setup(config, name) {
        config.reference = config.ref = name;
        config.parent = me;
      }
    }));
    if (me.stepTriggers === false && (triggers.back || triggers.forward)) {
      triggers = ObjectHelper.assign({}, triggers);
      delete triggers.back;
      delete triggers.forward;
    }
    manager.update(triggers);
    if (me.element) {
      me.keyMap = me.keyMap;
    }
    if (!was) {
      return manager.target;
    }
  }
  updateInputWidth(newValue) {
    this.input.style.width = DomHelper.setLength(newValue);
    this.element.classList.add("b-has-width");
  }
  updateInputAlign(newValue) {
    this.input.style.textAlign = newValue;
  }
  /**
   * Returns true if the field value is valid
   * @type {Boolean}
   * @readonly
   */
  get isValid() {
    const me = this;
    if (!me.disabled) {
      me.syncRequired();
      if (me.errors && Object.keys(me.errors).length) {
        return false;
      }
      const validity = me.validity;
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  /**
   * Returns `true` if this field is empty. That is, if it would violate the {@link #config-required}
   * setting.
   *
   * This may have different definitions in subclasses from simple text fields.
   * @type {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.value == null || this.value === "";
  }
  /**
   * Returns true if the field's input is empty
   * @type {Boolean}
   * @readonly
   */
  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === "";
  }
  /**
   * Returns the DOM `ValidityState` for this widget's input element, or `null` if there
   * isn't one.
   * @returns {ValidityState}
   * @private
   */
  get validity() {
    const input = this.input;
    return input == null ? void 0 : input.validity;
  }
  // Called by Editor.js, for overriding in subclasses that require async setting of values (custom editors in React)
  async setValue(value) {
    this.value = value;
  }
  changeValue(value, was) {
    if (value == null) {
      value = this.nullValue;
    }
    if (this.hasChanged(was, value)) {
      return value;
    }
    if (value === "") {
      this.syncRequired();
    }
    return was;
  }
  updateValue(value, oldValue) {
    const me = this;
    if (!me.isConfiguring) {
      me.syncRequired();
      if (!me.inputting) {
        me.triggerChange();
      }
    }
    if (!me.inputting) {
      me._lastValue = value;
    }
    me.syncInputFieldValue();
    if (me.overflowTwin && !me._overflowTwinSync) {
      me._overflowTwinSync = true;
      me.overflowTwin.value = value;
      me._overflowTwinSync = false;
    }
  }
  /**
   * Compares this field's value with its previous value. May be overridden in subclasses
   * which have more complex value types. See, for example, {@link Core.widget.DurationField}.
   * @param {*} oldValue
   * @param {*} newValue
   * @private
   */
  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }
  /**
   * Called by the base Field class's `set value` to sync the state of the UI with the field's value.
   *
   * Relies upon the class implementation of `get inputValue` to return a string representation of
   * the value for user consumption and editing.
   * @private
   */
  syncInputFieldValue(skipHighlight = false) {
    const me = this, { input, parent, inputValueAttr, inputValue } = me;
    if (input && !me.inputting && input[inputValueAttr] !== inputValue) {
      input[inputValueAttr] = inputValue;
      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove("b-field-updated");
        me.clearTimeout("removeUpdatedCls");
        if (parent) {
          const { assigningValues } = parent;
          if (assigningValues === true || (assigningValues == null ? void 0 : assigningValues.highlight) === false) {
            skipHighlight = true;
          }
        }
        if (!skipHighlight) {
          me.highlightChanged();
        }
      }
    }
    me.syncEmpty();
    me.syncInvalid();
  }
  highlightChanged() {
    this.input.classList.add("b-field-updated");
    this.setTimeout("removeUpdatedCls", this.updatedClsDuration);
  }
  removeUpdatedCls() {
    this.input.classList.remove("b-field-updated");
  }
  /**
   * A String representation of the value of this field for {@link #function-syncInputFieldValue} to use
   * as the input element's value.
   *
   * Subclasses may override this to create string representations.
   *
   * For example, {@link Core.widget.DateField}'s implementation will format the field date
   * value according to its configured {@link Core.widget.DateField#config-format}. And {@link Core.widget.Combo}'s
   * implementation will return the {@link Core.widget.Combo#config-displayField} of the selected record.
   * @internal
   * @readOnly
   */
  get inputValue() {
    return this.value == null ? "" : this.value;
  }
  get inputValueAttr() {
    return "value";
  }
  get supportsTextSelection() {
    const input = this.focusElement;
    return input && (input.tagName.toLowerCase() === "textarea" || input.type && /text|search|password|tel|url/.test(input.type));
  }
  //endregion
  //region Events
  internalOnInputFocus() {
    if (this.autoSelect) {
      this.selectAll();
    }
  }
  /**
   * Trigger event when fields input changes
   * @fires change
   * @private
   */
  internalOnChange(event) {
    const me = this;
    if (me.hasChanged(me._lastValue, me.value) && me.isValid) {
      me.triggerChange(event, true);
      me._lastValue = me.value;
    }
  }
  triggerChange(event, userAction = Boolean(this._isUserAction)) {
    const me = this, {
      value,
      _lastValue: oldValue,
      isValid: valid
    } = me;
    me.syncHint();
    me.triggerFieldChange({ value, oldValue, event, userAction, valid });
    if (me.defaultAction === "change") {
      me.trigger("action", { value, oldValue, event, userAction, valid });
    }
  }
  fetchInputValue() {
    this.value = this.input[this.inputValueAttr];
  }
  /**
   * Trigger event when user inputs into field
   * @fires input
   * @param event
   * @private
   */
  internalOnInput(event) {
    var _a4;
    const me = this;
    if (!me.validateOnInput) {
      me.errorTip.hide();
    }
    me.inputting = true;
    me.fetchInputValue();
    me.inputting = false;
    me.trigger("input", { value: me.value, event });
    (_a4 = me.changeOnKeyStroke) == null ? void 0 : _a4.call(me, event);
  }
  /**
   * Returns `true` if the {@link #property-input} field needs to be synced with the internal
   * {@link #property-value} of this field.
   *
   * May be overridden in subclasses where this is more complex such as multiSelect Combo
   * with a `ChipView` where the input area does not reflect the field's value.
   * @private
   */
  get needsInputSync() {
    var _a4;
    return this.input[this.inputValueAttr] !== String((_a4 = this.inputValue) != null ? _a4 : "");
  }
  internalOnKeyEvent(event) {
    const me = this, { value } = me;
    let stopEvent = false;
    if (event.type === "keydown") {
      if (event.key === "Escape" && !(me.readOnly || me.disabled)) {
        const wasValid = me.isValid, initialValue = "initialValue" in me ? me.initialValue : me.valueOnFocus, valueChanged = me.hasChanged(initialValue, value), { needsInputSync } = me;
        if (me.revertOnEscape && (!wasValid || valueChanged || needsInputSync)) {
          if (valueChanged) {
            me.value = initialValue;
          }
          if (needsInputSync) {
            me.syncInputFieldValue(true);
          }
          me.clearError();
          stopEvent = (valueChanged || needsInputSync) && me.isValid || wasValid !== me.validOnFocus;
        } else if (!me.isEmpty && me.clearable && me.revertOnEscape) {
          me.clear();
          event.stopPropagation();
        }
      }
    }
    if (!me.isDestroyed) {
      if (stopEvent) {
        event.stopImmediatePropagation();
      }
      me.trigger(event.type, { event });
    }
  }
  /**
   * Clears the value of this Field, and triggers the {@link #event-clear} event.
   */
  clear(event) {
    const me = this, { value } = me;
    if (value !== me.nullValue || me.input.value.length > 0) {
      me.value = me.nullValue;
      me.clearError();
      me.syncInvalid();
      me.trigger("clear", { event });
    }
  }
  /**
   * Called when disabled state is changed.
   * Used to add or remove 'b-invalid' class for the invalid field based on current disabled state.
   * @private
   */
  onDisabled() {
    this.syncInvalid();
  }
  //endregion
  //region Error
  syncRequired() {
    var _a4;
    const me = this;
    if (!me.isConfiguring && (!me.focusing || me.accessibility) && me.required && me.isEmpty && !((_a4 = me.parent) == null ? void 0 : _a4.isSettingValues)) {
      me.setError("L{fieldRequired}", me.updatingInvalid);
    } else {
      me.clearError("L{fieldRequired}", me.updatingInvalid);
    }
  }
  /**
   * Adds an error message to the list of errors on this field.
   * By default, the field's valid/invalid state is updated; pass
   * `false` as the second parameter to disable that if multiple
   * changes are being made to the error state.
   *
   * Note, that you need to manually remove the added error with the {@link #function-clearError} method
   * to "release" the normal data update process (invalid data won't be synced). You can also use the 3rd
   * argument of this method to automatically remove the error upon the next user interaction.
   *
   * @param {String} error A locale string, or message to use as an error message.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   * @param {Boolean} [temporary=false] Pass as `true` to remove the error upon the next user interaction.
   */
  setError(error, silent, temporary) {
    const me = this;
    (me.errors || (me.errors = {}))[me.optionalL(error)] = 1;
    if (!silent) {
      me.syncInvalid();
    }
    if (temporary) {
      const clearError = () => {
        me.clearError(error);
        remover();
      }, remover = me.ion({
        keydown: clearError,
        focusOut: clearError
      });
    }
  }
  /**
   * Removes an error message from the list of errors on this field.
   *
   * By default, the field's valid/invalid state is updated; pass `false` as the second parameter to disable that if
   * multiple changes are being made to the error state.
   *
   * @param {String} [error] A locale string, or message to remove. If not passed, all errors are cleared.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   */
  clearError(error, silent) {
    const me = this;
    if (me.errors) {
      if (error) {
        delete this.errors[this.optionalL(error)];
      } else {
        me.errors = {};
      }
    }
    if (!silent) {
      me.syncInvalid();
    }
  }
  /**
   * Returns an array of error messages as set by {@link #function-setError}, or
   * `undefined` if there are currently no errors.
   * @returns {String[]} The errors for this field, or `undefined` if there are no errors.
   */
  getErrors() {
    const me = this;
    if (!me.isValid) {
      const validity = me.validity, stateName = ObjectHelper.keys(validity).find((key) => key !== "valid" && key !== "customError" && validity[key]), errorKeys = me.errors && Object.keys(me.errors);
      let errors;
      if (errorKeys == null ? void 0 : errorKeys.length) {
        errors = errorKeys;
      } else if (validity.customError) {
        errors = [me.input.validationMessage];
      } else if (stateName) {
        errors = [me.L(stateName, {
          // In case min/max limits are present they will be used in the translation
          min: me.min,
          max: me.max
        })];
      } else {
        errors = [me.L(me.invalidValueError)];
      }
      if ((errors == null ? void 0 : errors.length) > 0) {
        return errors;
      }
    }
  }
  //endregion
  createOverflowTwin(overrides) {
    const me = this, overflowTwin = super.createOverflowTwin(overrides);
    overflowTwin.ion({
      change({ value }) {
        me._overflowTwinSync = true;
        me.value = value;
        me._overflowTwinSync = false;
      }
    });
    return overflowTwin;
  }
  //region Container
  get containerCollapsed() {
    var _a4;
    return (_a4 = this.container) == null ? void 0 : _a4.collapsed;
  }
  set containerCollapsed(collapsed) {
    const { container } = this;
    if (container) {
      container.collapsed = collapsed;
    }
  }
  afterSyncChildConfigs(container) {
  }
  changeContainer(config, existing) {
    if (config && (Array.isArray(config) || !("type" in config || "items" in config))) {
      config = {
        items: config
      };
    }
    const me = this, defaults = config && ObjectHelper.merge({
      owner: me,
      layout: "box"
    }, me.containerDefaults), container = Widget.reconfigure(existing, config, {
      owner: me,
      defaults
    });
    if (container) {
      container.autoLayout = (defaults == null ? void 0 : defaults.layout) === "box";
      if (container === existing) {
        container.syncContainer();
        return;
      }
    }
    return container;
  }
  onConfigChange(info) {
    var _a4, _b;
    super.onConfigChange(info);
    if ((_b = (_a4 = this.container) == null ? void 0 : _a4.syncConfigTriggers) == null ? void 0 : _b[info.name]) {
      this.container.syncChildConfigs();
    }
  }
  assignValue(values, options) {
    const me = this, { container, containValues } = me, valueName = me.getValueName(options), storedValue = values && valueName in values;
    if (container && containValues !== false) {
      if (values && containValues === "nested") {
        if (storedValue) {
          values = ObjectHelper.clone(values[valueName]);
          super.assignValue({
            // Removing 'value:true' from nested values is a trick done by checkbox (could be done by
            // any toggle-like thing) so just put true back in:
            [valueName]: values && !("value" in values) || values.value
          }, options);
          if (values) {
            delete values.value;
          }
          container.assignValue(values, options);
        }
      } else {
        super.assignValue(values, options);
        container.assignValue(values, options);
      }
    } else {
      super.assignValue(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    this.gatherValues(values);
  }
  gatherValues(values, storedValue) {
    const me = this, { container, containValues, valueName } = me, cvt = typeof containValues;
    storedValue = storedValue != null ? storedValue : valueName in values;
    if (container && containValues !== false) {
      if (containValues === "nested") {
        if (storedValue) {
          values[valueName] = {
            value: values[valueName],
            ...container.values
          };
        }
      } else if (containValues === true || containValues == null && storedValue || cvt === "string" && me[containValues] || cvt === "function" && containValues(me)) {
        container.gatherValues(values);
      }
    }
  }
  updateContainer(container, was) {
    was && this.detachListeners(was.id);
    if (container) {
      if (!container.rendered) {
        container.render();
      }
      container.syncContainer();
      container.syncChildConfigs();
    }
  }
  //endregion
};
//region Config
__publicField(_Field, "$name", "Field");
__publicField(_Field, "type", "field");
var Field = _Field;
var _a2;
Field.Trigger = (_a2 = class extends Widget {
  static get factoryable() {
    return {
      defaultType: Field.Trigger,
      extends: null
    };
  }
  get field() {
    return this.parent;
  }
  construct() {
    super.construct(...arguments);
    if (this.key) {
      this.keyMap = {
        [this.key]: "onClick"
      };
    }
  }
  compose() {
    return {
      "aria-hidden": true,
      class: {
        [`b-align-${this.align || "end"}`]: 1,
        "b-icon": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onClick",
        mousedown: "onMousedown"
      }
    };
  }
  changeAlign(align) {
    return align;
  }
  onClick(e) {
    const me = this, { field } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.key) {
        e.preventDefault();
      }
      if (field.trigger("trigger", { trigger: me }) !== false && me.handler) {
        field.callback(me.handler, field, [e, me]);
      }
    }
  }
  onMousedown(e) {
    const field = this.field, isKeyEvent = "key" in e;
    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => field.editable = true, 500);
      }
    }
    e.preventDefault();
    if (DomHelper.getActiveElement(field.input) !== field.input) {
      field.focus();
    }
  }
}, __publicField(_a2, "$name", "FieldTrigger"), // Factoryable type name
__publicField(_a2, "type", "trigger"), // Align is a simple string at this level
__publicField(_a2, "configurable", {
  align: null,
  weight: null,
  role: void 0
}), _a2);
var _a3;
Field.SpinTrigger = (_a3 = class extends Field.Trigger {
  compose() {
    return {
      children: {
        upButton: {
          class: {
            "b-icon": 1,
            "b-spin-up": 1
          }
        },
        downButton: {
          class: {
            "b-icon": 1,
            "b-spin-down": 1
          }
        }
      }
    };
  }
  updateRepeat(repeat) {
    var _a4;
    (_a4 = this.clickRepeater) == null ? void 0 : _a4.destroy();
    this.clickRepeater = repeat ? ClickRepeater.new({
      element: this.element
    }, repeat) : null;
  }
  onClick(e) {
    const me = this, { field } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.target === me.upButton) {
        field.doSpinUp(e.shiftKey);
      } else if (e.target === me.downButton) {
        field.doSpinDown(e.shiftKey);
      }
    }
  }
  get isFocusable() {
    return !this.disabled && super.isFocusable;
  }
}, __publicField(_a3, "$name", "SpinTrigger"), // Factoryable type name
__publicField(_a3, "type", "spintrigger"), __publicField(_a3, "configurable", {
  repeat: {
    $config: ["nullify"],
    value: true
  }
}), _a3);
Field.Trigger.initClass();
Field.SpinTrigger.initClass();
Widget.register(Field.Trigger, "trigger");
Widget.register(Field.SpinTrigger, "spintrigger");
Field._$name = "Field";

// ../Core/lib/Core/widget/TextField.js
var TextField = class extends Field {
  static get configurable() {
    return {
      /**
       * The tab index of the input field
       * @config {Number} tabIndex
       * @category Input element
       */
      /**
       * The min number of characters for the input field
       * @config {Number} minLength
       * @category Field
       */
      /**
       * The max number of characters for the input field
       * @config {Number} maxLength
       * @category Field
       */
      nullValue: ""
    };
  }
  construct(config) {
    if ((config == null ? void 0 : config.inputType) === "hidden") {
      config.hidden = true;
    }
    super.construct(...arguments);
  }
};
__publicField(TextField, "$name", "TextField");
__publicField(TextField, "type", "textfield");
__publicField(TextField, "alias", "text");
TextField.initClass();
TextField._$name = "TextField";

// ../Core/lib/Core/widget/PickerField.js
var PickerField = class extends TextField {
  static get configurable() {
    return {
      /**
       * User can edit text in text field (otherwise only pick from attached picker)
       * @config {Boolean}
       * @default
       */
      editable: true,
      /**
       * The name of the element property to which the picker should size and align itself.
       * @config {String}
       * @default element
       */
      pickerAlignElement: "inputWrap",
      // Does not get set, but prevents PickerFields inheriting value:'' from Field.
      value: null,
      triggers: {
        expand: {
          cls: "bars"
        }
      },
      /**
       * By default, PickerField's picker is transient, and will {@link #function-hidePicker} when the user clicks or
       * taps outside or when focus moves outside picker.
       *
       * Configure as `false` to make picker non-transient.
       * @config {Boolean}
       * @default
       * @deprecated This will be removed in 6.0
       */
      autoClose: true,
      /**
       * Configure as `true` to have the picker expand upon focus enter.
       * @config {Boolean}
       */
      autoExpand: null,
      /**
       * Configuration object for the {@link Core.widget.List picker} on initialization. Returns the
       * {@link Core.widget.List picker} instance at runtime.
       * A config object which is merged into the generated picker configuration on initialization
       * to allow specific use cases to override behaviour.
       * For example:
       *
       * ```javascript
       *     picker: {
       *         align: {
       *             anchor: true
       *         }
       *     }
       * ```
       *
       * Returns the picker instance at runtime.
       *
       * @prp {Core.widget.Widget}
       * @accepts {Object}
       * @readonly
       */
      picker: {
        value: {
          floating: true
        },
        $config: ["lazy", "nullify"]
      },
      inputType: "text",
      // We need to realign the picker if we resize (eg a multiSelect Combo's ChipView wrapping)
      monitorResize: true,
      nullValue: null
    };
  }
  //endregion
  //region Init & destroy
  doDestroy() {
    var _a4;
    (_a4 = this.globalTapListener) == null ? void 0 : _a4.call(this);
    super.doDestroy();
  }
  changeEditable(editable) {
    if (BrowserHelper.isMobile && this.initialConfig.editable !== true) {
      editable = false;
    }
    return editable;
  }
  updateAutoClose(autoClose) {
    !autoClose && VersionHelper.deprecate("Core", "6.0.0", "PickerField.autoClose is no longer supported");
  }
  updateEditable(editable) {
    var _a4;
    const me = this, {
      element,
      ariaElement,
      nonEditableClickTarget
    } = me, { expand } = me.triggers, narrow = globalThis.matchMedia("(max-width: 410px)").matches;
    super.updateEditable(...arguments);
    element.classList.toggle("b-not-editable", !editable);
    if (editable === false) {
      if (BrowserHelper.isMobile && narrow) {
        expand == null ? void 0 : expand.hide();
      }
      ariaElement.removeAttribute("aria-autocomplete");
      (_a4 = me.globalTapListener) == null ? void 0 : _a4.call(me);
      EventHelper.on({
        element: nonEditableClickTarget,
        click: (e) => {
          const target = nonEditableClickTarget.getRootNode().elementFromPoint(e.clientX, e.clientY);
          if (e.target === nonEditableClickTarget && target === nonEditableClickTarget) {
            me.onTriggerClick(e);
          }
        },
        thisObj: me
      });
    } else {
      expand == null ? void 0 : expand.show();
      ariaElement.setAttribute("aria-autocomplete", "list");
      me.globalTapListener = GlobalEvents_default.ion({
        globaltap: "showKeyboard",
        thisObj: me
      });
    }
  }
  get nonEditableClickTarget() {
    return this.input;
  }
  updateElement(element, oldElement) {
    var _a4;
    const result = super.updateElement(element, oldElement), picker = this.peekConfig("picker"), role = picker ? picker.isWidget ? picker.role : (_a4 = this.constructor.resolveType(picker.type)) == null ? void 0 : _a4.$meta.config.role : false;
    DomHelper.setAttributes(this.ariaElement, {
      "aria-expanded": false
    });
    this.ariaHasPopup = role;
    return result;
  }
  //endregion
  //region Picker
  changePicker(picker, oldPicker) {
    throw new Error("changePicker(oldPicker, newPicker) must be implemented in PickerField subclass implementations");
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-picker} config being a lazy config and only being converted to be a
   * `List` instance just before it's shown, the picker will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    const result = super.childItems;
    if (this._picker) {
      result.push(this.picker);
    }
    return result;
  }
  //endregion
  //region Events
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    super.onEditComplete();
    this.autoClosePicker();
  }
  onElementResize(resizedElement) {
    const me = this;
    if (me.pickerVisible) {
      me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
    }
    super.onElementResize(resizedElement);
  }
  /**
   * Allows using arrow keys to open/close list. Relays other keypresses to list if open.
   * @private
   */
  internalOnKeyEvent(event) {
    const me = this;
    let callSuper = true;
    if (event.type === "keydown" && !me.disabled && !event.shiftKey && !event.ctrlKey) {
      if (me.pickerVisible) {
        const { picker } = me;
        if (event.key === "Escape") {
          event.preventDefault();
          event.stopImmediatePropagation();
          me.hidePicker();
          callSuper = false;
        } else if (picker.onInternalKeyDown) {
          picker.onInternalKeyDown(event);
        } else if (event.key === "ArrowDown") {
          if (picker.focusable) {
            picker.focus();
          }
        }
      } else if (event.key === "ArrowDown") {
        event.stopImmediatePropagation();
        event.preventDefault();
        me.onTriggerClick(event);
      }
    }
    if (callSuper) {
      super.internalOnKeyEvent(event);
    }
  }
  onFocusIn(e) {
    var _a4;
    const me = this, target = (_a4 = GlobalEvents_default.currentPointerDown) == null ? void 0 : _a4.target;
    super.onFocusIn(e);
    if (me.autoExpand && !(target == null ? void 0 : target.matches(".b-fieldtrigger"))) {
      me.minChars = 0;
      me.onTriggerClick(e);
    }
  }
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    if (!this.disabled) {
      this.togglePicker("key" in event);
    }
  }
  /**
   * User clicked on an editable input field. If it's a touch event
   * ensure that the keyboard is shown.
   * @private
   */
  showKeyboard({ event }) {
    const input = this.input;
    if (DomHelper.isTouchEvent && DomHelper.getActiveElement(input) === input && event.target === input) {
      GlobalEvents_default.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents_default.resumeFocusEvents();
    }
  }
  //endregion
  //region Toggle picker
  /**
   * Toggle the {@link #property-picker} visibility
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  togglePicker(focus) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focus);
    }
  }
  /**
   * Show the {@link #property-picker}
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  showPicker(focus) {
    const me = this, { picker } = me;
    if (!me.pickerHideShowListenersAdded) {
      picker.ion({
        show: "onPickerShow",
        hide: "onPickerHide",
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }
    DomHelper.setAttributes(me.ariaElement, {
      "aria-controls": picker.id,
      "aria-expanded": true
    });
    picker.autoClose = me.autoClose;
    picker.show();
    if (picker.isVisible) {
      if (focus) {
        me.focusPicker();
      }
    }
  }
  onPickerShow() {
    const me = this;
    me.pickerVisible = true;
    me.element.classList.add("b-open");
    me.trigger("togglePicker", { show: true });
    me.pickerTapOutRemover = GlobalEvents_default.ion({
      globaltap: "onPickerTapOut",
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: "onPickerKeyDown",
      thisObj: me
    });
  }
  onPickerHide() {
    var _a4, _b;
    const me = this;
    me.ariaElement.setAttribute("aria-expanded", false);
    me.pickerVisible = false;
    me.element.classList.remove("b-open");
    me.trigger("togglePicker", { show: false });
    (_a4 = me.pickerTapOutRemover) == null ? void 0 : _a4.call(me);
    (_b = me.pickerKeyDownRemover) == null ? void 0 : _b.call(me);
  }
  onPickerTapOut({ event }) {
    if (!this.containsFocus && !this.owns(event.target)) {
      this.autoClosePicker();
    }
  }
  onPickerKeyDown(event) {
    if (event.key === "Tab" && !this.picker.trapFocus) {
      const activeEl = DomHelper.getActiveElement(this.input), forwardedEvent = new KeyboardEvent("keydown", event);
      this.input.dispatchEvent(forwardedEvent);
      if (forwardedEvent.defaultPrevented) {
        event.preventDefault();
      }
      if (DomHelper.getActiveElement(this.input) === activeEl) {
        this.input.focus();
      } else {
        event.preventDefault();
      }
      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }
  //endregion
  //region Visibility
  autoClosePicker() {
    if (this.autoClose) {
      this.hidePicker();
    }
  }
  /**
   * Hide picker
   */
  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }
  focusPicker() {
  }
  focus() {
    const input = this.input;
    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      this.setTimeout(() => input.readOnly = false, 500);
    }
    super.focus();
  }
  //endregion
};
//region Config
__publicField(PickerField, "$name", "PickerField");
__publicField(PickerField, "type", "pickerfield");
PickerField._$name = "PickerField";

// ../Core/lib/Core/widget/List.js
var itemRange = document.createRange();
var List = class extends Widget {
  //endregion
  //region Events
  /**
   * User activated an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * @event item
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model} record Activated record
   * @param {Number} index List item index
   * @param {Event} event Triggering event
   */
  /**
   * User going to activate an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * It is preventable by returning `false`
   * @event beforeItem
   * @preventable
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model} record Activated record
   * @param {Number} args List item index
   * @param {Event} event Triggering event
   */
  /**
   * Fired when selection changes
   * @event selectionChange
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model[]} selected An array of the currently selected records
   */
  //endregion
  construct(config, ...args) {
    var _a4;
    const me = this;
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }
    super.construct(config, ...args);
    const { element } = me, { classList } = element;
    if (me.multiSelect) {
      classList.add("b-multiselect");
    }
    if ((_a4 = me.store) == null ? void 0 : _a4.count) {
      me.refresh();
    } else {
      classList.add("b-empty");
    }
    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: "onMouseOver",
      thisObj: me
    });
    EventHelper.on({
      element,
      click: "onClick",
      thisObj: me
    });
  }
  doDestroy() {
    var _a4;
    this.detachListeners("store");
    (_a4 = this.navigator) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  onFocusIn(e) {
    var _a4;
    this.restoreActiveItem((_a4 = e._target) == null ? void 0 : _a4.closest(this.itemSelector));
    super.onFocusIn(e);
  }
  contentTpl() {
    const me = this, allRecordsTpl = me.store.records.map((record, i) => me.itemWrapperTpl(record, i));
    if (me.multiSelect && me.selectAllItem !== false) {
      allRecordsTpl.unshift(me.selectAllItemTpl());
    }
    if (me.title) {
      allRecordsTpl.unshift(`<li class="b-list-item b-list-title">${me.title}</li>`);
    }
    return TemplateHelper.tpl`${allRecordsTpl}`;
  }
  itemWrapperTpl(record, i) {
    const {
      selected,
      getItemStyle,
      store
    } = this, style = getItemStyle ? `style="${this.callback(getItemStyle, this, [record])}"` : "";
    if (store.isGrouped && !record.isGroupHeader) {
      const groupRecord = record.groupParent.get(store.id);
      if (groupRecord.meta.collapsed) {
        return "";
      }
    }
    return TemplateHelper.tpl`<li ${style} class="${this.getItemClasses(record, i)}" role="option" aria-selected="${selected.includes(record)}" data-index="${i}" data-id="${StringHelper.encodeHtml(record.id)}" ${this.itemsFocusable ? 'tabindex="-1"' : ""}>${this.itemContentTpl(record, i)}</li>`;
  }
  itemContentTpl(record, i) {
    if (record.isGroupHeader) {
      let result = this.groupHeaderTpl(record, StringHelper.capitalize(record.meta.groupRowFor));
      if (this.collapsibleGroups) {
        const arrowDirection = record.meta.collapsed ? "right" : "down";
        result += `<button class="b-button b-tool b-icon b-icon-collapse-${arrowDirection} b-list-expander-icon" data-noselect></button>`;
      }
      return result;
    }
    return `${this.itemIconTpl(record, i)}${this.itemTpl(record, i)}`;
  }
  itemIconTpl(record, i) {
    return this.multiSelect ? `<i class="b-selected-icon b-icon ${this.selectIconCls}"></i>` : "";
  }
  selectAllItemTpl() {
    const selectedCls = this.allSelected ? "b-selected" : "";
    return `<li class="${this.itemCls} b-select-all-item ${selectedCls}" data-noselect data-select-all data-id="select-all" ${this.itemsFocusable ? 'tabindex="-1"' : ""}>${this.itemIconTpl({})}<div>${this.L("selectAll")}</div></li>`;
  }
  getItemClasses(record) {
    var _a4;
    const me = this, { getItemCls } = me, activeItem = (_a4 = me._navigator) == null ? void 0 : _a4.activeItem, isActive = (activeItem == null ? void 0 : activeItem.dataset.id) == record.id, groupHeaderCls = "groupRowFor" in record.meta ? "b-list-item-group-header" : "", isSelected = me.selected.includes(record) || record.isSpecialRow && record.groupChildren.every((r) => me.selected.includes(r)), itemCls = getItemCls ? this.callback(getItemCls, this, [record]) : "";
    return `${me.itemCls} ${record.cls || ""} ${itemCls} ${isSelected ? me.selectedCls : ""} ${isActive ? me.navigator.focusCls : ""} ${groupHeaderCls}`;
  }
  onBeforeStoreLoad() {
    this.mask(this.L("L{loading}"));
  }
  onAfterStoreRequest() {
    this.unmask();
  }
  onStoreChange({ source: store, action, records, record, changes }) {
    const me = this, { selected } = me;
    switch (action) {
      case "dataset": {
        selected.match(store.storage, !me._externallyOwnedSelection);
        break;
      }
      case "remove":
        selected.remove(records);
        break;
      case "clear":
        me.deselectAll();
        break;
      case "update": {
        const { id } = changes;
        if (id) {
          DomHelper.setAttributes(
            me.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, id.oldValue)),
            {
              "data-id": id.value
            }
          );
        }
        me.refreshItem(record);
        return;
      }
    }
    me.refresh();
  }
  onStoreRefresh() {
    if (this._selected) {
      this.refresh();
    } else {
      this.getConfig("selected");
    }
  }
  refresh() {
    var _a4;
    const me = this;
    if (me.isVisible && me.store) {
      const activeItem = (_a4 = me.navigator) == null ? void 0 : _a4.activeItem;
      me.paintListener = null;
      const node = DomHelper.createElementFromTemplate(me.contentTpl(), { fragment: true });
      me.clearItems().insertNode(node);
      if (activeItem) {
        me.restoreActiveItem(activeItem);
      }
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.element.classList[me.store.count > 0 ? "remove" : "add"]("b-empty");
      me.updateSelectAllState();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "refresh",
        thisObj: me,
        once: true
      });
    }
  }
  clearItems() {
    const me = this, firstItem = me.contentElement.querySelector(me.itemSelector), lastChild = me.contentElement.lastChild;
    if (firstItem) {
      const items2 = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(items2[items2.length - 1]);
      itemRange.deleteContents();
    } else {
      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }
    return itemRange;
  }
  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);
      if (item) {
        const index = this.store.indexOf(record), newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));
        DomHelper.sync(newItem, item);
      }
    }
  }
  getItem(recordOrId) {
    if (recordOrId != null) {
      if (typeof recordOrId === "number") {
        return this.contentElement.querySelector(`[data-index="${recordOrId < 0 ? this.store.count + recordOrId : recordOrId}"]`);
      } else if (recordOrId.nodeType === Element.ELEMENT_NODE) {
        recordOrId = recordOrId.dataset.id;
      }
      if ((recordOrId == null ? void 0 : recordOrId.id) != null) {
        recordOrId = recordOrId.id;
      }
      return this.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, recordOrId));
    }
  }
  /**
   * Searches up from the specified element for a list item and returns the associated record.
   * @param {HTMLElement} element Element somewhere within a list item element
   * @returns {Core.data.Model} Record for the item
   */
  getRecordFromElement(element) {
    if (element.target) {
      element = element.target;
    }
    element = element.closest(this.itemSelector);
    return this.store.getAt(parseInt(element.dataset.index));
  }
  //region getters/setters
  /**
   * May be *set* as an array of Objects which are converted into records and used to create this
   * List's {@link #config-store}
   * @member {Object[]} items
   */
  updateItems(items2) {
    var _a4;
    const me = this, newStore = Store.getStore(ArrayHelper.asArray(items2));
    if ((_a4 = me.store) == null ? void 0 : _a4.autoCreated) {
      me.store.data = (newStore == null ? void 0 : newStore.records) || [];
    } else {
      me.store = newStore;
    }
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this.navigator && (this.navigator.disabled = disabled);
  }
  updateLocalization() {
    super.updateLocalization();
    this.refresh();
  }
  updateTitle() {
    this.refresh();
  }
  changeSelected(selected, oldSelected) {
    const me = this, internalListeners = {
      change: "onInternalSelectionChange",
      thisObj: me
    };
    if (selected) {
      if (selected.isCollection) {
        me._externallyOwnedSelection = true;
        selected.ion(internalListeners);
      } else {
        me._externallyOwnedSelection = false;
        selected = ArrayHelper.asArray(selected).reduce((r, s) => {
          s = s.isModel ? s : me.store.getById(s);
          if (s) {
            r.push(s);
          }
          return r;
        }, []);
        if (oldSelected) {
          oldSelected.splice(0, oldSelected.count, selected);
          selected = oldSelected;
          me.refresh();
        } else {
          const records = selected;
          selected = me._selected = new Collection({
            internalListeners
          });
          selected.add(records);
        }
      }
      if (selected !== oldSelected) {
        oldSelected == null ? void 0 : oldSelected.un(internalListeners);
      }
    } else {
      oldSelected == null ? void 0 : oldSelected.destroy();
    }
    return selected;
  }
  updateSelected(selected) {
    if (selected) {
      this.refresh();
    }
  }
  get itemSelector() {
    return `.${this.itemCls}`;
  }
  /**
   * Gets/sets the collection of selected records.
   *
   * When used as a setter, a record, or record `id` or array of same may be passed to
   * set the selected records.
   * @property {Core.util.Collection}
   * @accepts {Core.data.Model|Core.data.Model[]|String|String[]|Number|Number[]}
   */
  get selected() {
    return this._selected;
  }
  updateMultiSelect(value, old) {
    if (!value && old && this.selected.count > 1) {
      this.deselect(this.selected.allValues.slice(1));
    }
  }
  get store() {
    this.getConfig("items");
    return this._store;
  }
  changeStore(store) {
    const me = this;
    if (!(store instanceof Store)) {
      if (Array.isArray(store)) {
        store = {
          data: store
        };
      }
      store = new Store(store);
    }
    me.detachListeners("store");
    if (store) {
      const storeListeners = {
        name: "store",
        change: "onStoreChange",
        refresh: "onStoreRefresh",
        thisObj: me
      };
      if (store.readUrl) {
        storeListeners.beforeLoad = "onBeforeStoreLoad";
        storeListeners.afterRequest = "onAfterStoreRequest";
      }
      if (store.isGrouped) {
        me.element.classList.add("b-grouped");
        storeListeners.groupchange = "onStoreRefresh";
      }
      store.ion(storeListeners);
    }
    return store;
  }
  updateStore(store) {
    if (store == null ? void 0 : store.records.length) {
      this.getConfig("selected");
    }
    this.refresh();
  }
  changeNavigator(navigator2, oldNavigator) {
    const me = this, { element } = me;
    if (element) {
      navigator2 = Navigator.reconfigure(oldNavigator, navigator2 ? Navigator.mergeConfigs({
        ownerCmp: me,
        disabled: me.disabled,
        target: element,
        keyEventTarget: element
      }, navigator2) : null, me);
      if ((navigator2 == null ? void 0 : navigator2.keyEventTarget) === element && !me.itemsTabbable) {
        element.tabIndex = 0;
      }
    }
    return navigator2;
  }
  get minAlignHeight() {
    const lastItem = this.element.lastElementChild, minHeight = this.minHeight;
    if (minHeight != null) {
      return lastItem ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }
  //endregion
  //region Hide/Show
  alignTo(...args) {
    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }
  hide(...args) {
    this.navigator && (this.navigator.activeItem = null);
    return super.hide(...args);
  }
  show() {
    const { refreshCount } = this, { previousActiveItem } = this.navigator;
    super.minHeight = this._minHeight;
    const retVal = super.show(...arguments);
    if (this.refreshCount === refreshCount) {
      this.restoreActiveItem(previousActiveItem, true);
    }
    return retVal;
  }
  /**
   * Sets the passed record as the current focused record for keyboard navigation and selection purposes.
   * @param {Core.data.Model} activeItem The item to highlight as the active ("focused") item.
   * @param {String|Boolean} [block='nearest'] The block scroll specification to scroll
   * the item into view. Defaults to `'nearest'` which means a minimal scroll, only if
   * the item is actually out of view. Passing `true` is for when the List is aligned
   * to a picker and the selected item should be scrolled to be close to the picker,
   * however that is aligned. See `Combo.showPicker` for usage.
   * @internal
   */
  restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = "nearest") {
    const me = this, { navigator: navigator2, lastAlignSpec } = me;
    if (activeItem != null) {
      if (typeof block !== "string") {
        const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;
        block = alignZone & 1 ? "nearest" : alignZone ? "start" : "end";
      }
      activeItem = me.getItem(activeItem);
      if (activeItem && !me.disabled) {
        me.scrollable.scrollIntoView(activeItem, {
          block
        });
        navigator2.activeItem = activeItem;
      }
    }
  }
  //endregion
  //region Events
  /**
   * Focuses list items on hover.
   * @private
   */
  onMouseOver(event) {
    const me = this, itemElement = event.currentTarget;
    if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
      me.setTimeout({
        fn: "handleMouseOver",
        delay: 30,
        args: [itemElement],
        cancelOutstanding: true
      });
    }
  }
  handleMouseOver(itemElement) {
    this.navigator.activeItem = itemElement;
  }
  /**
   * Selects list items on click.
   * @private
   */
  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);
    if (itemElement) {
      this.onItemClick(itemElement, event);
    } else if (this.clearSelectionOnEmptySpaceClick) {
      this.deselectAll();
    }
  }
  onSpaceKey(event) {
    if (event.target.nodeName.toUpperCase() !== "INPUT" || event.target.readOnly) {
      this.onEnterKey(event);
    }
  }
  onEnterKey(event) {
    const active = this.navigator.activeItem;
    if (active && !this.disabled) {
      this.onItemClick(active, event);
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }
  /**
   * Key events which are not navigation are delegated up to here by the Navigator
   * @private
   */
  onInternalKeyDown(event) {
    const me = this;
    switch (event.key) {
      case "ArrowLeft":
        me.collapseItem();
        break;
      case "ArrowRight":
        me.expandItem();
        break;
      case " ":
        me.onSpaceKey(event);
        break;
      case "Enter":
        me.onEnterKey(event);
        break;
    }
  }
  collapseItem() {
    const { activeItem } = this.navigator;
    if (activeItem) {
      this.toggleCollapse(this.getRecordFromElement(activeItem), true);
    }
  }
  expandItem() {
    const { activeItem } = this.navigator;
    if (activeItem) {
      this.toggleCollapse(this.getRecordFromElement(activeItem), false);
    }
  }
  //endregion
  onItemClick(item, event) {
    var _a4;
    const me = this, { allowGroupSelect } = me, index = parseInt(item.dataset.index), record = me.store.getAt(index), isSpecialRow = record == null ? void 0 : record.isSpecialRow, isNoSelect = item.contains(event.target.closest("[data-noselect]"));
    if (me.disabled || me.trigger("beforeItem", { item, record, index, event, userAction: true }) === false) {
      return;
    }
    me._isUserAction = true;
    if (item.contains(event.target.closest("[data-select-all]"))) {
      me.onSelectAllClick(item, event);
    } else if (event.target.matches(".b-list-expander-icon")) {
      me.toggleCollapse(record);
      return;
    } else if (record && !isNoSelect && (!isSpecialRow || allowGroupSelect)) {
      const { selected } = me, groupParent = (_a4 = record.groupParent) == null ? void 0 : _a4.get(me.store.id);
      if (me.multiSelect) {
        let isSelected = selected.includes(record), toAddRemove = record;
        if (me.toggleAllIfCtrlPressed && event.ctrlKey) {
          toAddRemove = me.store.records;
        } else if (allowGroupSelect && isSpecialRow) {
          isSelected = !record.groupChildren.some((rec) => !selected.includes(rec));
          item.classList.toggle("b-selected", !isSelected);
          toAddRemove = record.groupChildren;
        }
        selected[isSelected ? "remove" : "add"](toAddRemove);
        if (!isSpecialRow && groupParent && allowGroupSelect) {
          const groupItem = me.getItem(groupParent);
          groupItem.classList.toggle("b-selected", groupParent.groupChildren.every((r) => selected.includes(r)));
        }
      } else {
        selected.splice(0, selected.count, record);
      }
    }
    if (me.isDestroyed) {
      return;
    }
    me.lastClicked = record;
    me.trigger("item", {
      item,
      record,
      index,
      event,
      userAction: true
    });
    me._isUserAction = false;
  }
  /**
   * Handles items being added or removed from the selected Collection
   * @param {Object} changeEvent
   * @private
   */
  onInternalSelectionChange({ action, removed, added, replaced }) {
    const me = this, {
      selectedCls,
      unselectedCls
    } = me;
    let record, item;
    if (action === "clear") {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
        item.setAttribute("aria-selected", false);
        unselectedCls && item.classList.remove(unselectedCls);
      }
    } else if (action !== "replaceValues") {
      for (record of removed) {
        item = me.getItem(record);
        if (item) {
          item.classList.remove(selectedCls);
          item.setAttribute("aria-selected", false);
        }
      }
      for (record of added) {
        item = me.getItem(record);
        if (item) {
          item.classList.add(selectedCls);
          item.setAttribute("aria-selected", true);
        }
      }
    }
    me.selectAllItem && me.updateSelectAllState();
    me.trigger("selectionChange", { selected: me.selected.values });
  }
  onSelectAllClick(item) {
    const checked = item.classList.contains(this.selectedCls);
    if (checked) {
      this.deselectAll();
    } else {
      this.selectAll();
    }
  }
  updateSelectAllState() {
    var _a4;
    (_a4 = this.element.querySelector(".b-select-all-item")) == null ? void 0 : _a4.classList.toggle(this.selectedCls, this.allSelected);
  }
  /**
   * Yields `true` if all the available items are selected.
   * @property {Boolean}
   * @readonly
   */
  get allSelected() {
    const { selected, store } = this;
    return selected.count && (store.isFiltered ? store.records.every((r) => selected.includes(r)) : store.count === selected.count);
  }
  /**
   * Selects all items in this list.
   * @category Selection
   */
  selectAll(keyEvent) {
    const me = this;
    if (me.multiSelect || !keyEvent) {
      me.selected.add(me.store.records);
      if (keyEvent && !me.navigator.activeItem) {
        me.navigator.activeItem = me.getItem(-1);
      }
    }
  }
  /**
   * Deselects all selected items
   * @category Selection
   */
  deselectAll() {
    this.selected.clear();
  }
  /**
   * Selects the passed item(s).
   *
   * An item to select may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  select(toSelect) {
    const { store } = this, { modelClass } = store;
    toSelect = ArrayHelper.asArray(toSelect).reduce((v, c) => {
      c = store.getById(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.add(toSelect);
  }
  /**
   * Deselects the passed item(s).
   *
   * An item to deselect may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  deselect(toDeselect) {
    const { modelClass } = this.store;
    toDeselect = ArrayHelper.asArray(toDeselect).reduce((v, c) => {
      c = this.selected.get(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.remove(toDeselect);
  }
  /**
   * Toggles the collapsed state of a group header record
   * @param {Core.data.Model} record The group record
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @fires toggleGroup
   */
  toggleCollapse(groupRecord, collapse) {
    if (!groupRecord.isGroupHeader) {
      return;
    }
    collapse = collapse === void 0 ? !groupRecord.meta.collapsed : collapse;
    this.store[collapse ? "collapse" : "expand"](groupRecord);
    this.refresh();
    this.trigger("toggleGroup", { groupRecord, collapse });
  }
  updateCollapsibleGroups(value, old) {
    if (old && !value) {
      const { store } = this;
      store.groupRecords.forEach((record) => store.expand(record));
    }
    this.refresh();
  }
};
//region Config
__publicField(List, "$name", "List");
__publicField(List, "type", "list");
__publicField(List, "configurable", {
  itemCls: "b-list-item",
  selectedCls: "b-selected",
  selectIconCls: "b-icon-check",
  tag: "ul",
  /**
   * An array of Objects which are converted into records and used to create this
   * List's {@link #config-store}
   * @config {Object[]}
   */
  items: null,
  /**
   * The model field to render into each list item
   * @config {String}
   * @default
   */
  displayField: "text",
  /**
   * A {@link Core.data.Store} which provides the records which map to List items. Each record is passed through the
   * {@link #config-itemTpl} to produce the DOM structure of the List. May be generated from an array of {@link #config-items}.
   *
   * The store may also be configured as an array of records, or record data objects from which records may be constructed.
   * @prp {Core.data.Store}
   * @accepts {Object|Object[]|StoreConfig|Core.data.Store}
   */
  store: null,
  navigator: true,
  scrollable: {
    overflowX: false,
    overflowY: true
  },
  itemsFocusable: true,
  /**
   * Configure as `true` to allow multi select and add checkboxes to the items
   * @prp {Boolean}
   * @default
   */
  multiSelect: false,
  /**
   * Select/deselect all if `CMD`/`CTRL` is pressed when clicking
   * @prp {Boolean}
   * @default false
   */
  toggleAllIfCtrlPressed: false,
  /**
   * True to add a collapse icon to toggle groups being collapsed or expanded
   * @prp {Boolean}
   * @default false
   */
  collapsibleGroups: false,
  /**
   * Set to `true` to add a "Select all" item to the list to select/unselect all items at once.
   * Only applies when {@link #config-multiSelect} mode is enabled.
   * @config {Boolean|String}
   * @default false
   */
  selectAllItem: false,
  /**
   * Template function which, when passed a record, returns the textual HTML for that item. Defaults to a
   * function returning the value of the record´s {@link #config-displayField}
   *
   * @config {Function}
   * @param {Core.data.Model} record The record
   * @returns {String}
   */
  itemTpl(record) {
    let text = StringHelper.encodeHtml(record.getValue(this.displayField));
    if (text == null || text === "") {
      text = "&nbsp;";
    }
    return text;
  },
  /**
   * Configure this as a function or the name of a function, which when passed a record in the
   * list, returns a style string to apply to its list item.
   *
   * @config {Function|String} getItemStyle
   * @param {Core.data.Model} record The record
   * @returns {String}
   */
  getItemStyle: null,
  /**
   * Configure this as a function or the name of a function, which when passed a record in the
   * list, returns a CSS class name string to apply to its list item.
   *
   * @config {Function|String} getItemCls
   * @param {Core.data.Model} record The record
   * @returns {String}
   */
  getItemCls: null,
  /**
   * Template function which is passed a group record and the uppercased group field name. The text returned
   * will be rendered as the group header.
   *
   * @config {Function}
   * @param {Core.data.Model} record The record
   * @param {String} groupName The current group name
   * @returns {String}
   */
  groupHeaderTpl(record, groupName) {
    let name = StringHelper.encodeHtml(groupName);
    if (name == null || name === "") {
      name = "&nbsp;";
    }
    return `${this.allowGroupSelect ? this.itemIconTpl(record) : ""}${name}`;
  },
  /**
   * Configure as `true` to allow selecting groups (all the group child records will be toggled). Only
   * applicable when the store is grouped.
   * @config {Boolean}
   * @default
   */
  allowGroupSelect: true,
  /**
   * Configure as `true` to clear selection when clicking on empty space inside the List´s element.
   * @config {Boolean}
   * @default false
   */
  clearSelectionOnEmptySpaceClick: false,
  /**
   * A {@link Core.util.Collection}, or Collection config object to use to contain this List's selected
   * records.
   *
   * Or, an array encapsulating the initial selection which this List is to have upon Store load. This may be
   * an array of `id`s , or an array of objects with an `id` property:
   *
   * ```javascript
   * new List({
   *     // initially select record IDs 1 and 5 when store loads
   *     selected : [1, 5]
   * });
   * ```
   * @config {Object[]|Number[]|String[]|Core.util.Collection|CollectionConfig}
   */
  selected: {
    $config: ["nullify", "lazy"],
    value: []
  },
  /**
   * Configure as `true` to activate items on mouseover. This is used by the Combo
   * field when using a List as its dropdown.
   * @config {Boolean}
   */
  activateOnMouseover: null,
  role: "listbox",
  keyMap: {
    "Ctrl+a": "selectAll"
  },
  /**
   * The title to show at the top of the list.
   * @prp {String}
   */
  title: null
});
List.initClass();
List.prototype.navigatorClass = Navigator;
List._$name = "List";

// ../Core/lib/Core/widget/ChipView.js
var ChipView = class extends List {
  itemContentTpl(record, i) {
    const me = this;
    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ""}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ""}`;
  }
  onInternalKeyDown(event) {
    const me = this, { selected } = me, { generation } = selected;
    if (me.closable && selected.count && (event.key === "Delete" || event.key === "Backspace")) {
      if (me.closeHandler) {
        me.callback(me.closeHandler, me.owner, [selected.values, { isKeyEvent: true }]);
      } else {
        me.store.remove(selected.values);
      }
      if (selected.generation !== generation) {
        event.stopImmediatePropagation();
      }
    } else {
      super.onInternalKeyDown(event);
    }
  }
  updateClosable(closable) {
    this.element.classList[closable ? "add" : "remove"]("b-chips-closable");
    this.navigator && (this.navigator.disabled = !closable);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  onClick(event) {
    const me = this, item = event.target.closest(`.${me.itemCls}`);
    if (me.closable && event.target.classList.contains("b-close-icon")) {
      const record = me.store.getAt(parseInt(item.dataset.index));
      if (me.closeHandler) {
        me.callback(me.closeHandler, me.owner, [[record]]);
      } else {
        me.store.remove(record);
      }
    } else {
      super.onClick(event);
    }
  }
};
//region Config
__publicField(ChipView, "$name", "ChipView");
__publicField(ChipView, "type", "chipview");
__publicField(ChipView, "configurable", {
  itemCls: "b-chip",
  /**
   * Configure as `true` to allow multi select and allow clicking and key navigation to select multiple chips.
   * @config {Boolean}
   * @default
   */
  multiSelect: false,
  /**
   * Configure as `true` to display a clickable close icon after the {@link Core.widget.List#config-itemTpl}.
   * When tapped, the configured {@link #config-closeHandler} is called passing the associated record.
   *
   * Chips may also be selected using the `LEFT` and `RIGHT` arrows (And the `Shift` key to do multiple,
   * contiguous selection). Pressing the `DELETE` or `BACKSPACE` key passes the selected records to the
   * {@link #config-closeHandler} (if not provided, the record representing the chip is removed from the store).
   *
   * @config {Boolean}
   * @default
   */
  closable: true,
  /**
   * A template function, which, when passed a record, returns the markup which encapsulates a chip's icon to be
   * placed before the {@link Core.widget.List#config-itemTpl}.
   * @config {Function}
   * @param {Core.data.Model} record The record to provide an icon for
   * @returns {DomConfig|String|null}
   */
  iconTpl: null,
  /**
   * If {@link #config-closable} is `true`, this is the name of a callback function to handle what the "close"
   * action means. If not provided, the record representing the chip is removed from the store.
   *
   * @config {String|Function}
   * @params {Core.data.Model[]} records Records to be closed
   * @params {Object} options Close options
   * @returns {void}
   */
  closeHandler: null
});
ChipView.initClass();
ChipView._$name = "ChipView";

// ../Core/lib/Core/widget/Combo.js
var errorFieldRequired = "L{Field.fieldRequired}";
var errorValidateFilter = "L{Field.validateFilter}";
var errorTooShort = "L{Field.tooShort}";
var errorRecordNotCommitted = "L{Combo.recordNotCommitted}";
var filterKeyTypes = /[\w\s]/;
var Combo = class extends PickerField {
  static get configurable() {
    return {
      /**
       * Optionally a {@link Core.util.CollectionFilter Filter} config object which the combo should use for
       * filtering using the typed value.
       * This may use a `filterBy` property to test its `value` against any field in the passed record.
       * ```javascript
       * {
       *     type          : 'combo',
       *     store         : myStore,
       *     primaryFilter : {
       *         filterBy(record) {
       *             if (this.value == null) {
       *                 return true;
       *             }
       *             const value = this.value.toLowerCase();
       *
       *             // Match typed value with forename or surname
       *             return record.forename.toLowerCase().startsWith(value)
       *                 || record.surname.toLowerCase().startsWith(value);
       *         }
       *     }
       * }
       * ```
       * @config {CollectionFilterConfig}
       */
      primaryFilter: {},
      /**
       * Configuration object for the {@link Core.widget.List picker} on initialization. Returns the
       * {@link Core.widget.List picker} instance at runtime.
       *
       * For example:
       *
       * ```javascript
       * new Combo({
       *     ...
       *     // configure the combobox picker
       *     picker : {
       *         listeners : {
       *             // prevent selection of item with id == 2
       *             beforeItem : ({ record }) => record.id !== 2
       *         }
       *     }
       * })
       * ```
       *
       * @prp {Core.widget.List}
       * @accepts {ListConfig}
       */
      picker: {
        type: "list",
        floating: true,
        scrollAction: "realign",
        itemsFocusable: false,
        activateOnMouseover: true,
        align: {
          align: "t0-b0",
          axisLock: true
        },
        maxHeight: 324,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false
      },
      /**
       * Configure as `true` to allow selection of multiple values from the dropdown list.
       *
       * Each value is displayed as a "Chip" to the left of the input area. Chips may be
       * selected using the `LEFT` and `RIGHT` arrow keys and deleted using the `DELETE` key
       * to remove values from the field. There is also a clickable close icon in each chip.
       *
       * Use {@link Core.widget.List#config-toggleAllIfCtrlPressed} to implement "select all" behaviour.
       *
       * ```javascript
       * {
       *     type   : 'combo',
       *     store  : myStore,
       *     picker : {
       *         toggleAllIfCtrlPressed : true
       *     }
       * }
       * ```
       *
       * @config {Boolean}
       * @default false
       */
      multiSelect: null,
      /**
       * Rows to display in the dropdown (list items).
       *
       * If an object, the property names provide the {@link #config-value} for the Combo, and
       * the property values provide the displayed test in the list and input area eg:
       *
       *     items : {
       *         small  : 'Small',
       *         medium : 'Medium',
       *         large  : 'Large'
       *     }
       *
       * If an array, each entry may be
       *  - an object containing properties which must include
       * the {@link #config-valueField} and {@link #config-displayField} which populates the dropdown
       * with text and provides the corresponding field value.
       *  - An array whose first value provides the {@link #config-value} for the Combo and whose
       * second value provides the displayed test in the list and input area.
       *  - An array of values where the {@link #config-valueField} and {@link #config-displayField} are the same.
       *
       * eg:
       *
       *     items : [
       *         {value : 'small',  text : 'Small'},
       *         {value : 'medium', text : 'Medium'},
       *         {value : 'large',  text : 'Large'},
       *     ]
       *
       * or
       *
       *     items : [
       *         ['small',  'Small'],
       *         ['medium', 'Medium'],
       *         ['large',  'Large'],
       *     ]
       *
       * or
       *
       *     items : [ 'Small', 'Medium', 'Large' ]
       *
       * @config {Object[]|String[]|Object}
       */
      items: null,
      /**
       * Store used to populate items. Also accepts a Store config object
       * @prp {Core.data.Store|StoreConfig}
       */
      store: null,
      /**
       * Field used for item value when populating from store. Setting this to `null` will
       * yield the selected record as the Combo's {@link #property-value}.
       * @config {String|null}
       */
      valueField: void 0,
      /**
       * Field used for item text when populating from store
       * @config {String}
       * @default
       */
      displayField: "text",
      /**
       * Width of picker, defaults to this combo's {@link #config-pickerAlignElement} width
       * @config {Number}
       */
      pickerWidth: null,
      /**
       * The minimum string length to trigger the filtering, only relevant when {@link #config-editable} is `true`.
       *
       * This defaults to `1` in the case of local filtering, but `4` if the
       * {@link #config-filterParamName} is set to cause remote dropdown loading.
       *
       * @config {Number}
       * @default
       */
      minChars: null,
      selected: null,
      /**
       * Template string used to render the list items in the dropdown list
       *
       * ```javascript
       * new Combo({
       *     listItemTpl : ({ text }) => `<div class="combo-color-box ${text}"></div>${text}`,
       *     editable    : false,
       *     items       : [
       *         'Black',
       *         'Green',
       *         'Orange',
       *         'Pink',
       *         'Purple',
       *         'Red',
       *         'Teal'
       *     ]
       * });
       * ```
       *
       * @config {Function}
       * @param {Core.data.Model} record The record representing the item being rendered
       * @returns {String|null}
       */
      listItemTpl: null,
      /**
       * Template function that can be used to customize the displayed value
       * @param {Core.data.Model} record The record to provide a textual value for
       * @param {Core.widget.Combo} combo A reference to this Combo
       * @config {Function}
       * @returns {String|null}
       */
      displayValueRenderer: null,
      /**
       * CSS class to add to picker
       * @config {String}
       */
      listCls: null,
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      /**
       * If the dropdown is to be populated with a filtered query to a remote server, specify the
       * name of the parameter to pass the typed string here. By default, the string is simply sent
       * as the value of the parameter. For special encoding, configure the combo with {@link #config-encodeFilterParams}
       * @config {String}
       */
      filterParamName: null,
      /**
       * A function which creates an array of values for the {@link #config-filterParamName} to pass
       * any filters to the server upon load.
       *
       * The default behaviour is just to set the parameter value to the filter's `value`,
       * but the filter can be fully encoded for example:
       *
       * ```javascript
       *    {
       *        encodeFilterParams(filters) {
       *            const result = [];
       *
       *            for (const { property, operator, value, caseSensitive } of filters) {
       *                result.push(JSON.stringify({
       *                    field : property,
       *                    operator,
       *                    value,
       *                    caseSensitive
       *                }));
       *           }
       *        return result;
       *    }
       * ```
       * @config {Function}
       * @param {Object[]} filters filters
       * @returns {Object[]} array of values
       */
      encodeFilterParams: (filters) => filters.map((f) => f.value),
      /**
       * If `false`, filtering will be triggered once you exceed {@link #config-minChars}. To filter only when
       * hitting Enter key, set this to `true`;
       * @config {Boolean}
       */
      filterOnEnter: false,
      /**
       * Configure as `true` to hide the expand trigger. This is automatically set to `true` if
       * remote filtering is enabled by setting the {@link #config-filterParamName} config.
       * @config {Boolean}
       * @default false
       */
      hideTrigger: null,
      /**
       * This implies that the picker will display an anchor pointer, but also means that the picker will align closer
       * to the input field so that the pointer pierces the {@link #config-pickerAlignElement}
       * @config {Boolean}
       * @default false
       */
      overlayAnchor: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before filtering the list.
       *
       * This is a minimum of 300ms for remote filtering to keep network requests manageable, and
       * defaults to 10ms for locally filtered stores.
       * @config {Number}
       * @default
       */
      keyStrokeFilterDelay: null,
      defaultAction: "select",
      /**
       * How to query the store upon click of the expand trigger. Specify one of these values:
       *
       *  - `'all'` - Clear the filter and display the whole dataset in the dropdown.
       *  - `'last'` - Filter the dataset using the last filter value.
       *  - `null`/any other - Use the value in the input field to filter the dataset.
       *
       * @config {'all'|'last'|null}
       * @default
       */
      triggerAction: "all",
      /**
       * The name of an operator type as implemented in {@link Core.util.CollectionFilter#config-operator}
       * to use when filtering the dropdown list based upon the typed value.
       *
       * This defaults to `'startsWith'`, but the `'*'` operator may be used to match all
       * values which _contain_ the typed value.
       *
       * Not used when {@link #config-filterParamName} is set to cause remote dropdown loading.
       * The exact filtering operation is up to the server.
       *
       * @default
       * @prp {CollectionCompareOperator}
       */
      filterOperator: "startsWith",
      /**
       * Configure as `true` to force case matching when filtering the dropdown list based upon the typed value.
       *
       * @config {Boolean}
       * @default false
       */
      caseSensitive: false,
      /**
       * By default, the picker is hidden on selection in single select mode, and
       * remains to allow more selections when {@link #config-multiSelect} is `true`.
       * Setting this to a `Boolean` value can override that default.
       * @config {Boolean}
       */
      hidePickerOnSelect: null,
      /**
       * A config object to configure the {@link Core.widget.ChipView} to display the
       * selected value set when {@link #config-multiSelect} is `true`.
       *
       * For example the {@link Core.widget.List#config-itemTpl} or
       * {@link Core.widget.ChipView#config-iconTpl} might be configured to display
       * richer chips for selected items.
       * @config {ChipViewConfig}
       */
      chipView: {
        $config: ["lazy", "nullify"],
        value: {
          type: "combochipview"
        }
      },
      chipStore: {
        $config: ["lazy", "nullify"],
        value: {}
      },
      /**
       * When {@link #config-multiSelect} is `true`, you may configure `filterSelected` as
       * `true` to hide items in the dropdown when they are added to the selection.
       * It will appear as if the requested item has "moved" into the field's
       * {@link #config-chipView ChipView}.
       *
       * @config {Boolean}
       * @default false
       */
      filterSelected: null,
      /**
       * Text to display in the drop down when there are no items in the underlying store
       * @config {String}
       * @default
       */
      emptyText: null,
      /**
       * Get/sets combo value, selects corresponding item in the list
       * Setting null clears the field.
       *
       * If {@link #config-multiSelect} is `true`, then multiple values may be passed as an array.
       * If the values are records, these become the selected record set held by {@link #property-valueCollection},
       * and the `value` yielded by this field is an array of all the {@link #config-valueField}s from the records.
       * @fires select
       * @fires action
       * @member {Object|Number|String} value
       */
      /**
       * The initial value of this Combo box. In single select mode (default) it's a simple string value, for
       * {@link #config-multiSelect} mode, it should be an array of record ids.
       * @config {String|Number|String[]|Number[]}
       * @default
       */
      value: null,
      valueCollection: {
        $config: ["nullify", "lazy"],
        value: {}
      },
      /**
       * `true` to cause the field to be in an invalid state while the typed filter string does not match a record in the store.
       * @config {Boolean}
       * @default
       */
      validateFilter: true,
      /**
       * `true` to clear value typed to a multiselect combo when picker is collapsed
       * @config {Boolean}
       * @default
       */
      clearTextOnPickerHide: true,
      /**
       * `true` to clear value typed to a multiselect combo when an item is selected. `true` by default as
       * of version 6.0
       * @config {Boolean}
       * @default false
       */
      clearTextOnSelection: VersionHelper.checkVersion("core", "6.0", ">="),
      // set to true to destroy the old combo store when it is replaced with a new store
      destroyStore: false,
      /**
       * A key value which, when typed in a {@link #config-multiSelect} Combo, selects the
       * currently active item in the picker, and clears the input field ready for another
       * match to be typed.
       * @config {String}
       * @default
       */
      multiValueSeparator: ",",
      /**
       * If configured as `true`, this means that when an unmatched string is typed into the
       * combo's input field, and `ENTER`, or the {@link #config-multiValueSeparator} is typed,
       * a new record will be created using the typed string as the {@link #config-displayField}.
       *
       * If configured as a function, or the name of a function in the owning component hierarchy, the function
       * will be called passing the string and combo field instance and should return the record to add (if any).
       *
       * The new record will be appended to the store, and the value selected.
       *
       * If the Store is an {@link Core.data.AjaxStore}, the new record will be eiligible for
       * syncing to the database through its {@link Core.data.AjaxStore#config-createUrl createUrl}.
       *
       * If the `AjaxStore` is configured to {@link Core.data.AjaxStore#config-autoCommit autoCommit},
       * the record will be synced immediately. If the server does not accept the new addition,
       * the field is placed temporarily into an invalid state with a message that explains this.
       *
       * For example:
       *
       * ```javascript
       *     new Combo({
       *         label : 'Employee name',
       *         store : employees,
       *         createOnUnmatched(name, combo) {
       *             name = validateEmployeeName(name);
       *
       *             if (name) {
       *                 return new Employee({
       *                     name,
       *                     email : generateEmployeeEmail(name)
       *                 });
       *             }
       *             else {
       *                 combo.setError('Invalid new employee name');
       *             }
       *         }
       *     });
       * ```
       * @config {Function|String|Boolean}
       * @param {String} name Record name
       * @param {Core.widget.Combo} combo Combo instance
       * @returns {Core.data.Model} New record
       */
      createOnUnmatched: null,
      role: "combobox",
      /**
       * Configure this as `true` to render the dropdown list as a permanently visible list
       * in the document flow immediately below the input area instead of as a popup.
       *
       * This also hides the expand trigger since it is not needed.
       * @config {Boolean}
       * @default false
       */
      inlinePicker: null,
      testConfig: {
        // So that locally filtered tests do not have to wait after type gestures.
        // Note that for remote filtering, we set a min of 300ms
        keyStrokeFilterDelay: 0
      },
      /**
       * Configure this as `true` and the items display field values will be localized. The display field values
       * need to be a locale string.
       * @config {Boolean}
       * @private
       * @default
       */
      localizeDisplayFields: false,
      /**
       * Provide a function that returns items to be shown in the combo's selector.
       * @config {Function}
       * @private
       */
      buildItems: null,
      /**
       * Configure this as `true` to reapply sorting after
       * {@link #config-localizeDisplayFields localizing the items}.
       * @config {Boolean}
       * @private
       * @default
       */
      sortItemsOnLocaleChange: false
    };
  }
  /**
   * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
   * filter the dataset using the last filter query string, *not* the input field value.
   * @member {String} queryLast
   * @readonly
   * @static
   */
  static get queryLast() {
    return "last";
  }
  //endregion
  construct(config) {
    super.construct(...arguments);
    if (!this.store) {
      this.items = [];
    }
    if (this.filterOnEnter) {
      this.hideTrigger = true;
    }
  }
  startConfigure(config) {
    this.usingRecordAsValue = config.valueField === null;
    super.startConfigure(...arguments);
  }
  afterConfigure() {
    super.afterConfigure();
    const me = this;
    if (!ObjectHelper.hasOwn(me, "_value")) {
      me._value = me.valueField === me.displayField ? "" : null;
      me._lastValue = me._lastValue || me._value;
    }
  }
  get childItems() {
    const { _chipView } = this, result = super.childItems;
    if (_chipView) {
      result.push(_chipView);
    }
    return result;
  }
  get innerElements() {
    var _a4;
    const chipViewElement = (_a4 = this._chipView) == null ? void 0 : _a4.element, { input, inputElement } = this;
    if (chipViewElement) {
      DomSync.sync({
        targetElement: input,
        domConfig: inputElement
      });
    }
    return [chipViewElement || inputElement];
  }
  updateInlinePicker(inlinePicker) {
    if (inlinePicker) {
      this.element.classList.add("b-inline-picker");
      this.getConfig("picker");
      this.triggers.expand = null;
      this.pickerVisible = true;
    }
  }
  hidePicker() {
    if (!this.inlinePicker) {
      return super.hidePicker(...arguments);
    }
  }
  changeChipStore(chipStore) {
    if (chipStore && !(chipStore instanceof Store)) {
      chipStore = new Store(Store.mergeConfigs({
        storage: this.valueCollection
      }, chipStore));
    }
    return chipStore;
  }
  updateChipStore(store, was) {
    was == null ? void 0 : was.destroy();
  }
  changeChipView(chipView, oldChipView) {
    const me = this;
    me.element.classList[chipView ? "add" : "remove"]("b-uses-chipview");
    if (chipView) {
      const { input } = me;
      if (!me.chipStore) {
        me.chipStore = {};
      }
      return ComboChipView.reconfigure(oldChipView, chipView, {
        defaults: {
          parent: me,
          insertBefore: input,
          store: me.chipStore,
          closable: !me.readOnly,
          navigator: {
            type: "combochipnavigator",
            keyEventTarget: input
          }
        }
      });
    }
    oldChipView == null ? void 0 : oldChipView.destroy();
  }
  updateChipView(chipView) {
    var _a4;
    const me = this;
    me._chipViewEventDetacher = (_a4 = me._chipViewEventDetacher) == null ? void 0 : _a4.call(me);
    me.chipStore = chipView == null ? void 0 : chipView.store;
    if (chipView) {
      chipView.element.appendChild(me.input);
      me._chipViewEventDetacher = EventHelper.on({
        element: chipView.element,
        mousedown: "onChipViewMousedown",
        thisObj: me
      });
    }
  }
  updateMultiSelect(multiSelect, oldMultiSelect) {
    const me = this, {
      input,
      element
    } = me, fixValue = !me.isConfiguring;
    let { value } = me;
    element.classList[multiSelect ? "add" : "remove"]("b-multiselect");
    if (multiSelect) {
      const { chipView } = me, { parentNode } = input, chipViewEl = chipView == null ? void 0 : chipView.element;
      if (chipViewEl && chipViewEl !== parentNode) {
        parentNode.insertBefore(chipViewEl, input);
        chipViewEl.appendChild(input);
        me.chipView.refresh();
      }
      input.value = "";
      if (fixValue) {
        value = ArrayHelper.asArray(value);
      }
    } else {
      const chipView = me._chipView, { parentNode } = input, chipViewEl = chipView == null ? void 0 : chipView.element;
      if (chipViewEl === parentNode) {
        chipViewEl.parentNode.insertBefore(input, chipViewEl);
        chipViewEl.remove();
        element.classList.remove("b-uses-chipview");
      }
      if (fixValue && typeof value !== "string") {
        value = (value == null ? void 0 : value.length) ? value[0] : null;
      }
    }
    if (fixValue) {
      me.value = value;
    }
  }
  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();
    if (!this.containsFocus) {
      this.focus();
    }
  }
  onChipClose(records, options = {}) {
    if (options.isKeyEvent && this.input.value === "" || !options.isKeyEvent) {
      this._isUserAction = true;
      this.valueCollection.remove(records);
      this._isUserAction = false;
    }
  }
  updateFilterParamName(filterParamName) {
    if (this.hideTrigger !== false) {
      this.hideTrigger = Boolean(filterParamName);
    }
  }
  updateHideTrigger(hideTrigger) {
    this.element.classList[hideTrigger ? "add" : "remove"]("b-hide-trigger");
  }
  //region Getters/setters
  updateKeyStrokeFilterDelay(delay) {
    this.filterOnInput.delay = delay;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(...arguments);
    this._chipView && (this._chipView.closable = !readOnly);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this._chipView && (this._chipView.closable = !disabled);
  }
  updateFilterOperator(filterOperator) {
    if (this.primaryFilter) {
      this.primaryFilter.operator = filterOperator;
    }
  }
  get minChars() {
    var _a4;
    return (_a4 = this._minChars) != null ? _a4 : this.remoteFilter ? 4 : 1;
  }
  get validateFilter() {
    return this._validateFilter && !this.createOnUnmatched;
  }
  get items() {
    return this.store.allRecords;
  }
  updateBuildItems(fn) {
    if (fn) {
      this.items = fn.call(this);
    }
  }
  /**
   * Prepares items to work in attached menu (converts strings to items)
   * @private
   */
  changeItems(items2) {
    const me = this;
    if (items2 == null) {
      if (me.store && !me.store.isItemStore) {
        return;
      }
      items2 = [];
    }
    if (me.buildItems && !(items2 == null ? void 0 : items2.length)) {
      items2 = me.buildItems();
    }
    if (items2 instanceof Store) {
      me.store = items2;
      return;
    }
    const displayField = me.displayField;
    let itemModel, valueField = me.valueField, storeData;
    if (Array.isArray(items2)) {
      storeData = items2.map((item) => {
        let result = item;
        if (item instanceof Model) {
          itemModel = item.constructor;
          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === "string" || typeof item === "number") {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }
            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = "value";
            }
            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }
        if (item.selected) {
          me.value = result;
        }
        return result;
      });
    } else {
      if (!valueField) {
        me.valueField = valueField = "value";
      }
      storeData = [];
      Object.entries(items2).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }
    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition = valueField === displayField ? {
        name: "value",
        dataSource: displayField
      } : valueField;
      if (!itemModel) {
        class ModelClass extends Model {
          static get idField() {
            return me.valueField;
          }
          static set idField(idField) {
            super.idField = idField;
          }
          static get fields() {
            const result = [valueFieldDefinition, displayField];
            if (me.localizeDisplayFields) {
              result.push("localeClass");
            }
            return result;
          }
        }
        itemModel = ModelClass;
      }
      me.store = new Store({
        isItemStore: true,
        data: storeData,
        idField: valueField,
        // We frequently populate combos with data from other stores, don't want warnings for consuming local
        // records from those stores with generated ids
        verifyNoGeneratedIds: false,
        modelClass: itemModel
      });
    }
  }
  get value() {
    const me = this, { valueCollection, valueField } = me;
    if (valueField == null) {
      return me.multiSelect ? valueCollection.values.slice() : valueCollection.first;
    }
    let value;
    if (me.multiSelect) {
      value = valueCollection.count ? valueCollection.map((r) => r[valueField]) : me._lastValue || [];
    } else {
      value = valueCollection.count ? valueCollection.first[valueField] : me._lastValue;
    }
    return value;
  }
  set value(value) {
    super.value = value;
  }
  // Documented in superclass.
  get needsInputSync() {
    return this.usesChipView ? false : !this.editable;
  }
  changeValue(value, oldValue) {
    var _a4, _b;
    const me = this;
    if (value === oldValue) {
      me.syncInputFieldValue(true);
      return;
    }
    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error("Multiple values cannot be set to a non-multiSelect Combo");
    }
    me.triggerConfig("items");
    if (!me.inputting) {
      (_a4 = me._chipView) == null ? void 0 : _a4.selected.clear();
    }
    if (!me.store) {
      me.items = [];
    }
    const {
      valueField,
      displayField,
      store,
      valueCollection,
      _picker
    } = me, { storage } = store, hidePicker = (_b = me.hidePickerOnSelect) != null ? _b : !me.multiSelect, isUserAction = me._isUserAction || (_picker == null ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false;
    if (!me.remoteFilter && store.isAjaxStore && !store.count) {
      store.ion({ load: () => me.value = value, once: true, thisObj: me });
      me._lastValue = value;
      return;
    }
    let record;
    if (value != null) {
      const arrayPassed = Array.isArray(value), values = arrayPassed ? value.slice() : [value];
      if (me.remoteFilter) {
        if (value != null) {
          if (ObjectHelper.isObject(value) || value.isModel) {
            me.store.data = [value];
            me.valueCollection.splice(0, me.valueCollection.count, me.store.first);
          } else {
            const wasConfiguring = me.isConfiguring;
            me.primaryFilter.setConfig({
              value,
              disabled: false
            });
            store.performFilter(true).then(() => {
              if (me.isDestroyed) {
                return;
              }
              const { isConfiguring } = me;
              me.isConfiguring = wasConfiguring;
              valueCollection.splice(0, valueCollection.count, store.allRecords);
              me.isConfiguring = isConfiguring;
            });
          }
          return;
        }
      } else if (store.isFiltered) {
        if (store.isChained) {
          store.fillFromMaster();
        }
        me.primaryFilter.disabled = true;
        store.filter();
      } else if (store.isChained) {
        store.fillFromMaster();
      }
      for (let i = 0, len = values.length; i < len; i++) {
        let currentValue = values[i];
        if (currentValue instanceof Model) {
          if (!storage.includes(currentValue, true)) {
            store.add(currentValue);
          }
        } else {
          const isObject3 = ObjectHelper.isObject(currentValue);
          if (isObject3 && valueField) {
            currentValue = currentValue[store.modelClass.fieldMap[valueField].dataSource];
          }
          record = storage.getBy(displayField, currentValue) || storage.getBy(valueField, currentValue) || (valueCollection.getBy(displayField, currentValue) || valueCollection.getBy(valueField, currentValue));
          if (record instanceof Set) {
            record = [...record][0];
          }
          if (record) {
            if (isObject3) {
              record.set(values[i]);
            }
            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }
      const noMatches = !values.length;
      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);
      if (noMatches) {
        me._value = arrayPassed && value.length === 0 ? null : value;
        me._lastValue = me._value;
      }
      if (noMatches || valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }
      me.syncEmpty();
      if (noMatches && !me.isConfiguring) {
        me.triggerFieldChange({
          value,
          oldValue,
          userAction: isUserAction,
          valid: me.isValid
        });
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue2 = me._value;
        me._value = null;
        me.syncInputFieldValue();
        me.syncEmpty();
        if (!me.isConfiguring) {
          me.triggerFieldChange({
            value,
            oldValue: oldValue2,
            userAction: isUserAction,
            valid: me.isValid
          });
        }
      }
    }
    me._lastValue = me._value;
  }
  hasChanged(oldValue, newValue) {
    if (this.multiSelect) {
      return !ObjectHelper.isEqual(oldValue, newValue);
    }
    return super.hasChanged(...arguments);
  }
  onComboStoreChange({ action }) {
    if (action !== "filter") {
      this.syncInputFieldValue(true);
    }
  }
  syncInputFieldValue(skipHighlight) {
    var _a4;
    if (this.usesChipView) {
      (_a4 = this.chipView) == null ? void 0 : _a4.refresh();
    } else {
      super.syncInputFieldValue(skipHighlight);
    }
  }
  get usesChipView() {
    return Boolean(this.multiSelect && this._chipView);
  }
  /**
   * Returns `true` if this field has no selected records.
   * @property {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.valueCollection.count === 0;
  }
  get inputValue() {
    const me = this;
    let result = me.selected ? me.selected[me.displayField] : me.value;
    if (me.displayValueRenderer) {
      result = me.callback(me.displayValueRenderer, me, [me.selected, me]);
    }
    return result == null ? "" : result;
  }
  get nonEditableClickTarget() {
    var _a4;
    return this.multiSelect && ((_a4 = this.chipView) == null ? void 0 : _a4.element) || super.nonEditableClickTarget;
  }
  /**
   * A {@link Core/util/Collection} which holds the currently selected records
   * from the store which dictates this field's value.
   *
   * Usually, this will contain one record, the record selected.
   *
   * When {@link #config-multiSelect} is `true`, there may be several records selected.
   * @member {Core.util.Collection} valueCollection
   * @readonly
   */
  changeValueCollection(valueCollection, oldValueCollection) {
    oldValueCollection == null ? void 0 : oldValueCollection.destroy();
    if (valueCollection) {
      if (!valueCollection.isCollection) {
        valueCollection = new Collection({
          internalListeners: {
            noChange: "onValueCollectionNoChange",
            change: "onValueCollectionChange",
            prio: -1e3,
            // The ChipView must react to changes first.
            thisObj: this
          }
        });
      }
      return valueCollection;
    }
  }
  changePrimaryFilter(primaryFilter) {
    if (primaryFilter.isCollectionFilter) {
      primaryFilter.setConfig({
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      });
    } else {
      if (typeof primaryFilter === "function") {
        primaryFilter = {
          filterBy: primaryFilter
        };
      }
      primaryFilter = new CollectionFilter({
        // Need an id to replace any existing combo filter on the store.
        id: "primary",
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive,
        ...primaryFilter
      });
    }
    return primaryFilter;
  }
  changeStore(store) {
    const me = this, storeFilters = [], {
      valueCollection,
      keyStrokeFilterDelay,
      filterParamName
    } = me;
    if (Array.isArray(store)) {
      me.items = store;
      return;
    }
    let remoteFilter;
    if (store) {
      if (store.isStore) {
        const sharedFilter = store.filters.get("primary");
        if (me.remoteFilter) {
          store.filterParamName = filterParamName;
        }
        remoteFilter = store.remoteFilter;
        if (sharedFilter) {
          me.primaryFilter = sharedFilter;
        } else {
          storeFilters.push(me.primaryFilter);
        }
      } else {
        if (typeof store === "string") {
          store = Store.getStore(store);
        } else {
          store = new (store.readUrl ? AjaxStore : Store)(store);
          me.destroyStore = true;
        }
        remoteFilter = me.remoteFilter || store.restfulFilter;
        if (remoteFilter && filterParamName) {
          store.filterParamName = filterParamName;
          if (me.encodeFilterParams) {
            store.encodeFilterParams = me.encodeFilterParams;
          }
        }
        storeFilters.push(me.primaryFilter);
      }
      if (!me.valueField && !me.usingRecordAsValue) {
        me.valueField = store.modelClass.idField;
      }
      if (me.filterSelected) {
        const selectedItemsFilter = (r) => !me.containsFocus || !valueCollection.includes(r);
        if (remoteFilter) {
          store.storage.autoFilter = true;
          store.storage.addFilter({
            id: `${me.id}-selected-filter`,
            filterBy: selectedItemsFilter
          });
        } else {
          storeFilters.push(selectedItemsFilter);
          store.reapplyFilterOnAdd = true;
        }
      }
      valueCollection.addIndex({
        property: me.displayField,
        unique: false
      });
      valueCollection.addIndex({
        property: me.valueField,
        unique: true
      });
      storeFilters.forEach((f) => store.addFilter(f, true));
      if (remoteFilter) {
        me.keyStrokeFilterDelay = Math.max(300, keyStrokeFilterDelay || 0);
      } else {
        me.keyStrokeFilterDelay = keyStrokeFilterDelay != null ? keyStrokeFilterDelay : 10;
      }
    }
    return store;
  }
  updateStore(store, oldStore) {
    const me = this, { _picker } = me;
    let storeListeners;
    if (me.destroyStore && oldStore) {
      oldStore.destroy();
    }
    if (_picker) {
      _picker.store = store;
    }
    store.storage.addIndex({
      property: me.displayField,
      unique: false
    });
    store.storage.addIndex({
      property: me.valueField,
      unique: true
    });
    storeListeners = {
      filter: "onStoreFilter"
    };
    if (me.displayValueRenderer) {
      (storeListeners || (storeListeners = {})).change = "onComboStoreChange";
    }
    me.detachListeners("store");
    (store == null ? void 0 : store.storage) && me.valueCollection.match(store.storage);
    me.syncInputFieldValue();
    if (storeListeners) {
      storeListeners.name = "store";
      storeListeners.thisObj = me;
      store.ion(storeListeners);
    }
  }
  get remoteFilter() {
    var _a4;
    return Boolean(this.filterParamName || ((_a4 = this._store) == null ? void 0 : _a4.restfulFilter));
  }
  /**
   * Get selected record.
   * @property {Core.data.Model}
   * @readonly
   */
  get record() {
    return this.selected;
  }
  /**
   * Get the selected record(s).
   * @property {Core.data.Model[]}
   * @readonly
   */
  get records() {
    return this.valueCollection.values.slice();
  }
  get selected() {
    const { store } = this;
    return this.multiSelect ? this.valueCollection.values.slice().sort((l, r) => store.indexOf(l) - store.indexOf(r))[0] : this.valueCollection.first;
  }
  //endregion
  //region Value handling
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    const me = this, selectionCount = me.valueCollection.count;
    super.onEditComplete();
    if (selectionCount) {
      me.clearError(errorValidateFilter);
      me.syncInputFieldValue();
    }
    if (me.required && !selectionCount) {
      me.setError(errorFieldRequired);
    }
  }
  //endregion
  //region Events
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    var _a4;
    const me = this, activatePicker = "key" in event;
    if (me.remoteFilter && me.filterOnEnter) {
      return;
    }
    if (me.pickerVisible) {
      me.hidePicker();
    } else if (!me.readOnly && !me.disabled) {
      switch ((_a4 = me.triggerAction) == null ? void 0 : _a4.toLowerCase()) {
        case "all":
          me.doFilter(null, activatePicker);
          break;
        case "last":
          me.doFilter(me.lastQuery, activatePicker);
          break;
        default:
          me.doFilter(me.input.value, activatePicker);
      }
    }
  }
  /**
   * User types into input field in editable combo, show list and filter it.
   * @private
   */
  internalOnInput(event) {
    const me = this;
    me.syncEmpty();
    me.syncInputWidth();
    me.filterOnInput(event);
    me.trigger("input", { value: me.input.value, event });
  }
  filterOnInput(event) {
    const me = this, { value } = event.type === "input" ? event.target : me.input, inputLen = value.length;
    me.inputting = true;
    if (me.inlinePicker || inputLen >= me.minChars && (!me.filterOnEnter || event.key === "Enter")) {
      me.doFilter(value);
    } else {
      if (me.validateFilter && !me.remoteFilter) {
        me[inputLen ? "setError" : "clearError"](errorValidateFilter);
      }
      me.hidePicker();
    }
    me.inputting = false;
  }
  syncInputWidth() {
    const me = this;
    if (me.usesChipView) {
      const input = me.input, inputPadding = me._inputPadding || (me._inputPadding = DomHelper.getEdgeSize(input, "padding", "lr")), value = input.value || "", width = (
        // +'W' to avoid text getting clipped or horizontal scrolling
        DomHelper.measureText(value + "W", input, false, me.element) + inputPadding.width
      );
      input.style.flex = `1 1 ${Math.ceil(width)}px`;
    }
  }
  doFilter(queryString, activatePicker) {
    var _a4;
    const me = this, {
      store,
      // Force the lazy config to create picker since the List needs to add its beforeLoad listener
      picker
    } = me, disableFilter = queryString == null || queryString === "";
    me.lastQuery = queryString;
    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });
    if (me.remoteFilter) {
      store.clear(true);
    }
    const onAfterFilter = () => {
      const { navigator: navigator2, isVisible: isVisible2 } = picker;
      if (store.count) {
        if (!disableFilter && navigator2) {
          navigator2.activeItem = 0;
        }
      } else if (!me.remoteFilter && !disableFilter) {
        if (navigator2) {
          navigator2.activeItem = null;
        }
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      isVisible2 && picker.realign();
    };
    (_a4 = me.filterPromise = store.filter()) == null ? void 0 : _a4.then(() => {
      me.filterPromise = null;
      onAfterFilter();
    });
    if (!me.inlinePicker) {
      if (picker == null ? void 0 : picker.isVisible) {
        if (picker.lastAlignSpec.zone === 0) {
          picker.realign();
        }
      } else {
        me.showPicker(activatePicker);
      }
    }
    if (!me.filterPromise) {
      onAfterFilter();
    }
  }
  onStoreFilter({ source: store }) {
    const me = this, picker = me._picker, dataset = picker == null ? void 0 : picker.element.dataset, { count } = store;
    if (me.remoteFilter) {
      if (count) {
        if (picker) {
          picker.navigator.activeItem = 0;
        }
      } else {
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      if (me.filterSelected && me.valueCollection.count) {
        store.storage.onFiltersChanged({ action: "splice", oldCount: 1 });
        if (picker) {
          picker.refresh();
        }
      }
    }
    if (dataset) {
      if (me.createOnUnmatched && !count && me.primaryFilter.value != null) {
        dataset.addNewValue = me.L("L{addNewValue}")(me.primaryFilter.value);
      } else {
        dataset == null ? true : delete dataset.addNewValue;
      }
    }
  }
  /**
   * This reacts to our {@link #property-valueCollection} being mutated in any way.
   * The `change`, `select` and `action` events are fired here.
   *
   * This could happen in four ways:
   *
   *  - User selected or deselected an item in the dropdown list.
   *  - `set value` changes the content.
   *  - The {@link #config-multiSelect} Chip view (which uses this in its store) deletes a record.
   *  - The application programmatically mutates the {@link #property-valueCollection}.
   *
   * @private
   */
  onValueCollectionChange({ source: valueCollection }) {
    var _a4, _b, _c, _d;
    const me = this, { multiSelect, _picker } = me, hidePicker = (_a4 = me.hidePickerOnSelect) != null ? _a4 : !multiSelect, record = multiSelect ? valueCollection.values.slice() : valueCollection.first, records = valueCollection.values.slice(), isUserAction = me._isUserAction || (_picker == null ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false, oldValue = me._value;
    if (hidePicker) {
      me.hidePicker();
    }
    if (multiSelect && me.clearTextOnSelection) {
      me.input.value = "";
    }
    if (!valueCollection.count && me.required) {
      me.setError(errorFieldRequired);
    } else {
      me.clearError(errorFieldRequired);
      me.clearError(errorValidateFilter);
    }
    if (me.validateFilter && record) {
      me.clearError(errorValidateFilter);
    }
    if (me.filterSelected) {
      const navigator2 = _picker == null ? void 0 : _picker.navigator, activeItem = Number((_c = (_b = navigator2 == null ? void 0 : navigator2.activeItem) == null ? void 0 : _b.dataset) == null ? void 0 : _c.index);
      if (me.remoteFilter) {
        me.store.storage.onFiltersChanged({ action: "splice", oldCount: 1 });
        if (me._picker) {
          me._picker.refresh();
        }
      } else {
        me.store.filter();
      }
      if (!isNaN(activeItem)) {
        navigator2.activeItem = Math.min(_picker.store.count, activeItem);
      }
    }
    me._value = null;
    me._lastValue = null;
    const value = me.cacheCurrentValue(me.value);
    me.syncInputFieldValue();
    me.syncEmpty();
    if (!me.isConfiguring) {
      me.triggerFieldChange({
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });
      (_d = me.trigger) == null ? void 0 : _d.call(me, "select", { record, records, userAction: isUserAction });
      if (me.defaultAction === "select") {
        me.trigger("action", { value, record, records, userAction: isUserAction });
      }
    }
  }
  // Caching a copy of current value, which can be changed by subclasses (see AssignmentField for reference)
  cacheCurrentValue(v) {
    return this._value = v;
  }
  /**
   * This listens for when a record from the list is selected, but is already part of
   * the selection and so the {@link #property-valueCollection} rejects that as a no-op.
   * At this point, the user will still expect the picker to hide.
   * @param {Object} event The noChange event containing the splice parameters
   * @private
   */
  onValueCollectionNoChange({ toAdd }) {
    if (!this.inlinePicker && !this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
      this.syncInputFieldValue();
    }
  }
  //endregion
  //region Picker
  showPicker() {
    var _a4;
    const me = this, { picker } = me;
    if (me.readOnly || me.inlinePicker) {
      return;
    }
    picker.multiSelect = me.multiSelect;
    super.showPicker(...arguments);
    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }
    if (picker.restoreActiveItem) {
      if (me.multiSelect) {
        picker.restoreActiveItem(((_a4 = picker.navigator) == null ? void 0 : _a4.previousActiveItem) || me.selected || 0, true);
      } else {
        picker.restoreActiveItem(me.selected || 0, true);
      }
    }
    me.input.focus();
  }
  /**
   * Creates default picker widget
   *
   * @internal
   */
  changePicker(picker, oldPicker) {
    if (picker) {
      const me = this, pickerWidth = me.pickerWidth || (picker == null ? void 0 : picker.width), config = List.mergeConfigs({
        owner: me,
        store: me.store,
        selected: me.valueCollection,
        multiSelect: me.multiSelect,
        cls: me.listCls,
        displayField: me.displayField,
        forElement: me[me.pickerAlignElement],
        align: {
          matchSize: pickerWidth == null,
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement],
          // Reasonable minimal height to fit few combo items below the combo.
          // When height is not enough, list will appear on top. That works for windows higher than 280px,
          // worrying about shorter windows sounds overkill.
          // We cannot use relative measures here, each combo list item is ~40px high
          minHeight: me.inlinePicker ? null : Math.min(3, me.store.count) * 40
        },
        [me.listItemTpl ? "itemTpl" : void 0]: me.listItemTpl,
        width: pickerWidth,
        navigator: {
          keyEventTarget: me.input
        }
      }, picker);
      if (me.inlinePicker) {
        Object.assign(config, {
          floating: false,
          align: null,
          activateOnMouseover: false,
          maxHeight: null,
          appendTo: me.element
        });
      }
      picker = List.reconfigure(oldPicker, picker ? config : null, me);
      picker.element.classList.add("b-combo-picker");
      picker.element.dataset.emptyText = me.emptyText ? me.L(me.emptyText) : me.L("L{noResults}");
      picker.ion({
        navigate: "onPickerNavigate",
        thisObj: me
      });
      EventHelper.on({
        element: picker.element,
        pointerdown: (event) => me.onPickerNavigate({ event }),
        thisObj: me
      });
    } else {
      oldPicker == null ? void 0 : oldPicker.destroy();
    }
    return picker;
  }
  onPickerNavigate({ event }) {
    if (event.target.matches("[data-add-new-value]")) {
      this.addNewRecord(this.primaryFilter.value);
    }
  }
  onPickerHide() {
    const me = this;
    super.onPickerHide();
    if (me.multiSelect && me.clearTextOnPickerHide && !me.errors) {
      me.input.value = "";
    }
  }
  //endregion
  async internalOnKeyEvent(keyEvent) {
    var _a4;
    const me = this, value = me.input[me.inputValueAttr], inputLen = value.length, { key } = keyEvent, {
      primaryFilter,
      store,
      multiSelect,
      minChars,
      // Use the private property names here because these are lazy configs.
      // We do not want to pull them into existence if they have not yet been created.
      _picker: picker,
      _chipView: chipView
    } = me;
    let skipFilter;
    if (keyEvent.type === "keydown" && (picker == null ? void 0 : picker.isVisible) && picker.navigator) {
      const { activeItem } = picker.navigator;
      if (activeItem && multiSelect && key === me.multiValueSeparator) {
        me.input.value = "";
        picker.onItemClick(activeItem, keyEvent);
        primaryFilter.setConfig({
          value: "",
          disabled: true
        });
        store.filter();
        picker.hide();
        keyEvent.preventDefault();
        return;
      }
      if (!activeItem && me.createOnUnmatched && (multiSelect && key === me.multiValueSeparator || key === "Enter")) {
        keyEvent.preventDefault();
        await me.addNewRecord(value);
        return;
      }
    }
    if (me.editable) {
      if (chipView && !chipView.selected.count && keyEvent.type === "keydown" && key === "Backspace" && !inputLen) {
        chipView.navigator.activeItem = me.valueCollection.count - 1;
        keyEvent.stopImmediatePropagation();
      }
    } else if (me.pickerVisible) {
      if (key === "Backspace" && ((_a4 = primaryFilter.value) == null ? void 0 : _a4.length)) {
        primaryFilter.value = primaryFilter.value.substring(0, primaryFilter.value.length - 1);
        me.store.filter();
        picker.restoreActiveItem(0);
      } else if (keyEvent.type === "keypress" && key.match(filterKeyTypes)) {
        if (!me.lastFilterKeypressTime || keyEvent.timeStamp - me.lastFilterKeypressTime > 2e3) {
          primaryFilter.value = "";
        }
        primaryFilter.setConfig({
          value: (primaryFilter.value || "") + key,
          disabled: false
        });
        me.store.filter();
        picker.restoreActiveItem(0);
      }
      me.lastFilterKeypressTime = keyEvent.timeStamp;
    }
    if (me.pickerVisible && key === "Enter" && me.primaryFilter.value === me.input.value) {
      skipFilter = true;
    }
    super.internalOnKeyEvent(...arguments);
    if (keyEvent.type === "keydown" && key === "Enter" && !skipFilter && me.remoteFilter) {
      keyEvent.stopPropagation();
      if (inputLen >= minChars) {
        me.filterOnInput.now(keyEvent);
      } else {
        me.setError(errorTooShort + ` (${minChars})`, false, true);
      }
    }
  }
  async addNewRecord(value) {
    var _a4, _b;
    const me = this, {
      store,
      _picker: picker,
      valueCollection,
      multiSelect,
      primaryFilter
    } = me, remoteAutoCommit = store.remoteFilter && store.autoCommit;
    if (me.filterPromise) {
      await me.filterPromise;
    }
    if (!remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    me._isUserAction = true;
    const [newRecord] = store.add(me.callback(me.createOnUnmatched, me, [value, me]));
    if (store.isCommitting) {
      let error;
      try {
        await store.autoCommitTimeoutPromise;
        await store.commitPromise;
      } catch (exception) {
        error = (_b = (_a4 = exception.response) == null ? void 0 : _a4.parsedJson) == null ? void 0 : _b.error;
      }
      if (newRecord.isPhantom) {
        me.clearError();
        me.setError(error || errorRecordNotCommitted, false, true);
        store.remove(newRecord);
        store.removed.remove(newRecord);
      }
    }
    if (remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    me.input.value = "";
    if (store.includes(newRecord)) {
      valueCollection.splice(multiSelect ? valueCollection.count : 0, multiSelect ? 0 : valueCollection.count, newRecord);
    }
    picker == null ? void 0 : picker.hide();
    me._isUserAction = false;
  }
  changeCreateOnUnmatched(createOnUnmatched) {
    if (createOnUnmatched === true) {
      createOnUnmatched = this.defaultRecordCreator;
    }
    return createOnUnmatched;
  }
  defaultRecordCreator(value) {
    return this.store.createRecord({
      [this.displayField]: value
    });
  }
  updateLocalizeDisplayFields(value) {
    if (value) {
      this.localizableProperties.push("store");
    } else {
      ArrayHelper.remove(this.localizableProperties, "store");
    }
  }
  localizeProperty(property) {
    if (property === "store") {
      return this.localizeStore();
    }
    return super.localizeProperty(property);
  }
  localizeStore() {
    var _a4;
    const me = this, { displayField } = me;
    let { localizedDisplayFieldsMap } = me;
    if (!localizedDisplayFieldsMap) {
      me.localizedDisplayFieldsMap = localizedDisplayFieldsMap = /* @__PURE__ */ new Map();
    }
    if (!me.store && me.buildItems) {
      me.items = me.buildItems();
    }
    for (const item of me.items) {
      if (item.id) {
        let localeString = localizedDisplayFieldsMap.get(item.id);
        if (!localeString && ((_a4 = item[displayField]) == null ? void 0 : _a4.startsWith("L{"))) {
          localeString = item[displayField];
          localizedDisplayFieldsMap.set(item.id, localeString);
        }
        if (localeString) {
          item[displayField] = (item.localeClass || me).L(localeString);
        }
      }
    }
    if (me.sortItemsOnLocaleChange) {
      me.store.sort();
    }
    me.syncInputFieldValue();
  }
};
//region Config
__publicField(Combo, "$name", "Combo");
__publicField(Combo, "type", "combo");
__publicField(Combo, "alias", "combobox,dropdown");
__publicField(Combo, "delayable", {
  filterOnInput: 0
});
var ComboChipView = class extends ChipView {
  static get $name() {
    return "ComboChipView";
  }
  static get type() {
    return "combochipview";
  }
  static get defaultConfig() {
    return {
      closeHandler: "up.onChipClose",
      itemsFocusable: false,
      multiSelect: true,
      itemTpl(record) {
        return StringHelper.encodeHtml(record.getValue(this.owner.displayField));
      },
      scrollable: {
        overflowY: "auto"
      }
    };
  }
};
var ComboChipNavigator = class extends Navigator {
  static get $name() {
    return "ComboChipNavigator";
  }
  // Factoryable type name
  static get type() {
    return "combochipnavigator";
  }
  static get configurable() {
    return {
      allowShiftKey: true
    };
  }
  onTargetClick(clickEvent) {
    const me = this, item = clickEvent.target.closest(me.itemSelector);
    if (item && !clickEvent.target.classList.contains("b-close-icon")) {
      if (!clickEvent.shiftKey && !item.contains(clickEvent.target.closest("[data-noselect]"))) {
        me.ownerCmp.selected.clear();
      }
      me.inClickHandler = true;
      me.activeItem = item;
      me.inClickHandler = false;
    }
  }
  onKeyDown(keyEvent) {
    if (keyEvent.key !== "Enter" && !keyEvent.target.selectionStart && !keyEvent.target.selectionEnd) {
      super.onKeyDown(keyEvent);
    }
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const chipView = this.ownerCmp;
    super.updateActiveItem(activeItem, oldActiveItem);
    if (activeItem && !this.inClickHandler) {
      chipView.selected.add(chipView.getRecordFromElement(activeItem));
    }
  }
  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
};
Combo.initClass();
ComboChipView.initClass();
ComboChipNavigator.initClass();
Combo._$name = "Combo";

// ../Core/lib/Core/widget/base/UndoRedoBase.js
var UndoRedoBase = class extends Container {
  static get configurable() {
    return {
      // Documented on subclasses
      project: null,
      stm: null,
      /**
       * Configure as `true` to show "Undo" and "Redo" as button texts. The buttons always have a tooltip
       * as a hint to the user as to their purpose.
       * @config {Boolean}
       */
      text: null,
      /**
       * Button color for the undo and redo buttons. See {@link Core.widget.Button#config-color}.
       * @config {String}
       */
      color: null,
      /**
       * Configure as `true` to show "0" badge on the undo and redo buttons when they have no actions
       * left to perform. By default when there are no actions, no badge is displayed.
       * @config {Boolean}
       */
      showZeroActionBadge: null,
      cls: "b-undo-controls b-toolbar",
      layoutStyle: {
        alignItems: "stretch",
        flexFlow: "row nowrap",
        overflow: "visible"
      },
      items: {
        undoBtn: {
          type: "button",
          icon: "b-icon-undo",
          tooltip: "L{UndoRedo.UndoLastAction}",
          onAction: "up.onUndo"
          // 'up.' means method is on a parent Widget.
        },
        transactionsCombo: {
          type: "combo",
          valueField: "idx",
          editable: false,
          store: {},
          emptyText: "L{UndoRedo.NoActions}",
          onAction: "up.onTransactionSelected",
          displayValueRenderer: "up.transactionsDisplayValueRenderer"
        },
        redoBtn: {
          type: "button",
          icon: "b-icon-redo",
          tooltip: "L{UndoRedo.RedoLastAction}",
          onAction: "up.onRedo"
        }
      },
      // This is treated as atomic by the Toolbar's menu overflow processing.
      overflowable: true
    };
  }
  afterConstruct() {
    this.updateUndoRedoControls();
  }
  updateStm(stm) {
    this.detachListeners("undoredo");
    stm == null ? void 0 : stm.ion({
      name: "undoredo",
      recordingstop: "updateUndoRedoControls",
      restoringstop: "updateUndoRedoControls",
      queueReset: "updateUndoRedoControls",
      disabled: "updateUndoRedoControls",
      thisObj: this
    });
  }
  changeItems(items2) {
    const { undoBtn, redoBtn } = items2;
    if (this.color) {
      undoBtn && (undoBtn.color = this.color);
      redoBtn && (redoBtn.color = this.color);
    }
    if (this.text) {
      undoBtn && (undoBtn.text = "L{UndoRedo.Undo}");
      redoBtn && (redoBtn.text = "L{UndoRedo.Redo}");
    }
    return super.changeItems(items2);
  }
  updateProject(project) {
    this.stm = project.stm;
  }
  fillUndoRedoCombo() {
    const { transactionsCombo } = this.widgetMap;
    transactionsCombo && (transactionsCombo.items = [[0, "Original data"], ...this.stm.queue.map((title, idx) => [idx + 1, title || `Transaction ${idx + 1}`])]);
  }
  updateUndoRedoControls() {
    const {
      stm,
      showZeroActionBadge
    } = this, {
      undoBtn,
      redoBtn,
      transactionsCombo
    } = this.widgetMap;
    undoBtn.badge = stm.position || (showZeroActionBadge ? "0" : "");
    redoBtn.badge = stm.length - stm.position || (showZeroActionBadge ? "0" : "");
    undoBtn.disabled = !stm.canUndo;
    redoBtn.disabled = !stm.canRedo;
    this.fillUndoRedoCombo();
    if (transactionsCombo) {
      transactionsCombo.disabled = transactionsCombo.store.count <= 1;
    }
  }
  transactionsDisplayValueRenderer(record, combo) {
    var _a4;
    const stmPos = ((_a4 = this.stm) == null ? void 0 : _a4.position) || 0;
    return `${stmPos} undo actions / ${combo.store.count - stmPos - 1} redo actions`;
  }
  onUndo() {
    this.stm.canUndo && this.stm.undo();
  }
  onRedo() {
    this.stm.canRedo && this.stm.redo();
  }
  onTransactionSelected(combo) {
    const { stm } = this, delta = stm.position - combo.value;
    if (delta > 0) {
      stm.canUndo && stm.undo(delta);
    } else if (delta < 0) {
      stm.canRedo && stm.redo(-delta);
    }
  }
};
__publicField(UndoRedoBase, "$name", "UndoRedoBase");
__publicField(UndoRedoBase, "type", "undoredobase");
UndoRedoBase.initClass();
UndoRedoBase._$name = "UndoRedoBase";

// ../Core/lib/Core/widget/BooleanCombo.js
var BooleanCombo = class extends Combo {
  //region Config
  static get configurable() {
    return {
      /**
       * Positive option value
       *
       * @config {*}
       */
      positiveValue: true,
      /**
       * Positive option display value
       *
       * @config {String}
       */
      positiveText: null,
      /**
       * Negative option value
       *
       * @config {*}
       */
      negativeValue: false,
      /**
       * False option display value
       *
       * @config {String}
       */
      negativeText: null,
      store: {
        value: [],
        $config: "lazy"
      },
      /**
       * Default value
       *
       * @config {*}
       */
      value: false
    };
  }
  //endregion
  changeStore(store, oldStore) {
    const me = this;
    return super.changeStore(new Store({
      data: [{
        id: me.positiveValue,
        text: me.positiveText || me.L("L{Object.Yes}")
      }, {
        id: me.negativeValue,
        text: me.negativeText || me.L("L{Object.No}")
      }]
    }), oldStore);
  }
};
__publicField(BooleanCombo, "$name", "BooleanCombo");
__publicField(BooleanCombo, "type", "booleancombo");
BooleanCombo.initClass();
BooleanCombo._$name = "BooleanCombo";

// ../Core/lib/Core/widget/ButtonGroup.js
var _ButtonGroup = class _ButtonGroup extends Container.mixin(Rotatable_default) {
  onChildAdd(item) {
    super.onChildAdd(item);
    item.ion({
      click: "resetValueCache",
      toggle: "onItemToggle",
      thisObj: this,
      // This needs to run before the 'click' event is relayed by this button group, in such listener
      // the `value` must already be updated
      prio: 1e4
    });
  }
  onChildRemove(item) {
    item.un({
      toggle: "resetValueCache",
      click: "resetValueCache",
      thisObj: this
    });
    super.onChildRemove(item);
  }
  onItemToggle(event) {
    const me = this;
    me.resetValueCache();
    if (!me.isSettingValue && (!me.toggleGroup || event.pressed)) {
      me.triggerFieldChange({ value: me.value, userAction: true, event });
    }
  }
  resetValueCache() {
    this._value = null;
  }
  createWidget(widget) {
    const me = this, type = me.constructor.resolveType(widget.type || "button");
    if (type.isButton) {
      if (me.color && !widget.color) {
        widget.color = me.color;
      }
      if (me.toggleGroup && !widget.toggleGroup) {
        if (typeof me.toggleGroup === "boolean") {
          me.toggleGroup = _ButtonGroup.generateId("toggleGroup");
        }
        widget.toggleGroup = me.toggleGroup;
      }
    }
    if (me.columns) {
      widget.width = `${100 / me.columns}%`;
    }
    widget = super.createWidget(widget);
    me.relayEvents(widget, ["click", "action", "toggle"]);
    return widget;
  }
  updateRotate(rotate) {
    this.eachWidget((btn) => {
      if (btn.rotate !== false) {
        btn.rotate = rotate;
      }
    });
  }
  get value() {
    if (!this._value) {
      const values = [];
      this.items.forEach((w) => {
        if (w.pressed && w.value !== void 0) {
          values.push(w.value);
        }
      });
      this._value = values.join(this.valueSeparator);
    }
    return this._value;
  }
  set value(value) {
    const me = this, oldValue = me.value;
    if (!Array.isArray(value)) {
      if (value === void 0 || value === null) {
        value = [];
      } else if (typeof value == "string") {
        value = value.split(me.valueSeparator);
      } else {
        value = [value];
      }
    }
    me._value = value.join(me.valueSeparator);
    me.isSettingValue = true;
    me.items.forEach((w) => {
      if (w.value !== void 0) {
        w.pressed = value.includes(w.value);
      }
    });
    me.isSettingValue = false;
    if (!me.isConfiguring && oldValue !== me.value) {
      me.triggerFieldChange({ value: me.value, userAction: false });
    }
  }
  updateDisabled(disabled) {
    this.items.forEach((button) => button.disabled = disabled || !button.ignoreParentReadOnly && this.readOnly);
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(readOnly);
    this.updateDisabled(this.disabled);
  }
  get widgetClassList() {
    const classList = super.widgetClassList;
    this.columns && classList.push("b-columned");
    return classList;
  }
};
/**
 * Fires when a button in the group is clicked
 * @event click
 * @param {Core.widget.Button} source Clicked button
 * @param {Event} event DOM event
 */
/**
 * Fires when the default action is performed on a button in the group (the button is clicked)
 * @event action
 * @param {Core.widget.Button} source Clicked button
 * @param {Event} event DOM event
 */
/**
 * Fires when a button in the group is toggled (the {@link Core.widget.Button#property-pressed} state is changed).
 * If you need to process the pressed button only, consider using {@link #event-click} event or {@link #event-action} event.
 * @event toggle
 * @param {Core.widget.Button} source Toggled button
 * @param {Boolean} pressed New pressed state
 * @param {Event} event DOM event
 */
__publicField(_ButtonGroup, "$name", "ButtonGroup");
__publicField(_ButtonGroup, "type", "buttongroup");
__publicField(_ButtonGroup, "configurable", {
  defaultType: "button",
  /**
   * Custom CSS class to add to element. When using raised buttons (cls 'b-raised' on the buttons), the group
   * will look nicer if you also set that cls on the group.
   *
   * ```
   * new ButtonGroup({
   *   cls : 'b-raised,
   *   items : [
   *       { icon : 'b-fa b-fa-unicorn', cls : 'b-raised' },
   *       ...
   *   ]
   * });
   * ```
   *
   * @config {String}
   * @category CSS
   */
  cls: null,
  /**
   * An array of Buttons or typed Button config objects.
   * @config {ButtonConfig[]|Core.widget.Button[]}
   */
  items: null,
  /**
   * Default color to apply to all contained buttons, see {@link Core.widget.Button#config-color Button#color}.
   * Individual buttons can override the default.
   * @config {String}
   */
  color: null,
  /**
   * Set to `true` to turn the ButtonGroup into a toggle group, assigning a generated value to each contained
   * buttons {@link Core.widget.Button#config-toggleGroup toggleGroup config}. Individual buttons can
   * override the default.
   * @config {Boolean}
   */
  toggleGroup: null,
  valueSeparator: ",",
  columns: null,
  hideWhenEmpty: true,
  defaultBindProperty: "value"
});
var ButtonGroup = _ButtonGroup;
ButtonGroup.initClass();
ButtonGroup._$name = "ButtonGroup";

// ../Core/lib/Core/widget/CalendarPanel.js
var weekendDays = { 0: 1, 6: 1 };
var CalendarPanel = class extends Panel {
  static get configurable() {
    return {
      layout: "vbox",
      textContent: false,
      /**
       * Gets or sets the date that orientates the panel to display a particular month.
       * Changing this causes the content to be refreshed.
       * @member {Date} date
       */
      /**
       * The date which this CalendarPanel encapsulates.
       * @config {Date|String}
       */
      date: {
        $config: {
          equal: "date"
        },
        value: null
      },
      /**
       * A {@link Core.util.Month} Month utility object which encapsulates this Panel's month
       * and provides contextual information and navigation services.
       * @config {Core.util.Month|MonthConfig}
       */
      month: {},
      year: null,
      /**
       * The week start day, 0 meaning Sunday, 6 meaning Saturday.
       * Defaults to {@link Core.helper.DateHelper#property-weekStartDay-static}.
       * @config {Number}
       */
      weekStartDay: null,
      /**
       * Configure as `true` to always show a six week calendar.
       * @config {Boolean}
       * @default
       */
      sixWeeks: true,
      /**
       * Configure as `true` to show a week number column at the start of the calendar block.
       * @deprecated Since 4.0.0. Use {@link #config-showWeekColumn} instead.
       * @config {Boolean}
       */
      showWeekNumber: null,
      /**
       * Configure as `true` to show a week number column at the start of the calendar block.
       * @config {Boolean}
       */
      showWeekColumn: null,
      /**
       * Either an array of `Date` objects which are to be disabled, or
       * a function (or the name of a function), which, when passed a `Date` returns `true` if the
       * date is disabled.
       * @config {Function|Date[]|String}
       * @param {Date} date Date to check
       * @returns {Boolean} Returns `true` if the provided date is disabled
       */
      disabledDates: null,
      /**
       * A function (or the name of a function) which creates content in, and may mutate a day header element.
       *
       * @config {Function|String}
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cell The header element
       * @param {Number} renderData.day The day number conforming to the specified {@link #config-weekStartDay}. Will be in the range `0` to `6`
       * @param {Number} renderData.weekDay The canonical day number where Monday is 0 and Sunday is
       * @returns {String|DomConfig|null}
       */
      headerRenderer: null,
      /**
       * A function (or the name of a function) which creates content in, and may mutate the week cell element at the start of a week row.
       *
       * @config {Function|String}
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cell The header element
       * @param {Number[]} renderData.week An array containing `[year, weekNumber]`
       * @returns {String|DomConfig|null}
       */
      weekRenderer: null,
      /**
       * A function (or the name of a function) which creates content in, and may mutate a day cell element.
       *
       * @config {Function|String}
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cell The header element
       * @param {Date} renderData.date The date for the cell
       * @param {Number} renderData.day The day for the cell (`0` to `6` for Sunday to Saturday)
       * @param {Number[]} renderData.rowIndex The row index, 0 to month row count (6 if {@link #config-sixWeeks} is `true`)
       * @param {HTMLElement} renderData.row The row element encapsulating the week which the cell is a part of
       * @param {Number[]} renderData.cellIndex The cell index in the whole panel. May be from `0` to up to `42`
       * @param {Number[]} renderData.columnIndex The column index, `0` to `6`
       * @param {Number[]} renderData.visibleColumnIndex The visible column index taking hidden non working days into account
       * @returns {String|DomConfig|null}
       */
      cellRenderer: null,
      /**
       * Configure as `true` to render Saturdays and Sundays as {@link #config-disabledDates}.
       * @config {Boolean}
       */
      disableWeekends: null,
      /**
       * Configure as `true` to render non working days as {@link #config-disabledDates}.
       *
       * Note, that by default, non working days are read from the locale, and are normally
       * Saturday and Sunday. But they can be set to other days than weekend days.
       * @config {Boolean}
       */
      disableNonWorkingDays: null,
      hideNonWorkingDays: null,
      hideNonWorkingDaysCls: "b-hide-nonworking-days",
      /**
       * Non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
       * Defaults to {@link Core.helper.DateHelper#property-nonWorkingDays-static}.
       * @config {Object<Number,Boolean>}
       */
      nonWorkingDays: null,
      /**
       * A config object to create a tooltip which will show on hover of a date cell including disabled, weekend,
       * and "other month" cells.
       *
       * It is the developer's responsibility to hook the `beforeshow` event to either veto the show by returning
       * `false` or provide contextual content for the date.
       *
       * The tip instance will be primed with a `date` property.
       * @config {TooltipConfig}
       */
      tip: null,
      dayCellCls: "b-calendar-cell",
      dayHeaderCls: "b-calendar-day-header",
      /**
       * The class name to add to disabled calendar cells.
       * @config {String}
       */
      disabledCls: "b-disabled-date",
      /**
       * The class name to add to calendar cells which are in the previous or next month.
       * @config {String}
       */
      otherMonthCls: "b-other-month",
      /**
       * The class name to add to calendar cells which are weekend dates.
       * @config {String}
       */
      weekendCls: "b-weekend",
      /**
       * The class name to add to the calendar cell which contains today's date.
       * @config {String}
       */
      todayCls: "b-today",
      /**
       * The class name to add to calendar cells which are {@link #config-nonWorkingDays}.
       * @config {String}
       */
      nonWorkingDayCls: "b-nonworking-day",
      /**
       * The {@link Core.helper.DateHelper} format string to format the day names
       * in the header row above the calendar cells.
       * @config {String}
       * @default
       */
      dayNameFormat: "ddd",
      /**
       * By default, week rows flex to share available Panel height equally.
       *
       * Set this config if the available height is too small, and the cell height needs
       * to be larger to show events.
       *
       * Setting this config causes the month grid to become scrollable in the `Y` axis.
       *
       * May be specified as a number in which case it will be taken to mean pixels,
       * or a length in standard CSS units.
       * @config {Number|String}
       */
      minRowHeight: {
        $config: ["lazy"],
        value: null
      },
      /**
       * By default, day cells flex to share available Panel width equally.
       *
       * Set this config if the available width is too small, and the cell width needs
       * to be larger to show events.
       *
       * Setting this config causes the month grid to become scrollable in the `X` axis.
       * @config {Number}
       */
      minColumnWidth: {
        $config: ["lazy"],
        value: null
      },
      /**
       * Configure this as true to disable pointer interaction with cells which are outside the
       * range of the current month.
       * @config {Boolean}
       */
      disableOtherMonthCells: null,
      disableOtherMonthCellsCls: "b-disable-othermonth-cells",
      /**
       * Configure this as `true` to hide cells which are outside the range of the current month.
       * @config {Boolean}
       */
      hideOtherMonthCells: null,
      hideOtherMonthCellsCls: "b-hide-othermonth-cells",
      /**
       * By default, when navigating through time, the next time
       * block will be animated in from the appropriate direction.
       *
       * Configure this as `false` to disable this.
       * @prp {Boolean} animateTimeShift
       * @default
       */
      animateTimeShift: true
    };
  }
  construct(config) {
    super.construct(config);
    if (!this.refreshCount) {
      this.refresh();
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a4;
    (_a4 = super.onInternalPaint) == null ? void 0 : _a4.call(this, ...arguments);
    if (firstPaint) {
      if (!this.refreshCount) {
        this.refresh();
      }
      this.getConfig("minColumnWidth");
      this.getConfig("minRowHeight");
    }
  }
  get overflowElement() {
    return this.weeksElement;
  }
  doDestroy() {
    var _a4;
    (_a4 = this.tip) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  updateMinRowHeight(minRowHeight) {
    this.element.style.setProperty("--min-row-height", DomHelper.setLength(minRowHeight));
    this.scrollable = {
      overflowY: minRowHeight ? "auto" : false
    };
  }
  updateMinColumnWidth(minColumnWidth) {
    const me = this;
    me.element.style.setProperty("--min-column-width", DomHelper.setLength(minColumnWidth));
    me.scrollable = {
      overflowX: minColumnWidth ? "auto" : false
    };
    me.overflowElement.classList[minColumnWidth ? "add" : "remove"]("b-min-columnwidth");
  }
  getDateFromDomEvent(domEvent) {
    const element = (domEvent.nodeType === Element.ELEMENT_NODE ? domEvent : domEvent.target).closest(`#${this.id} [data-date]`);
    if (element) {
      return DateHelper.parseKey(element.dataset.date);
    }
  }
  changeTip(tip, existingTip) {
    const me = this;
    return Tooltip.reconfigure(existingTip, tip, {
      owner: me,
      defaults: {
        type: "tooltip",
        owner: me,
        id: `${me.id}-cell-tip`,
        forElement: me.bodyElement,
        forSelector: `.${me.dayCellCls}`
      }
    });
  }
  updateTip(tip) {
    this.detachListeners("tip");
    tip == null ? void 0 : tip.ion({
      pointerOver: "onTipOverCell",
      name: "tip",
      thisObj: this
    });
  }
  updateElement(element, was) {
    const me = this;
    super.updateElement(element, was);
    me.updateHideNonWorkingDays(me.hideNonWorkingDays);
    me.weekdayCells = Array.from(element.querySelectorAll(".b-calendar-day-header"));
    me.weekElements = Array.from(element.querySelectorAll(".b-calendar-week"));
    me.weekDayElements = Array.from(element.querySelectorAll(".b-calendar-days"));
    me.cellElements = [];
    for (let i = 0, { length } = me.weekDayElements; i < length; i++) {
      me.cellElements.push(me.weekDayElements[i].previousSibling, ...me.weekDayElements[i].children);
    }
  }
  changeDate(date) {
    date = typeof date === "string" ? DateHelper.parse(date) : new Date(date);
    if (isNaN(date)) {
      throw new Error("CalendarPanel date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clearTime(date);
  }
  /**
   * The date which this CalendarPanel encapsulates. Setting this causes the
   * content to be refreshed.
   * @property {Date}
   */
  updateDate(value) {
    this.month.date = value;
  }
  updateDayNameFormat() {
    const d = /* @__PURE__ */ new Date("2000-06-04T12:00:00");
    this.shortDayNames = [];
    for (let date = 4; date < 11; date++) {
      d.setDate(date);
      this.shortDayNames.push(DateHelper.format(d, this.dayNameFormat));
    }
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  /**
   * Set to 0 for Sunday (the default), 1 for Monday etc.
   *
   * Set to `null` to use the default value from {@link Core/helper/DateHelper}.
   */
  updateWeekStartDay(weekStartDay) {
    const me = this;
    if (me._month) {
      me.month.weekStartDay = weekStartDay;
      me.dayNames = [];
      for (let i = 0; i < 7; i++) {
        me.dayNames[i] = me.shortDayNames[me.canonicalDayNumbers[i]];
      }
      if (me.refreshCount) {
        me.refresh();
      }
    }
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    var _a4;
    this.contentElement.classList.toggle(this.hideNonWorkingDaysCls, Boolean(hideNonWorkingDays));
    (_a4 = this.scrollable) == null ? void 0 : _a4.syncOverflowState();
    if (this._month) {
      this.month.hideNonWorkingDays = hideNonWorkingDays;
    }
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateHideOtherMonthCells(hideOtherMonthCells) {
    var _a4;
    this.element.classList.toggle(this.hideOtherMonthCellsCls, Boolean(hideOtherMonthCells));
    (_a4 = this.scrollable) == null ? void 0 : _a4.syncOverflowState();
  }
  updateDisableOtherMonthCells(disableOtherMonthCells) {
    var _a4;
    this.element.classList.toggle(this.disableOtherMonthCellsCls, Boolean(disableOtherMonthCells));
    (_a4 = this.scrollable) == null ? void 0 : _a4.syncOverflowState();
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || (this._localeNonWorkingDays || (this._localeNonWorkingDays = DateHelper.nonWorkingDays));
  }
  get weekends() {
    return this._localeWeekends || (this._localeWeekends = DateHelper.weekends);
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays(nonWorkingDays) {
    var _a4;
    if (this._month) {
      this.month.nonWorkingDays = nonWorkingDays;
      this.refresh();
      (_a4 = this.scrollable) == null ? void 0 : _a4.syncOverflowState();
    }
  }
  get visibleDayColumnIndex() {
    return this.month.visibleDayColumnIndex;
  }
  get dayColumnIndex() {
    return this.month.dayColumnIndex;
  }
  get canonicalDayNumbers() {
    return this.month.canonicalDayNumbers;
  }
  get visibleColumnCount() {
    return this.month.visibleColumnCount;
  }
  get weekLength() {
    return this.month.weekLength;
  }
  /**
   * The date of the first day cell in this panel.
   * Note that this may *not* be the first of this panel's current month.
   * @property {Date}
   * @readonly
   */
  get startDate() {
    return this.month.startDate;
  }
  get duration() {
    return DateHelper.diff(this.month.startDate, this.month.endDate, "day") + 1;
  }
  /**
   * The end date of this view. Note that in terms of full days, this is exclusive,
   * ie: 2020-01-012 to 2020-01-08 is *seven* days. The end is 00:00:00 on the 8th.
   *
   * Note that this may *not* be the last date of this panel's current month.
   * @property {Date}
   * @readonly
   */
  get endDate() {
    const { endDate } = this.month;
    if (endDate) {
      return DateHelper.add(endDate, 1, "day");
    }
  }
  changeMonth(month2, currentMonth) {
    const me = this;
    if (!(month2 instanceof Month)) {
      if (typeof month2 === "number") {
        if (currentMonth) {
          currentMonth.month = month2;
          return;
        }
        const date = me.date || DateHelper.clearTime(/* @__PURE__ */ new Date());
        date.setMonth(month2);
        month2 = {
          date
        };
      }
      month2 = Month.new({
        weekStartDay: me.weekStartDay,
        nonWorkingDays: me.nonWorkingDays,
        hideNonWorkingDays: me.hideNonWorkingDays,
        sixWeeks: me.sixWeeks
      }, month2);
    }
    month2.ion({
      dateChange: "onMonthDateChange",
      thisObj: me
    });
    return month2;
  }
  onMonthDateChange({ source: month2, newDate, oldDate, changes }) {
    const me = this;
    me.year = month2.year;
    if (!me.isConfiguring) {
      if (!me.getCell(newDate) || (changes.m || changes.y)) {
        const { isVisible: isVisible2 } = me;
        me.refresh();
        if (me.animateTimeShift && isVisible2) {
          DomHelper.slideIn(me.contentElement, newDate > oldDate ? 1 : -1);
        }
      }
      me.trigger("dateChange", {
        changes,
        value: newDate,
        oldValue: oldDate
      });
    }
  }
  updateYear(year) {
    this.month.year = year;
  }
  updateShowWeekNumber(showWeekNumber) {
    this.updateShowWeekColumn(showWeekNumber);
  }
  updateShowWeekColumn(showWeekColumn) {
    const me = this;
    me.element.classList[showWeekColumn ? "add" : "remove"]("b-show-week-column");
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
  }
  updateSixWeeks(sixWeeks) {
    if (this.month) {
      this.month.sixWeeks = sixWeeks;
      this.refresh();
    }
  }
  /**
   * Refreshes the UI after changing a config that would affect the UI.
   */
  refresh() {
    this.doRefresh();
  }
  /**
   * Implementation of the UI refresh.
   * @private
   */
  doRefresh() {
    var _a4;
    this.getConfig("element");
    const me = this, timeZone = me.timeZone != null ? me.timeZone : (_a4 = me.project) == null ? void 0 : _a4.timeZone, today = timeZone != null ? TimeZoneHelper.toTimeZone(/* @__PURE__ */ new Date(), timeZone) : /* @__PURE__ */ new Date(), {
      weekElements,
      weekDayElements,
      date,
      month: month2,
      dayCellCls,
      dayHeaderCls,
      disabledCls,
      otherMonthCls,
      weekendCls,
      todayCls,
      nonWorkingDayCls,
      nonWorkingDays,
      canonicalDayNumbers,
      sixWeeks
    } = me;
    today.setHours(0, 0, 0, 0);
    if (!date) {
      me.date = today;
      return;
    }
    me.element.style.setProperty("--visible-week-count", month2.weekCount);
    me.trigger("beforeRefresh");
    me.getConfig("dayNameFormat");
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const cell = me.weekdayCells[columnIndex], cellDay = me.canonicalDayNumbers[columnIndex], cellClassList = {
        [dayHeaderCls]: 1,
        [weekendCls]: weekendDays[cellDay],
        [nonWorkingDayCls]: nonWorkingDays[cellDay]
      };
      if (me.headerRenderer) {
        cell.innerHTML = "";
        me.callback(me.headerRenderer, me, [cell, columnIndex, cellDay]);
      } else {
        DomHelper.setInnerText(cell, me.shortDayNames[cellDay]);
      }
      DomHelper.syncClassList(cell, cellClassList);
      cell.dataset.columnIndex = columnIndex;
      cell.dataset.cellDay = cellDay;
    }
    let rowIndex = 0, cellIndex = 0, lastWorkingColumn = 6;
    for (let columnIndex = 6; columnIndex >= 0; columnIndex--) {
      if (!nonWorkingDays[canonicalDayNumbers[columnIndex]]) {
        lastWorkingColumn = columnIndex;
        break;
      }
    }
    weekElements[4].classList.toggle("b-hide-display", month2.weekCount < 5 && !sixWeeks);
    weekElements[5].classList.toggle("b-hide-display", month2.weekCount < 6 && !sixWeeks);
    month2.eachWeek((week, dates) => {
      const weekDayElement = weekDayElements[rowIndex], weekCells = [weekDayElement.previousSibling, ...weekDayElement.children];
      weekElements[rowIndex].dataset.week = `${week[0]},${week[1]}`;
      if (me.weekRenderer) {
        me.callback(me.weekRenderer, me, [weekCells[0], week]);
      } else {
        weekCells[0].innerText = week[1];
      }
      for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
        const date2 = dates[columnIndex], day2 = date2.getDay(), key = DateHelper.makeKey(date2), isNonWorking = nonWorkingDays[day2], cell = weekCells[columnIndex + 1], cellClassList = {
          [dayCellCls]: 1,
          [disabledCls]: me.isDisabledDate(date2),
          [otherMonthCls]: date2.getMonth() !== month2.month,
          [weekendCls]: weekendDays[day2],
          [todayCls]: date2.getTime() === today.getTime(),
          [nonWorkingDayCls]: isNonWorking,
          "b-last-working-day": columnIndex === lastWorkingColumn,
          "b-first-visible-cell": !(date2 - (me.firstVisibleDate || -1)),
          "b-last-visible-cell": !(date2 - (me.lastVisibleDate || -1)),
          [`b-day-of-week-${day2}`]: 1
        };
        DomHelper.syncClassList(cell, cellClassList);
        cell.dataset.date = key;
        cell.dataset.cellIndex = cellIndex;
        cell.dataset.columnIndex = columnIndex;
        if (cell.lastDomConfig) {
          delete cell.lastDomConfig.class;
          delete cell.lastDomConfig.className;
        }
        if (me.cellRenderer) {
          me.callback(me.cellRenderer, me, [{
            cell,
            date: date2,
            day: day2,
            row: weekElements[rowIndex],
            rowIndex,
            cellIndex,
            columnIndex,
            visibleColumnIndex: me.visibleDayColumnIndex[day2],
            week,
            key
          }]);
        } else {
          cell.innerHTML = date2.getDate();
        }
        cellIndex++;
      }
      rowIndex++;
    });
    me.visibleWeekCount = rowIndex;
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.trigger("refresh");
  }
  isDisabledDate(date) {
    const me = this, day2 = date.getDay(), {
      disabledDates
    } = me;
    if (me.disableWeekends && weekendDays[day2]) {
      return true;
    }
    if (me.disableNonWorkingDays && me.nonWorkingDays[day2]) {
      return true;
    }
    if (disabledDates) {
      if (Array.isArray(disabledDates)) {
        date = DateHelper.clearTime(date, true);
        return disabledDates.some((d) => !(DateHelper.clearTime(d, true) - date));
      } else {
        return me.callback(disabledDates, me, [date]);
      }
    }
  }
  get bodyConfig() {
    const result = super.bodyConfig, weeksContainerChildren = [];
    result.children = [{
      tag: "div",
      className: "b-calendar-row b-calendar-weekdays",
      reference: "weekdaysHeader",
      children: [
        { class: "b-week-number-cell" },
        ...ArrayHelper.fill(7, { class: this.dayHeaderCls }),
        DomHelper.scrollBarPadElement
      ]
    }, {
      // `notranslate` prevents google translate messing up the DOM, https://github.com/facebook/react/issues/11538
      className: "b-weeks-container notranslate",
      reference: "weeksElement",
      children: weeksContainerChildren
    }];
    for (let i = 0; i < 6; i++) {
      const weekRow = {
        className: "b-calendar-row b-calendar-week",
        dataset: {
          rowIndex: i
        },
        children: [{
          className: "b-week-number-cell"
        }, {
          className: "b-calendar-days",
          children: [{}, {}, {}, {}, {}, {}, {}],
          syncOptions: {
            ignoreRefs: true,
            strict: false
            // allow complete replacement of classes w/o matching lastDomConfig
          }
        }]
      };
      weeksContainerChildren.push(weekRow);
    }
    return result;
  }
  get firstVisibleDate() {
    if (this.hideOtherMonthCells) {
      const { year, month: month2 } = this.month;
      return new Date(year, month2, 1);
    }
    for (const me = this, date = me.month.startDate; ; date.setDate(date.getDate() + 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date.getDay()]) {
        return date;
      }
    }
  }
  get lastVisibleDate() {
    const lastDate = DateHelper.add(this.endDate, -1, "d");
    if (this.hideOtherMonthCells) {
      return lastDate;
    }
    for (const me = this, date = lastDate; ; date.setDate(date.getDate() - 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date.getDay()]) {
        return date;
      }
    }
  }
  /**
   * Returns the cell associated with the passed date.
   *
   * To exclude dates which are outside of the panel's current month, pass the `strict` parameter as `true`
   * @param {Date|String} date The date to find the element for or a key in the format `YYYY-MM-DD`
   * @param {Boolean} strict Only return the element if this view *owns* the date.
   * @returns {HTMLElement} The cell for the passed date if it exists
   */
  getCell(date, strict) {
    if (!(typeof date === "string")) {
      date = DateHelper.makeKey(date);
    }
    const cell = this.weeksElement.querySelector(`[data-date="${date}"]`);
    if (cell && (!strict || !cell.classList.contains(this.otherMonthCls))) {
      return cell;
    }
  }
  onTipOverCell({ source: tip, target }) {
    tip.date = DateHelper.parseKey(target.dataset.date);
  }
  updateLocalization() {
    this._localeNonWorkingDays = this._localeWeekends = null;
    this.updateDayNameFormat();
    this.updateWeekStartDay(this.weekStartDay);
    super.updateLocalization();
  }
};
__publicField(CalendarPanel, "$name", "CalendarPanel");
__publicField(CalendarPanel, "type", "calendarpanel");
CalendarPanel.initClass();
CalendarPanel._$name = "CalendarPanel";

// ../Core/lib/Core/widget/Checkbox.js
var whenNotChecked = (field) => !field.value;
var Checkbox = class extends Field {
  static get configurable() {
    return {
      inputType: "checkbox",
      /**
       * Specify `true` to automatically {@link Core.widget.FieldContainer#config-collapsed collapse} the field's
       * {@link #config-container} when the field is not {@link #property-checked}.
       *
       * Alternatively, this can be a function that returns the desired `collapse` state when passed the field
       * instance as its one parameter.
       *
       * @config {Boolean|Function}
       * @returns {Boolean}
       * @default false
       */
      autoCollapse: null,
      containerDefaults: {
        syncableConfigs: {
          disabled: (field) => field.disabled || !field.value
        },
        syncConfigTriggers: {
          autoCollapse: 1,
          value: 1
        }
      },
      /**
       * Get/set label
       * @member {String} name
       */
      /**
       * Text to display on checkbox label
       * @config {String}
       */
      text: "",
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is
       * {@link #property-checked}.
       * A value of `undefined` will cause this widget not to include its value when checked.
       * @config {*}
       * @default
       */
      checkedValue: true,
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is not
       * {@link #property-checked}.
       *
       * A value of `undefined` will cause this widget to not include its value when it is unchecked.
       * @config {*}
       * @default
       */
      uncheckedValue: false,
      /**
       * The checked state. The same as `value`.
       * @config {Boolean} checked
       */
      /**
       * Checkbox color, must have match in CSS
       * @config {String}
       */
      color: null,
      /**
       * Get/set value
       * @member {String} value
       */
      /**
       * Sets input fields value attribute
       * @config {String}
       */
      value: "",
      toggleGroup: null,
      localizableProperties: ["label", "text"]
    };
  }
  //endregion
  //region Init
  construct(config) {
    if ("checked" in config) {
      config = ObjectHelper.assign({}, config);
      config.value = config.checked;
      delete config.checked;
    }
    super.construct(config);
    this.syncHasText();
  }
  get textLabelCls() {
    return "b-checkbox-label";
  }
  // Implementation needed at this level because it has two inner elements in its inputWrap
  get innerElements() {
    return [
      this.inputElement,
      {
        tag: "label",
        class: this.textLabelCls,
        for: `${this.id}-input`,
        reference: "textLabel",
        html: this.text || ""
      }
    ];
  }
  get inputElement() {
    const config = super.inputElement;
    if (this.toggleGroup) {
      config.dataset = {
        group: this.toggleGroup
      };
    }
    config.listeners = {
      click: "internalOnClick",
      change: "internalOnChange",
      input: "internalOnInput"
    };
    return config;
  }
  //endregion
  //region Toggle
  /**
   * Get/set checked state. Equivalent to `value` config.
   * @property {Boolean}
   */
  get checked() {
    return this.value;
  }
  set checked(value) {
    this.value = value;
  }
  syncHasText() {
    this.element.classList[this.text ? "add" : "remove"]("b-text");
  }
  updateText(value) {
    if (this.textLabel) {
      this.syncHasText();
      this.textLabel.innerHTML = value;
    }
  }
  afterSyncChildConfigs(container) {
    super.afterSyncChildConfigs(container);
    let { autoCollapse } = this;
    if (autoCollapse) {
      autoCollapse = autoCollapse === true ? whenNotChecked : autoCollapse;
      container.collapsed = autoCollapse(this);
    }
  }
  assignFieldValue(values, key, value) {
    this.value = value === this.checkedValue || (value === this.uncheckedValue ? false : null);
  }
  fetchInputValue() {
    if (!this.readOnly) {
      this.value = this.input.checked;
    }
  }
  gatherValue(values) {
    var _a4;
    const me = this, value = me.value ? me.checkedValue : me.uncheckedValue, storedValue = value !== void 0, { valueName } = me;
    if (storedValue) {
      values[valueName] = value;
    }
    me.gatherValues(values, storedValue);
    if (value === true && ((_a4 = values[valueName]) == null ? void 0 : _a4.value) === value) {
      delete values[valueName].value;
    }
  }
  changeValue(value) {
    return value === "false" ? false : Boolean(value);
  }
  updateValue(value) {
    var _a4;
    const me = this, changed = me.input.checked !== value;
    me.input.checked = value;
    (_a4 = me.container) == null ? void 0 : _a4.syncChildConfigs();
    if (changed && !me.inputting && !me.isConfiguring) {
      me.uncheckToggleGroupMembers();
      me.triggerChange(false, null);
    }
  }
  get inputValueAttr() {
    return "checked";
  }
  updateColor(value, was) {
    const classes = this.element.classList;
    if (was) {
      classes.remove(was);
    }
    if (value) {
      classes.add(value);
    }
  }
  getToggleGroupMembers() {
    const me = this, { checked, toggleGroup, input: checkedElement, type } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `input[type=${type}][data-group=${toggleGroup}]`, (inputEl) => {
        if (inputEl !== checkedElement) {
          const partnerCheckbox = Widget.fromElement(inputEl);
          partnerCheckbox && result.push(partnerCheckbox);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  /**
   * Check the box
   */
  check() {
    this.checked = true;
  }
  /**
   * Uncheck the box
   */
  uncheck() {
    this.checked = false;
  }
  /**
   * Toggle checked state. If you want to force a certain state, assign to {@link #property-checked} instead.
   */
  toggle() {
    this.checked = !this.checked;
  }
  //endregion
  //region Events
  internalOnClick(event) {
    if (this.readOnly) {
      event.preventDefault();
      return false;
    }
    return this.trigger("click", { event });
  }
  /**
   * Triggers events when user toggles the checkbox
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  internalOnChange(event) {
    const me = this;
    if (me.readOnly && me.value !== me.input.checked) {
      me.input.checked = me.value;
      return;
    }
    me.value = me.input.checked;
    if (!me.inputting) {
      me.inputting = true;
      me.triggerChange(true, event);
      me.inputting = false;
    }
  }
  // Need to catch changes even if readOnly, because of chrome behaviour when re-enabling
  updateInputReadOnly(readOnly) {
  }
  /**
   * Triggers events when checked state is changed
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  triggerChange(userAction, event) {
    const me = this, { checked } = me.input;
    const eventObject = { checked, value: checked, oldValue: !checked, userAction, valid: true, event }, prevented = !checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter((widget) => widget.isVisible && !widget.disabled).length || // Since Widget has Events mixed in configured with 'callOnFunctions' this will also call onBeforeChange,
    // onChange and onAction
    me.trigger("beforeChange", eventObject) === false;
    if (prevented) {
      me.input.checked = me._value = !checked;
    } else {
      me.triggerFieldChange(eventObject, false);
      if (userAction) {
        me.uncheckToggleGroupMembers();
      }
      me.trigger("action", eventObject);
      me.trigger("change", eventObject);
      return true;
    }
  }
  //endregion
};
//region Config
__publicField(Checkbox, "$name", "Checkbox");
__publicField(Checkbox, "type", "checkbox");
__publicField(Checkbox, "alias", "check");
Checkbox.initClass();
Checkbox._$name = "Checkbox";

// ../Core/lib/Core/widget/ColorPicker.js
var ColorPicker = class extends List {
  configure(config) {
    super.configure(config);
    this.setItems();
    this.ion({
      item: "onColorSelect"
    });
  }
  setItems() {
    const me = this, { colors, colorClasses } = me;
    let useColors = colorClasses || colors;
    if (me.addNoColorItem) {
      useColors = [...useColors];
      useColors.push(null);
    }
    me.items = useColors.map((color) => !color || typeof color == "string" ? { color, text: (colorClasses ? StringHelper.capitalize(color) : color) || me.L("L{noColor}") } : color);
  }
  afterConfigure() {
    var _a4;
    super.afterConfigure(...arguments);
    if (this.addNoColorItem || this.value) {
      this.select((_a4 = this.value) != null ? _a4 : null);
    }
  }
  updateColors() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  updateAddNoColorItem() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  onColorSelect({ record }) {
    var _a4;
    this.refresh();
    const event = { color: record.color, record, bubbles: true };
    (_a4 = this.colorSelected) == null ? void 0 : _a4.call(this, event);
    this.trigger("colorSelected", event);
  }
  select(value) {
    if (!value || typeof value === "string") {
      value = this.store.findRecord("color", value != null ? value : null);
    }
    value && super.select(value);
  }
  updateColumns(columns) {
    this.style = `grid-template-columns:repeat(${columns}, 1fr);`;
  }
  getColorClassName(color) {
    var _a4, _b;
    if (((_a4 = this.colorClasses) == null ? void 0 : _a4.includes(color)) || ((_b = this.colorClasses) == null ? void 0 : _b.find((r) => r && r.color === color))) {
      return this.colorClassPrefix + color;
    }
    return color ? "" : "b-no-color";
  }
};
__publicField(ColorPicker, "$name", "ColorPicker");
__publicField(ColorPicker, "type", "colorpicker");
__publicField(ColorPicker, "configurable", {
  itemsFocusable: false,
  navigator: {
    focusCls: "b-color-active"
  },
  itemWrapperTpl(record, i) {
    const { selected } = this, { color, text } = record, colorClassName = this.getColorClassName(color);
    return TemplateHelper.tpl`
                    <li
                        class="${this.getItemClasses(record, i)} ${colorClassName}"
                        role="option"
                        aria-selected="${selected.includes(record)}"
                        data-index="${i}"
                        data-id="${StringHelper.encodeHtml(color)}"
                        data-btip="${text}"
                        ${this.itemsFocusable ? 'tabindex="-1"' : ""}
                        style="${colorClassName ? "" : "background-color: " + color}"
                    ></li>`;
  },
  /**
   * Array of internal color class names, without prefix, like `red`, `violet` etc. If specified, this will
   * take precedence over {@link #config-colors}.
   * @config {String[]}
   * @private
   */
  colorClasses: null,
  /**
   * Prefix to be inserted before the color class names in {@link #config-colorClasses}, like `b-sch-`
   * @config {String}
   * @private
   */
  colorClassPrefix: null,
  /**
   * Array of CSS color strings from which the user can chose from.
   *
   * Provide an array of string CSS colors:
   * ```javascript
   * new ColorMenu({
   *     colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']
   * });
   * ```
   *
   * The colors can also be named. To do that, put them in an object with a `color` and a `text` property, like:
   * ```javascript
   * new ColorMenu({
   *    colors : [
   *        { color : '#000000', text : 'Black'},
   *        { color : '#FF0000', text : 'Red'},
   *        { color : '#00FF00', text : 'Green'},
   *        { color : '#0000FF', text : 'Blue'},
   *        { color : '#FFFFFF', text : 'White'},
   *    ]
   * });
   * ```
   *
   * Default colors are:
   * <div class="b-colorbox b-inline" style="background-color: #45171D"></div>#45171D
   * <div class="b-colorbox b-inline" style="background-color: #F03861"></div>#F03861
   * <div class="b-colorbox b-inline" style="background-color: #FF847C"></div>#FF847C
   * <div class="b-colorbox b-inline" style="background-color: #FECEA8"></div>#FECEA8
   * <div class="b-colorbox b-inline" style="background-color: #A5F2E7"></div>#A5F2E7
   * <div class="b-colorbox b-inline" style="background-color: #AA83F3"></div>#AA83F3
   * <div class="b-colorbox b-inline" style="background-color: #8983F3"></div>#8983F3
   * <div class="b-colorbox b-inline" style="background-color: #A10054"></div>#A10054
   * <div class="b-colorbox b-inline" style="background-color: #073059"></div>#073059
   * <div class="b-colorbox b-inline" style="background-color: #2866AB"></div>#2866AB
   * <div class="b-colorbox b-inline" style="background-color: #5FBDC5"></div>#5FBDC5
   * <div class="b-colorbox b-inline" style="background-color: #D8D95C"></div>#D8D95C
   * <div class="b-colorbox b-inline" style="background-color: #FFDEDE"></div>#FFDEDE
   * <div class="b-colorbox b-inline" style="background-color: #F7F3CE"></div>#F7F3CE
   * <div class="b-colorbox b-inline" style="background-color: #C5ECBE"></div>#C5ECBE
   * <div class="b-colorbox b-inline" style="background-color: #3E3E3E"></div>#3E3E3E
   * <div class="b-colorbox b-inline" style="background-color: #405559"></div>#405559
   * <div class="b-colorbox b-inline" style="background-color: #68868C"></div>#68868C
   * <div class="b-colorbox b-inline" style="background-color: #EDEDED"></div>#EDEDED
   * <div class="b-colorbox b-inline" style="background-color: #D3D6DB"></div>#D3D6DB
   * <div class="b-colorbox b-inline" style="background-color: #3A4750"></div>#3A4750
   * <div class="b-colorbox b-inline" style="background-color: #303841"></div>#303841
   * <div class="b-colorbox b-inline" style="background-color: #BE3144"></div>#BE3144
   * @prp {String[]}
   */
  colors: [
    "#45171D",
    "#F03861",
    "#FF847C",
    "#FECEA8",
    "#A5F2E7",
    "#AA83F3",
    "#8983F3",
    "#A10054",
    "#073059",
    "#2866AB",
    "#5FBDC5",
    "#D8D95C",
    "#FFDEDE",
    "#F7F3CE",
    "#C5ECBE",
    "#3E3E3E",
    "#405559",
    "#68868C",
    "#EDEDED",
    "#D3D6DB",
    "#3A4750",
    "#303841",
    "#BE3144"
  ],
  /**
   * Adds an option to set no background color
   * @prp {Boolean}
   */
  addNoColorItem: true,
  /**
   * The color items is displayed in a grid layout with 6 columns as default. Change this to another number to
   * affect appearance.
   * @prp {Number}
   */
  columns: 6,
  /**
   * A callback function that will be called when the user selects a color in the picker.
   * @param {Object} event Object containing event data
   * @param {Core.data.Model} event.record The selected color's record instance
   * @param {String} event.color The string color value
   * @config {Function}
   * @returns {void}
   */
  colorSelected: null
});
ColorPicker.initClass();
ColorPicker._$name = "ColorPicker";

// ../Core/lib/Core/widget/ColorField.js
var ColorField = class extends Combo {
  configure(config) {
    var _a4;
    const pickerCfg = (_a4 = config.picker) != null ? _a4 : {};
    if (config.colors) {
      pickerCfg.colors = config.colors;
    }
    if ("addNoColorItem" in config) {
      pickerCfg.addNoColorItem = config.addNoColorItem;
    }
    config.picker = pickerCfg;
    super.configure(config);
  }
  updatePicker(picker) {
    if (picker) {
      this.items = picker.store.records;
    }
  }
  updateColors(colors) {
    if (!this.isConfiguring) {
      this.picker.colors = colors;
    }
  }
  updateAddNoColorItem(addNoColorItem) {
    if (!this.isConfiguring) {
      this.picker.addNoColorItem = addNoColorItem;
    }
  }
  set value(value) {
    if (!this.store) {
      this.items = [];
      this.store = this.picker.store;
    }
    if (!value) {
      value = this.store.findRecord("color", null);
    }
    super.value = value;
  }
  showPicker() {
    this.picker.refresh();
    super.showPicker(...arguments);
  }
  get value() {
    return super.value;
  }
  syncInputFieldValue(...args) {
    var _a4;
    const me = this, { value } = me;
    let className = (_a4 = me.picker) == null ? void 0 : _a4.getColorClassName(value);
    if (!className) {
      me.colorBox.style.color = value;
    }
    className = "b-colorbox " + className;
    me.colorBox.className = className;
    if (!me.showBoxForNoColor) {
      me.element.classList.toggle("b-colorless", !value);
    }
    super.syncInputFieldValue(...args);
  }
  get innerElements() {
    return [
      {
        reference: "colorBox",
        className: "b-colorbox"
      },
      ...super.innerElements
    ];
  }
};
__publicField(ColorField, "$name", "ColorField");
__publicField(ColorField, "type", "colorfield");
__publicField(ColorField, "configurable", {
  /**
   * @hideconfigs text,color,editable,picker
   */
  displayField: "text",
  valueField: "color",
  editable: false,
  picker: {
    type: "colorpicker",
    align: {
      align: "t100-b100",
      matchSize: false
    }
  },
  showBoxForNoColor: true,
  /**
   * Array of CSS color strings to be able to chose from. This will override the
   * {@link Core.widget.ColorPicker#config-colors pickers default colors}.
   *
   * Provide an array of string CSS colors:
   * ```javascript
   * new ColorField({
   *     colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']
   * });
   * ```
   *
   * @prp {String[]}
   */
  colors: null,
  /**
   * Adds an option in the picker to set no background color
   * @prp {Boolean}
   */
  addNoColorItem: true
});
ColorField.initClass();
ColorField._$name = "ColorField";

// ../Core/lib/Core/widget/YearPicker.js
var YearPicker = class extends Panel {
  construct(config) {
    super.construct({
      year: (/* @__PURE__ */ new Date()).getFullYear(),
      ...config
    });
    EventHelper.on({
      element: this.contentElement,
      click: "onYearClick",
      delegate: ".b-yearpicker-year",
      thisObj: this
    });
  }
  get focusElement() {
    return this.getYearButton(this.year) || this.getYearButton(this.startYear);
  }
  getYearButton(y) {
    return this.contentElement.querySelector(`.b-yearpicker-year[data-year="${y}"]`);
  }
  /**
   * The currently selected year.
   * @member {Number} value
   */
  get value() {
    return this.year;
  }
  set value(year) {
    this.year = year;
  }
  onYearClick({ target }) {
    const clickedYear = Math.min(Math.max(parseInt(target.innerText), this.minYear || 1), this.maxYear || 9999);
    if (this.year === clickedYear) {
      this.trigger("select", { oldValue: clickedYear, value: clickedYear });
    } else {
      this.year = clickedYear;
    }
  }
  handleTitleClick(e) {
    this.trigger("titleClick", e);
  }
  previous() {
    this.startYear = this.startYear - this.yearButtonCount;
  }
  next() {
    this.startYear = this.endYear + 1;
  }
  ingestYear(year) {
    if (!isNaN(year)) {
      return ObjectHelper.isDate(year) ? year.getFullYear() : year;
    }
  }
  changeYear(year) {
    if (year = this.ingestYear(year)) {
      return Math.min(Math.max(year, this.minYear || 1), this.maxYear || 9999);
    }
  }
  updateYear(year, oldValue) {
    const me = this;
    if (!me.startYear || year > me.endYear) {
      me.startYear = year;
    } else if (year < me.startYear) {
      me.startYear = year - (me.yearButtonCount - 1);
    }
    if (!me.isConfiguring) {
      me.trigger("select", { oldValue, value: year });
    }
  }
  /**
   * The ending year displayed in the widget.
   * @member {Number} endYear
   * @readonly
   */
  get endYear() {
    return this.startYear + this.yearButtonCount - 1;
  }
  changeStartYear(startYear) {
    if (startYear = this.ingestYear(startYear)) {
      startYear = this.minYear ? Math.max(startYear, this.minYear) : startYear;
      return this.maxYear ? Math.min(startYear, this.maxYear - (this.yearButtonCount - 1)) : startYear;
    }
  }
  async updateStartYear(startYear, oldStartYear) {
    if (this.isVisible) {
      DomHelper.slideIn(this.contentElement, Math.sign(startYear - oldStartYear));
    }
  }
  composeBody() {
    this.getConfig("year");
    const { startYear } = this, result = super.composeBody(), children = result.children[this.tbar ? 1 : 0].children = [];
    this.widgetMap.title.text = `${`000${startYear}`.slice(-4)} - ${`000${this.endYear}`.slice(-4)}`;
    for (let i = 0, y = startYear; i < this.yearButtonCount; i++, y++) {
      children.push({
        tag: "button",
        dataset: {
          year: y
        },
        class: {
          "b-yearpicker-year": 1,
          "b-selected": y === this.year
        },
        text: `000${y}`.slice(-4)
      });
    }
    return result;
  }
};
__publicField(YearPicker, "$name", "YearPicker");
__publicField(YearPicker, "type", "yearpicker");
__publicField(YearPicker, "configurable", {
  textContent: false,
  /**
   * The definition of the top toolbar which displays the title and "previous" and
   * "next" buttons.
   *
   * This contains the following predefined `items` which may be reconfigured by
   * application code:
   *
   * - `title` A widget which displays the visible year range. Weight 100.
   * - `previous` A button which navigates to the previous block. Weight 200.
   * - `next` A button which navigates to the next block. Weight 300.
   *
   * These may be reordered:
   *
   * ```javascript
   * new YearPicker({
   *     appendTo : targetElement,
   *     tbar     : {
   *         items : {
   *             // Move title to centre
   *             title : {
   *                 weight : 250
   *             }
   *         }
   *     },
   *     width    : '24em'
   * });
   * ```
   * @config {ToolbarConfig}
   */
  tbar: {
    overflow: null,
    items: {
      previous: {
        type: "tool",
        cls: "b-icon b-icon-previous",
        onAction: "up.previous",
        weight: 100
      },
      title: {
        type: "button",
        cls: "b-yearpicker-title",
        weight: 200,
        onAction: "up.handleTitleClick"
      },
      next: {
        type: "tool",
        cls: "b-icon b-icon-next",
        onAction: "up.next",
        weight: 300
      }
    }
  },
  itemCls: "b-year-container",
  /**
   * The number of clickable year buttons to display in the widget.
   *
   * It may be useful to change this if a non-standard shape or size is used.
   * @config {Number}
   * @default
   */
  yearButtonCount: 12,
  /**
   * The currently selected year.
   * @member {Number} year
   */
  /**
   * The year to use as the selected year. Defaults to the current year.
   * @config {Number}
   */
  year: null,
  /**
   * The lowest year to allow.
   * @config {Number}
   */
  minYear: null,
  /**
   * The highest year to allow.
   * @config {Number}
   */
  maxYear: null,
  /**
   * The starting year displayed in the widget.
   * @member {Number} startYear
   */
  /**
   * The year to show at the start of the widget
   * @config {Number}
   */
  startYear: null
});
YearPicker.initClass();
YearPicker._$name = "YearPicker";

// ../Core/lib/Core/widget/DisplayField.js
var DisplayField = class extends TextField {
  static get configurable() {
    return {
      readOnly: true,
      editable: false,
      cls: "b-display-field",
      /**
       * A template string used to render the value of this field. Please note you are responsible for encoding
       * any strings protecting against XSS.
       *
       * ```javascript
       * new DisplayField({
       *     appendTo : document.body,
       *     name     : 'age',
       *     label    : 'Age',
       *     template : data => `${data.value} years old`
       * })
       * ```
       * @config {Function}
       * @param {ContainerItemConfig} fieldConfig Configuration object for the field
       * @returns {DomConfig|String|null}
       */
      template: null,
      ariaElement: "displayElement"
    };
  }
  get focusElement() {
  }
  changeReadOnly() {
    return true;
  }
  changeEditable() {
    return false;
  }
  get inputElement() {
    return {
      tag: "span",
      id: `${this.id}-input`,
      reference: "displayElement",
      html: this.template ? this.template(this.value) : StringHelper.encodeHtml(this.value)
    };
  }
};
__publicField(DisplayField, "$name", "DisplayField");
__publicField(DisplayField, "type", "displayfield");
__publicField(DisplayField, "alias", "display");
DisplayField.initClass();
DisplayField._$name = "DisplayField";

// ../Core/lib/Core/widget/DatePicker.js
var generateMonthNames = () => DateHelper.getMonthNames().map((m, i) => [i, m]);
var dateSort = (lhs, rhs) => lhs.valueOf() - rhs.valueOf();
var emptyArray10 = Object.freeze([]);
var ReadOnlyCombo = class extends Combo {
  static get $name() {
    return "ReadOnlyCombo";
  }
  static get type() {
    return "readonlycombo";
  }
  static get configurable() {
    return {
      editable: false,
      inputAttributes: {
        tag: "div",
        tabIndex: -1
      },
      inputValueAttr: "innerHTML",
      highlightExternalChange: false,
      monitorResize: false,
      triggers: {
        expand: false
      },
      picker: {
        align: {
          align: "t-b",
          axisLock: true,
          matchSize: false
        },
        cls: "b-readonly-combo-list",
        scrollable: {
          overflowX: false
        }
      }
    };
  }
};
ReadOnlyCombo.initClass();
var DatePicker = class extends CalendarPanel {
  static get delayable() {
    return {
      refresh: "raf"
    };
  }
  static get configurable() {
    return {
      /**
       * The date that the user has navigated to using the UI *prior* to setting the widget's
       * value by selecting. The initial default is today's date.
       *
       * This may be changed using keyboard navigation. The {@link Core.widget.CalendarPanel#property-date} is set
       * by pressing `ENTER` when the desired date is reached.
       *
       * Programmatically setting the {@link Core.widget.CalendarPanel#config-date}, or using the UI to select the date
       * by clicking it also sets the `activeDate`
       * @config {Date}
       */
      activeDate: {
        value: /* @__PURE__ */ new Date(),
        $config: {
          equal: "date"
        }
      },
      focusable: true,
      textContent: false,
      tbar: {
        overflow: null,
        items: {
          prevYear: {
            cls: "b-icon b-icon-first",
            onAction: "up.gotoPrevYear",
            tooltip: "L{DatePicker.gotoPrevYear}"
          },
          prevMonth: {
            cls: "b-icon b-icon-previous",
            onAction: "up.gotoPrevMonth",
            tooltip: "L{DatePicker.gotoPrevMonth}"
          },
          fields: {
            type: "container",
            cls: "b-datepicker-title",
            items: {
              monthField: {
                type: "readonlycombo",
                cls: "b-datepicker-monthfield",
                items: generateMonthNames(),
                internalListeners: {
                  select: "up.onMonthPicked"
                }
              },
              yearButton: {
                type: "button",
                cls: "b-datepicker-yearbutton",
                internalListeners: {
                  click: "up.onYearPickerRequested"
                }
              }
            }
          },
          nextMonth: {
            cls: "b-icon b-icon-next",
            onAction: "up.gotoNextMonth",
            tooltip: "L{DatePicker.gotoNextMonth}"
          },
          nextYear: {
            cls: "b-icon b-icon-last",
            onAction: "up.gotoNextYear",
            tooltip: "L{DatePicker.gotoNextYear}"
          }
        }
      },
      yearPicker: {
        value: {
          type: "YearPicker",
          yearButtonCount: 16,
          trapFocus: true,
          positioned: true,
          hidden: true,
          internalListeners: {
            titleClick: "up.onYearPickerTitleClick",
            select: "up.onYearPicked"
          }
        },
        $config: "lazy"
      },
      /**
       * The initially selected date.
       * @config {Date}
       */
      date: null,
      /**
       * The minimum selectable date. Selection of and navigation to dates prior
       * to this date will not be possible.
       * @config {Date}
       */
      minDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      /**
       * The maximum selectable date. Selection of and navigation to dates after
       * this date will not be possible.
       * @config {Date}
       */
      maxDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      /**
       * By default, disabled dates cannot be navigated to, and they are skipped over
       * during keyboard navigation. Configure this as `true` to enable navigation to
       * disabled dates.
       * @config {Boolean}
       * @default
       */
      focusDisabledDates: null,
      /**
       * Configure as `true` to enable selecting multiple discontiguous date ranges using
       * click and Shift+click to create ranges and Ctrl+click to select/deselect individual dates.
       *
       * Configure as `'range'` to enable selecting a single date range by selecting a
       * start and end date. Hold "SHIFT" button to select date range. Ctrl+click may add
       * or remove dates to/from either end of the range.
       * @config {Boolean|'range'}
       * @default
       */
      multiSelect: false,
      /**
       * If {@link #config-multiSelect} is configured as `true`, this is an array of dates
       * which are selected. There may be multiple, discontiguous date ranges.
       *
       * If {@link #config-multiSelect} is configured as `'range'`, this is a two element array
       * specifying the first and last selected dates in a range.
       * @config {Date[]}
       */
      selection: {
        $config: {
          equal: (v1, v2) => v1 && v1.equals(v2)
        },
        value: null
      },
      /**
       * By default, the month and year are editable. Configure this as `false` to prevent that.
       * @config {Boolean}
       * @default
       */
      editMonth: true,
      /**
       * The {@link Core.helper.DateHelper} format string to format the day names.
       * @config {String}
       * @default
       */
      dayNameFormat: "dd",
      trapFocus: true,
      role: "grid",
      focusDescendant: true,
      /**
       * By default, when the {@link #property-date} changes, the UI will only refresh
       * if it doesn't contain a cell for that date, so as to keep a stable UI when
       * navigating.
       *
       * Configure this as `true` to refresh the UI whenever the month changes, even if
       * the UI already shows that date.
       * @config {Boolean}
       * @internal
       */
      alwaysRefreshOnMonthChange: null,
      /**
       * Configure as `true` to add a highlighted border and background to the week row which
       * encapsulates the selected date.
       * @prp {Boolean}
       * @default false
       */
      highlightSelectedWeek: null
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * The class name to add to the calendar cell whose date which is outside of the
       * {@link #config-minDate}/{@link #config-maxDate} range.
       * @config {String}
       * @private
       */
      outOfRangeCls: "b-out-of-range",
      /**
       * The class name to add to the currently focused calendar cell.
       * @config {String}
       * @private
       */
      activeCls: "b-active-date",
      /**
       * The class name to add to selected calendar cells.
       * @config {String}
       * @private
       */
      selectedCls: "b-selected-date"
    };
  }
  // region Init
  construct(config) {
    const me = this;
    super.construct(config);
    me.externalCellRenderer = me.cellRenderer;
    me.cellRenderer = me.internalCellRenderer;
    me.element.setAttribute("aria-activedescendant", `${me.id}-active-day`);
    me.weeksElement.setAttribute("role", "grid");
    me.weekElements.forEach((w) => w.setAttribute("role", "row"));
    me.element.setAttribute("ariaLabelledBy", me.widgetMap.fields.id);
    EventHelper.on({
      element: me.weeksElement,
      click: {
        handler: "onCellClick",
        delegate: `.${me.dayCellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`
      },
      mousedown: {
        handler: "onCellMousedown",
        delegate: `.${me.dayCellCls}`
      },
      thisObj: me
    });
    me.widgetMap.monthField.readOnly = me.widgetMap.yearButton.disabled = !me.editMonth;
    me.refresh.flush();
  }
  afterHide() {
    var _a4;
    (_a4 = this._yearPicker) == null ? void 0 : _a4.hide();
    super.afterHide(...arguments);
  }
  doDestroy() {
    var _a4, _b;
    (_a4 = this.yearButton) == null ? void 0 : _a4.destroy();
    (_b = this.monthField) == null ? void 0 : _b.destroy();
    super.doDestroy();
  }
  // endregion
  get focusElement() {
    return this.weeksElement.querySelector(`.${this.dayCellCls}[tabIndex="0"]`);
  }
  doRefresh() {
    const me = this, { date } = me, oldActiveCell = me.focusElement, activeDate = DateHelper.betweenLesser(me.activeDate, me.month.startDate, me.month.endDate) ? me.activeDate : me._activeDate = date;
    me.getConfig("tbar");
    super.doRefresh(...arguments);
    me.widgetMap.monthField.value = date.getMonth();
    me.widgetMap.yearButton.text = date.getFullYear();
    const dateOfOldActiveCell = DateHelper.parseKey(oldActiveCell == null ? void 0 : oldActiveCell.dataset.date);
    if (activeDate - dateOfOldActiveCell) {
      me.syncActiveDate(activeDate, dateOfOldActiveCell);
    }
  }
  internalCellRenderer({ cell, date }) {
    const me = this, {
      activeCls,
      selectedCls,
      externalCellRenderer
    } = me, isSelected = me.isSelectedDate(date), cellClassList = {
      [activeCls]: activeCls && me.isActiveDate(date),
      [selectedCls]: isSelected,
      [me.outOfRangeCls]: me.minDate && date < me.minDate || me.maxDate && date > me.maxDate
    };
    if (isSelected) {
      if (me.multiSelect) {
        const isStart = !me.isSelectedDate(DateHelper.add(date, -1, "d")), isEnd = !me.isSelectedDate(DateHelper.add(date, 1, "d"));
        cellClassList["b-range-start"] = isStart;
        cellClassList["b-range-end"] = isEnd;
        cellClassList["b-in-range"] = !isStart && !isEnd;
      }
    }
    DomHelper.updateClassList(cell, cellClassList);
    cell.innerHTML = `<div class="b-datepicker-cell-inner">${date.getDate()}</div>`;
    cell.setAttribute("role", "gridcell");
    cell.setAttribute("aria-label", DateHelper.format(date, "MMMM D, YYYY"));
    if (me.isActiveDate(date)) {
      cell.id = `${me.id}-active-day`;
    } else {
      cell.removeAttribute("id");
    }
    if (externalCellRenderer) {
      arguments[0].cell = cell.firstChild;
      me.callback(externalCellRenderer, this, arguments);
    }
  }
  onCellMousedown(event) {
    const cell = event.target.closest("[data-date]");
    cell.focus();
    if (DomHelper.getActiveElement(cell) === cell) {
      event.preventDefault();
    }
    this.activeDate = DateHelper.parseKey(cell.dataset.date);
  }
  onCellClick(event) {
    const cell = event.target.closest("[data-date]");
    this.onUIDateSelect(DateHelper.parseKey(cell.dataset.date), event);
  }
  /**
   * Called when the user uses the UI to select the current activeDate. So ENTER when focused
   * or clicking a date cell.
   * @param {Date} date The active date to select
   * @param {Event} event the instigating event, either a `click` event or a `keydown` event.
   * @internal
   */
  onUIDateSelect(date, event) {
    const me = this, {
      lastClickedDate,
      multiSelect
    } = me;
    me.lastClickedDate = date;
    if (!me.isDisabledDate(date)) {
      me.activatingEvent = event;
      if (multiSelect) {
        me.handleMultiSelect(lastClickedDate, date, event);
      } else {
        me.selection = me.month.date = date;
        if (me.floating) {
          me.hide();
        }
      }
      me.activatingEvent = null;
    }
  }
  // Calls updateSelection if the selection is mutated
  handleMultiSelect(lastClickedDate, date, event) {
    const me = this, {
      multiSelect
    } = me, _selection = me._selection || (me._selection = new DateSet()), selection = _selection.dates, singleRange = multiSelect === "range", {
      size,
      generation
    } = _selection, rangeEnds = size && {
      [DateHelper.makeKey(DateHelper.add(selection[0], -1, "d"))]: 1,
      [DateHelper.makeKey(selection[0])]: 1,
      [DateHelper.makeKey(selection[selection.length - 1])]: 1,
      [DateHelper.makeKey(DateHelper.add(selection[selection.length - 1], 1, "d"))]: 1
    }, isSelected = _selection.has(date), toggleFn = isSelected ? "delete" : "add";
    const clickedRangeEnd = singleRange && (rangeEnds == null ? void 0 : rangeEnds[DateHelper.makeKey(date)]);
    if (event.ctrlKey) {
      if (multiSelect === true || !size || clickedRangeEnd) {
        _selection[toggleFn](date);
        if (singleRange && !_selection.has(me.rangeStartDate)) {
          me.rangeStartDate.setDate(me.rangeStartDate.getDate() + (date < selection[1] ? 1 : -1));
        }
      }
    } else if (event.shiftKey && size) {
      const [start, end] = [
        new Date(singleRange ? me.rangeStartDate || (me.rangeStartDate = selection[0]) : lastClickedDate),
        date
      ].sort(dateSort);
      if (singleRange) {
        _selection.clear();
      }
      for (const d = start; d <= end; d.setDate(d.getDate() + 1)) {
        _selection.add(d);
      }
    } else if (!(_selection.has(date) && _selection.size === 1)) {
      _selection.clear();
      _selection.add(date);
    }
    const newSize = _selection.size;
    if (newSize === 1) {
      me.rangeStartDate = date;
    } else if (!newSize) {
      me.rangeStartDate = null;
    }
    if (_selection.generation !== generation) {
      me.updateSelection(_selection);
    }
  }
  changeSelection(selection) {
    const me = this;
    let result, rangeStartDate;
    if (selection) {
      if (!selection.forEach) {
        selection = [selection];
      }
      selection.forEach((d, i) => selection[i] = me.changeDate(d));
      rangeStartDate = selection[0];
      selection.sort(dateSort);
      if (me.multiSelect === "range" && selection.length === 2) {
        result = new DateSet();
        for (const d = new Date(selection[0]); d <= selection[1]; d.setDate(d.getDate() + 1)) {
          result.add(d);
        }
      } else {
        rangeStartDate = selection[0];
        result = new DateSet(selection);
      }
    } else {
      result = new DateSet();
    }
    if (rangeStartDate) {
      me.activeDate = me.rangeStartDate = DateHelper.clearTime(rangeStartDate);
    }
    return result;
  }
  updateHighlightSelectedWeek(highlightSelectedWeek) {
    this.element.classList.toggle("b-highlight-selected-week", Boolean(highlightSelectedWeek));
  }
  updateMultiSelect(multiSelect) {
    this.element.classList.toggle("b-multiselect", Boolean(multiSelect));
    if (!multiSelect) {
      this.selection = [...this.selection][0];
    }
  }
  updateSelection(dateSet) {
    const me = this, { dates } = dateSet, selection = me.multiSelect === "range" ? [dates[0], dates[dates.length - 1]] : dates;
    dates.length && (me.date = dates[0]);
    if (!me.isConfiguring) {
      me.refresh.now();
      me.trigger("selectionChange", {
        selection,
        userAction: Boolean(me.activatingEvent)
      });
    }
  }
  /**
   * The selected Date(s).
   *
   * When {@link #config-multiSelect} is `'range'`, then this yields a two element array
   * representing the start and end of the selected range.
   *
   * When {@link #config-multiSelect} is `true`, this yields an array containing every selected
   * Date.
   * @member {Date[]} selection
   */
  get selection() {
    const { _selection } = this, dates = _selection ? _selection.dates : emptyArray10;
    return this.multiSelect === "range" && dates.length ? [dates[0], dates[dates.length - 1]] : dates;
  }
  onInternalKeyDown(keyEvent) {
    const me = this, keyName = keyEvent.key.trim() || keyEvent.code, activeDate = me.activeDate;
    let newDate = new Date(activeDate);
    if (keyName === "Escape" && me.floating) {
      return me.hide();
    }
    if (activeDate && me.weeksElement.contains(keyEvent.target)) {
      do {
        switch (keyName) {
          case "ArrowLeft":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoPrevMonth();
            } else {
              newDate.setDate(newDate.getDate() - 1);
            }
            break;
          case "ArrowUp":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() - 7);
            break;
          case "ArrowRight":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoNextMonth();
            } else {
              newDate.setDate(newDate.getDate() + 1);
            }
            break;
          case "ArrowDown":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() + 7);
            break;
          case "Enter":
            return me.onUIDateSelect(activeDate, keyEvent);
        }
      } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);
      if (me.minDate && newDate < me.minDate) {
        return;
      }
      if (me.maxDate && newDate > me.maxDate) {
        return;
      }
      me.activeDate = newDate;
    }
  }
  changeMinDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMinDate(minDate) {
    this._yearpicker && (this._yearpicker.minYear = minDate == null ? void 0 : minDate.getFullYear());
    this.refresh();
  }
  changeMaxDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMaxDate(maxDate) {
    this._yearpicker && (this._yearpicker.maxYear = maxDate == null ? void 0 : maxDate.getFullYear());
    this.refresh();
  }
  changeDate(date) {
    return DateHelper.clamp(super.changeDate(date), this.minDate, this.maxDate);
  }
  updateDate(date, oldDate) {
    const me = this, { month: month2 } = me;
    me.isConfiguring && !me.initializingActiveDate && (me.selection = date);
    if (!month2.date || date.getMonth() === month2.month || !me.getCell(date) || me.alwaysRefreshOnMonthChange || me.isNavigating) {
      super.updateDate(date);
    } else {
      const newMonth = month2.getOtherMonth(date), changes = me.eventListeners && (oldDate ? date.getDate() !== oldDate.getDate() | (newMonth.getWeekId(date) !== month2.getWeekId(oldDate)) << 1 | (date.getMonth() !== (oldDate == null ? void 0 : oldDate.getMonth())) << 2 | (date.getFullYear() !== (oldDate == null ? void 0 : oldDate.getFullYear())) << 3 : 15);
      me.trigger("dateChange", {
        changes: {
          d: true,
          w: Boolean(changes & 2),
          m: Boolean(changes & 12),
          y: Boolean(changes & 8),
          r: newMonth.weekCount !== month2.weekCount
        },
        value: date,
        oldValue: oldDate
      });
    }
  }
  changeActiveDate(activeDate, oldActiveDate) {
    if (this.trigger("beforeActiveDateChange", { activeDate, oldActiveDate }) === false) {
      return;
    }
    activeDate = activeDate ? this.changeDate(activeDate) : this.date || (this.date = DateHelper.clearTime(/* @__PURE__ */ new Date()));
    if (isNaN(activeDate)) {
      throw new Error("DatePicker date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clamp(activeDate, this.minDate, this.maxDate);
  }
  updateActiveDate(activeDate, wasActiveDate) {
    const me = this, { isConfiguring } = me;
    if (isConfiguring || !me.getCell(activeDate)) {
      me.initializingActiveDate = isConfiguring;
      me.date = activeDate;
      me.initializingActiveDate = false;
    }
    if (!isConfiguring && !me.refresh.isPending) {
      me.syncActiveDate(activeDate, wasActiveDate);
    }
  }
  syncActiveDate(activeDate, wasActiveDate) {
    const me = this, { activeCls } = me, activeCell = me.getCell(activeDate), wasActiveCell = wasActiveDate && me.getCell(wasActiveDate), activeElement = DomHelper.getActiveElement(me.element);
    activeCell.setAttribute("tabIndex", 0);
    activeCls && activeCell.classList.add(activeCls);
    activeCell.id = `${me.id}-active-day`;
    if (me.weeksElement.contains(activeElement)) {
      activeCell.focus();
    }
    if (wasActiveCell && wasActiveCell !== activeCell) {
      wasActiveCell.removeAttribute("tabIndex");
      activeCls && wasActiveCell.classList.remove(activeCls);
      wasActiveCell.removeAttribute("id");
    }
  }
  set value(value) {
    const me = this, {
      selection,
      duration
    } = me;
    me.isNavigating = true;
    if (value) {
      value = me.changeDate(value, me.value);
      if (me.multiSelect === "range" && (selection == null ? void 0 : selection.length) === 2) {
        if (!DateHelper.betweenLesserEqual(value, ...selection)) {
          if (value < selection[0]) {
            me.selection = [value, DateHelper.add(value, duration - 1, "d")];
          } else {
            me.selection = [DateHelper.add(value, -(duration - 1), "d"), value];
          }
        }
        me.date = me.activeDate = value;
        return;
      }
      if (value !== void 0) {
        me.selection = value;
      }
    } else {
      me.date = /* @__PURE__ */ new Date();
      me.selection = null;
    }
    me.isNavigating = false;
  }
  get value() {
    return this.selection[this.selection.length - 1];
  }
  get duration() {
    return this.multiSelect === "range" ? DateHelper.diff(...this.selection, "d") + 1 : 1;
  }
  gotoPrevYear() {
    return this.goto(-1, "year");
  }
  gotoPrevMonth() {
    return this.goto(-1, "month");
  }
  gotoNextMonth() {
    return this.goto(1, "month");
  }
  gotoNextYear() {
    return this.goto(1, "year");
  }
  goto(direction, unit) {
    const me = this, { activeDate } = me, activeCell = activeDate && me.getCell(activeDate);
    let newDate;
    if (unit === "month" && activeCell && (activeDate == null ? void 0 : activeDate.getMonth()) === me.month.month + direction) {
      newDate = activeDate;
    } else {
      newDate = DateHelper.add(activeCell ? activeDate : me.date, direction, unit);
    }
    const firstDateOfNewMonth = new Date(newDate);
    firstDateOfNewMonth.setDate(1);
    const lastDateOfNewMonth = DateHelper.add(DateHelper.add(firstDateOfNewMonth, 1, "month"), -1, "day");
    if (me.minDate && direction < 0 && lastDateOfNewMonth < me.minDate || me.maxDate && direction > 0 && firstDateOfNewMonth > me.maxDate) {
      return;
    }
    me.isNavigating = true;
    const result = me.date = newDate;
    if (activeCell) {
      me.activeDate = newDate;
    }
    me.isNavigating = false;
    return result;
  }
  isActiveDate(date) {
    return !(date - this.activeDate);
  }
  isSelectedDate(date) {
    var _a4;
    return (_a4 = this._selection) == null ? void 0 : _a4.has(date);
  }
  onMonthPicked({ record, userAction }) {
    var _a4;
    if (userAction) {
      this.activeDate = DateHelper.add(this.activeDate, record.value - this.activeDate.getMonth(), "month");
      (_a4 = this.focusElement) == null ? void 0 : _a4.focus();
    }
  }
  onYearPickerRequested() {
    const { yearPicker } = this;
    if (yearPicker.isVisible) {
      yearPicker.hide();
    } else {
      yearPicker.year = yearPicker.startYear = this.activeDate.getFullYear();
      yearPicker.show();
      yearPicker.focus();
    }
  }
  onYearPickerTitleClick() {
    this.yearPicker.hide();
  }
  onYearPicked({ value, source }) {
    var _a4;
    const newDate = new Date(this.activeDate);
    newDate.setFullYear(value);
    this.activeDate = newDate;
    (_a4 = this.focusElement) == null ? void 0 : _a4.focus({ preventScroll: true });
    source.hide();
  }
  changeYearPicker(yearPicker, oldYearPicker) {
    var _a4, _b;
    return YearPicker.reconfigure(oldYearPicker, yearPicker ? YearPicker.mergeConfigs({
      owner: this,
      appendTo: this.element,
      minYear: (_a4 = this.minDate) == null ? void 0 : _a4.getFullYear(),
      maxYear: (_b = this.maxDate) == null ? void 0 : _b.getFullYear()
    }, yearPicker) : null, this);
  }
  get childItems() {
    const { _yearPicker } = this, result = super.childItems;
    if (_yearPicker) {
      result.push(_yearPicker);
    }
    return result;
  }
  updateLocalization() {
    var _a4;
    const {
      monthField
    } = this.widgetMap, newData = generateMonthNames();
    if (!this.isConfiguring && !newData.every((d, i) => d[1] === monthField.store.getAt(i).text)) {
      newData[(_a4 = monthField.value) != null ? _a4 : this.date.getMonth()].selected = true;
      monthField.items = newData;
    }
    super.updateLocalization();
  }
};
__publicField(DatePicker, "$name", "DatePicker");
__publicField(DatePicker, "type", "datepicker");
var DateSet = class _DateSet extends Set {
  add(d) {
    d = DateHelper.makeKey(d);
    if (!this.has(d)) {
      this.generation = (this.generation || 0) + 1;
    }
    return super.add(d);
  }
  delete(d) {
    d = DateHelper.makeKey(d);
    if (this.has(d)) {
      this.generation++;
    }
    return super.delete(d);
  }
  has(d) {
    return super.has(DateHelper.makeKey(d));
  }
  clear() {
    if (this.size) {
      this.generation++;
    }
    return super.clear();
  }
  equals(other) {
    Array.isArray(other) && (other = new _DateSet(other));
    return other.size === this.size && [...this].every((s) => other.has(s));
  }
  get dates() {
    return [...this].sort().map((k) => DateHelper.parseKey(k));
  }
};
DatePicker.initClass();
DatePicker._$name = "DatePicker";

// ../Core/lib/Core/widget/DateField.js
var DateField = class extends PickerField {
  static get configurable() {
    return {
      /**
       * Get / set format for date displayed in field (see {@link Core.helper.DateHelper#function-format-static}
       * for formatting options).
       * @member {String} format
       */
      /**
       * Format for date displayed in field. Defaults to using long date format, as defined by current locale (`L`)
       * @config {String}
       * @default
       */
      format: "L",
      /**
       * A flag which indicates whether the date parsing should be strict - meaning if the date
       * is missing a year/month/day part - parsing fails.
       *
       * Turned off by default, meaning default values are substituted for missing parts.
       *
       * @config {Boolean}
       * @default
       */
      strictParsing: false,
      // same for all languages
      fallbackFormat: "YYYY-MM-DD",
      timeFormat: "HH:mm:ss:SSS",
      /**
       * A flag which indicates what time should be used for selected date.
       * `false` by default which means time is reset to midnight.
       *
       * Possible options are:
       * - `false` to reset time to midnight
       * - `true` to keep original time value
       * - `'17:00'` a string which is parsed automatically
       * - `new Date(2020, 0, 1, 17)` a date object to copy time from
       * - `'entered'` to keep time value entered by user (in case {@link #config-format} includes time info)
       *
       * @config {Boolean|Date|String}
       * @default
       */
      keepTime: false,
      /**
       * Format for date in the {@link #config-picker}. Uses localized format per default
       * @config {String}
       */
      pickerFormat: null,
      /**
       * Set to true to first clear time of the field's value before comparing it to the max value
       * @internal
       * @config {Boolean}
       */
      validateDateOnly: null,
      triggers: {
        expand: {
          cls: "b-icon-calendar",
          handler: "onTriggerClick",
          weight: 200
        },
        back: {
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick",
          align: "start",
          weight: 100
        },
        forward: {
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick",
          align: "end",
          weight: 100
        }
      },
      // An optional extra CSS class to add to the picker container element
      calendarContainerCls: "",
      /**
       * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} min
       * @accepts {String|Date}
       */
      /**
       * Min value
       * @config {String|Date}
       */
      min: null,
      /**
       * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} max
       * @accepts {String|Date}
       */
      /**
       * Max value
       * @config {String|Date}
       */
      max: null,
      /**
       * The `step` property may be set in object form specifying two properties, `magnitude`, a Number, and
       * `unit`, a String.
       *
       * If a Number is passed, the step's current unit is used (or `day` if no current step set) and just the
       * magnitude is changed.
       *
       * If a String is passed, it is parsed by {@link Core.helper.DateHelper#function-parseDuration-static}, for
       * example `'1d'`, `'1 d'`, `'1 day'`, or `'1 day'`.
       *
       * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
       * @member {DurationConfig} step
       * @accepts {String|Number|DurationConfig}
       */
      /**
       * Time increment duration value. If specified, `forward` and `back` triggers are displayed.
       * The value is taken to be a string consisting of the numeric magnitude and the units.
       * The units may be a recognised unit abbreviation of this locale or the full local unit name.
       * For example `'1d'` or `'1w'` or `'1 week'`. This may be specified as an object containing
       * two properties: `magnitude`, a Number, and `unit`, a String
       * @config {String|Number|DurationConfig}
       */
      step: false,
      stepTriggers: null,
      /**
       * The week start day in the {@link #config-picker}, 0 meaning Sunday, 6 meaning Saturday.
       * Uses localized value per default.
       * @config {Number}
       */
      weekStartDay: null,
      /**
       * A config object used to configure the {@link Core.widget.DatePicker datePicker}.
       * ```javascript
       * dateField = new DateField({
       *      picker    : {
       *          multiSelect : true
       *      }
       *  });
       * ```
       * @config {DatePickerConfig}
       */
      picker: {
        type: "datepicker",
        role: "dialog",
        floating: true,
        scrollAction: "realign",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      /**
       * Get/set value, which can be set as a Date or a string but always returns a Date. If a string is
       * specified, it will be converted using the specified {@link #config-format}
       * @member {Date} value
       * @accepts {String|Date}
       */
      /**
       * Value, which can be a Date or a string. If a string is specified, it will be converted using the
       * specified {@link #config-format}
       * @config {String|Date}
       */
      value: null
    };
  }
  //endregion
  //region Init & destroy
  /**
   * Creates default picker widget
   *
   * @internal
   */
  changePicker(picker, oldPicker) {
    const me = this, config = DatePicker.mergeConfigs({
      owner: me,
      forElement: me[me.pickerAlignElement],
      minDate: me.min,
      maxDate: me.max,
      weekStartDay: me._weekStartDay,
      // need to pass the raw value to let the component to use its default value
      align: {
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      onSelectionChange: ({ selection, source: picker2 }) => {
        if (picker2.isVisible) {
          me._isUserAction = me._isPickerInput = true;
          me.value = me.value ? DateHelper.copyTimeValues(new Date(selection[0]), me.value) : new Date(selection[0]);
          me._isPickerInput = me._isUserAction = false;
          picker2.hide();
        }
      }
    }, picker);
    if (me.calendarContainerCls) {
      config.cls = me.calendarContainerCls;
    }
    if (me.value) {
      config.value = me.value;
    } else if (!config.activeDate) {
      config.activeDate = /* @__PURE__ */ new Date();
    }
    const result = DatePicker.reconfigure(oldPicker, picker ? config : null, me);
    result == null ? void 0 : result.refresh.flush();
    return result;
  }
  //endregion
  //region Click listeners
  get backShiftDate() {
    return DateHelper.add(this.value, -1 * this._step.magnitude, this._step.unit);
  }
  onBackClick() {
    const me = this, { min: min2 } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.backShiftDate;
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  get forwardShiftDate() {
    return DateHelper.add(this.value, this._step.magnitude, this._step.unit);
  }
  onForwardClick() {
    const me = this, { max } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.forwardShiftDate;
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  //endregion
  //region Toggle picker
  showPicker(focusPicker) {
    if (this.readOnly) {
      return;
    }
    const me = this, { _picker } = me;
    if (_picker) {
      const pickerConfig = {
        minDate: me.min,
        maxDate: me.max
      };
      if (me.value) {
        pickerConfig.value = me.value;
      } else if (!_picker.activeDate) {
        pickerConfig.activeDate = /* @__PURE__ */ new Date();
      }
      _picker.setConfig(pickerConfig);
    }
    super.showPicker(focusPicker);
  }
  focusPicker() {
    this.picker.focus();
  }
  //endregion
  // region Validation
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      let { min: min2, max, validateDateOnly } = me;
      if (validateDateOnly) {
        value = DateHelper.clearTime(value, false);
        if (min2) {
          min2 = DateHelper.clearTime(min2, false);
        }
        if (max) {
          max = DateHelper.clearTime(max, false);
        }
      }
      if (min2 && value < min2) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (max && value > max) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  //endregion
  //region Getters/setters
  transformDateValue(value, checkBounds = true) {
    const me = this;
    if (value != null) {
      if (!DateHelper.isDate(value)) {
        if (typeof value === "string") {
          value = DateHelper.parse(value, me.format, me.strictParsing) || DateHelper.parse(value, me.fallbackFormat, me.strictParsing);
        } else {
          value = new Date(value);
        }
      }
      if (DateHelper.isValidDate(value)) {
        if (checkBounds && (!me.min || value - me.min > -DateHelper.MS_PER_DAY) && (!me.max || value <= me.max)) {
          return me.transformTimeValue(value);
        }
        return value;
      }
    }
    return null;
  }
  transformTimeValue(value) {
    const me = this, { keepTime } = me;
    value = DateHelper.clone(value);
    if (!keepTime) {
      DateHelper.clearTime(value, false);
    } else if (keepTime !== "entered" && keepTime !== true) {
      const timeValue = DateHelper.parse(keepTime, me.timeFormat);
      if (DateHelper.isValidDate(timeValue)) {
        DateHelper.copyTimeValues(value, timeValue);
      } else if (DateHelper.isValidDate(me.value)) {
        DateHelper.copyTimeValues(value, me.value);
      }
    } else if (keepTime === true && (me._isPickerInput || me.inputting) && DateHelper.isValidDate(me.value)) {
      DateHelper.copyTimeValues(value, me.value);
    }
    return value;
  }
  changeMin(value) {
    return this.transformDateValue(value, false);
  }
  updateMin(min2) {
    const { input, _picker } = this;
    if (input) {
      if (min2 == null) {
        input.removeAttribute("min");
      } else {
        input.min = min2;
      }
    }
    if (_picker) {
      _picker.minDate = min2;
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformDateValue(value, false);
  }
  updateMax(max) {
    const { input, _picker } = this;
    if (input) {
      if (max == null) {
        input.removeAttribute("max");
      } else {
        input.max = max;
      }
    }
    if (_picker) {
      _picker.maxDate = max;
    }
    this.syncInvalid();
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay(weekStartDay) {
    if (this._picker) {
      this._picker.weekStartDay = weekStartDay;
    }
  }
  changeValue(value, oldValue) {
    const me = this, newValue = me.transformDateValue(value);
    if (value && !newValue) {
      if (!me.inputting || me.validateOnInput) {
        me.setError("L{invalidDate}");
      }
      return;
    }
    me.clearError("L{invalidDate}");
    if (me.hasChanged(oldValue, newValue)) {
      return super.changeValue(newValue, oldValue);
    }
    if (!me.inputting) {
      me.syncInputFieldValue();
    }
  }
  updateValue(value, oldValue) {
    const picker = this._picker;
    if (picker && !this.inputting) {
      picker.value = picker.activeDate = value;
    }
    super.updateValue(value, oldValue);
  }
  changeStep(value, was) {
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "day"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if (value && value.unit && value.magnitude) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          // Math.abs
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  hasChanged(oldValue, newValue) {
    if ((oldValue == null ? void 0 : oldValue.getTime) && (newValue == null ? void 0 : newValue.getTime) && this.keepTime !== "entered" && this.keepTime !== true) {
      return !DateHelper.isEqual(DateHelper.clearTime(oldValue), DateHelper.clearTime(newValue));
    }
    return super.hasChanged(oldValue && oldValue.getTime(), newValue && newValue.getTime());
  }
  get inputValue() {
    const date = this.value;
    return date ? DateHelper.format(date, this.format) : "";
  }
  updateFormat() {
    if (!this.isConfiguring) {
      this.syncInputFieldValue(true);
    }
  }
  //endregion
  //region Localization
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
  //endregion
  //region Other
  internalOnKeyEvent(event) {
    super.internalOnKeyEvent(event);
    if (event.key === "Enter" && this.isValid) {
      this.picker.hide();
    }
  }
  //endregion
};
//region Config
__publicField(DateField, "$name", "DateField");
__publicField(DateField, "type", "datefield");
__publicField(DateField, "alias", "date");
DateField.initClass();
DateField._$name = "DateField";

// ../Core/lib/Core/widget/NumberField.js
var preventDefault = (e) => e.ctrlKey && e.preventDefault();
var NumberField = class extends Field {
  static get configurable() {
    return {
      /**
       * Reset to min value when max value is reached using steppers, and vice-versa.
       * @config {Boolean}
       * @default false
       */
      wrapAround: null,
      /**
       * Min value
       * @config {Number}
       */
      min: null,
      /**
       * Max value
       * @config {Number}
       */
      max: null,
      /**
       * Step size for spin button clicks.
       * @member {Number} step
       */
      /**
       * Step size for spin button clicks. Also used when pressing up/down keys in the field.
       * @config {Number}
       * @default
       */
      step: 1,
      /**
       * Large step size, defaults to 10 * `step`. Applied when pressing SHIFT and stepping either by click or
       * using keyboard.
       * @config {Number}
       * @default 10
       */
      largeStep: 0,
      /**
       * Initial value
       * @config {Number}
       */
      value: null,
      /**
       * The format to use for rendering numbers.
       *
       * For example:
       * ```
       *  format: '9,999.00##'
       * ```
       * The above enables digit grouping and will display at least 2 (but no more than 4) fractional digits.
       * @config {String|NumberFormatConfig}
       * @default
       */
      format: "",
      /**
       * The number of decimal places to allow. Defaults to no constraint.
       *
       * This config has been replaced by {@link #config-format}. Instead of this:
       *```
       *  decimalPrecision : 3
       *```
       * Use `format`:
       *```
       *  format : '9.###'
       *```
       * To set both `decimalPrecision` and `leadingZeroes` (say to `3`), do this:
       *```
       *  format : '3>9.###'
       *```
       * @config {Number}
       * @default
       * @deprecated Since 3.1. Use {@link #config-format} instead.
       */
      decimalPrecision: null,
      /**
       * The maximum number of leading zeroes to show. Defaults to no constraint.
       *
       * This config has been replaced by {@link #config-format}. Instead of this:
       *```
       *  leadingZeros : 3
       *```
       * Use `format`:
       *```
       *  format : '3>9'
       *```
       * To set both `leadingZeroes` and `decimalPrecision` (say to `2`), do this:
       *```
       *  format : '3>9.##'
       *```
       * @config {Number}
       * @default
       * @deprecated Since 3.1. Use {@link #config-format} instead.
       */
      leadingZeroes: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      /**
       * Controls how change events are triggered when stepping the value up or down using either spinners or
       * arrow keys.
       *
       * Configure with:
       * * `true` to trigger a change event per step
       * * `false` to not trigger change while stepping. Will trigger on blur/Enter
       * * A number of milliseconds to buffer the change event, triggering when no steps are performed during that
       *   period of time.
       *
       * @config {Boolean|Number}
       * @default
       */
      changeOnSpin: true,
      // NOTE: using type="number" has several trade-offs:
      //
      // Negatives:
      //   - No access to caretPos/textSelection. This causes anomalies when replacing
      //     the input value with a formatted version of that value (the caret moves to
      //     the end of the input el on each character typed).
      //   - The above also prevents Siesta/synthetic events from mimicking typing.
      //   - Thousand separators cannot be displayed (input.value = '1,000' throws an
      //     exception).
      // Positives:
      //   - On mobile, the virtual keyboard only shows digits et al.
      //   - validity property on DOM node that handles min/max checks.
      //
      // The above may not be exhaustive, but there is not a compelling reason to
      // use type="number" except on mobile.
      /**
       * This can be set to `'number'` to enable the numeric virtual keyboard on
       * mobile devices. Doing so limits this component's ability to handle keystrokes
       * and format properly as the user types, so this is not recommended for
       * desktop applications. This will also limit similar features of automated
       * testing tools that mimic user input.
       * @config {String}
       * @default text
       */
      inputType: null
    };
  }
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    const me = this;
    me.input.addEventListener("dblclick", () => {
      me.select();
    });
    if (typeof me.changeOnSpin === "number") {
      me.bufferedSpinChange = me.buffer(me.triggerChange, me.changeOnSpin);
    }
  }
  //endregion
  //region Internal functions
  acceptValue(value, rawValue) {
    let accept = !isNaN(value);
    if (accept && !this.hasTextSelection) {
      accept = false;
      const raw = this.input.value, current = parseFloat(raw);
      if (raw !== rawValue) {
        accept = !this.acceptValue(current, raw);
      }
    }
    return accept;
  }
  okMax(value) {
    return isNaN(this.max) || value <= this.max;
  }
  okMin(value) {
    return isNaN(this.min) || value >= this.min;
  }
  internalOnKeyEvent(e) {
    if (e.type === "keydown") {
      const me = this, key = e.key;
      let block;
      if (key === "ArrowUp") {
        me.doSpinUp(e.shiftKey);
        block = true;
      } else if (key === "ArrowDown") {
        me.doSpinDown(e.shiftKey);
        block = true;
      } else if (!e.altKey && !e.ctrlKey && key && key.length === 1) {
        const after = me.getAfterValue(key), afterValue = me.formatter.parseStrict(after), accepted = afterValue === me.value || after === "-" && (isNaN(me.min) || me.min < 0);
        block = !accepted && !me.acceptValue(afterValue, after);
      }
      if (key === "Enter" && me._changedBySilentSpin) {
        me.triggerChange(e, true);
        me._changedBySilentSpin = false;
      }
      if (block) {
        e.preventDefault();
      }
    }
    super.internalOnKeyEvent(e);
  }
  doSpinUp(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) + (largeStep ? me.largeStep : me.step);
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.applySpinChange(newValue);
    } else if (me.wrapAround) {
      newValue = me.min;
      me.applySpinChange(newValue);
    }
  }
  doSpinDown(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) - (largeStep ? me.largeStep : me.step);
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue)) {
      me.applySpinChange(newValue);
    } else if (me.wrapAround) {
      newValue = me.max;
      me.applySpinChange(newValue);
    }
  }
  applySpinChange(newValue) {
    const me = this;
    me._isUserAction = true;
    if (me.changeOnSpin !== true) {
      me._changedBySilentSpin = true;
      me.silenceChange = true;
      me.bufferedSpinChange && me.bufferedSpinChange(null, true);
    }
    me.value = newValue;
    me._isUserAction = false;
    me.silenceChange = false;
  }
  triggerChange() {
    if (!this.silenceChange) {
      super.triggerChange(...arguments);
    }
  }
  onFocusOut(e) {
    var _a4, _b, _c;
    super.onFocusOut(...arguments);
    const me = this, { input } = me, raw = input.value, value = me.formatter.truncate(raw), formatted = isNaN(value) ? raw : me.formatValue(value);
    (_c = (_b = (_a4 = me.triggers) == null ? void 0 : _a4.spin) == null ? void 0 : _b.clickRepeater) == null ? void 0 : _c.cancel();
    me.lastTouchmove = null;
    if (raw !== formatted) {
      input.value = formatted;
    }
    if (me._changedBySilentSpin) {
      me.triggerChange(e, true);
      me._changedBySilentSpin = false;
    }
  }
  internalOnInput(event) {
    const me = this, { formatter, input } = me, { parser, maximumFractionDigits } = formatter, raw = input.value, decimals = parser.decimalPlaces(raw);
    if (formatter.truncator && decimals > maximumFractionDigits) {
      let value = raw, valueDecimals;
      const trunc = formatter.truncate(raw);
      if (!isNaN(trunc)) {
        value = me.formatValue(trunc);
        valueDecimals = parser.decimalPlaces(value);
        if (valueDecimals < maximumFractionDigits) {
          value += "0".repeat(maximumFractionDigits - valueDecimals);
          valueDecimals = maximumFractionDigits;
        }
        if (valueDecimals < decimals) {
          const pos = raw.length - me.caretPos;
          input.value = value;
          me.caretPos = value.length - pos + 1;
        }
      }
    }
    super.internalOnInput(event);
  }
  formatValue(value) {
    return this.formatter.format(value);
  }
  changeFormat(format) {
    const me = this;
    if (format === "") {
      const { leadingZeroes, decimalPrecision } = me;
      format = leadingZeroes ? `${leadingZeroes}>9` : null;
      if (decimalPrecision != null) {
        format = `${format || ""}9.${"#".repeat(decimalPrecision)}`;
      } else if (format) {
        format += ".*";
      }
    }
    return format;
  }
  get formatter() {
    const me = this, format = me.format;
    let formatter = me._formatter;
    if (!formatter || me._lastFormat !== format) {
      formatter = NumberFormat.get(me._lastFormat = format);
      me._formatter = formatter;
    }
    return formatter;
  }
  //endregion
  //region Getters/Setters
  updateStep(step) {
    var _a4;
    const me = this;
    me.element.classList.toggle("b-hide-spinner", !step);
    me._step = step;
    if (step && BrowserHelper.isMobile) {
      if (!me.touchMoveListener) {
        me.touchMoveListener = EventHelper.on({
          element: me.input,
          touchmove: "onInputSwipe",
          thisObj: me,
          throttled: {
            buffer: 150,
            alt: preventDefault
          }
        });
      }
    } else {
      (_a4 = me.touchMoveListener) == null ? void 0 : _a4.call(me);
    }
  }
  onInputSwipe(e) {
    const { lastTouchmove } = this;
    if (lastTouchmove) {
      const deltaX = e.screenX - lastTouchmove.screenX, deltaY = lastTouchmove.screenY - e.screenY, delta = Math.abs(deltaX) > Math.abs(deltaY) ? deltaX : deltaY;
      this[`doSpin${delta > 0 ? "Up" : "Down"}`]();
    }
    e.preventDefault();
    this.lastTouchmove = e;
  }
  changeLargeStep(largeStep) {
    return largeStep || this.step * 10;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  /**
   * Get/set the NumberField's value, or `undefined` if the input field is empty
   * @property {Number}
   */
  changeValue(value, was) {
    const me = this;
    if (value || value === 0) {
      let valueIsNaN;
      if (typeof value !== "number") {
        value = typeof value === "string" ? me.formatter.parse(value) : Number(value);
        valueIsNaN = isNaN(value);
        if (valueIsNaN) {
          value = "";
        }
      }
      if (!valueIsNaN && me.format) {
        value = me.formatter.round(value);
      }
    } else {
      value = void 0;
    }
    return super.changeValue(value, was);
  }
  get inputValue() {
    let value = this.value;
    if (value != null && this.format) {
      value = this.formatValue(value);
    }
    return value;
  }
  //endregion
};
//region Config
__publicField(NumberField, "$name", "NumberField");
__publicField(NumberField, "type", "numberfield");
__publicField(NumberField, "alias", "number");
NumberField.initClass();
NumberField._$name = "NumberField";

// ../Core/lib/Core/widget/TimePicker.js
var TimePicker = class extends Panel {
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    this.refresh();
  }
  updateSeconds(seconds) {
    this.widgetMap.second[seconds ? "show" : "hide"]();
  }
  //endregion
  //region Event listeners
  // Automatically called by Widget's triggerFieldChange which announces changes to all ancestors
  onFieldChange() {
    if (!this.isConfiguring && !this.isRefreshing) {
      this.value = this.pickerToTime();
    }
  }
  onAmPmButtonClick({ source }) {
    this._pm = source.ref === "pmButton";
    if (this._value) {
      this.value = this.pickerToTime();
    }
  }
  onInternalKeyDown(keyEvent) {
    var _a4;
    const me = this;
    switch (keyEvent.key) {
      case "Escape":
        me.triggerTimeChange(me._initialValue);
        me.hide();
        keyEvent.preventDefault();
        return;
      case "Enter":
        me.value = me.pickerToTime();
        me.hide();
        keyEvent.preventDefault();
        return;
    }
    (_a4 = super.onInternalKeyDown) == null ? void 0 : _a4.call(this, keyEvent);
  }
  //endregion
  //region Internal functions
  pickerToTime() {
    const me = this, pm = me._pm, { hour: hour2, minute, second } = me.widgetMap;
    hour2.format = me._is24Hour ? "2>9" : null;
    let hours = hour2.value, newValue = new Date(me.value);
    if (!me._is24Hour) {
      if (pm && hours < 12)
        hours = hours + 12;
      if (!pm && hours === 12)
        hours = 0;
    }
    newValue.setHours(hours);
    newValue.setMinutes(minute.value);
    if (me.seconds) {
      newValue.setSeconds(second.value);
    }
    if (me._min) {
      newValue = DateHelper.max(me._min, newValue);
    }
    if (me._max) {
      newValue = DateHelper.min(me._max, newValue);
    }
    return newValue;
  }
  triggerTimeChange(time) {
    this.trigger("timeChange", { time });
  }
  //endregion
  //region Getters / Setters
  updateInitialValue(initialValue) {
    this.value = initialValue;
  }
  changeValue(value) {
    if (value) {
      value = typeof value === "string" ? DateHelper.parse(value, this.format) : value;
    }
    if (!this.isVisible) {
      this._initialValue = value;
    }
    return value != null ? value : DateHelper.getTime(0);
  }
  updateValue(value) {
    if (this.isVisible) {
      this.triggerTimeChange(value);
    }
    this.refresh();
  }
  updateFormat(format) {
    this._is24Hour = DateHelper.is24HourFormat(format);
    this.refresh();
  }
  changeMin(min2) {
    return typeof min2 === "string" ? DateHelper.parse(min2, this.format) : min2;
  }
  changeMax(max) {
    return typeof max === "string" ? DateHelper.parse(max, this.format) : max;
  }
  //endregion
  //region Display
  refresh() {
    const me = this;
    if (!me.isConfiguring && me.value) {
      me.isRefreshing = true;
      const { hour: hour2, minute, second, amButton, pmButton } = me.widgetMap, time = me.value, is24 = me._is24Hour, hours = time.getHours(), pm = me._pm = hours >= 12;
      me.element.classList[is24 ? "add" : "remove"]("b-24h");
      hour2.min = is24 ? 0 : 1;
      hour2.max = is24 ? 23 : 12;
      hour2.value = is24 ? hours : hours % 12 || 12;
      minute.value = time.getMinutes();
      second.value = time.getSeconds();
      amButton.pressed = !pm;
      pmButton.pressed = pm;
      amButton.hidden = pmButton.hidden = is24;
      me.isRefreshing = false;
    }
  }
  //endregion
};
//region Config
__publicField(TimePicker, "$name", "TimePicker");
__publicField(TimePicker, "type", "timepicker");
__publicField(TimePicker, "configurable", {
  floating: true,
  layout: "hbox",
  items: {
    hour: {
      label: "L{TimePicker.hour}",
      type: "number",
      min: 0,
      max: 23,
      highlightExternalChange: false,
      format: "2>9",
      wrapAround: true
    },
    minute: {
      label: "L{TimePicker.minute}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9",
      wrapAround: true
    },
    second: {
      hidden: true,
      label: "L{TimePicker.second}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9",
      wrapAround: true
    },
    amPm: {
      type: "buttongroup",
      items: {
        amButton: {
          type: "button",
          text: "AM",
          toggleGroup: "am-pm",
          cls: "b-blue",
          onClick: "up.onAmPmButtonClick"
        },
        pmButton: {
          type: "button",
          text: "PM",
          toggleGroup: "am-pm",
          cls: "b-blue",
          onClick: "up.onAmPmButtonClick"
        }
      }
    }
  },
  autoShow: false,
  trapFocus: true,
  /**
   * By default the seconds field is not displayed. If you require seconds to be visible,
   * configure this as `true`
   * @config {Boolean}
   * @default false
   */
  seconds: null,
  /**
   * Time value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @prp {Date}
   * @accepts {Date|String}
   */
  value: {
    $config: {
      equal: "date"
    },
    value: null
  },
  /**
   * Time format. Used to set appropriate 12/24 hour format to display.
   * See {@link Core.helper.DateHelper#function-format-static DateHelper} for formatting options.
   * @prp {String}
   */
  format: null,
  /**
   * Max value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @prp {Date}
   * @accepts {Date|String}
   */
  max: null,
  /**
   * Min value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @prp {Date}
   * @accepts {Date|String}
   */
  min: null,
  /**
   * Initial value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}. Initial value is restored on Escape click
   * @member {Date} initialValue
   * @accepts {Date|String}
   */
  initialValue: null
  // Not documented as config on purpose, API was that way
});
TimePicker.initClass();
TimePicker._$name = "TimePicker";

// ../Core/lib/Core/widget/TimeField.js
var TimeField = class extends PickerField {
  static get configurable() {
    return {
      picker: {
        type: "timepicker",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      /**
       * Get/Set format for time displayed in field (see {@link Core.helper.DateHelper#function-format-static}
       * for formatting options).
       * @member {String} format
       */
      /**
       * Format for date displayed in field (see Core.helper.DateHelper#function-format-static for formatting
       * options).
       * @config {String}
       * @default
       */
      format: "LT",
      triggers: {
        expand: {
          align: "end",
          handler: "onTriggerClick",
          compose: () => ({
            children: [{
              class: {
                "b-icon-clock-live": 1
              }
            }]
          })
        },
        back: {
          align: "start",
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick"
        },
        forward: {
          align: "end",
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick"
        }
      },
      /**
       * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} min
       * @accepts {String|Date}
       */
      /**
       * Min time value
       * @config {String|Date}
       */
      min: null,
      /**
       * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} max
       * @accepts {String|Date}
       */
      /**
       * Max time value
       * @config {String|Date}
       */
      max: null,
      /**
       * The `step` property may be set in Object form specifying two properties, `magnitude`, a Number, and
       * `unit`, a String.
       *
       * If a Number is passed, the steps's current unit is used and just the magnitude is changed.
       *
       * If a String is passed, it is parsed by {@link Core.helper.DateHelper#function-parseDuration-static}, for
       * example `'5m'`, `'5 m'`, `'5 min'`, `'5 minutes'`.
       *
       * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
       * @member {DurationConfig} step
       * @accepts {String|Number|DurationConfig}
       */
      /**
       * Time increment duration value. Defaults to 5 minutes.
       * The value is taken to be a string consisting of the numeric magnitude and the units.
       * The units may be a recognised unit abbreviation of this locale or the full local unit name.
       * For example `"10m"` or `"5min"` or `"2 hours"`
       * @config {String}
       */
      step: "5m",
      stepTriggers: null,
      /**
       * Get/set value, which can be a Date or a string. If a string is specified, it will be converted using the
       * specified {@link #config-format}.
       * @member {Date} value
       * @accepts {String|Date}
       */
      /**
       * Value, which can be a Date or a string. If a string is specified, it will be converted using the
       * specified {@link #config-format}
       * @config {String|Date}
       */
      value: null,
      /**
       * Set to true to not clean up the date part of the passed value. Set to false to reset the date part to
       * January 1st
       * @prp {Boolean}
       * @default
       */
      keepDate: false
    };
  }
  //endregion
  //region Init & destroy
  changePicker(picker, oldPicker) {
    const me = this;
    return TimePicker.reconfigure(oldPicker, picker, {
      owner: me,
      defaults: {
        value: me.value,
        forElement: me[me.pickerAlignElement],
        owner: me,
        align: {
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement]
        },
        onTimeChange({ time }) {
          me._isUserAction = true;
          me.value = time;
          me._isUserAction = false;
        }
      }
    });
  }
  //endregion
  //region Click listeners
  onBackClick() {
    const me = this, { min: min2 } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me.step.magnitude, me.step.unit);
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  onForwardClick() {
    const me = this, { max } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me.step.magnitude, me.step.unit);
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  //endregion
  // region Validation
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      value = value.getTime();
      if (me._min && me._min.getTime() > value) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (me._max && me._max.getTime() < value) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  hasChanged(oldValue, newValue) {
    if ((oldValue == null ? void 0 : oldValue.getTime) && (newValue == null ? void 0 : newValue.getTime)) {
      return this.keepDate ? oldValue - newValue !== 0 : !DateHelper.isSameTime(oldValue, newValue);
    }
    return super.hasChanged(oldValue, newValue);
  }
  //endregion
  //region Toggle picker
  /**
   * Show picker
   */
  showPicker() {
    const me = this, {
      picker,
      value
    } = me;
    if (me.readOnly) {
      return;
    }
    picker.value = value;
    picker.format = me.format;
    picker.maxTime = me.max;
    picker.minTime = me.min;
    if (!value) {
      me.value = picker.value;
    }
    super.showPicker(true);
  }
  onPickerShow() {
    var _a4;
    super.onPickerShow();
    this.pickerKeyDownRemover = (_a4 = this.pickerKeyDownRemover) == null ? void 0 : _a4.call(this);
  }
  /**
   * Focus time picker
   */
  focusPicker() {
    this.picker.focus();
  }
  //endregion
  //region Getters/setters
  transformTimeValue(value) {
    if (value != null) {
      if (typeof value === "string") {
        value = DateHelper.parse(value, this.format);
        if (this.keepDate) {
          value = DateHelper.copyTimeValues(new Date(this.value), value);
        }
      } else {
        value = new Date(value);
      }
      if (DateHelper.isValidDate(value)) {
        if (!this.keepDate) {
          return DateHelper.getTime(value);
        } else {
          return value;
        }
      }
    }
    return null;
  }
  changeMin(value) {
    return this.transformTimeValue(value);
  }
  updateMin(value) {
    const { input } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("min");
      } else {
        input.min = value;
      }
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformTimeValue(value);
  }
  updateMax(value) {
    const { input } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("max");
      } else {
        input.max = value;
      }
    }
    this.syncInvalid();
  }
  changeValue(value, was) {
    const me = this, newValue = me.transformTimeValue(value);
    if (value && !newValue || me.isRequired && value === "") {
      me.setError("L{invalidTime}");
      return;
    }
    me.clearError("L{invalidTime}");
    if (me.hasChanged(was, newValue)) {
      return super.changeValue(newValue, was);
    }
    if (!me.inputting) {
      me.syncInputFieldValue(true);
    }
  }
  updateValue(value, was) {
    const { expand } = this.triggers;
    if (expand && value) {
      expand.element.firstElementChild.style.animationDelay = -((value.getHours() * 60 + value.getMinutes()) / 10) + "s";
    }
    super.updateValue(value, was);
  }
  changeStep(value, was) {
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "hour"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if ((value == null ? void 0 : value.unit) && (value == null ? void 0 : value.magnitude)) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          // Math.abs
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  updateFormat() {
    this.syncInputFieldValue(true);
  }
  get inputValue() {
    return DateHelper.format(this.value, this.format);
  }
  //endregion
  //region Localization
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
  //endregion
};
//region Config
__publicField(TimeField, "$name", "TimeField");
__publicField(TimeField, "type", "timefield");
__publicField(TimeField, "alias", "time");
TimeField.initClass();
TimeField._$name = "TimeField";

// ../Core/lib/Core/widget/DateTimeField.js
var midnightDate = new Date(2e3, 0, 1);
var DateTimeField = class extends Field {
  doDestroy() {
    this.dateField.destroy();
    this.timeField.destroy();
    super.doDestroy();
  }
  get focusElement() {
    return this.dateField.input;
  }
  // Implementation needed at this level because it has two inner elements in its inputWrap
  get innerElements() {
    return [
      this.dateField.element,
      this.timeField.element
    ];
  }
  // Each subfield handles its own keystrokes
  internalOnKeyEvent() {
  }
  // CellEdit sets this dynamically on its editor field
  updateRevertOnEscape(revertOnEscape) {
    this.timeField.revertOnEscape = revertOnEscape;
    this.dateField.revertOnEscape = revertOnEscape;
  }
  // Converts the timeField config into a TimeField
  changeTimeField(config) {
    const me = this, result = TimeField.new({
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        TimeField.prototype.syncInvalid.apply(this, args);
        me.timeField && !updatingInvalid && me.syncInvalid();
      }
    }, config);
    EventHelper.on({
      element: result.element,
      keydown: "onTimeFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    return result;
  }
  // Set up change listener when TimeField is available. Not in timeField config to enable users to supply their own
  // listeners block there
  updateTimeField(timeField) {
    const me = this;
    timeField.ion({
      change({ userAction, value }) {
        if (userAction && !me.$settingValue) {
          const dateAndTime = me.dateField.value;
          me._isUserAction = true;
          me.value = dateAndTime ? DateHelper.copyTimeValues(new Date(dateAndTime), value || midnightDate) : null;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  // Converts the dateField config into a class based on { type : "..." } provided (DateField by default)
  changeDateField(config) {
    const me = this, type = (config == null ? void 0 : config.type) || "datefield", cls = Widget.resolveType(config.type || "datefield"), result = Widget.create(ObjectHelper.assign({
      type,
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        cls.prototype.syncInvalid.apply(this, args);
        me.dateField && !updatingInvalid && me.syncInvalid();
      }
    }, config));
    EventHelper.on({
      element: result.element,
      keydown: "onDateFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    result.ion({
      keydown: ({ event }) => {
        var _a4;
        if (event.key === "Tab" && !event.shiftKey && ((_a4 = this.timeField) == null ? void 0 : _a4.isVisible)) {
          event.stopPropagation();
          event.cancelBubble = true;
        }
      }
    });
    return result;
  }
  get childItems() {
    return [this.dateField, this.timeField];
  }
  // Set up change listener when DateField is available. Not in dateField config to enable users to supply their own
  // listeners block there
  updateDateField(dateField) {
    const me = this;
    dateField.ion({
      change({ userAction, value }) {
        if (userAction && !me.$isInternalChange) {
          me._isUserAction = true;
          me.timeField.value = value;
          me.value = value;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  updateWeekStartDay(weekStartDay) {
    if (this.dateField) {
      this.dateField.weekStartDay = weekStartDay;
    }
  }
  changeWeekStartDay(value) {
    var _a4, _b;
    return typeof value === "number" ? value : (_b = (_a4 = this.dateField) == null ? void 0 : _a4.weekStartDay) != null ? _b : DateHelper.weekStartDay;
  }
  // Apply our value to our underlying fields
  syncInputFieldValue(skipHighlight = this.isConfiguring) {
    super.syncInputFieldValue(true);
    const me = this, { dateField, timeField } = me, highlightDate = dateField.highlightExternalChange, highlightTime = timeField.highlightExternalChange;
    if (!skipHighlight && !me.highlightExternalChange) {
      skipHighlight = true;
    }
    me.$isInternalChange = true;
    dateField.highlightExternalChange = false;
    dateField.highlightExternalChange = highlightDate;
    if (skipHighlight) {
      timeField.highlightExternalChange = dateField.highlightExternalChange = false;
    }
    timeField.value = dateField.value = me.inputValue;
    dateField.highlightExternalChange = highlightDate;
    timeField.highlightExternalChange = highlightTime;
    me.$isInternalChange = false;
    me.syncInvalid();
  }
  onTimeFieldKeyDown(e) {
    const me = this;
    if (e.key === "Enter" || e.key === "Tab") {
      const dateAndTime = me.dateField.value;
      me._isUserAction = true;
      me.value = dateAndTime ? DateHelper.copyTimeValues(new Date(dateAndTime), me.timeField.value || midnightDate) : null;
      me._isUserAction = false;
    }
  }
  onDateFieldKeyDown(e) {
    const me = this;
    if (e.key === "Tab" && !e.shiftKey) {
      e.stopPropagation();
      e.preventDefault();
      me.timeField.focus();
    } else if (e.key === "Enter") {
      me.value = me.dateField.value;
    }
  }
  // Make us and our underlying fields required
  updateRequired(required) {
    this.timeField.required = this.dateField.required = required;
  }
  updateReadOnly(readOnly, was) {
    super.updateReadOnly(readOnly, was);
    if (!this.isConfiguring) {
      this.timeField.readOnly = this.dateField.readOnly = readOnly;
    }
  }
  // Make us and our underlying fields disabled
  onDisabled(value) {
    this.timeField.disabled = this.dateField.disabled = value;
  }
  focus() {
    this.dateField.focus();
  }
  hasChanged(oldValue, newValue) {
    var _a4, _b;
    if ((oldValue == null ? void 0 : oldValue.getTime) && (newValue == null ? void 0 : newValue.getTime)) {
      return !DateHelper.isEqual(oldValue, newValue);
    }
    return super.hasChanged((_a4 = oldValue == null ? void 0 : oldValue.getTime) == null ? void 0 : _a4.call(oldValue), (_b = newValue == null ? void 0 : newValue.getTime) == null ? void 0 : _b.call(newValue));
  }
  get isValid() {
    return this.timeField.isValid && this.dateField.isValid;
  }
  setError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.setError(error, silent));
  }
  getErrors() {
    const errors = [...this.dateField.getErrors() || [], ...this.timeField.getErrors() || []];
    return errors.length ? errors : null;
  }
  clearError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.clearError(error, silent));
  }
  updateInvalid() {
    this.updatingInvalid = true;
    [this.dateField, this.timeField].forEach((f) => f.updateInvalid());
    this.updatingInvalid = false;
  }
};
__publicField(DateTimeField, "$name", "DateTimeField");
__publicField(DateTimeField, "type", "datetimefield");
__publicField(DateTimeField, "alias", "datetime");
__publicField(DateTimeField, "configurable", {
  /**
   * Returns the TimeField instance
   * @readonly
   * @member {Core.widget.TimeField} timeField
   */
  /**
   * Configuration for the {@link Core.widget.TimeField}
   * @config {TimeFieldConfig}
   */
  timeField: {},
  /**
   * Returns the DateField instance
   * @readonly
   * @member {Core.widget.DateField} dateField
   */
  /**
   * Configuration for the {@link Core.widget.DateField}
   * @config {DateFieldConfig}
   */
  dateField: {
    // To be able to use transformDateValue for parsing without loosing time, a bit of a hack
    keepTime: true,
    step: "1 d"
  },
  /**
   * The week start day in the {@link Core.widget.DateField#config-picker}, 0 meaning Sunday, 6 meaning Saturday.
   * Uses localized value per default.
   *
   * @config {Number}
   */
  weekStartDay: null,
  inputTemplate: () => "",
  ariaElement: "element"
});
DateTimeField.initClass();
DateTimeField._$name = "DateTimeField";

// ../Core/lib/Core/widget/DurationField.js
var DurationField = class extends TextField {
  static get defaultConfig() {
    return {
      /**
       * The `value` config may be set in Object form specifying two properties,
       * `magnitude`, a Number, and `unit`, a String.
       *
       * If a String is passed, it is parsed in accordance with current locale rules.
       * The string is taken to be the numeric magnitude, followed by whitespace, then an abbreviation, or name of
       * the unit.
       * @config {DurationConfig|String}
       * @category Common
       */
      value: null,
      /**
       * Step size for spin button clicks.
       * @config {Number}
       * @default
       * @category Common
       */
      step: 1,
      /**
       * The duration unit to use with the current magnitude value.
       * @config {DurationUnit}
       * @category Common
       */
      unit: null,
      defaultUnit: "day",
      /**
       * The duration magnitude to use with the current unit value. Can be either an integer or a float value.
       * Both "," and "." are valid decimal separators.
       * @config {Number}
       * @category Common
       */
      magnitude: null,
      /**
       * When set to `true` the field will use short names of unit durations
       * (as returned by {@link Core.helper.DateHelper#function-getShortNameOfUnit-static}) when creating the
       * input field's display value.
       * @config {Boolean}
       * @category Common
       */
      useAbbreviation: false,
      /**
       * Set to `true` to allow negative duration
       * @config {Boolean}
       * @category Common
       */
      allowNegative: false,
      /**
       * The number of decimal places to allow. Defaults to no constraint.
       * @config {Number}
       * @default
       * @category Common
       */
      decimalPrecision: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      nullValue: null
    };
  }
  /**
   * Fired when this field's value changes.
   * @event change
   * @param {Core.data.Duration} value - This field's value
   * @param {Core.data.Duration} oldValue - This field's previous value
   * @param {Boolean} valid - True if this field is in a valid state.
   * @param {Event} [event] - The triggering DOM event if any.
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.DurationField} source - This field
   */
  /**
   * User performed default action (typed into this field or hit the triggers).
   * @event action
   * @param {Core.data.Duration} value - This field's value
   * @param {Core.data.Duration} oldValue - This field's previous value
   * @param {Boolean} valid - True if this field is in a valid state.
   * @param {Event} [event] - The triggering DOM event if any.
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.DurationField} source - This field
   */
  static get configurable() {
    return {
      /**
       * Get/set the min value (e.g. 1d)
       * @member {String} min
       * @category Common
       */
      /**
       * Minimum duration value (e.g. 1d)
       * @config {String}
       * @category Common
       */
      min: null,
      /**
       * Get/set the max value
       * @member {String} max (e.g. 10d)
       * @category Common
       */
      /**
       * Max duration value (e.g. 10d)
       * @config {String}
       * @category Common
       */
      max: null,
      /**
       * Get/set the allowed units, e.g. "day,hour,year".
       * @member {String} allowedUnits
       * @category Common
       */
      /**
       * Comma-separated list of units to allow in this field, e.g. "day,hour,year". Leave blank to allow all
       * valid units (the default)
       * @config {String}
       * @category Common
       */
      allowedUnits: null
    };
  }
  changeMin(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeMax(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeAllowedUnits(units) {
    if (typeof units === "string") {
      units = units.split(",");
    }
    if (units.length > 0 && !units.includes(this.defaultUnit)) {
      this.defaultUnit = units[0];
    }
    return units;
  }
  updateAllowedUnits(units) {
    this.allowedUnitsRe = new RegExp(`(${units.join("|")})`, "i");
  }
  get inputValue() {
    return this.value == null ? "" : this.calcValue(true).toString(this.useAbbreviation);
  }
  /**
   * Get/Set duration unit to use with the current magnitude value.
   * Valid values are:
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * @property {DurationUnit}
   * @category Common
   */
  set unit(unit) {
    this._unit = unit;
    this.value = this.calcValue();
  }
  get unit() {
    return this._unit;
  }
  get unitWithDefault() {
    return this._unit || this.defaultUnit;
  }
  /**
   * Get/Set numeric magnitude `value` to use with the current unit value.
   * @property {Number}
   * @category Common
   */
  set magnitude(magnitude) {
    this.clearError("L{invalidUnit}");
    this._magnitude = magnitude;
    super.value = this.calcValue();
  }
  get magnitude() {
    return this._magnitude;
  }
  roundMagnitude(value) {
    return value && this.decimalPrecision != null ? ObjectHelper.round(value, this.decimalPrecision) : value;
  }
  get allowDecimals() {
    return this.decimalPrecision !== 0;
  }
  get isValid() {
    const me = this, inputValue = me.input.value, value = DateHelper.parseDuration(inputValue, me.allowDecimals, inputValue.match(/[\p{Letter}\p{Mark}]+/gui) ? void 0 : me.unitWithDefault), isEmpty = !inputValue || value && value.magnitude == null;
    return super.isValid && (isEmpty && !me.required || !isEmpty && (me.allowNegative || (value == null ? void 0 : value.magnitude) >= 0));
  }
  internalOnChange(event) {
    const me = this, value = me.value, oldVal = me._lastValue;
    if (me.hasChanged(oldVal, value)) {
      me._lastValue = value;
      me.triggerFieldChange({ value, event, userAction: true, valid: me.isValid });
    }
  }
  onFocusOut(e) {
    var _a4, _b, _c;
    this.syncInputFieldValue(true);
    (_c = (_b = (_a4 = this.triggers) == null ? void 0 : _a4.spin) == null ? void 0 : _b.clickRepeater) == null ? void 0 : _c.cancel();
    return super.onFocusOut(e);
  }
  /**
   * The `value` property may be set in Object form specifying two properties, `magnitude`, a Number, and `unit`, a
   * String.
   *
   * If a Number is passed, the field's current unit is used and just the magnitude is changed.
   *
   * If a String is passed, it is parsed in accordance with current locale rules. The string is taken to be the
   * numeric magnitude, followed by whitespace, then an abbreviation, or name of the unit.
   *
   * Upon read, the value is always a {@link Core.data.Duration} object containing `magnitude` and `unit`.
   *
   * @property {Core.data.Duration}
   * @accepts {String|Number|DurationConfig|Core.data.Duration}
   * @category Common
   */
  set value(value) {
    const me = this;
    let newMagnitude, newUnit;
    me.getConfig("allowedUnits");
    me.clearError("L{invalidUnit}");
    if (typeof value === "number" || typeof value === "string" && value.length > 0 && !isNaN(value)) {
      newMagnitude = Number(value);
      newUnit = me.unitWithDefault;
    } else if (typeof value === "string") {
      if (/^\s*$/.test(value)) {
        newMagnitude = null;
      } else {
        const parsedDuration = DateHelper.parseDuration(value, me.allowDecimals, me.unitWithDefault);
        if (parsedDuration) {
          if (!me.allowedUnitsRe || me.allowedUnitsRe.test(parsedDuration.unit)) {
            newUnit = parsedDuration.unit;
            newMagnitude = parsedDuration.magnitude;
          } else {
            me.setError("L{invalidUnit}");
          }
        }
      }
    } else {
      if (value && "unit" in value && "magnitude" in value) {
        newUnit = value.unit;
        newMagnitude = value.magnitude;
      } else {
        newUnit = null;
        newMagnitude = null;
      }
    }
    if (me._magnitude !== newMagnitude || me._unit != newUnit) {
      me._magnitude = newMagnitude;
      if (newUnit) {
        me._unit = newUnit;
      }
      super.value = me.calcValue();
    }
  }
  okMax(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.max == null || value <= this.max;
  }
  okMin(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.min == null || value >= this.min;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  get value() {
    return super.value;
  }
  calcValue(round2 = false) {
    const me = this;
    if ((!me._unit || me._magnitude == null) && me.clearable) {
      return null;
    } else {
      return new Duration(round2 ? this.roundMagnitude(me._magnitude) : this._magnitude, me.unitWithDefault);
    }
  }
  hasChanged(oldValue, newValue) {
    return newValue && !oldValue || !newValue && oldValue || newValue && oldValue && !oldValue.isEqual(newValue);
  }
  /**
   * The `milliseconds` property is a read only property which returns the number of milliseconds in this field's
   * value
   * @member {Number} milliseconds
   * @readonly
   */
  get milliseconds() {
    return this.value ? this.value.milliseconds : 0;
  }
  onInternalKeyDown(keyEvent) {
    if (keyEvent.key === "ArrowUp") {
      this.doSpinUp();
    } else if (keyEvent.key === "ArrowDown") {
      this.doSpinDown();
    }
  }
  doSpinUp() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) + me.step;
    me._isUserAction = true;
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.value = newValue;
    }
    me._isUserAction = false;
  }
  doSpinDown() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) - me.step;
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue) && (me.allowNegative || (me.magnitude || 0) > 0)) {
      me._isUserAction = true;
      me.value = newValue;
      me._isUserAction = false;
    }
  }
};
__publicField(DurationField, "$name", "DurationField");
__publicField(DurationField, "type", "durationfield");
__publicField(DurationField, "alias", "duration");
DurationField.initClass();
DurationField._$name = "DurationField";

// ../Core/lib/Core/widget/layout/Fit.js
var Fit = class extends Layout {
};
__publicField(Fit, "$name", "Fit");
__publicField(Fit, "type", "fit");
__publicField(Fit, "configurable", {
  containerCls: "b-fit-container",
  itemCls: "b-fit-item"
});
Fit.initClass();
Fit._$name = "Fit";

// ../Core/lib/Core/widget/Editor.js
var Editor = class extends Container {
  //endregion
  //region Events
  /**
   * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
   * @event beforeStart
   * @param {HTMLElement} target The element which the Editor is to overlay to edit its content.
   * @param {Core.data.Model} [record] The record being edited.
   * @param {String} [field] The name of the field if a record is being edited.
   * @param {Object} value - The value to be edited.
   * @param {String|AlignSpec} align - How to align the editor.
   * @param {Boolean} hideTarget `true` if the target is to be hidden during the edit.
   * @param {Boolean|Object} matchSize Whether to match the target size. See {@link #config-matchSize}
   * @param {Boolean} matchSize.width Match width
   * @param {Boolean} matchSize.height Match height
   * @param {Boolean} matchFont Whether to match the target's font. See {@link #config-matchFont}
   * @param {Boolean} focus Whether to focus the editor's field.
   * @preventable
   */
  /**
   * Fired when an edit operation has begun.
   * @event start
   * @param {Object} value - The starting value of the field.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
   * The completion may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeComplete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @param {Function} [finalize] An async function may be injected into this property
   * which performs asynchronous finalization tasks such as complex validation of confirmation. The
   * value `true` or `false` must be returned.
   * @param {Object} [finalize.context] An object describing the editing context upon requested completion of the edit.
   * @preventable
   */
  /**
   * Edit has been completed, and any associated record or element has been updated.
   * @event complete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
   * The cancellation may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeCancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been canceled without updating the associated record or element.
   * @event cancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The value of the field.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fire to relay a `keydown` event from the field.
   * @event keyDown
   * @param {Event} event - The key event.
   */
  //endregion
  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.onTargetSizeChange = me.onTargetSizeChange.bind(me);
    EventHelper.on({
      element: me.element,
      keydown: "onEditorKeyDown",
      contextmenu: "stopMouseEvents",
      mousedown: "stopMouseEvents",
      mouseover: "stopMouseEvents",
      mouseout: "stopMouseEvents",
      mouseup: "stopMouseEvents",
      click: "stopMouseEvents",
      dblclick: "stopMouseEvents",
      thisObj: me
    });
    me.ion({
      beforeHide: "beforeEditorHide",
      hide: "afterEditorHide"
    });
    LocaleManager_default.ion({
      locale: "onLocaleChange",
      thisObj: me
    });
  }
  onLocaleChange() {
    const { inputField } = this;
    if (inputField && !inputField.isDestroyed) {
      if (inputField.syncInputFieldValue) {
        inputField.syncInputFieldValue(true);
      } else if (!(inputField instanceof Field)) {
      }
    }
  }
  render(renderTo) {
    const oldParent = this.element.parentNode, [parentElement] = this.getRenderContext(this, renderTo);
    parentElement.classList.add("b-editing");
    super.render(...arguments);
    if ((oldParent == null ? void 0 : oldParent.classList) && parentElement !== oldParent) {
      oldParent.classList.remove("b-editing");
    }
  }
  /**
   * Start editing
   * @param {Object} editObject An object containing details about what to edit.
   * @param {HTMLElement|Core.helper.util.Rectangle} editObject.target the element or Rectangle to align to.
   * @param {String} [editObject.align=t0-t0] How to align to the target.
   * @param {Boolean} [editObject.matchSize=true] Match editor size to target size.
   * @param {Boolean} [editObject.matchFont=true] Match editor's font-size size to target's font-size.
   * @param {Core.data.Model} [editObject.record] The record to edit.
   * @param {String} [editObject.field] The field name in the record to edit. This defaults to the `name` of the
   * {@link #config-inputField}. Also if record has method set + capitalized field, method will be called, e.g. if
   * record has method named `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`,
   * `record.setFoobar(value)` will be called.
   * @param {Object} [editObject.value] The value to edit.
   * @param {Boolean} [editObject.focus=true] Focus the field.
   * @param {Boolean} [editObject.fitTargetContent] Pass `true` to allow the Editor to expand beyond the width of its
   * target element if its content overflows horizontally. This is useful if the editor has triggers to display, such
   * as a combo.
   * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an
   * {@link #event-beforeStart} listener has vetoed the edit.
   */
  async startEdit(editObject) {
    var _a4, _b, _c;
    const me = this;
    editObject = ObjectHelper.assignIf(editObject, {
      align: me.align,
      hideTarget: me.hideTarget,
      matchSize: me.matchSize,
      matchFont: me.matchFont,
      fitTargetContent: me.fitTargetContent,
      focus: true
    });
    if (me.isVisible) {
      await me.completeEdit();
    }
    if (me.trigger("beforeStart", editObject) !== false) {
      const {
        target,
        hideTarget,
        matchSize,
        matchFont,
        fitTargetContent,
        record,
        field = me.inputField.name,
        focus
      } = editObject, { inputField, appendToTargetParent } = me, { input } = inputField, targetFontSize = DomHelper.getStyleValue(target, "font-size"), targetFontFamily = DomHelper.getStyleValue(target, "font-family");
      let { value, align } = editObject;
      if (record && field) {
        me.record = record;
        me.dataField = field;
        if (value === void 0) {
          value = record.getValue(field);
        }
      }
      if (appendToTargetParent && target.nodeType === Node.ELEMENT_NODE) {
        target.parentElement.appendChild(me.element);
      }
      if (matchSize) {
        if (target instanceof HTMLElement) {
          me.updateSize(target, matchSize);
        }
        if (target instanceof HTMLElement) {
          ResizeMonitor.addResizeListener(target, me.onTargetSizeChange);
        }
      }
      if (input) {
        if (matchFont) {
          input.style.fontSize = targetFontSize;
          input.style.fontFamily = targetFontFamily;
        } else {
          input.style.fontSize = input.style.fontFamily = "";
        }
      }
      me.assigningValues = true;
      (_a4 = inputField.clearError) == null ? void 0 : _a4.call(inputField);
      if ("setValue" in inputField) {
        await inputField.setValue(value);
      } else {
        inputField.value = value;
      }
      me.assigningValues = false;
      if (typeof align === "string") {
        align = { align };
      }
      await me.showBy({
        target,
        allowTargetOut: true,
        ...align
      });
      if (fitTargetContent) {
        const overflow = input.scrollWidth - input.clientWidth;
        if (overflow > 0) {
          me.width += overflow + DomHelper.scrollBarWidth;
        }
      }
      focus && ((_b = inputField.focus) == null ? void 0 : _b.call(inputField));
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (hideTarget) {
          target.classList.add("b-hide-visibility");
        }
      }
      me.editing = true;
      const convertedValue = inputField.value;
      me.trigger("start", { value: convertedValue });
      if (Array.isArray(convertedValue) && inputField.editingRecords && ((_c = convertedValue[0]) == null ? void 0 : _c.isModel)) {
        me.oldValue = convertedValue.map((record2) => record2.copy(record2.id));
      } else {
        me.oldValue = convertedValue;
        if (Array.isArray(me.oldValue)) {
          me.oldValue = me.oldValue.slice();
        }
      }
      inputField.initialValue = me.oldValue;
      return true;
    }
    return false;
  }
  async refreshEdit() {
    if (this.isVisible) {
      const { record, dataField, inputField } = this;
      if (record && dataField) {
        const value = record.getValue(dataField);
        if (!ObjectHelper.isEqual(inputField.value, value)) {
          await inputField.setValue(value);
        }
      }
    }
  }
  finishEdit() {
    const { target, aligningToElement } = this.lastAlignSpec;
    if (aligningToElement) {
      target.classList.remove("b-editing");
      target.classList.remove("b-hide-visibility");
    }
    this.editing = false;
    this.trigger("finishEdit");
  }
  onEditorKeyDown(event) {
    var _a4;
    const me = this;
    switch (event.key) {
      case me.completeKey:
        me.completeEdit(null, event);
        event.stopImmediatePropagation();
        break;
      case me.cancelKey:
        me.cancelEdit(event);
        event.stopImmediatePropagation();
        break;
    }
    (_a4 = me.trigger) == null ? void 0 : _a4.call(me, "keyDown", { event });
  }
  stopMouseEvents(e) {
    if (!this.allowMouseEvents) {
      e.stopPropagation();
    }
  }
  onFocusOut(event) {
    super.onFocusOut(event);
    const me = this;
    if (!me.isFinishing && me.editing) {
      switch (me.blurAction) {
        case "cancel":
          me.cancelEdit(event);
          break;
        case "complete":
          me.completeEdit(null, event);
      }
    }
  }
  /**
   * Complete the edit, and, if associated with a record, update the record if possible.
   * If editing is completed, the editor is hidden.
   *
   * If the field is invalid, the `{@link #config-invalidAction}` config is used to decide
   * upon the course of action.
   *
   * If a {@link #event-beforeComplete} handler returns `false` then editing is not completed.
   *
   * If the field's values has not been changed, then editing is terminated through {@link #function-cancelEdit}.
   *
   * @returns {Boolean} `true` if editing ceased, `false` if the editor is still active.
   */
  async completeEdit(finalize, triggeredByEvent) {
    var _a4, _b, _c, _d;
    const me = this, { inputField, oldValue, record } = me, invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? "block" : me.invalidAction), { value } = inputField;
    if (!me.isVisible) {
      return;
    }
    if (!inputField.isValid && invalidAction !== "allow") {
      if (invalidAction === "block") {
        (_a4 = inputField.focus) == null ? void 0 : _a4.call(inputField);
        return false;
      } else if (invalidAction === "revert") {
        return me.cancelEdit(triggeredByEvent) !== false;
      }
    } else if (ObjectHelper.isEqual(value, oldValue)) {
      return me.cancelEdit(triggeredByEvent) !== false;
    } else {
      const context = { inputField, record, value, oldValue };
      if (me.trigger("beforeComplete", context) === false) {
        (_b = inputField.focus) == null ? void 0 : _b.call(inputField);
      } else {
        if (!finalize) {
          finalize = context.finalize || ((_c = context.editorContext) == null ? void 0 : _c.finalize);
        }
        if (finalize) {
          let result = await finalize(context);
          if (result === true) {
            me.onEditComplete();
          } else {
            if (inputField.setError) {
              const error = result || inputField.invalidValueError, clearError = () => {
                listeners();
                inputField.clearError(error);
              }, listeners = inputField.ion({
                change: clearError,
                input: clearError
              });
              inputField.setError(error);
            }
            if (invalidAction === "block") {
              (_d = inputField.focus) == null ? void 0 : _d.call(inputField);
            } else if (invalidAction === "revert") {
              await inputField.setValue(oldValue);
              result = true;
            }
            result = false;
          }
          return result;
        } else {
          me.onEditComplete();
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Cancel the edit and hide the editor.
   */
  cancelEdit(triggeredByEvent) {
    var _a4;
    const me = this, { inputField, oldValue } = me, { value } = inputField;
    if (me.editing && !me.isFinishing && me.trigger("beforeCancel", { value, oldValue, event: triggeredByEvent }) !== false) {
      (_a4 = inputField.clearError) == null ? void 0 : _a4.call(inputField);
      me.isFinishing = true;
      me.hide();
      me.trigger("cancel", { value, oldValue, event: triggeredByEvent });
      me.finishEdit();
      me.isFinishing = false;
    } else {
      return false;
    }
  }
  // Handle updating what needs to be updated.
  onEditComplete() {
    const me = this, { record, dataField, inputField, oldValue } = me, { value } = inputField;
    if (!me.isFinishing) {
      me.isFinishing = true;
      me.hide();
      if (record && (!me.instantUpdate || inputField._outstandingUpdate)) {
        const setterName = `set${StringHelper.capitalize(dataField)}`;
        if (record[setterName]) {
          record[setterName](value);
        } else {
          record.setValue(dataField, value);
        }
      }
      me.trigger("complete", { value, oldValue });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }
    super.doDestroy();
  }
  set owner(owner) {
    this._owner = owner;
  }
  // This is a positioned widget appended to a Widget's contentElement. It may have no owner link.
  // Grab the owner by finding what widget it is inside.
  get owner() {
    return this._owner || Widget.fromElement(this.element.parentNode);
  }
  changeInputField(inputField, oldInputField) {
    const me = this;
    if (oldInputField) {
      oldInputField.destroy();
    }
    if (typeof inputField === "string") {
      inputField = {
        type: inputField
      };
    }
    if (!(inputField instanceof Widget)) {
      inputField = Widget.create(inputField);
      me.createdInputField = true;
    }
    if (me.completeOnChange) {
      inputField.ion({
        change: "onInputFieldChange",
        thisObj: me
      });
    }
    inputField.parent = me;
    return inputField;
  }
  updateInputField(inputField) {
    this.removeAll();
    this.add(inputField);
  }
  get inputField() {
    return this.items[0];
  }
  onInputFieldChange() {
    if (this.containsFocus) {
      this.completeEdit();
    }
  }
  onTargetSizeChange(resizedElement, oldRect, newRect) {
    if (oldRect && newRect) {
      this.updateSize(resizedElement);
    }
  }
  updateSize(targetEl, matchSize = this.lastMatchSize) {
    const me = this, rect = Rectangle.inner(targetEl);
    me.width = matchSize.width === false ? "auto" : rect.width - me.align.offset[0];
    me.height = matchSize.height === false ? "auto" : rect.height;
    me.lastMatchSize = matchSize;
  }
  beforeEditorHide() {
    if (this.editing && !this.isFinishing) {
      this.cancelEdit();
      return false;
    }
  }
  afterEditorHide() {
    if (this.positioned) {
      this.element.remove();
    }
    ResizeMonitor.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange);
  }
};
//region Config
__publicField(Editor, "$name", "Editor");
__publicField(Editor, "type", "editor");
__publicField(Editor, "configurable", {
  positioned: true,
  hidden: true,
  layout: "fit",
  /**
   * The alignment config for how this editor aligns to a target when asked to {@link #function-startEdit}
   * @config {AlignSpec}
   * @default
   */
  align: {
    align: "t0-t0",
    offset: [0, 0]
  },
  /**
   * Controls whether to hide the target element when asked to {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  hideTarget: false,
  /**
   * Set to `true` to automatically append the Editor's element to the parent element of the element being edited.
   * @config {Boolean}
   * @default
   */
  appendToTargetParent: false,
  /**
   * By default, an Editor matches both dimensions, width and height of the element it is targeted at in the
   * {@link #function-startEdit} function.
   *
   * Configure this as false to allow the editor's configured dimensions, or its CSS-imposed dimensions size it.
   *
   * This may also operate with more granularity by specifying both dimensions in an object:
   *
   * ```javascript
   *     // Editor can exceed its target's height
   *     matchSize : {
   *         width  : true,
   *         height : false
   *     }
   * ```
   * @config {Boolean|Object}
   * @property {Boolean} width `true` to match width
   * @property {Boolean} height `true`to match height
   * @default
   */
  matchSize: true,
  /**
   * Controls whether the editor should match target element's font when asked to {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  matchFont: true,
  /**
   * Controls whether the editor should expand its width if the input field has overflow {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  fitTargetContent: false,
  /**
   * A config object, or the `type` string of the widget (usually a {@link Core.widget.Field} subclass,
   * i.e. {@link Core.widget.TextField}) which this editor will encapsulate.
   * @prp {Core.widget.Widget}
   * @accepts {InputFieldConfig|String}
   * @default
   */
  inputField: "textfield",
  /**
   * What action should be taken when focus moves out of the editor, either by `TAB` or clicking outside.
   * May be `'complete'` or `'cancel`'. Any other value results in no action being taken upon focus leaving the editor
   * leaving the application to listen for the {@link #event-focusOut} event.
   * @config {'complete'|'cancel'|null}
   * @default
   */
  blurAction: "complete",
  /**
   * The name of the `key` which completes the edit.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
   * @config {String}
   * @default
   */
  completeKey: "Enter",
  /**
   * The name of the `key` which cancels the edit.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
   * @config {String}
   * @default
   */
  cancelKey: "Escape",
  /**
   * How to handle a request to complete the edit if the field is invalid. There are three choices:
   *  - `block` The default. The edit is not exited, the field remains focused.
   *  - `allow` Allow the edit to be completed.
   *  - `revert` The field value is reverted and the edit is completed.
   * @config {'block'|'allow'|'revert'}
   * @default
   */
  invalidAction: "block",
  /**
   * Configure as `true` to have editing complete as soon as the field fires its `change` event.
   * @config {Boolean}
   * @default false
   */
  completeOnChange: null,
  isolateFields: true,
  instantUpdate: false
});
Editor.initClass();
Editor._$name = "Editor";

// ../Core/lib/Core/widget/FieldFilterPicker.js
var filterableFieldDataTypes = {
  number: true,
  boolean: true,
  string: true,
  date: true,
  duration: true,
  time: true,
  auto: true
};
var isInferrableType = {
  number: true,
  boolean: true,
  string: true
};
var isSupportedDurationField = (field) => {
  var _a4;
  return ((_a4 = field == null ? void 0 : field.column) == null ? void 0 : _a4.type) === "duration";
};
var isFilterableField = (field) => filterableFieldDataTypes[field == null ? void 0 : field.type] || isSupportedDurationField(field);
var emptyString = "";
var clsBase = `b-fieldfilterpicker`;
var multiValueOperators = {
  between: true,
  notBetween: true,
  isIncludedIn: true,
  isNotIncludedIn: true
};
var valueInputTypes = {
  textfield: true,
  datefield: true,
  numberfield: true,
  durationfield: true,
  combo: true,
  timefield: true
};
var commonOperators = {
  empty: { value: "empty", text: "L{isEmpty}", argCount: 0 },
  notEmpty: { value: "notEmpty", text: "L{isNotEmpty}", argCount: 0 },
  "=": { value: "=", text: "L{equals}" },
  "!=": { value: "!=", text: "L{doesNotEqual}" },
  ">": { value: ">", text: "L{isGreaterThan}" },
  "<": { value: "<", text: "L{isLessThan}" },
  ">=": { value: ">=", text: "L{isGreaterThanOrEqualTo}" },
  "<=": { value: "<=", text: "L{isLessThanOrEqualTo}" },
  between: { value: "between", text: "L{isBetween}", argCount: 2 },
  notBetween: { value: "notBetween", text: "L{isNotBetween}", argCount: 2 },
  isIncludedIn: { value: "isIncludedIn", text: "L{isOneOf}", isArrayValued: true },
  isNotIncludedIn: { value: "isNotIncludedIn", text: "L{isNotOneOf}", isArrayValued: true }
};
var _FieldFilterPicker = class _FieldFilterPicker extends Container {
  static get defaultValueFieldPlaceholders() {
    return {
      string: "L{enterAValue}",
      number: "L{enterANumber}",
      date: "L{selectADate}",
      relation: "L{selectValue}",
      list: "L{selectOneOrMoreValues}",
      duration: "L{enterAValue}",
      time: "L{selectATime}",
      auto: "L{enterAValue}"
    };
  }
  afterConstruct() {
    const me = this;
    if (!me._fields) {
      throw new Error(`${_FieldFilterPicker.name} requires 'fields' to be configured.`);
    }
    if (!me._filter) {
      throw new Error(`${_FieldFilterPicker.name} requires 'filter' to be configured.`);
    }
    super.afterConstruct();
    const { widgetMap: { propertyPicker, operatorPicker, caseSensitive } } = me;
    propertyPicker.ion({ select: "onPropertySelect", thisObj: me });
    operatorPicker.ion({ select: "onOperatorSelect", thisObj: me });
    caseSensitive.ion({ change: "onCaseSensitiveChange", thisObj: me });
    me.propertyFieldConfig && propertyPicker.setConfig(me.propertyFieldConfig);
    me.operatorFieldConfig && operatorPicker.setConfig(me.operatorFieldConfig);
    propertyPicker.cls = me.allPropertyPickerClasses;
    operatorPicker.cls = me.allOperatorPickerClasses;
    me.populateUIFromFilter();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  get allChildInputs() {
    const { propertyPicker, operatorPicker, caseSensitive } = this.widgetMap;
    return [propertyPicker, operatorPicker, ...this.valueFields, caseSensitive];
  }
  updateDisabled(newDisabled) {
    this.allChildInputs.forEach((field) => field.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    const { propertyPicker, operatorPicker } = this.widgetMap;
    this.allChildInputs.forEach((field) => field.readOnly = newReadOnly);
    propertyPicker.readOnly = propertyPicker.readOnly || newReadOnly;
    operatorPicker.readOnly = operatorPicker.readOnly || newReadOnly;
  }
  updatePropertyLocked(newPropertyLocked) {
    this.widgetMap.propertyPicker.readOnly = newPropertyLocked || this.readOnly;
    this.widgetMap.propertyPicker.cls = this.allPropertyPickerClasses;
  }
  updateOperatorLocked(newOperatorLocked) {
    this.widgetMap.operatorPicker.readOnly = newOperatorLocked || this.readOnly;
    this.widgetMap.operatorPicker.cls = this.allOperatorPickerClasses;
  }
  changeOperators(newOperators) {
    const operators = newOperators != null ? newOperators : _FieldFilterPicker.defaultOperators;
    return Object.keys(operators).reduce((outOperators, dataType) => ({
      ...outOperators,
      [dataType]: operators[dataType].map((op) => ({ ...op, text: this.L(op.text) }))
    }), {});
  }
  changeFields(newFields) {
    let fields = newFields;
    if (Array.isArray(newFields)) {
      VersionHelper.deprecate("Core", "6.0.0", "FieldOption[] deprecated, use Object<String, FieldOption> keyed by field name instead");
      fields = ArrayHelper.keyBy(fields, "name");
    }
    return fields;
  }
  get isMultiSelectValueField() {
    var _a4;
    return ["isIncludedIn", "isNotIncludedIn"].includes((_a4 = this._filter) == null ? void 0 : _a4.operator);
  }
  get allPropertyPickerClasses() {
    var _a4;
    return new DomClassList(`${clsBase}-property`, (_a4 = this.propertyFieldConfig) == null ? void 0 : _a4.cls, {
      [`${clsBase}-combo-locked`]: this.propertyLocked
    });
  }
  get allOperatorPickerClasses() {
    var _a4;
    return new DomClassList(`${clsBase}-operator`, (_a4 = this.operatorFieldConfig) == null ? void 0 : _a4.cls, {
      [`${clsBase}-combo-locked`]: this.operatorLocked
    });
  }
  getValueFieldConfigs() {
    const me = this, {
      valueFieldCls,
      fieldType,
      _filter: { operator },
      onValueChange,
      filterValues,
      isMultiSelectValueField,
      operatorArgCount,
      getValueFieldConfig,
      fieldIsRelation,
      triggerChangeOnInput
    } = me, valueFieldPlaceholders = ObjectHelper.merge(
      {},
      _FieldFilterPicker.defaultValueFieldPlaceholders,
      me.valueFieldPlaceholders
    );
    if (!fieldType || !operator || operatorArgCount === 0) {
      return [];
    }
    let valueFieldCfg = {
      type: "textfield",
      // replaced as needed below
      internalListeners: {
        change: onValueChange,
        input: triggerChangeOnInput ? onValueChange : null,
        thisObj: me
      },
      bubbleEvents: { keydown: true },
      cls: valueFieldCls,
      dataset: {
        type: fieldType
      },
      placeholder: me.L(valueFieldPlaceholders[isMultiSelectValueField ? "list" : fieldIsRelation ? "relation" : fieldType]),
      highlightExternalChange: false
    };
    if (isMultiSelectValueField || fieldIsRelation) {
      valueFieldCfg = {
        ...valueFieldCfg,
        type: "combo",
        multiSelect: isMultiSelectValueField,
        createOnUnmatched: true,
        items: me.getUniqueDataValues(filterValues),
        value: filterValues != null ? filterValues : []
      };
    } else if (["number", "date", "boolean", "duration", "time"].includes(fieldType)) {
      valueFieldCfg.type = `${fieldType}field`;
    }
    if (getValueFieldConfig) {
      valueFieldCfg = me.callback(getValueFieldConfig, me, [me.filter, valueFieldCfg]);
    }
    if (isMultiSelectValueField) {
      return [valueFieldCfg];
    }
    return ArrayHelper.populate(operatorArgCount, (index) => [{
      type: "widget",
      tag: "div",
      cls: `${clsBase}-value-separator`,
      content: me.L("L{FieldFilterPicker.and}")
    }, {
      ...valueFieldCfg,
      value: filterValues[index]
    }]).flat().slice(1);
  }
  /**
   * Return an array of unique values in the data store for the currently selected field. If no store is
   * configured or no field is selected, returns an empty array.
   */
  getUniqueDataValues(extraValuesToInclude = []) {
    var _a4;
    const me = this, { fieldType } = me;
    if (!me.store || !((_a4 = me._filter) == null ? void 0 : _a4.property)) {
      return [];
    }
    const { relatedDisplayField } = me.selectedField;
    let values, sortedValues;
    if (me.fieldIsRelation) {
      const { foreignStore } = me.currentPropertyRelationConfig;
      if (relatedDisplayField) {
        values = foreignStore.allRecords.reduce((options, record) => {
          if (record.id != null) {
            options.push({
              text: record.getValue(relatedDisplayField),
              value: record.id
            });
          }
          return options;
        }, []);
        sortedValues = values.sort((a, b) => me.sortStrings(a.text, b.text));
      } else {
        values = foreignStore.allRecords.map((record) => record.id);
      }
    } else {
      values = me.store.allRecords.map((record) => record.getValue(me._filter.property));
    }
    if (!sortedValues) {
      values.push(...extraValuesToInclude);
      const uniqueValues = ArrayHelper.unique(values.reduce((primitiveValues, value) => {
        if (value != null && String(value).trim() !== "") {
          if (fieldType === "date") {
            primitiveValues.push(value.valueOf());
          } else if (fieldType === "duration") {
            primitiveValues.push(value.toString());
          } else {
            primitiveValues.push(value);
          }
        }
        return primitiveValues;
      }, []));
      if (fieldType === "string") {
        sortedValues = uniqueValues.sort(me.sortStrings);
      } else if (fieldType === "duration") {
        sortedValues = uniqueValues.map((durationStr) => new Duration(durationStr)).filter((duration) => duration.isValid).sort(me.sortDurations);
      } else {
        sortedValues = uniqueValues.sort(me.sortNumerics);
      }
      if (fieldType === "date") {
        sortedValues = sortedValues.map((timestamp) => {
          const date = new Date(timestamp);
          return {
            text: DateHelper.format(date, me.dateFormat),
            value: timestamp
          };
        });
      } else if (fieldType === "duration") {
        sortedValues = sortedValues.map((duration) => duration.toString());
      }
    }
    return sortedValues;
  }
  sortStrings(a, b) {
    return (a != null ? a : emptyString).localeCompare(b != null ? b : emptyString);
  }
  sortNumerics(a, b) {
    return a - b;
  }
  sortDurations(a, b) {
    return a.valueOf() - b.valueOf();
  }
  get fieldType() {
    var _a4;
    return (_a4 = this.selectedField) == null ? void 0 : _a4.type;
  }
  get selectedField() {
    var _a4, _b;
    return (_b = this.fields) == null ? void 0 : _b[(_a4 = this._filter) == null ? void 0 : _a4.property];
  }
  get propertyOptions() {
    var _a4;
    return Object.entries((_a4 = this.fields) != null ? _a4 : {}).filter(
      ([, fieldDef]) => filterableFieldDataTypes[fieldDef.type] || isSupportedDurationField(fieldDef)
    ).map(([fieldName, { title }]) => ({ value: fieldName, text: title != null ? title : fieldName })).sort((a, b) => a.text.localeCompare(b.text));
  }
  get operatorOptions() {
    return this.operators[this.fieldIsRelation ? "relation" : this.fieldType];
  }
  get fieldIsRelation() {
    return Boolean(this.currentPropertyRelationConfig);
  }
  get currentPropertyRelationConfig() {
    var _a4, _b;
    return (_b = (_a4 = this.store) == null ? void 0 : _a4.modelRelations) == null ? void 0 : _b.find(({ foreignKey }) => {
      var _a5;
      return foreignKey === ((_a5 = this._filter) == null ? void 0 : _a5.property);
    });
  }
  updateOperators() {
    delete this._operatorArgCountLookup;
  }
  /**
   * @internal
   */
  get operatorArgCountLookup() {
    return this._operatorArgCountLookup || (this._operatorArgCountLookup = _FieldFilterPicker.buildOperatorArgCountLookup(this.operators));
  }
  updateFilter() {
    if (this._filter) {
      this.onFilterChange();
    }
  }
  updateStore(newStore) {
    var _a4;
    (_a4 = this._store) == null ? void 0 : _a4.un(this);
    newStore == null ? void 0 : newStore.ion({ refresh: "onStoreRefresh", thisObj: this });
    this.inferFieldTypes();
  }
  onStoreRefresh({ action }) {
    if (this.isMultiSelectValueField && ["dataset", "create", "update", "delete"].includes(action)) {
      this.valueFields[0].items = this.getUniqueDataValues(this.filterValues);
    }
  }
  refreshValueFields() {
    const me = this, { valueFields } = me.widgetMap, {
      fieldType,
      operatorArgCount,
      _filter: { property, operator }
    } = me, isMultiValue = multiValueOperators[operator];
    valueFields.element.className = new DomClassList({
      [`${clsBase}-values`]: true,
      [`${clsBase}-values-multiple`]: isMultiValue,
      [`${clsBase}-values-${fieldType}`]: fieldType !== void 0,
      "b-hidden": property == void 0 || operator == void 0 || operatorArgCount === 0
    });
    valueFields.removeAll();
    valueFields.add(me.getValueFieldConfigs());
    delete me._valueFields;
    me.refreshCaseSensitive();
  }
  refreshCaseSensitive() {
    var _a4, _b;
    const me = this, { fieldType, operatorArgCount, isMultiSelectValueField } = me, operator = (_a4 = me._filter) == null ? void 0 : _a4.operator, { caseSensitive } = me.widgetMap;
    caseSensitive.hidden = fieldType !== "string" || !operator || isMultiSelectValueField || operatorArgCount === 0;
    caseSensitive.checked = ((_b = me._filter) == null ? void 0 : _b.caseSensitive) !== false;
  }
  onPropertySelect(event) {
    var _a4;
    const me = this, { _filter } = me;
    _filter.property = ((_a4 = event.record) == null ? void 0 : _a4.data.value) || null;
    if (me.fieldType !== me._fieldType) {
      _filter.operator = null;
      _filter.value = null;
    }
    me._fieldType = _filter.type = me.fieldType;
    me.refreshOperatorPicker();
    me.refreshValueFields();
    me.triggerChange();
  }
  onCaseSensitiveChange({ checked }) {
    this._filter.caseSensitive = checked;
    this.triggerChange();
  }
  onOperatorSelect(event) {
    var _a4;
    const me = this, wasMultiSelectValueField = me.isMultiSelectValueField;
    const prevArgCount = this.operatorArgCount;
    me._filter.operator = ((_a4 = event.record) == null ? void 0 : _a4.data.value) || null;
    if (me.operatorArgCount !== prevArgCount) {
      me._filter.value = null;
    }
    if (me.isMultiSelectValueField && !wasMultiSelectValueField) {
      me._filter.value = [];
    }
    me.refreshValueFields();
    me.triggerChange();
  }
  triggerChange() {
    const { filter, isValid } = this;
    this.trigger("change", {
      filter,
      isValid
    });
  }
  onValueChange() {
    const me = this, { isMultiSelectValueField, fieldType, _filter } = me, values = this.valueFields.map((field) => field.value);
    if (isMultiSelectValueField && fieldType === "date") {
      _filter.value = values[0].map((timestamp) => new Date(timestamp));
    } else if (isMultiSelectValueField && fieldType === "duration") {
      _filter.value = values[0].map((durationStr) => new Duration(durationStr));
    } else {
      if (fieldType === "date" && _filter.operator === "between" && DateHelper.isValidDate(values[1])) {
        values[1].setHours(23, 59, 59, 999);
      }
      _filter.value = values.length === 1 ? values[0] : values;
    }
    me.triggerChange();
  }
  refreshOperatorPicker() {
    const { operatorPicker } = this.widgetMap, { _filter: { operator, property }, operatorOptions } = this;
    operatorPicker.items = operatorOptions;
    operatorPicker.value = operator;
    operatorPicker.hidden = property === null;
  }
  populateUIFromFilter(forceRefreshValueFields = false) {
    const me = this, {
      filterValues,
      widgetMap: { propertyPicker, operatorPicker },
      _filter: { property, operator, disabled },
      propertyOptions,
      operatorOptions,
      isMultiSelectValueField
    } = me;
    propertyPicker.items = propertyOptions;
    operatorPicker.items = operatorOptions;
    operatorPicker.hidden = property === null;
    let refreshValueFields = forceRefreshValueFields;
    if (propertyPicker.value !== property) {
      propertyPicker.value = property;
      me.refreshOperatorPicker();
      refreshValueFields = true;
    }
    if (operatorPicker.value !== operator) {
      if (operator === null || !operatorPicker.items.find(({ value }) => value === operator)) {
        operatorPicker.clear();
      } else {
        operatorPicker.value = operator;
      }
      refreshValueFields = true;
    }
    if (!operator && operatorPicker.items.length === 1) {
      operatorPicker.value = me._filter.operator = operatorPicker.items[0].value;
    }
    if (refreshValueFields) {
      me.refreshValueFields();
    }
    me.refreshCaseSensitive();
    me.valueFields.forEach((valueField, fieldIndex) => {
      if (isMultiSelectValueField && (valueField.value.length > 0 || filterValues.length > 0)) {
        if (me.fieldType === "date") {
          valueField.value = filterValues.map((date) => date == null ? void 0 : date.valueOf());
        } else if (me.fieldType === "duration") {
          valueField.value = filterValues.map((duration) => duration == null ? void 0 : duration.toString());
        } else {
          valueField.value = filterValues;
        }
      } else if (fieldIndex >= filterValues.length) {
        valueField.clear();
      } else {
        valueField.value = filterValues[fieldIndex];
      }
    });
    me.allChildInputs.forEach((widget) => widget.disabled = me.disabled || disabled);
  }
  get valueFields() {
    return this._valueFields || (this._valueFields = this.widgetMap.valueFields.queryAll(
      (w) => w.owner === this.widgetMap.valueFields && valueInputTypes[w.type]
    ));
  }
  get filterValues() {
    var _a4;
    if (((_a4 = this._filter) == null ? void 0 : _a4.value) == null) {
      return [];
    }
    return ArrayHelper.asArray(this._filter.value);
  }
  // Must be called manually when filter modified externally
  onFilterChange() {
    const me = this, newFieldType = me.fieldType, forceRefreshValueFields = newFieldType !== me._fieldType;
    me._fieldType = me._filter.type = newFieldType;
    me.populateUIFromFilter(forceRefreshValueFields);
  }
  get operatorArgCount() {
    const { fieldType, filter: { operator }, operatorArgCountLookup } = this;
    return fieldType && operator ? operatorArgCountLookup[fieldType][operator] : 1;
  }
  get isValid() {
    const me = this, { filter, fieldType, filterValues, isMultiSelectValueField, operatorArgCount } = me, { operator } = filter, missingValue = operatorArgCount > 0 && (filter == null ? void 0 : filter.value) == null;
    return (
      // fieldType here validates that we have a matching field
      fieldType && operator && !missingValue && (isMultiSelectValueField && filterValues.length > 0 || filterValues.length === operatorArgCount) && filterValues.every((value) => value != null && (fieldType !== "duration" || value.isValid))
    );
  }
  get focusElement() {
    var _a4, _b, _c, _d;
    return (_d = (_c = (_b = (_a4 = this.valueFields.find((f) => f.isEmptyInput)) != null ? _a4 : this.operatorPicker) != null ? _b : this.propertyPicker) == null ? void 0 : _c.input) != null ? _d : super.focusElement;
  }
  inferFieldTypes() {
    if (this.store && this.fields) {
      for (const [fieldName, fieldDef] of Object.entries(this.fields)) {
        if (fieldDef.type === "auto") {
          fieldDef.type = _FieldFilterPicker.inferFieldType(this.store, fieldName);
        }
      }
    }
  }
  static inferFieldType(store, fieldName) {
    var _a4;
    const firstValue = (_a4 = store.find((record) => record.getValue(fieldName) != null, true)) == null ? void 0 : _a4.getValue(fieldName);
    if (firstValue !== void 0) {
      const valueType = typeof firstValue;
      if (valueType === "object" && firstValue instanceof Date) {
        return "date";
      } else if (isInferrableType[valueType]) {
        return valueType;
      }
    }
    return "auto";
  }
};
//region Config
__publicField(_FieldFilterPicker, "$name", "FieldFilterPicker");
__publicField(_FieldFilterPicker, "type", "fieldfilterpicker");
__publicField(_FieldFilterPicker, "operators", {
  empty: { value: "empty", text: "L{isEmpty}", argCount: 0 },
  notEmpty: { value: "notEmpty", text: "L{isNotEmpty}", argCount: 0 },
  "=": { value: "=", text: "L{equals}" },
  "!=": { value: "!=", text: "L{doesNotEqual}" },
  ">": { value: ">", text: "L{isGreaterThan}" },
  "<": { value: "<", text: "L{isLessThan}" },
  ">=": { value: ">=", text: "L{isGreaterThanOrEqualTo}" },
  "<=": { value: "<=", text: "L{isLessThanOrEqualTo}" },
  between: { value: "between", text: "L{isBetween}", argCount: 2 },
  notBetween: { value: "notBetween", text: "L{isNotBetween}", argCount: 2 },
  isIncludedIn: { value: "isIncludedIn", text: "L{isOneOf}" },
  isNotIncludedIn: { value: "isNotIncludedIn", text: "L{isNotOneOf}" }
});
__publicField(_FieldFilterPicker, "defaultOperators", {
  string: [
    // In display order
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    { value: "includes", text: "L{contains}" },
    { value: "doesNotInclude", text: "L{doesNotContain}" },
    { value: "startsWith", text: "L{startsWith}" },
    { value: "endsWith", text: "L{endsWith}" },
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  number: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators[">"],
    commonOperators["<"],
    commonOperators[">="],
    commonOperators["<="],
    commonOperators.between,
    commonOperators.notBetween,
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  date: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    { value: "<", text: "L{isBefore}" },
    { value: ">", text: "L{isAfter}" },
    commonOperators.between,
    { value: "isToday", text: "L{isToday}", argCount: 0 },
    { value: "isTomorrow", text: "L{isTomorrow}", argCount: 0 },
    { value: "isYesterday", text: "L{isYesterday}", argCount: 0 },
    { value: "isThisWeek", text: "L{isThisWeek}", argCount: 0 },
    { value: "isNextWeek", text: "L{isNextWeek}", argCount: 0 },
    { value: "isLastWeek", text: "L{isLastWeek}", argCount: 0 },
    { value: "isThisMonth", text: "L{isThisMonth}", argCount: 0 },
    { value: "isNextMonth", text: "L{isNextMonth}", argCount: 0 },
    { value: "isLastMonth", text: "L{isLastMonth}", argCount: 0 },
    { value: "isThisYear", text: "L{isThisYear}", argCount: 0 },
    { value: "isNextYear", text: "L{isNextYear}", argCount: 0 },
    { value: "isLastYear", text: "L{isLastYear}", argCount: 0 },
    { value: "isYearToDate", text: "L{isYearToDate}", argCount: 0 },
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  boolean: [
    { value: "isTrue", text: "L{isTrue}", argCount: 0 },
    { value: "isFalse", text: "L{isFalse}", argCount: 0 }
  ],
  duration: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators[">"],
    commonOperators["<"],
    commonOperators[">="],
    commonOperators["<="],
    commonOperators.between,
    commonOperators.notBetween,
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  time: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators[">"],
    commonOperators["<"],
    commonOperators[">="],
    commonOperators["<="],
    commonOperators.between,
    commonOperators.notBetween,
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  relation: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  auto: [
    { value: "*", text: "L{contains}" }
  ]
});
__publicField(_FieldFilterPicker, "configurable", {
  /**
   * Dictionary of {@link #typedef-FieldOption} representing the fields against which filters can be defined,
   * keyed by field name.
   *
   * <div class="note">5.3.0 Syntax accepting FieldOption[] was deprecated in favor of dictionary and will be removed in 6.0</div>
   *
   * If filtering a {@link Grid.view.Grid}, consider using {@link Grid.widget.GridFieldFilterPicker}, which can be configured
   * with an existing {@link Grid.view.Grid} instead of, or in combination with, defining fields manually.
   *
   * Example:
   * ```javascript
   * fields: {
   *     // Allow filters to be defined against the 'age' and 'role' fields in our data
   *     age  : { title: 'Age', type: 'number' },
   *     role : { title: 'Role', type: 'string' }
   * }
   * ```
   *
   * @config {Object<String,FieldOption>}
   */
  fields: null,
  /**
   * Make the entire picker disabled.
   *
   * @config {Boolean}
   * @default
   */
  disabled: false,
  /**
   * Make the entire picker read-only.
   *
   * @config {Boolean}
   * @default
   */
  readOnly: false,
  layout: "vbox",
  /**
   * Make only the property selector readOnly.
   * @private
   *
   * @config {Boolean}
   * @default
   */
  propertyLocked: false,
  /**
   * Make only the operator selector readOnly.
   * @private
   *
   * @config {Boolean}
   * @default
   */
  operatorLocked: false,
  /**
   * Configuration object for the {@link Core.util.CollectionFilter} displayed
   * and editable in this picker.
   *
   * Example:
   *
   * ```javascript
   * {
   *     property: 'age',
   *     operator: '=',
   *     value: 25
   * }
   * ```
   *
   * @config {CollectionFilterConfig}
   */
  filter: null,
  /**
   * Optional configuration for the property selector {@link Core.widget.Combo}.
   *
   * @config {ComboConfig}
   */
  propertyFieldConfig: null,
  /**
   * Optional configuration for the operator selector {@link Core.widget.Combo}.
   *
   * @config {ComboConfig}
   * @private
   */
  operatorFieldConfig: null,
  /**
   * Optional CSS class to apply to the value field(s).
   *
   * @config {String}
   * @private
   */
  valueFieldCls: null,
  /**
   * Whether to raise {@link #event-change} events as the user types into a value field. If `false`,
   * {@link #event-change} events will be raised only when the value input field's own `change` event
   * occurs, for example on field blur.
   *
   * @config {Boolean}
   * @default
   */
  triggerChangeOnInput: true,
  /**
   * @private
   */
  items: {
    inputs: {
      type: "container",
      layout: "hbox",
      cls: `${clsBase}-inputs`,
      items: {
        propertyPicker: {
          type: "combo",
          items: {},
          cls: `${clsBase}-property`,
          placeholder: "L{FieldFilterPicker.selectAProperty}",
          highlightExternalChange: false
        },
        operatorPicker: {
          type: "combo",
          items: {},
          cls: `${clsBase}-operator`,
          placeholder: "L{FieldFilterPicker.selectAnOperator}",
          highlightExternalChange: false
        },
        valueFields: {
          type: "container",
          cls: `${clsBase}-values`,
          items: {}
        }
      }
    },
    caseSensitive: {
      type: "checkbox",
      text: "L{FieldFilterPicker.caseSensitive}",
      cls: `${clsBase}-case-sensitive`
    }
  },
  /**
   * Overrides the built-in list of operators that are available for selection. Specify operators as
   * an object with data types as keys and lists of operators as values, like this:
   *
   * ```javascript
   * operators : {
   *     string : [
   *         { value : 'empty', text : 'is empty', argCount : 0 },
   *         { value : 'notEmpty', text : 'is not empty', argCount : 0 }
   *     ],
   *     number : [
   *         { value : '=', text : 'equals' },
   *         { value : '!=', text : 'does not equal' }
   *     ],
   *     date : [
   *         { value : '<', text : 'is before' }
   *     ]
   * }
   * ```
   *
   * Here `value` is what will be stored in the `operator` field in the filter when selected, `text` is the text
   * displayed in the Combo for selection, and `argCount` is the number of arguments (comparison values) the
   * operator requires. The default argCount if not specified is 1.
   *
   * **Note:** The operators config is a subset of valid operators described in {@link Core.util.CollectionFilter#typedef-CollectionCompareOperator}.
   * The use of any other operator apart from these is not supported and will lead to unexpected behavior.
   *
   * @config {Object}
   */
  operators: _FieldFilterPicker.defaultOperators,
  /**
   * The date format string used to display dates when using the 'is one of' / 'is not one of' operators with a date
   * field. Defaults to the current locale's `FieldFilterPicker.dateFormat` value.
   *
   * @config {String}
   * @default
   */
  dateFormat: "L{FieldFilterPicker.dateFormat}",
  /**
   * Optional {Core.data.Store} against which filters are being defined. This is used to supply options to filter against
   * when using the 'is one of' and 'is not one of' operators.
   *
   * @config {Core.data.Store}
   */
  store: null,
  /**
   * Optional {@link ValueFieldPlaceholders} object specifying custom placeholder text for value input fields.
   *
   * @config {ValueFieldPlaceholders}
   */
  valueFieldPlaceholders: null,
  /**
   * Optional function that modifies the configuration of value fields shown for a filter. The default configuration
   * is received as an argument and the returned value will be used as the final configuration. For example:
   *
   * ```javascript
   * getValueFieldConfig : (filter, fieldConfig) => {
   *     return {
   *         ...fieldConfig,
   *         title : fieldName    // Override the `title` config for the field
   *     };
   * }
   * ```
   *
   * The supplied function should accept the following arguments:
   *
   * @config {Function}
   * @param {Core.util.CollectionFilter} filter The filter being displayed
   * @param {ContainerItemConfig} fieldConfig Configuration object for the value field
   * @returns {ContainerItemConfig} the resulting configuration
   */
  getValueFieldConfig: null
});
//endregion
// Make lookup of operator arity (arg count) by [fieldType][operator]
__publicField(_FieldFilterPicker, "buildOperatorArgCountLookup", (operators) => ArrayHelper.keyBy(
  Object.entries(operators),
  ([fieldType]) => fieldType,
  ([, operators2]) => ArrayHelper.keyBy(
    operators2,
    ({ value }) => value,
    ({ argCount }) => argCount === void 0 ? 1 : argCount
  )
));
var FieldFilterPicker = _FieldFilterPicker;
FieldFilterPicker.initClass();
FieldFilterPicker._$name = "FieldFilterPicker";

// ../Core/lib/Core/widget/Label.js
var Label = class extends Widget {
  compose() {
    const { text, html } = this;
    return {
      tag: "label",
      text,
      html
    };
  }
};
__publicField(Label, "$name", "Label");
__publicField(Label, "type", "label");
__publicField(Label, "configurable", {
  /**
   * Get/set label text
   * @prp {String}
   */
  text: null,
  localizableProperties: ["text"]
});
Label.initClass();
Label._$name = "Label";

// ../Core/lib/Core/widget/FieldFilterPickerGroup.js
var _FieldFilterPickerGroup = class _FieldFilterPickerGroup extends Container {
  afterConstruct() {
    const me = this;
    me.validateConfig();
    const { addFilterButton } = me.widgetMap;
    addFilterButton.ion({ click: "addFilter", thisObj: me });
    addFilterButton.text = me.L(addFilterButton.text);
    me.store && me.updateStore(me.store);
    super.afterConstruct();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  validateConfig() {
    if (!this.fields && !this.store) {
      throw new Error(
        `FieldFilterPickerGroup requires either a 'fields' or 'store' config property.`
      );
    }
  }
  updateFields(newFields) {
    this.widgetMap.pickers.childItems.forEach((picker) => picker.fields = newFields);
  }
  updateFilters(newFilters, oldFilters) {
    const me = this;
    if (oldFilters) {
      oldFilters.filter((filter) => !newFilters.find((newFilter) => newFilter.id === filter.id)).forEach((filter) => {
        var _a4;
        return (_a4 = me.store) == null ? void 0 : _a4.removeFilter(filter.id);
      });
    }
    newFilters.forEach((filter) => filter.id = filter.id || me.nextFilterId);
    me.widgetMap.pickers.items = (newFilters == null ? void 0 : newFilters.map((filter) => me.getPickerRowConfig(filter))) || [];
  }
  changeFilters(newFilters) {
    const { canManageFilter } = this;
    return newFilters && canManageFilter ? newFilters.filter((filter) => this.callback(canManageFilter, this, [filter])) : newFilters;
  }
  updateStore(newStore) {
    const me = this;
    me.detachListeners("store");
    if (newStore) {
      me.widgetMap.pickers.childItems.forEach(({ widgetMap: { filterPicker: { filter, isValid } } }) => {
        newStore.removeFilter(filter.id, true);
        if (isValid) {
          newStore.addFilter(filter, true);
        }
      });
      newStore.filter();
      me.appendFiltersFromStore();
      newStore.ion({
        name: "store",
        filter: "onStoreFilter",
        thisObj: me
      });
    }
    me.widgetMap.pickers.childItems.forEach((picker) => picker.store = newStore);
  }
  updateShowAddFilterButton(newShow) {
    this.widgetMap.addFilterButton.hidden = !newShow;
  }
  updateAddFilterButtonText(newText) {
    this.widgetMap.addFilterButton.text = newText != null ? newText : _FieldFilterPickerGroup.addFilterButtonDefaultText;
  }
  /**
   * Find any filters the store has that we don't know about yet, and add to our list
   * @private
   */
  appendFiltersFromStore() {
    const me = this;
    me.store.filters.forEach((filter) => {
      var _a4;
      const canManage = me.canManage(filter), { property, operator, id } = filter;
      if (canManage && property && operator && !((_a4 = me.filters) == null ? void 0 : _a4.find((filter2) => filter2.id === id))) {
        me.appendFilter(filter);
      }
    });
  }
  /**
   * @private
   */
  canManage(filter) {
    const me = this;
    return !me.canManageFilter || me.callback(me.canManageFilter, me, [filter]) === true;
  }
  /**
   * Get the configuration object for one child FieldFilterPicker.
   * @param {Core.util.CollectionFilter} filter The filter represented by the child FieldFilterPicker
   * @returns {Object} The FieldFilterPicker configuration
   */
  getFilterPickerConfig(filter) {
    const me = this, {
      fields,
      store,
      disabled,
      readOnly,
      valueFieldCls,
      operators,
      limitToProperty,
      dateFormat,
      getFieldFilterPickerConfig,
      triggerChangeOnInput
    } = me;
    return {
      type: me.constructor.childPickerType,
      fields: fields != null ? fields : me.getFieldsFromStore(store),
      filter,
      store,
      disabled,
      readOnly,
      propertyLocked: Boolean(limitToProperty),
      valueFieldCls,
      operators,
      dateFormat,
      internalListeners: {
        change: "onFilterPickerChange",
        thisObj: me
      },
      flex: 1,
      triggerChangeOnInput,
      ...getFieldFilterPickerConfig ? me.callback(getFieldFilterPickerConfig, me, [filter]) : void 0
    };
  }
  /**
   * Get store fields as {@link Core.widget.FieldFilterPicker#typedef-FieldOption}s in a dictionary keyed by name.
   * @private
   */
  getFieldsFromStore(store) {
    var _a4, _b;
    return Object.fromEntries((_b = (_a4 = store.modelClass) == null ? void 0 : _a4.fields.map(({ name, type }) => [name, { type }])) != null ? _b : []);
  }
  getPickerRowConfig(filter) {
    const me = this, { disabled, readOnly, canDeleteFilter } = me, canDelete = !(canDeleteFilter && me.callback(canDeleteFilter, me, [filter]) === false);
    return {
      type: "container",
      layout: "box",
      cls: {
        [`b-${_FieldFilterPickerGroup.type}-row`]: true,
        [`b-${_FieldFilterPickerGroup.type}-row-removable`]: canDelete
      },
      dataset: {
        separatorText: me.L("L{FieldFilterPicker.and}")
      },
      items: {
        activeCheckbox: {
          type: "checkbox",
          disabled,
          readOnly,
          checked: !Boolean(filter.disabled),
          internalListeners: {
            change: "onFilterActiveChange",
            thisObj: me
          },
          cls: `b-${_FieldFilterPickerGroup.type}-filter-active`
        },
        filterPicker: me.getFilterPickerConfig(filter),
        removeButton: {
          type: "button",
          ref: "removeButton",
          disabled,
          readOnly,
          hidden: !canDelete,
          cls: `b-transparent b-${_FieldFilterPickerGroup.type}-remove`,
          icon: "b-fa-trash",
          internalListeners: {
            click: "removeFilter",
            thisObj: me
          }
        }
      }
    };
  }
  get allInputs() {
    const childInputTypes = [this.constructor.childPickerType, "button", "checkbox"];
    return this.queryAll((w) => childInputTypes.includes(w.type));
  }
  updateDisabled(newDisabled) {
    this.allInputs.forEach((input) => input.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    this.allInputs.forEach((input) => input.readOnly = newReadOnly);
  }
  onFilterActiveChange({ source, checked }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter = me.filters[filterIndex], filterPicker = me.getFilterPicker(filterIndex);
    filter.disabled = !checked;
    filterPicker.onFilterChange();
    if (me.store && filterPicker.isValid) {
      me.store.addFilter(filter, true);
    }
    me.updateStoreFilter();
    me.triggerChange();
  }
  onFilterPickerChange({ source, filter, isValid }) {
    const me = this, { store } = me, filterIndex = me.getFilterIndex(source);
    if (store) {
      store.removeFilter(filter.id, true);
      if (isValid) {
        store.addFilter(filter, true);
      }
      me.updateStoreFilter();
    }
    Object.assign(me.filters[filterIndex], filter);
    me.triggerChange();
  }
  getFilterIndex(eventSource) {
    return parseInt(eventSource.parent.element.dataset.itemIndex);
  }
  getPickerRow(index) {
    return this.widgetMap.pickers.childItems[index];
  }
  /**
   * Return the {@link Core.widget.FieldFilterPicker} for the filter at the specified index.
   * @param {Number} filterIndex
   * @returns {Core.widget.FieldFilterPicker}
   */
  getFilterPicker(filterIndex) {
    return this.getPickerRow(filterIndex).widgetMap.filterPicker;
  }
  get nextFilterId() {
    this._nextId = (this._nextId || 0) + 1;
    return `${this.id}-filter-${this._nextId}`;
  }
  removeFilter({ source }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter = me.filters[filterIndex], pickerRow = me.getPickerRow(filterIndex), newFocusWidget = me.query((w) => w.isFocusable && w.type !== "container" && !pickerRow.contains(w));
    if (newFocusWidget) {
      newFocusWidget.focus();
    }
    me.removeFilterAt(filterIndex);
    if (me.store) {
      me.store.removeFilter(filter.id, true);
      me.updateStoreFilter();
    }
    me.trigger("remove", { filter });
    me.triggerChange();
  }
  /**
   * Appends a filter at the bottom of the list.
   * @param {CollectionFilterConfig} [filter={}] Configuration object for the {@link Core.util.CollectionFilter} to
   * add. Defaults to an empty filter.
   */
  addFilter({ property = null, operator = null, value = null } = {}) {
    var _a4;
    const me = this, { filters } = me, newFilter = {
      property: me.limitToProperty || property,
      operator,
      value,
      disabled: false,
      id: me.nextFilterId,
      caseSensitive: false
    };
    if (!me.trigger("beforeAddFilter", { filter: newFilter })) {
      return;
    }
    me.appendFilter(newFilter);
    if (me.getFilterPicker(filters.length - 1).isValid) {
      (_a4 = me.store) == null ? void 0 : _a4.addFilter(newFilter, true);
      me.store && me.updateStoreFilter();
    }
    me.trigger("add", { filter: newFilter });
    me.triggerChange();
  }
  /**
   * @private
   */
  appendFilter(filter) {
    const me = this;
    if (!me.limitToProperty || filter.property === me.limitToProperty) {
      me.filters.push(filter);
      me.widgetMap.pickers.add(
        me.getPickerRowConfig(filter, me.filters.length - 1)
      );
    }
  }
  onStoreFilter(event) {
    const me = this;
    if (me._isUpdatingStore) {
      return;
    }
    const { filters } = event, storeFiltersById = filters.values.reduce((byId, filter) => ({ ...byId, [filter.id]: filter }), {});
    for (let filterIndex = me.filters.length - 1; filterIndex >= 0; filterIndex--) {
      const filter = me.filters[filterIndex], storeFilter = storeFiltersById[filter.id], filterRow = me.getPickerRow(filterIndex);
      if (filterRow) {
        const { filterPicker, activeCheckbox } = filterRow.widgetMap;
        if (!storeFilter && filterPicker.isValid) {
          me.removeFilterAt(filterIndex);
        } else if (storeFilter !== void 0) {
          const { operator, value, property, disabled, caseSensitive } = storeFilter;
          if (filter !== storeFilter) {
            Object.assign(filter, { operator, value, property, disabled, caseSensitive });
          }
          filterPicker.filter = filter;
          filterPicker.onFilterChange();
          activeCheckbox.checked = !disabled;
        }
      }
    }
    me.appendFiltersFromStore();
    me.triggerChange();
  }
  /**
   * Remove the filter at the given index.
   * @param {Number} filterIndex The index of the filter to remove
   */
  removeFilterAt(filterIndex) {
    const { widgetMap: { pickers }, filters } = this;
    pickers.remove(pickers.childItems[filterIndex]);
    filters.splice(filterIndex, 1);
    this.triggerChange();
  }
  /**
   * Trigger a store re-filter after filters have been silently modified.
   * @private
   */
  updateStoreFilter() {
    var _a4;
    this._isUpdatingStore = true;
    (_a4 = this.store) == null ? void 0 : _a4.filter();
    this._isUpdatingStore = false;
  }
  /**
   * Returns the array of filter configuration objects currently represented by this picker group.
   * @type {CollectionFilterConfig[]}
   */
  get value() {
    return this.filters;
  }
  triggerChange() {
    const { filters } = this, validFilters = filters.filter((f, index) => this.getPickerRow(index).widgetMap.filterPicker.isValid);
    this.trigger("change", {
      filters,
      validFilters
    });
  }
  /**
   * Sets all current filters to enabled and checks their checkboxes.
   */
  activateAll() {
    this.setAllActiveStatus(true);
  }
  /**
   * Sets all current filters to disabled and clears their checkboxes.
   */
  deactivateAll() {
    this.setAllActiveStatus(false);
  }
  /**
   * @private
   */
  setAllActiveStatus(newActive) {
    const me = this, { _filters, store } = me;
    _filters.forEach((filter, filterIndex) => {
      if (newActive === filter.disabled) {
        const { filterPicker, activeCheckbox } = me.getPickerRow(filterIndex).widgetMap;
        filter.disabled = !newActive;
        filterPicker.onFilterChange();
        activeCheckbox.checked = newActive;
        if (newActive && store && filterPicker.isValid) {
          store.addFilter(filter, true);
        }
      }
    });
    me.updateStoreFilter();
  }
  get focusElement() {
    const { length } = this._filters;
    return length > 0 ? this.getPickerRow(length - 1).widgetMap.filterPicker.focusElement : super.focusElement;
  }
};
//region Config
__publicField(_FieldFilterPickerGroup, "$name", "FieldFilterPickerGroup");
__publicField(_FieldFilterPickerGroup, "type", "fieldfilterpickergroup");
/**
 * @private
 */
__publicField(_FieldFilterPickerGroup, "addFilterButtonDefaultText", "L{FieldFilterPickerGroup.addFilter}");
__publicField(_FieldFilterPickerGroup, "configurable", {
  /**
   * Array of {@link Core.util.CollectionFilter} configuration objects. One
   * {@link Core.widget.FieldFilterPicker} will be created
   * for each object in the array.
   *
   * When {@link #config-store} is provided, any filters in the store will
   * be automatically added and do not need to be provided explicitly.
   *
   * Example:
   * ```javascript
   * filters: [{
   *     // Filter properties should exist among field names configured
   *     // via `fields` or `store`
   *     property: 'age',
   *     operator: '<',
   *     value: 30
   * },{
   *     property: 'title',
   *     operator: 'startsWith',
   *     value: 'Director'
   * }]
   * ```
   *
   * @config
   * @type {CollectionFilterConfig[]}
   */
  filters: [],
  /**
   * Dictionary of {@link Core.widget.FieldFilterPicker#typedef-FieldOption} representing the fields against which filters can be defined,
   * keyed by field name.
   *
   * If filtering a {@link Grid.view.Grid}, consider using {@link Grid.widget.GridFieldFilterPicker}, which can be configured
   * with an existing {@link Grid.view.Grid} instead of, or in combination with, defining fields manually.
   *
   * Example:
   * ```javascript
   * fields: {
   *     // Allow filters to be defined against the 'age' and 'role' fields in our data
   *     age  : { text: 'Age', type: 'number' },
   *     role : { text: 'Role', type: 'string' }
   * }
   * ```
   *
   * @config {Object<String,FieldOption>}
   * @deprecated 5.3.0 Syntax accepting FieldOptions[] was deprecated in favor of dictionary and will be removed in 6.0
   */
  fields: null,
  /**
   * Whether the picker group is disabled.
   *
   * @config {Boolean}
   * @default
   */
  disabled: false,
  /**
   * Whether the picker group is read-only.
   *
   * Example:
   * fields: [
   *    { name: 'age', type: 'number' },
   *    { name: 'title', type: 'string' }
   * ]
   *
   * @config {Boolean}
   * @default
   */
  readOnly: false,
  layout: "vbox",
  /**
   * The {@link Core.data.Store} whose records will be filtered. The store's {@link Core.data.Store#property-modelClass}
   * will be used to determine field types.
   *
   * This store will be kept in sync with the filters defined in the picker group, and new filters added to the store
   * via other means will appear in this filter group when they are able to be modified by it. (Some types of filters,
   * like arbitrary filter functions, cannot be managed through this widget.)
   *
   * As a corollary, multiple `FieldFilterPickerGroup`s configured with the same store will stay in sync, showing the
   * same filters as the store's filters change.
   *
   * @config {Core.data.Store}
   */
  store: null,
  /**
   * When `limitToProperty` is set to the name of an available field (as specified either
   * explicitly in {@link #config-fields} or implicitly in the
   * {@link #config-store}'s model), it has the following effects:
   *
   * - the picker group will only show filters defined on the specified property
   * - it will automatically set the `property` to the specified property for all newly added
   *   filters where the property is not already set
   * - the property selector is made read-only
   *
   * @config {String}
   */
  limitToProperty: null,
  /**
   * Optional CSS class to apply to the value field(s).
   *
   * @config {String}
   * @private
   */
  valueFieldCls: null,
  /**
   * Show a button at the bottom of the group that adds a new, blank filter to the group.
   *
   * @config {Boolean}
   * @default
   */
  showAddFilterButton: true,
  /**
   * Optional predicate that returns whether a given filter can be deleted. When `canDeleteFilter` is provided,
   * it will be called for each filter and will not show the delete button for those for which the
   * function returns `false`.
   *
   * @config {Function}
   * @param {*} filter  filter for checking
   * @returns {Boolean} truthy value if filter can be deleted
   */
  canDeleteFilter: null,
  /**
   * Optional function that returns {@link Core.widget.FieldFilterPicker} configuration properties for
   * a given filter. When `getFieldFilterPickerConfig` is provided, it will be called for each filter and the returned
   * object will be merged with the configuration properties for the individual
   * {@link Core.widget.FieldFilterPicker} representing that filter.
   *
   * The supplied function should accept a single argument, the {@link Core.util.CollectionFilter} whose picker
   * is being created.
   *
   * @config {Function}
   * @returns {FieldFilterPickerConfig}
   */
  getFieldFilterPickerConfig: null,
  /**
   * Optional predicate that returns whether a given filter can be managed by this widget. When `canManageFilter`
   * is provided, it will be used to decide whether to display filters found in the configured
   * {@link #config-store}.
   *
   * @config {Function}
   * @param {*} filter  filter for checking
   * @returns {Boolean} truthy value if filter can be managed
   */
  canManageFilter: null,
  /**
   * Sets the text displayed in the 'add filter' button if one is present.
   *
   * @config {String}
   */
  addFilterButtonText: null,
  /**
   * Whether to raise {@link #event-change} events as the user types into a value field. If `false`,
   * {@link #event-change} events will be raised only when the value input field's own `change` event
   * occurs, for example on field blur.
   *
   * @config {Boolean}
   * @default
   */
  triggerChangeOnInput: true,
  /**
   * @private
   */
  items: {
    pickers: {
      type: "container",
      layout: "vbox",
      scrollable: true,
      items: {}
    },
    addFilterButton: {
      type: "button",
      text: _FieldFilterPickerGroup.addFilterButtonDefaultText,
      cls: `b-${_FieldFilterPickerGroup.type}-add-button`,
      hidden: true
    }
  },
  /**
   * When specified, overrides the built-in list of available operators. See
   * {@link Core.widget.FieldFilterPicker#config-operators}.
   *
   * @config {Object}
   */
  operators: null,
  /**
   * The date format string used to display dates when using the 'is one of' / 'is not one of' operators with a date
   * field. Defaults to the current locale's `FieldFilterPicker.dateFormat` value.
   *
   * @config {String}
   * @default
   */
  dateFormat: "L{FieldFilterPicker.dateFormat}"
});
// endregion
__publicField(_FieldFilterPickerGroup, "childPickerType", "fieldfilterpicker");
var FieldFilterPickerGroup = _FieldFilterPickerGroup;
FieldFilterPickerGroup.initClass();
FieldFilterPickerGroup._$name = "FieldFilterPickerGroup";

// ../Core/lib/Core/widget/FieldSet.js
var FieldSet = class extends Panel.mixin(Labelable_default) {
  static get configurable() {
    return {
      bodyTag: "fieldset",
      focusable: false,
      /**
       * Setting this config to `true` assigns a horizontal box layout (`flex-flow: row`) to the items in this
       * container, while `false` assigns a vertical box layout (`flex-flow: column`).
       *
       * By default, this value is automatically determined based on the {@link #config-label} and
       * {@link #config-labelPosition} configs.
       * @config {Boolean}
       */
      inline: null,
      inlineInternal: null,
      layout: {
        type: "box",
        horizontal: false
      }
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  //endregion
  //region Composition
  get bodyConfig() {
    const result = super.bodyConfig, { className } = result, { inlineInternal: inline, hasLabel, title } = this;
    delete result.html;
    className["b-inline"] = inline;
    className["b-fieldset-has-label"] = hasLabel;
    if (title) {
      result.children = {
        // We render the <legend> element for a11y (not 100% sure it is needed)
        legendElement: {
          tag: "legend",
          text: title,
          class: {
            "b-fieldset-legend": 1
          }
        }
      };
    }
    return result;
  }
  compose() {
    const { inlineInternal: inline, label, labelCls, labelWidth } = this;
    return {
      class: {
        "b-field": label,
        "b-vbox": !inline
        // override panel
      },
      children: {
        "labelElement > headerElement": (label || null) && {
          tag: "label",
          html: label,
          class: {
            "b-label": 1,
            "b-align-start": 1,
            [labelCls]: labelCls
          },
          style: {
            width: DomHelper.unitize("width", labelWidth)[1]
          }
        }
      }
    };
  }
  //endregion
  syncInlineInternal() {
    var _a4;
    this.inlineInternal = (_a4 = this.inline) != null ? _a4 : this.label != null && this.labelPosition === "before";
  }
  updateDisabled(value, was) {
    super.updateDisabled(value, was);
    this.eachWidget(
      (item) => {
        item.disabled = value;
      },
      /* deep = */
      false
    );
  }
  updateInline() {
    this.syncInlineInternal();
  }
  updateInlineInternal(inline) {
    this.layout.horizontal = inline;
  }
  updateLabel() {
    this.syncInlineInternal();
  }
  updateLabelPosition() {
    this.syncInlineInternal();
  }
};
//region Config
__publicField(FieldSet, "$name", "FieldSet");
__publicField(FieldSet, "type", "fieldset");
FieldSet.initClass();
FieldSet._$name = "FieldSet";

// ../Core/lib/Core/widget/FileField.js
var FileField = class extends Field {
  static get configurable() {
    return {
      /**
       * Set to true to allow picking multiple files. Note that when set to a truthy value,
       * the field is set to accept multiple files, but the value returned will be
       * an empty string since this is what is rendered into the HTML.
       * @config {Boolean}
       * @default
       */
      multiple: null,
      /**
       * Comma-separated list of file extensions or MIME type to accept. E.g.
       * ".jpg,.png,.doc" or "image/*". Null by default, allowing all files.
       * @config {String}
       */
      accept: null,
      inputType: "file",
      attributes: ["multiple", "accept"]
    };
  }
  /**
   * Returns list of selected files
   * @property {FileList}
   * @readonly
   */
  get files() {
    return this.input.files;
  }
  /**
   * Opens browser file picker
   * @internal
   */
  pickFile() {
    this.input.click();
  }
  get multiple() {
    return this._multiple ? "" : null;
  }
  /**
   * Clears field value
   */
  clear() {
    this.input.value = null;
  }
  triggerChange(event) {
    this.triggerFieldChange({
      event,
      value: this.input.value,
      oldValue: this._lastValue,
      userAction: true,
      valid: true
    });
  }
};
__publicField(FileField, "$name", "FileField");
__publicField(FileField, "type", "filefield");
FileField.initClass();
FileField._$name = "FileField";

// ../Core/lib/Core/widget/FilePicker.js
var FilePicker = class extends Container {
  construct(config = {}) {
    const me = this;
    config.items = [
      Object.assign({
        type: "button",
        ref: "fileButton",
        text: "L{FilePicker.file}",
        localeClass: this
      }, config.buttonConfig),
      Object.assign({
        type: "filefield",
        ref: "fileField",
        style: "display: none"
      }, config.fileFieldConfig)
    ].concat(config.items || []);
    super.construct(config);
    me.button.ion({
      click: me.onButtonClick,
      thisObj: me
    });
    me.fileField.ion({
      change: me.onFileFieldChange,
      thisObj: me
    });
    me._thisIsAUsedExpression(me.fileTip);
  }
  get button() {
    return this.widgetMap.fileButton;
  }
  get fileField() {
    return this.widgetMap.fileField;
  }
  /**
   * List of selected files
   * @property {FileList}
   * @readonly
   */
  get files() {
    return this.fileField.files;
  }
  get fileTip() {
    const me = this;
    return me._fileTip || (me._fileTip = new Tooltip({
      cls: "b-file-tip",
      forElement: me.button.element,
      showOnHover: true,
      align: "b-t",
      scrollAction: "realign",
      internalListeners: {
        beforeshow() {
          const tip = this, files = me.files;
          if (files && files.length) {
            tip.html = `${Array.from(files).map((file) => StringHelper.encodeHtml(file.name)).join("<br>")}`;
            return true;
          }
          return false;
        }
      }
    }));
  }
  /**
   * Clears field
   */
  clear() {
    const me = this;
    me.fileField.clear();
    me.updateBadge();
    me.trigger("clear");
  }
  onButtonClick({ event }) {
    const me = this;
    me.fileField.pickFile();
    event.preventDefault();
  }
  onFileFieldChange({ valid }) {
    const me = this;
    me.updateBadge();
    me.triggerFieldChange({ files: me.files, valid });
  }
  updateShowBadge() {
    if (!this.isConfiguring) {
      this.updateBadge();
    }
  }
  updateBadge() {
    this.button.badge = this.showBadge && this.files.length || "";
  }
};
__publicField(FilePicker, "$name", "FilePicker");
__publicField(FilePicker, "type", "filepicker");
__publicField(FilePicker, "configurable", {
  /**
   * The name of the property to set when a single value is to be applied to this FilePicker. Such as when used
   * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
   * @config {String}
   * @default
   * @category Misc
   */
  defaultBindProperty: "value",
  /**
   * Fires after user closes file picker dialog.
   * @event change
   * @param {FileList} files List of picked files
   */
  /**
   * Fires when field is cleared with {@link #function-clear} method
   * @event clear
   */
  /**
   * Wrapper button config object. See {@link Core/widget/Button} for list of available configs.
   * @config {ButtonConfig}
   */
  buttonConfig: null,
  /**
   * Underlying field config object. See {@link Core/widget/FileField} for list of available configs.
   * @config {FileFieldConfig}
   */
  fileFieldConfig: null,
  /**
   * Set to `false` to hide the badge indicating the number of files selected
   * @prp {Boolean}
   * @default true
   */
  showBadge: true
});
FilePicker.initClass();
FilePicker._$name = "FilePicker";

// ../Core/lib/Core/widget/FilterField.js
var FilterField = class extends TextField {
  static get configurable() {
    return {
      /**
       * The model field name to filter by. Can optionally be replaced by {@link #config-filterFunction}
       * @config {String}
       * @category Filtering
       */
      field: null,
      /**
       * The store to filter.
       * @config {Core.data.Store}
       * @category Filtering
       */
      store: null,
      /**
       * Optional filter function to be called with record and value as parameters for store filtering.
       * ```javascript
       * {
       *     type           : 'filterfield',
       *     store          : myStore,
       *     filterFunction : (record, value)  => {
       *        return record.text.includes(value);
       *     }
       * }
       * ```
       *
       * @config {Function}
       * @param {Core.data.Model} record Record for comparison
       * @param {String} value Value to compare with
       * @returns {Boolean} Returns `true` if record matches comparison requirements
       *
       * @category Filtering
       */
      filterFunction: null,
      clearable: true,
      revertOnEscape: true,
      ignoreParentReadOnly: true,
      keyStrokeChangeDelay: 100,
      internalListeners: {
        change: "onInternalChange"
      }
    };
  }
  updateValue(value, old) {
    super.updateValue(value, old);
    if (value && this.isConfiguring) {
      this.onInternalChange({ value });
    }
  }
  onInternalChange({ value }) {
    const { store, field, filterFunction } = this;
    if (store) {
      const filterId = `${field || this.id}-Filter`;
      if (value.length === 0) {
        store.removeFilter(filterId);
      } else {
        let filterBy;
        if (filterFunction) {
          filterBy = (record) => filterFunction(record, value);
        } else {
          value = value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          filterBy = (record) => {
            var _a4;
            return (_a4 = record.getValue(field)) == null ? void 0 : _a4.match(new RegExp(value, "i"));
          };
        }
        store.filter({
          id: filterId,
          filterBy
        });
      }
    }
  }
};
__publicField(FilterField, "$name", "FilterField");
__publicField(FilterField, "type", "filterfield");
FilterField.initClass();
FilterField._$name = "FilterField";

// ../Core/lib/Core/widget/MessageDialog.js
var items = [
  {
    ref: "cancelButton",
    cls: "b-messagedialog-cancelbutton b-gray",
    text: "L{Object.Cancel}",
    onClick: "up.onCancelClick"
  },
  {
    ref: "okButton",
    cls: "b-messagedialog-okbutton b-raised b-blue",
    text: "L{Object.Ok}",
    onClick: "up.onOkClick"
  }
];
if (BrowserHelper.isWindows) {
  items.reverse();
}
var _MessageDialogConstructor = class _MessageDialogConstructor extends Popup {
  static get configurable() {
    return {
      centered: true,
      modal: true,
      hidden: true,
      autoShow: false,
      closeAction: "hide",
      title: "\xA0",
      lazyItems: {
        $config: ["lazy"],
        value: [{
          cls: "b-messagedialog-message",
          ref: "message"
        }, {
          type: "textfield",
          cls: "b-messagedialog-input",
          ref: "input"
        }]
      },
      showClass: null,
      bbar: {
        overflow: null,
        items
      }
    };
  }
  construct() {
    this.okButton = this.yesButton = 1;
    this.cancelButton = 3;
    super.construct(...arguments);
  }
  // Protect from queryAll -> destroy
  destroy() {
  }
  /**
   * Shows a confirm dialog with "Ok" and "Cancel" buttons. The returned promise resolves passing the button identifier
   * of the button that was pressed ({@link #property-okButton} or {@link #property-cancelButton}).
   * @function confirm
   * @param {Object} options An options object for what to show.
   * @param {String} [options.title] The title to show in the dialog header.
   * @param {String} [options.message] The message to show in the dialog body.
   * @param {String} [options.rootElement] The root element of this widget, defaults to document.body. Use this
   * if you use the MessageDialog inside a web component ShadowRoot
   * @param {String|ButtonConfig} [options.cancelButton] A text or a config object to apply to the Cancel button.
   * @param {String|ButtonConfig} [options.okButton] A text or config object to apply to the OK button.
   * @returns {Promise} A promise which is resolved when the dialog is closed
   */
  async confirm() {
    return this.showDialog("confirm", ...arguments);
  }
  /**
   * Shows an alert popup with a message. The returned promise resolves when the button is clicked.
   * @function alert
   * @param {Object} options An options object for what to show.
   * @param {String} [options.title] The title to show in the dialog header.
   * @param {String} [options.message] The message to show in the dialog body.
   * @param {String} [options.rootElement] The root element of this widget, defaults to document.body. Use this
   * if you use the MessageDialog inside a web component ShadowRoot
   * @param {String|ButtonConfig} [options.okButton] A text or config object to apply to the OK button.
   * @returns {Promise} A promise which is resolved when the dialog is closed
   */
  async alert() {
    return this.showDialog("alert", ...arguments);
  }
  /**
   * Shows a popup with a basic {@link Core.widget.TextField} along with a message. The returned promise resolves when
   * the dialog is closed and yields an Object with a `button` ({@link #property-okButton} or {@link #property-cancelButton})
   * and a `text` property with the text the user provided
   * @function prompt
   * @param {Object} options An options object for what to show.
   * @param {String} [options.title] The title to show in the dialog header.
   * @param {String} [options.message] The message to show in the dialog body.
   * @param {String} [options.rootElement] The root element of this widget, defaults to document.body. Use this
   * if you use the MessageDialog inside a web component ShadowRoot
   * @param {TextFieldConfig} [options.textField] A config object to apply to the TextField.
   * @param {String|ButtonConfig} [options.cancelButton] A text or a config object to apply to the Cancel button.
   * @param {String|ButtonConfig} [options.okButton] A text or config object to apply to the OK button.
   * @returns {Promise} A promise which is resolved when the dialog is closed. The promise yields an Object with
   * a `button` ({@link #property-okButton} or {@link #property-cancelButton}) and a `text` property with the text the
   * user provided
   */
  async prompt({
    textField
  }) {
    const field = this.widgetMap.input;
    Widget.reconfigure(field, textField);
    field.value = "";
    return this.showDialog("prompt", ...arguments);
  }
  showDialog(mode, {
    message = "",
    title = "\xA0",
    cancelButton,
    okButton,
    rootElement = document.body
  }) {
    const me = this;
    me.rootElement = rootElement;
    me.getConfig("lazyItems");
    me.title = me.optionalL(title);
    me.widgetMap.message.html = me.optionalL(message);
    me.showClass = `b-messagedialog-${mode}`;
    if (okButton) {
      okButton = typeof okButton === "string" ? { text: okButton } : okButton;
    }
    if (cancelButton) {
      cancelButton = typeof cancelButton === "string" ? { text: cancelButton } : cancelButton;
    }
    okButton = Object.assign({}, me.widgetMap.okButton.initialConfig, okButton);
    cancelButton = Object.assign({}, me.widgetMap.cancelButton.initialConfig, cancelButton);
    okButton.text = me.optionalL(okButton.text);
    cancelButton.text = me.optionalL(cancelButton.text);
    Widget.reconfigure(me.widgetMap.okButton, okButton);
    Widget.reconfigure(me.widgetMap.cancelButton, cancelButton);
    me.show();
    return me.promise = new Promise((resolve) => {
      me.resolve = resolve;
    });
  }
  show() {
    const activeElement = DomHelper.getActiveElement(this.element);
    this.owner = this.element.contains(activeElement) ? null : _MessageDialogConstructor.fromElement(document.activeElement);
    return super.show(...arguments);
  }
  updateShowClass(showClass, oldShowClass) {
    const { classList } = this.element;
    if (oldShowClass) {
      classList.remove(oldShowClass);
    }
    if (showClass) {
      classList.add(showClass);
    }
  }
  doResolve(value) {
    const me = this, { resolve } = me;
    if (resolve) {
      const isPrompt = me.showClass === "b-messagedialog-prompt";
      if (isPrompt && value === me.okButton && !me.widgetMap.input.isValid) {
        return;
      }
      me.resolve = me.reject = me.promise = null;
      resolve(isPrompt ? { button: value, text: me.widgetMap.input.value } : value);
      me.hide();
    }
  }
  onInternalKeyDown(event) {
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      this.onCancelClick();
    } else if (event.key === "Enter" && !event.target.closest(".b-button")) {
      event.stopImmediatePropagation();
      event.preventDefault();
      this.onOkClick();
    }
    super.onInternalKeyDown(event);
  }
  onOkClick() {
    this.doResolve(MessageDialog.okButton);
  }
  onCancelClick() {
    this.doResolve(MessageDialog.cancelButton);
  }
};
__publicField(_MessageDialogConstructor, "$name", "MessageDialog");
__publicField(_MessageDialogConstructor, "type", "messagedialog");
var MessageDialogConstructor = _MessageDialogConstructor;
MessageDialogConstructor.initClass();
var MessageDialog = new Proxy({}, {
  get(target, prop) {
    const instance = target.instance || (target.instance = new MessageDialogConstructor({
      rootElement: document.body
    })), result = instance[prop];
    return typeof result === "function" ? result.bind(instance) : result;
  }
});
var MessageDialog_default = MessageDialog;

// ../Core/lib/Core/widget/PagingToolbar.js
var PagingToolbar = class extends Toolbar {
  static get defaultConfig() {
    return {
      /**
       * The {@link Core.data.AjaxStore} that this PagingToolbar is to control.
       * @config {Core.data.AjaxStore}
       */
      store: null,
      defaults: {
        localeClass: this
      },
      items: {
        firstPageButton: {
          onClick: "up.onFirstPageClick",
          icon: "b-icon-first",
          weight: 100,
          tooltip: "L{PagingToolbar.firstPage}"
        },
        previousPageButton: {
          onClick: "up.onPreviousPageClick",
          icon: "b-icon-previous",
          weight: 110,
          tooltip: "L{PagingToolbar.prevPage}"
        },
        pageNumber: {
          type: "numberfield",
          label: "L{page}",
          min: 1,
          max: 1,
          triggers: null,
          onChange: "up.onPageNumberChange",
          highlightExternalChange: false,
          weight: 120
        },
        pageCount: {
          type: "widget",
          cls: "b-pagecount b-toolbar-text",
          weight: 130
        },
        nextPageButton: {
          onClick: "up.onNextPageClick",
          icon: "b-icon-next",
          weight: 140,
          tooltip: "L{PagingToolbar.nextPage}"
        },
        lastPageButton: {
          onClick: "up.onLastPageClick",
          icon: "b-icon-last",
          weight: 150,
          tooltip: "L{PagingToolbar.lastPage}"
        },
        separator: {
          type: "widget",
          cls: "b-toolbar-separator",
          weight: 151
        },
        reloadButton: {
          onClick: "up.onReloadClick",
          icon: "b-icon-reload",
          weight: 160,
          tooltip: "L{PagingToolbar.reload}"
        },
        spacer: {
          type: "widget",
          cls: "b-toolbar-fill",
          weight: 161
        },
        dataSummary: {
          type: "widget",
          cls: "b-toolbar-text",
          weight: 170
        }
      }
    };
  }
  // Retrieve store from grid when "assigned" to it
  set parent(parent) {
    super.parent = parent;
    if (!this.store) {
      this.store = parent.store;
    }
  }
  get parent() {
    return super.parent;
  }
  set store(store) {
    const me = this;
    me.detachListeners("store");
    me._store = store;
    if (store) {
      store.ion({
        name: "store",
        beforerequest: "onStoreBeforeRequest",
        afterrequest: "onStoreChange",
        change: "onStoreChange",
        thisObj: me
      });
      if (store.isLoading) {
        me.onStoreBeforeRequest();
      }
    }
  }
  get store() {
    return this._store;
  }
  onStoreBeforeRequest() {
    this.eachWidget((w) => w.disable());
  }
  updateLocalization() {
    this.updateSummary();
    super.updateLocalization();
  }
  updateSummary() {
    const me = this, { pageCount, dataSummary } = me.widgetMap;
    let count = 0, lastPage = 0, start = 0, end = 0, allCount = 0;
    if (me.store) {
      const { store } = me, { pageSize, currentPage } = store;
      count = store.count;
      lastPage = store.lastPage;
      allCount = store.allCount;
      start = Math.max(0, (currentPage - 1) * pageSize + 1);
      end = Math.min(allCount, start + pageSize - 1);
    }
    pageCount.html = me.L("L{pageCountTemplate}")({ lastPage });
    dataSummary.html = count ? me.L("L{summaryTemplate}")({ start, end, allCount }) : me.L("L{noRecords}");
  }
  onStoreChange() {
    const me = this, { widgetMap, store } = me, { count, lastPage, currentPage } = store, {
      pageNumber,
      pageCount,
      firstPageButton,
      previousPageButton,
      nextPageButton,
      lastPageButton,
      dataSummary
    } = widgetMap;
    me.eachWidget((w) => w.enable());
    pageNumber.value = currentPage;
    pageNumber.max = lastPage;
    dataSummary.disabled = pageNumber.disabled = pageCount.disabled = !count;
    firstPageButton.disabled = previousPageButton.disabled = currentPage <= 1 || !count;
    nextPageButton.disabled = lastPageButton.disabled = currentPage >= lastPage || !count;
    me.updateSummary();
  }
  onPageNumberChange({ value }) {
    if (this.store.currentPage !== value) {
      this.store.loadPage(value);
    }
  }
  onFirstPageClick() {
    this.store.loadPage(1);
  }
  onPreviousPageClick() {
    this.store.previousPage();
  }
  onNextPageClick() {
    this.store.nextPage();
  }
  onLastPageClick() {
    this.store.loadPage(this.store.lastPage);
  }
  onReloadClick() {
    this.store.loadPage(this.store.currentPage);
  }
};
__publicField(PagingToolbar, "$name", "PagingToolbar");
__publicField(PagingToolbar, "type", "pagingtoolbar");
PagingToolbar.initClass();
PagingToolbar._$name = "PagingToolbar";

// ../Core/lib/Core/widget/panel/PanelCollapserOverlay.js
var { dockIsHorz: dockIsHorz2 } = PanelCollapser.maps;
var collapseExposeEdge = {
  top: 0,
  down: 0,
  left: 1,
  bottom: 2,
  up: 2,
  right: 3
};
var translateByDir = {
  up: {
    from: `translate(0,0)`,
    to: "translate(0,-100%)"
  },
  down: {
    from: `translate(0,0)`,
    to: "translate(0,100%)"
  },
  left: {
    from: `translate(0,0)`,
    to: "translate(-100%,0)"
  },
  right: {
    from: `translate(0,0)`,
    to: "translate(100%,0)"
  }
};
var PanelCollapserOverlay = class extends PanelCollapser.mixin(Delayable_default) {
  static get configurable() {
    return {
      /**
       * The number of milliseconds to wait once the mouse leaves a {@link Core.widget.Panel#config-revealed}
       * panel before returning to an unrevealed state. Clicking outside the revealed panel will immediately
       * return the panel to its collapsed state.
       *
       * This may be disabled by configuring {@link #config-autoClose} as `null`.
       *
       * If this value is negative, the panel will not automatically recollapse due to the mouse leaving, however,
       * clicks outside the panel will still recollapse it.
       *
       * If this value is `null`, the panel will not automatically recollapse for either outside clicks or if
       * the mouse leaves the panel.
       * @config {Number}
       * @default
       */
      autoCloseDelay: 1e3,
      /**
       * By default, clicking outside the revealed overlay hides the revealed overlay.
       *
       * If the revealed overlay was shown using the {@link #property-recollapseTool}
       * then moving the mouse outside of the revealed overlay hides the revealed overlay.
       *
       * Configure this as `false` to disable auto hiding, making overlayed
       * state permanent, and changeable using the {@link #function-toggleReveal} method.
       * @config {Boolean}
       * @default
       */
      autoClose: true,
      revealing: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * The reveal/hide tool which slides the collapsed panel over the top of the UI.
       * @member {Core.widget.Tool} recollapseTool
       */
      /**
       * The reveal/hide tool which slides the collapsed panel over the top of the UI.
       *
       * The `type` of this instance should not be changed but the tool instance can be
       * configured in other ways via this config property.
       * @config {ToolConfig|Core.widget.Tool}
       */
      recollapseTool: {
        type: "collapsetool",
        cls: "b-recollapse",
        collapsify: "overlay",
        handler() {
          var _a4;
          (_a4 = this.collapsible) == null ? void 0 : _a4.toggleReveal();
        }
      }
    };
  }
  static get delayable() {
    return {
      doAutoClose: 0
    };
  }
  doAutoClose() {
    this.toggleReveal(false);
  }
  updateAutoCloseDelay(delay) {
    const { doAutoClose } = this;
    if (!(doAutoClose.suspended = delay == null || delay < 0)) {
      doAutoClose.delay = delay;
      doAutoClose.immediate = !delay;
    }
  }
  changeRecollapseTool(tool) {
    const me = this, { panel } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      recollapse: tool
    };
  }
  beforeCollapse(operation) {
    if (super.beforeCollapse(operation) === false) {
      return false;
    }
    if (this.panel.revealed) {
      operation.animation = null;
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    var _a4;
    (_a4 = this.panel) == null ? void 0 : _a4.recompose();
    super.applyHeaderDock(collapsed, flush);
  }
  collapseBegin(operation) {
    const me = this, { collapseDir, innerElement } = me, { animation } = operation, { collapseTool, panel } = me;
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.applyHeaderDock(true);
    me.lockInnerSize();
    collapseTool == null ? void 0 : collapseTool.element.classList.add("b-collapsed");
    if (animation) {
      panel.element.classList.add("b-collapsing");
      animation.element = innerElement;
      animation.transform = translateByDir[collapseDir];
      operation.animation = Animator.run(animation);
    }
  }
  onComplete(action) {
    var _a4, _b;
    super.onComplete(action);
    const me = this, { panel } = me, { element } = panel;
    me.autoCloseLeaveDetacher = (_a4 = me.autoCloseLeaveDetacher) == null ? void 0 : _a4.call(me);
    me.autoCloseClickDetacher = (_b = me.autoCloseClickDetacher) == null ? void 0 : _b.call(me);
    me.doAutoClose.cancel();
    if (action === "reveal" && me.autoClose) {
      if (panel.containsFocus) {
        me.autoCloseLeaveDetacher = EventHelper.on({
          element,
          mouseenter: (ev) => {
            me.doAutoClose.cancel();
          },
          mouseleave: (ev) => {
            me.doAutoClose();
          }
        });
      }
      me.autoCloseClickDetacher = EventHelper.on({
        element: document.body,
        thisObj: panel,
        mousedown: (ev) => {
          var _a5;
          if (!panel.owns(ev) && !((_a5 = me.revealer) == null ? void 0 : _a5.contains(ev.target)) && me.autoCloseDelay != null) {
            me.doAutoClose.now();
          }
        }
      });
    }
  }
  expandBegin(operation) {
    const me = this, { animation } = operation, { collapseDir, collapseTool, innerElement, panel } = me, { element } = panel;
    element.classList.remove("b-collapsed", "b-collapsing");
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    me.lockInnerSize();
    collapseTool == null ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      element.classList.add("b-collapsed", "b-expanding");
      animation.element = innerElement;
      animation.transform = {
        from: translateByDir[collapseDir].to,
        to: translateByDir[collapseDir].from
      };
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    super.expandEnd(operation);
    const { panel } = this;
    if (operation.completed) {
      panel.revealed = false;
    }
    panel.element.classList.remove("b-expanding");
  }
  expandRevert(operation) {
    super.expandRevert(operation);
    this.panel.element.classList.add("b-expanding");
  }
  get innerElement() {
    return this.panel.overlayElement;
  }
  get innerSizeElement() {
    return this.panel.element;
  }
  get toolsConfig() {
    const me = this, { direction } = me, config = super.toolsConfig, tool = me.recollapseTool;
    if (tool) {
      return {
        ...config,
        recollapse: tool && ObjectHelper.assign({
          direction: direction.toLowerCase()
        }, tool)
      };
    }
    return config;
  }
  lockInnerSize(lock = true) {
    const me = this, { panel } = me, panelRect = lock && panel.rectangle(), inset = lock ? [0, 0, 0, 0] : "", innerRect = super.lockInnerSize(lock);
    if (lock) {
      inset[collapseExposeEdge[me.collapseDir]] = `-${panelRect[me.collapseDim] + 10}px`;
    }
    panel.element.style.clipPath = lock ? `inset(${inset.join(" ")})` : "";
    return innerRect;
  }
  onOverlayTransitionDone(ev) {
    const me = this, { panel } = me;
    if (ev.srcElement === panel.overlayElement && me.revealing) {
      me.revealing = false;
      me.onComplete(panel.revealed ? "reveal" : "unreveal");
    }
  }
  onRevealerClick() {
    this.toggleReveal();
  }
  /**
   * Toggles the revealed state of the Panel to match the passed boolean flag.
   * @param {Boolean} [state]  If not specified, this method toggles current state. Otherwise, pass `true` to reveal
   * the overlay, or `false` to hide it.
   */
  toggleReveal(state) {
    const { panel } = this, { element } = panel;
    if (panel.collapsed) {
      this.revealer = DomHelper.getActiveElement(element);
      if (state == null) {
        state = !panel.revealed;
      }
      if (panel.revealed !== state && panel.trigger("beforeToggleReveal", { reveal: state }) !== false) {
        if (!state && element.contains(this.revealer)) {
          panel.revertFocus(true);
        }
        this.revealing = true;
        panel.revealed = state;
      }
    }
  }
  updateRevealing(value) {
    const me = this, horzDirRe = /left|right/i, { panel } = me, dim = horzDirRe.test(me.collapseDir) ? "height" : "width";
    if (panel) {
      me.innerElement.style[dim] = "0px";
      me.innerElement.style[`min-${dim}`] = "100%";
      panel.element.classList[value ? "add" : "remove"]("b-panel-overlay-revealing");
    }
  }
  wrapCollapser(key, body) {
    var _a4;
    const me = this, { collapseDir, panel } = me, { expandedHeaderDock, header, uiClassList } = panel, recollapse = (_a4 = panel.tools) == null ? void 0 : _a4.recollapse, [before, after] = me.splitHeaderItems({ as: "element", dock: me.collapseDock }), horz = dockIsHorz2[expandedHeaderDock], title = panel.hasHeader ? panel.title || (header == null ? void 0 : header.title) || "\xA0" : null;
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return [
      "overlayElement",
      {
        class: {
          ...uiClassList,
          [`b-panel-overlay-header-${expandedHeaderDock}`]: 1,
          [`b-panel-overlay-${collapseDir}`]: 1,
          [`b-${horz ? "h" : "v"}box`]: 1,
          "b-panel-overlay": 1,
          "b-box-center": 1
        },
        // internalListeners is not correct for element listeners in domConfigs
        listeners: {
          // eslint-disable-line bryntum/no-listeners-in-lib
          transitionend: (ev) => me.onOverlayTransitionDone(ev),
          transitioncancel: (ev) => me.onOverlayTransitionDone(ev)
        },
        children: {
          overlayHeaderElement: title && {
            tag: "header",
            class: new DomClassList({
              ...uiClassList,
              [`b-dock-${expandedHeaderDock}`]: 1,
              "b-panel-header": 1,
              "b-panel-overlay-header": 1
            }, header == null ? void 0 : header.cls),
            children: [
              ...before,
              {
                reference: "overlayTitleElement",
                html: title,
                class: {
                  ...uiClassList,
                  [`b-align-${(header == null ? void 0 : header.titleAlign) || "start"}`]: 1,
                  "b-header-title": 1
                }
              },
              ...after
            ]
          },
          [key]: body
        }
      }
    ];
  }
};
__publicField(PanelCollapserOverlay, "$name", "PanelCollapserOverlay");
__publicField(PanelCollapserOverlay, "type", "overlay");
PanelCollapserOverlay.initClass();
PanelCollapserOverlay._$name = "PanelCollapserOverlay";

// ../Core/lib/Core/widget/PasswordField.js
var PasswordField = class extends Field {
  construct(config = {}) {
    config.inputType = "password";
    super.construct(...arguments);
    this.element.classList.add("b-textfield");
  }
};
__publicField(PasswordField, "$name", "PasswordField");
__publicField(PasswordField, "type", "passwordfield");
__publicField(PasswordField, "alias", "password");
PasswordField.initClass();
PasswordField._$name = "PasswordField";

// ../Core/lib/Core/widget/Radio.js
var Radio = class extends Checkbox {
  static get configurable() {
    return {
      inputType: "radio",
      /**
       * Set this to `true` so that clicking a checked radio button will clear its checked state.
       * @config {Boolean}
       * @default false
       */
      clearable: null,
      uncheckedValue: void 0
      // won't store to Container#values when unchecked
    };
  }
  //endregion
  //region Init
  get textLabelCls() {
    return super.textLabelCls + " b-radio-label";
  }
  //endregion
  internalOnClick(info) {
    if (super.internalOnClick(info) !== false) {
      if (this.checked && this.clearable) {
        this.checked = false;
      }
    }
  }
  updateName(name) {
    this.toggleGroup = name;
  }
  // Empty override to get rid of clear trigger
  updateClearable() {
  }
};
//region Config
__publicField(Radio, "$name", "Radio");
__publicField(Radio, "type", "radio");
__publicField(Radio, "alias", "radiobutton");
Radio.initClass();
Radio._$name = "Radio";

// ../Core/lib/Core/widget/RadioGroup.js
var RadioGroup = class extends FieldSet {
  static get configurable() {
    return {
      defaultType: "radio",
      /**
       * Set this to `true` so that clicking the currently checked radio button will clear the check from all
       * radio buttons in the group.
       * @config {Boolean}
       * @default false
       */
      clearable: null,
      /**
       * The name by which this widget's {@link #property-value} is accessed using the parent container's
       * {@link Core.widget.Container#property-values}.
       *
       * The config must be provided as it is used to set the {@link Core.widget.Radio#config-name} of the
       * child {@link Core.widget.Radio radio buttons}.
       * @config {String}
       */
      name: null,
      /**
       * The set of radio button options for this radio button group. This is a shorthand for defining these in
       * the {@link Core.widget.Container#config-items}. The keys of this object hold the radio button's
       * {@link Core.widget.Radio#config-checkedValue} while the object values are a string for the radio button's
       * {@link Core.widget.Radio#config-text} or a config object for that radio button.
       *
       * The {@link #property-value} of this radio button group will be one of the keys in this object or `null`
       * if no radio button is checked.
       *
       * For example, consider the following configuration:
       * ```javascript
       *  {
       *      type    : 'radiogroup',
       *      name    : 'resolution',
       *      value   : 'A',
       *      options : {
       *          A : 'Keep the original version',
       *          B : 'Use the new version',
       *          C : 'Reconcile individual conflicts'
       *      }
       *  }
       * ```
       *
       * The above is equivalent to this configuration below using {@link #config-items}:
       * ```javascript
       *  {
       *      type  : 'radiogroup',
       *      items : [{
       *          text         : 'Keep the original version',
       *          name         : 'resolution',
       *          ref          : 'resolution_A',
       *          checked      : true,
       *          checkedValue : 'A'
       *      }, {
       *          text         : 'Use the new version',
       *          name         : 'resolution',
       *          ref          : 'resolution_B',
       *          checkedValue : 'B'
       *      }, {
       *          text         : 'Reconcile individual conflicts',
       *          name         : 'resolution',
       *          ref          : 'resolution_C',
       *          checkedValue : 'C'
       *      }]
       *  }
       * ```
       * @config {Object<String,String|RadioConfig>} options
       */
      options: {
        value: null,
        $config: {
          merge: "items"
        }
      },
      defaultBindProperty: "value"
    };
  }
  get existingOptions() {
    const { name } = this;
    return this.ensureItems().filter((c) => c.name === name);
  }
  get refPrefix() {
    return `${this.name || this.ref || this.id}_`;
  }
  get selected() {
    return this.existingOptions.filter((c) => c.input.checked)[0] || null;
  }
  /**
   * This property corresponds to the {@link Core.widget.Radio#config-checkedValue} of the currently
   * {@link Core.widget.Radio#property-checked} radio button.
   * @prp {String}
   */
  get value() {
    const { selected } = this;
    return selected ? selected.checkedValue : null;
  }
  set value(v) {
    this.existingOptions.forEach((c) => {
      c.isConfiguring = this.isConfiguring;
      c.checked = c.checkedValue === v;
      c.isConfiguring = false;
    });
  }
  ensureItems() {
    this.getConfig("options");
    return super.ensureItems();
  }
  changeOptions(options, was) {
    if (!(options && was && ObjectHelper.isDeeplyEqual(was, options))) {
      return options;
    }
  }
  convertOption(key, option, existing) {
    const me = this, { name } = me, ret = {
      name,
      type: "radio",
      value: key === me.value,
      ref: `${me.refPrefix}${key}`,
      checkedValue: key
    };
    if (typeof option === "string") {
      ret.text = option;
    } else {
      ObjectHelper.assign(ret, option);
    }
    return existing ? Widget.reconfigure(existing, ret) : ret;
  }
  isOurRadio(item) {
    return item.isRadio && item.name === this.name;
  }
  isolateFieldChange(field) {
    return this.isOurRadio(field);
  }
  onChildAdd(item) {
    super.onChildAdd(item);
    if (this.isOurRadio(item)) {
      item.ion({
        name: item.id,
        beforeChange: "onRadioItemBeforeChange",
        change: "onRadioItemChange",
        click: "onRadioClick",
        thisObj: this
      });
    }
  }
  onChildRemove(item) {
    if (this.isOurRadio(item)) {
      this.detachListeners(item.id);
    }
    super.onChildRemove(item);
  }
  onRadioClick(ev) {
    const { source } = ev;
    if (source.checked && this.clearable && source.clearable == null) {
      source.checked = false;
    }
  }
  onRadioItemBeforeChange(ev) {
    if (ev.checked) {
      const me = this, { lastValue } = me;
      if (!me.reverting && me.trigger("beforeChange", me.wrapRadioEvent(ev)) === false) {
        if (lastValue != null && lastValue !== me.value) {
          me.reverting = true;
          ev.source.uncheckToggleGroupMembers();
          me.value = lastValue;
          me.lastValue = lastValue;
          me.reverting = false;
          return false;
        }
      }
    }
  }
  onRadioItemChange(ev) {
    const me = this;
    if (ev.checked && !me.reverting) {
      me.triggerFieldChange(me.wrapRadioEvent(ev));
      me.lastValue = me.value;
    }
  }
  wrapRadioEvent(ev) {
    return {
      from: ev,
      item: ev.source,
      userAction: ev.userAction,
      lastValue: this.lastValue,
      value: this.value
    };
  }
  updateOptions() {
    const me = this, { options, refPrefix } = me, existingOptions = me.existingOptions.reduce((m, c) => {
      m[c.ref.substring(refPrefix.length)] = c;
      return m;
    }, {});
    let index = 0, key, option;
    if (options) {
      for (key in options) {
        option = me.convertOption(key, options[key], existingOptions[key]);
        delete existingOptions[key];
        me.insert(option, index++);
      }
    }
    const existing = Object.values(existingOptions);
    if (existing == null ? void 0 : existing.length) {
      me.remove(existing);
      existing.forEach((c) => c.destroy());
    }
  }
  //endregion
};
//region Config
__publicField(RadioGroup, "$name", "RadioGroup");
__publicField(RadioGroup, "type", "radiogroup");
RadioGroup.initClass();
RadioGroup._$name = "RadioGroup";

// ../Core/lib/Core/widget/Slider.js
var arrowKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowLeft: 1,
  ArrowRight: 1
};
var Slider = class extends Widget {
  static get configurable() {
    return {
      /**
       * Get input element.
       * @readonly
       * @member {HTMLInputElement} input
       */
      /**
       * Get/set text. Appends value if Slider.showValue is true
       * @member {String} text
       */
      /**
       * Slider label text
       * @config {String}
       */
      text: null,
      /**
       * Show value in label (appends in () if text is set)
       * @config {Boolean}
       * @default
       */
      showValue: true,
      /**
       * Show the slider value in a tooltip
       * @config {Boolean}
       * @default
       */
      showTooltip: false,
      /**
       * Get/set min value
       * @member {Number} min
       */
      /**
       * Minimum value
       * @config {Number}
       * @default
       */
      min: 0,
      /**
       * Get/set max value
       * @member {Number} max
       */
      /**
       * Maximum value
       * @config {Number}
       * @default
       */
      max: 100,
      /**
       * Get/set step size
       * @member {Number} step
       */
      /**
       * Step size
       * @config {Number}
       * @default
       */
      step: 1,
      /**
       * Get/set value
       * @member {Number} value
       */
      /**
       * Initial value
       * @config {Number}
       */
      value: 50,
      /**
       * Unit to display next to the value, when configured with `showValue : true`
       * @config {String}
       * @default
       */
      unit: null,
      // The value is set in the Light theme. The Material theme will have different value.
      thumbSize: 20,
      /**
       * A config object for the tooltip to show while hovering the slider.
       * @config {TooltipConfig}
       */
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip",
          align: "b-t",
          anchor: false,
          // No anchor displayed since thumbSize is different for different themes
          axisLock: true
        }
      },
      localizableProperties: ["text"],
      /**
       * By default, the {@link #event-change} event is fired when a change gesture is completed, ie: on
       * the mouse up gesture of a drag.
       *
       * Configure this as `true` to fire the {@link #event-change} event as the value changes *during* a drag.
       * @prp {Boolean}
       */
      triggerChangeOnInput: null,
      defaultBindProperty: "value"
    };
  }
  //endregion
  //region Init
  compose() {
    const { id, min: min2, max, showValue, step, text, value, unit = "", disabled, readOnly } = this, inputId = `${id}-input`, hasText = Boolean(text || showValue);
    return {
      class: {
        "b-has-label": hasText,
        "b-text": hasText,
        "b-disabled": disabled
      },
      children: {
        input: {
          tag: "input",
          type: "range",
          id: inputId,
          reference: "input",
          [disabled ? "disabled" : ""]: disabled,
          [readOnly ? "readOnly" : ""]: readOnly,
          min: min2,
          max,
          step,
          value,
          // eslint-disable-next-line bryntum/no-listeners-in-lib
          listeners: {
            input: "onInternalInput",
            change: "onInternalChange",
            mouseover: "onInternalMouseOver",
            mouseout: "onInternalMouseOut"
          }
        },
        label: {
          tag: "label",
          for: inputId,
          text: showValue ? text ? `${text} (${value}${unit})` : value + unit : text
        }
      }
    };
  }
  get focusElement() {
    return this.input;
  }
  get percentProgress() {
    return (this.value - this.min) / (this.max - this.min) * 100;
  }
  //endregion
  //region Events
  /**
   * Fired while slider thumb is being dragged.
   * @event input
   * @param {Core.widget.Slider} source The slider
   * @param {Number} value The value
   */
  /**
   * Fired after the slider value changes (on mouse up following slider interaction).
   * @event change
   * @param {Number} value The value
   * @param {Boolean} userAction Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.Slider} source The slider
   */
  /* break from doc comment */
  onInternalKeyDown(e) {
    if (!this.readOnly && arrowKeys[e.key]) {
      e.stopImmediatePropagation();
    }
  }
  onInternalChange() {
    this.updateUI();
    this.triggerChange(true);
    this.trigger("action", { value: this.value });
  }
  onInternalInput() {
    const me = this;
    if (me.readOnly) {
      me.input.value = me.value;
      return;
    }
    me.value = parseInt(me.input.value, 10);
    me.trigger("input", { value: me.value });
    if (me.triggerChangeOnInput) {
      me.triggerChange(me);
    }
  }
  onInternalMouseOver() {
    var _a4;
    const me = this, thumbPosition = me.rtl ? 100 - me.percentProgress : me.percentProgress;
    (_a4 = me.tooltip) == null ? void 0 : _a4.showBy({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(thumbPosition)}`
    });
  }
  onInternalMouseOut() {
    var _a4;
    (_a4 = this.tooltip) == null ? void 0 : _a4.hide();
  }
  triggerChange(userAction) {
    this.triggerFieldChange({
      value: this.value,
      valid: true,
      userAction
    });
  }
  //endregion
  //region Config Handling
  // max
  updateMax(max) {
    const me = this;
    if (me.input && me._value > max) {
      me.value = max;
      me.trigger("input", { value: me.value });
    }
  }
  // min
  updateMin(min2) {
    const me = this;
    if (me.input && me._value < min2) {
      me.value = min2;
      me.trigger("input", { value: me.value });
    }
  }
  // tooltip
  changeTooltip(config, existingTooltip) {
    var _a4;
    if (config) {
      config.owner = this;
    }
    return this.showTooltip ? Tooltip.reconfigure(existingTooltip, config, {
      owner: this,
      defaults: {
        forElement: this.input,
        html: String(this.value) + ((_a4 = this.unit) != null ? _a4 : "")
      }
    }) : null;
  }
  changeValue(value) {
    const me = this, { min: min2, step } = me;
    value = Math.min(Math.max(value, min2), me.max);
    if (value > min2) {
      return min2 + ObjectHelper.roundTo(value - min2, step);
    }
    return ObjectHelper.roundTo(value, step);
  }
  updateValue(value) {
    var _a4;
    const me = this, { input, _tooltip } = me;
    if (_tooltip) {
      _tooltip.html = me.value + ((_a4 = me.unit) != null ? _a4 : "");
    }
    if (input && input.value !== String(value)) {
      input.value = value;
      me.triggerChange(false);
    }
    me.updateUI();
  }
  //endregion
  //region Util
  updateUI() {
    var _a4, _b;
    const me = this;
    ((_a4 = me._tooltip) == null ? void 0 : _a4.isVisible) && ((_b = me._tooltip) == null ? void 0 : _b.alignTo({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(me.percentProgress)}`
    }));
  }
  //endregion
};
//region Config
__publicField(Slider, "$name", "Slider");
__publicField(Slider, "type", "slider");
Slider.initClass();
Slider._$name = "Slider";

// ../Core/lib/Core/widget/SlideToggle.js
var SlideToggle = class extends Checkbox {
  static get properties() {
    return {
      toggledCls: "b-slidetoggle-checked"
    };
  }
  construct(config) {
    if (config.checked) {
      config.cls = DomClassList.from(config.cls) || {};
      config.cls[this.constructor.properties.toggledCls] = 1;
    }
    super.construct(config);
  }
  get innerElements() {
    const innerEls = super.innerElements;
    innerEls.splice(1, 0, this.toggleElement);
    if (this.text) {
      innerEls[innerEls.length - 1].class = "b-slidetoggle-label";
    } else {
      innerEls.pop();
    }
    return innerEls;
  }
  get toggleElement() {
    return {
      class: "b-slidetoggle-toggle",
      reference: "slideToggle",
      children: [
        {
          class: "b-slidetoggle-thumb",
          reference: "slideThumb"
        }
      ]
    };
  }
  internalOnChange() {
    super.internalOnChange();
    this.element.classList[this.value ? "add" : "remove"](this.toggledCls);
  }
};
__publicField(SlideToggle, "$name", "SlideToggle");
__publicField(SlideToggle, "type", "slidetoggle");
SlideToggle.initClass();
SlideToggle._$name = "SlideToggle";

// ../Core/lib/Core/widget/Splitter.js
var classesHV = ["b-horizontal", "b-vertical"];
var hasFlex = (el) => DomHelper.getStyleValue(el.parentElement, "display") === "flex" && (parseInt(DomHelper.getStyleValue(el, "flex-basis"), 10) || parseInt(DomHelper.getStyleValue(el, "flex-grow"), 10));
var verticality = {
  horizontal: false,
  vertical: true
};
var Splitter = class extends Widget {
  static get configurable() {
    return {
      /**
       * Fired when a drag starts
       * @event dragStart
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Fired while dragging
       * @event drag
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Fired after a drop
       * @event drop
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Splitter orientation, see {@link #config-orientation}. When set to 'auto' then actually used orientation
       * can be retrieved using {@link #property-currentOrientation}.
       * @member {'auto'|'horizontal'|'vertical'} orientation
       * @readonly
       */
      /**
       * The splitter's orientation, configurable with 'auto', 'horizontal' or 'vertical'.
       *
       * 'auto' tries to determine the orientation by either checking the `flex-direction` of the parent element
       * or by comparing the positions of the closest sibling elements to the splitter. If they are above and
       * below 'horizontal' is used, if not it uses 'vertical'.
       *
       * ```
       * new Splitter({
       *    orientation : 'horizontal'
       * });
       * ```
       *
       * To receive the actually used orientation when configured with 'auto', see
       * {@link #property-currentOrientation}.
       *
       * @config {'auto'|'horizontal'|'vertical'}
       * @default
       */
      orientation: "auto",
      vertical: null,
      containerElement: {
        $config: "nullify",
        value: null
      },
      nextNeighbor: {
        $config: "nullify",
        value: null
      },
      previousNeighbor: {
        $config: "nullify",
        value: null
      }
    };
  }
  static get delayable() {
    return {
      syncState: "raf"
    };
  }
  //endregion
  //region Init & destroy
  doDestroy() {
    var _a4;
    (_a4 = this.mouseDetacher) == null ? void 0 : _a4.call(this);
    super.doDestroy();
  }
  //endregion
  //region Template & element
  compose() {
    return {
      class: {
        "b-splitter": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        pointerdown: "onMouseDown",
        mouseenter: "onMouseEnter",
        mouseleave: "onMouseLeave",
        ...!BrowserHelper.supportsPointerEvents && {
          mousedown: "onMouseDown",
          touchstart: "onMouseDown"
        }
      }
    };
  }
  //endregion
  //region Orientation
  /**
   * Get actually used orientation, which is either the configured value for `orientation` or if configured with
   * 'auto' the currently used orientation.
   * @property {String}
   * @readonly
   */
  get currentOrientation() {
    return this.vertical ? "vertical" : "horizontal";
  }
  getSibling(next = true) {
    let { element } = this, result;
    while (!result && (element = element[`${next ? "next" : "previous"}ElementSibling`])) {
      if (!element.isConnected || DomHelper.isVisible(element)) {
        result = element;
      }
    }
    return result;
  }
  get nextWidget() {
    let { element } = this, result;
    while (!result && (element = element.nextElementSibling)) {
      result = Widget.fromElement(element, this.element.parentElement);
    }
    return result;
  }
  get previousWidget() {
    let { element } = this, result;
    while (!result && (element = element.previousElementSibling)) {
      result = Widget.fromElement(element, this.element.parentElement);
    }
    return result;
  }
  updateContainerElement(containerElement) {
    var _a4;
    const me = this;
    me.stateDetector = (_a4 = me.stateDetector) == null ? void 0 : _a4.disconnect();
    if (containerElement) {
      me.stateDetector = new MutationObserver(() => me.syncState());
      me.stateDetector.observe(containerElement, {
        attributes: true,
        // in case style changes flip our orientation (when == 'auto')
        childList: true
        // watch for our neighbors to render (so we can disable on hidden/collapsed state)
      });
    }
  }
  updateNextNeighbor(next) {
    this.watchNeighbor(next, "next");
  }
  updatePreviousNeighbor(previous) {
    this.watchNeighbor(previous, "previous");
  }
  watchNeighbor(neighbor, name) {
    this.detachListeners(name);
    neighbor == null ? void 0 : neighbor.ion({
      name,
      thisObj: this,
      collapse: "syncState",
      expand: "syncState",
      hide: "syncState",
      show: "syncState"
    });
  }
  updateOrientation() {
    this.syncState.now();
  }
  updateVertical(vertical) {
    var _a4;
    const classList = (_a4 = this.element) == null ? void 0 : _a4.classList;
    classList == null ? void 0 : classList.add(classesHV[vertical ? 1 : 0]);
    classList == null ? void 0 : classList.remove(classesHV[vertical ? 0 : 1]);
  }
  /**
   * Determine orientation when set to `'auto'` and detects neighboring widgets to monitor their hidden/collapsed
   * states.
   * @private
   */
  syncState() {
    var _a4;
    const me = this, { element, nextWidget, previousWidget } = me;
    let vertical = (_a4 = verticality[me.orientation]) != null ? _a4 : null;
    me.nextNeighbor = nextWidget;
    me.previousNeighbor = previousWidget;
    me.disabled = nextWidget && (nextWidget.collapsible && nextWidget.collapsed || nextWidget.hidden) || previousWidget && (previousWidget.collapsible && previousWidget.collapsed || previousWidget.hidden);
    if (vertical !== null && nextWidget && previousWidget) {
      me.containerElement = null;
    } else {
      me.containerElement = element.parentElement;
      if (me.rendered && element.offsetParent) {
        const flexDirection = DomHelper.getStyleValue(element.parentElement, "flex-direction");
        if (flexDirection) {
          vertical = !flexDirection.startsWith("column");
        } else {
          const previous = element.previousElementSibling, next = element.nextElementSibling;
          if (!previous || !next) {
            return;
          }
          const prevRect = previous.getBoundingClientRect(), nextRect = next.getBoundingClientRect(), topMost = prevRect.top < nextRect.top ? prevRect : nextRect, bottomMost = topMost === nextRect ? prevRect : nextRect;
          vertical = topMost.top === bottomMost.top;
        }
      }
    }
    me.vertical = vertical;
  }
  //endregion
  //region Events
  onMouseDown(event) {
    var _a4;
    event.preventDefault();
    if (event.touches) {
      event = event.touches[0];
    }
    const me = this, {
      element,
      nextNeighbor,
      previousNeighbor
    } = me, prev = previousNeighbor ? previousNeighbor.element : me.getSibling(false), next = nextNeighbor ? nextNeighbor.element : me.getSibling(), prevHasFlex = hasFlex(prev), nextHasFlex = hasFlex(next), flexed = [];
    (_a4 = me.mouseDetacher) == null ? void 0 : _a4.call(me);
    for (const child of element.parentElement.children) {
      if (hasFlex(child) && child !== element) {
        flexed.push({
          element: child,
          width: child.offsetWidth,
          height: child.offsetHeight
        });
      }
    }
    me.context = {
      startX: event.pageX,
      startY: event.pageY,
      prevWidth: prev.offsetWidth,
      prevHeight: prev.offsetHeight,
      nextWidth: next.offsetWidth,
      nextHeight: next.offsetHeight,
      prevHasFlex,
      nextHasFlex,
      flexed,
      prev,
      next
    };
    const events = {
      element: document,
      pointermove: "onMouseMove",
      pointerup: "onMouseUp",
      thisObj: me
    };
    if (!BrowserHelper.supportsPointerEvents) {
      events.mousemove = events.touchmove = "onMouseMove";
      events.mouseup = events.touchend = "onMouseUp";
    }
    element.classList.add("b-moving");
    me.mouseDetacher = EventHelper.on(events);
    me.trigger("splitterMouseDown", { event });
  }
  onMouseEnter(event) {
    this.syncState();
    this.trigger("splitterMouseEnter", { event });
  }
  onMouseLeave(event) {
    this.trigger("splitterMouseLeave", { event });
  }
  onMouseMove(event) {
    const me = this, {
      context,
      nextWidget,
      previousWidget
    } = me, prevStyle = context.prev.style, nextStyle = context.next.style, deltaX = (event.pageX - context.startX) * (me.rtl ? -1 : 1), deltaY = event.pageY - context.startY;
    event.preventDefault();
    Object.assign(context, {
      deltaX,
      deltaY
    });
    if (!context.started) {
      context.started = true;
      me.trigger("dragStart", { context, event });
      context.flexed.forEach((flexed) => {
        flexed.element.style.flexGrow = me.vertical ? flexed.width : flexed.height;
        flexed.element.style.flexBasis = "0";
      });
    }
    if (me.vertical) {
      const newPrevWidth = context.prevWidth + deltaX, newNextWidth = context.nextWidth - deltaX;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevWidth;
      } else if (previousWidget) {
        previousWidget.width = newPrevWidth;
      } else {
        prevStyle.width = `${newPrevWidth}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextWidth;
      } else if (nextWidget) {
        nextWidget.width = newNextWidth;
      } else {
        nextStyle.width = `${newNextWidth}px`;
      }
    } else {
      const newPrevHeight = context.prevHeight + deltaY, newNextHeight = context.nextHeight - deltaY;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevHeight;
      } else if (previousWidget) {
        previousWidget.height = newPrevHeight;
      } else {
        prevStyle.height = `${newPrevHeight}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextHeight;
      } else if (nextWidget) {
        nextWidget.height = newNextHeight;
      } else {
        nextStyle.height = `${newNextHeight}px`;
      }
    }
    me.trigger("drag", { context, event });
  }
  onMouseUp(event) {
    var _a4;
    const me = this;
    (_a4 = me.mouseDetacher) == null ? void 0 : _a4.call(me);
    me.mouseDetacher = null;
    me.element.classList.remove("b-moving");
    if (me.context.started) {
      me.trigger("drop", { context: me.context, event });
    }
    me.context = null;
  }
  //endregion
  render() {
    super.render(...arguments);
    this.syncState.now();
    if (this.vertical === null) {
      this.syncState();
    }
  }
};
//region Config
__publicField(Splitter, "$name", "Splitter");
__publicField(Splitter, "type", "splitter");
Splitter.initClass();
Splitter._$name = "Splitter";

// ../Core/lib/Core/widget/Tab.js
var Tab = class extends Button {
  static get configurable() {
    return {
      /**
       * This config is set to `true` when this tab represents the `activeTab` of a {@link Core.widget.TabPanel}.
       * It is managed by the tab panel and should not be set directly.
       * @config {Boolean} active
       * @internal
       * @default false
       */
      active: null,
      /**
       * This config is set to the ordinal position of this tab in the {@link Core.widget.TabPanel}.
       * It is managed by the tab panel and should not be set directly.
       * @internal
       * @config {Number} index
       */
      index: null,
      /**
       * This config is set to `true` when this tab represents the first tab of a {@link Core.widget.TabPanel}.
       * It is managed by the tab panel and should not be set directly.
       * @internal
       * @config {Boolean} isFirst
       */
      isFirst: null,
      /**
       * This config is set to `true` when this tab represents the last tab of a {@link Core.widget.TabPanel}.
       * It is managed by the tab panel and should not be set directly.
       * @internal
       * @config {Boolean} isLast
       */
      isLast: null,
      /**
       * The {@link Core.widget.Widget} in the {@link Core.widget.TabPanel} corresponding to this tab.
       * It is managed by the tab panel and should not be set directly.
       * @internal
       * @config {Core.widget.Widget} item
       */
      item: {
        value: null,
        $config: "nullify"
      },
      itemCls: null,
      /**
       * The tab panel that owns this tab.
       * @config {Core.widget.TabPanel} tabPanel
       * @internal
       */
      tabPanel: null,
      /**
       * The config property on this tab that will be set to the value of the {@link #config-titleSource} property
       * of this tab's {@link #config-item}.
       *
       * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}
       * property of its {@link #config-item}.
       * @config {String} titleProperty
       * @default
       */
      titleProperty: "text",
      /**
       * The config property on this tab's {@link #config-item} that is used to set the value of the
       * {@link #config-titleProperty} of this tab.
       *
       * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}
       * property of its {@link #config-item}.
       * @config {String} titleSource
       * @default
       */
      titleSource: "title",
      role: "tab"
    };
  }
  compose() {
    const { active, cls, index, isFirst, isLast } = this, setSize = this.owner.visibleChildCount;
    return {
      tabindex: 0,
      "aria-selected": active,
      "aria-setsize": setSize,
      "aria-posinset": index + 1,
      class: {
        "b-tabpanel-tab": 1,
        "b-active": active,
        "b-tab-first": isFirst,
        "b-tab-last": isLast,
        ...cls
        // cls is a DomClassList
      },
      dataset: {
        index
      }
    };
  }
  //endregion
  updateIndex(index) {
    this.isFirst = !index;
  }
  updateItem(item, was) {
    var _a4, _b;
    const me = this;
    if ((was == null ? void 0 : was.tab) === me) {
      was.tab = null;
    }
    if (item) {
      item.tab = me;
      me[me.titleProperty] = item[me.titleSource];
      me.itemCls = item.cls;
      me.ariaElement.setAttribute("aria-controls", item.id);
      item.role = "tabpanel";
    }
    (_a4 = me.itemChangeDetacher) == null ? void 0 : _a4.call(me);
    me.itemChangeDetacher = item && FunctionHelper.after(item, "onConfigChange", "onItemConfigChange", me, {
      return: false
    });
    (_b = me.itemHideDetacher) == null ? void 0 : _b.call(me);
    me.itemHideDetacher = item == null ? void 0 : item.ion({
      beforeChangeHidden: "onItemBeforeChangeHidden",
      beforeHide: "onItemBeforeHide",
      beforeUpdateDisabled: "onItemBeforeUpdateDisabled",
      thisObj: me,
      prio: 1e3
      // We must know before the layout intercepts and activates a sibling
    });
    me.syncMinMax();
  }
  updateItemCls(cls, was) {
    const { element } = this, classList = element && DomClassList.from(
      element == null ? void 0 : element.classList,
      /* returnEmpty= */
      true
    );
    if (element) {
      classList.remove(was).add(cls);
      element.className = classList.value;
    }
  }
  updateRotate(rotate, was) {
    if (!rotate !== !was) {
      this.syncMinMax();
    }
  }
  syncMinMax() {
    const me = this, { rotate, tabPanel } = me;
    let { _minWidth: minWidth, _minHeight: minHeight, _maxWidth: maxWidth, _maxHeight: maxHeight } = me;
    if (tabPanel) {
      const { tabMinWidth, tabMaxWidth } = tabPanel;
      if (tabMinWidth != null) {
        if (rotate) {
          if (minWidth === tabMinWidth) {
            minWidth = null;
          }
          minHeight = tabMinWidth;
        } else {
          if (minHeight === tabMinWidth) {
            minHeight = null;
          }
          minWidth = tabMinWidth;
        }
      }
      if (tabMaxWidth != null) {
        if (rotate) {
          if (maxWidth === tabMaxWidth) {
            maxWidth = null;
          }
          maxHeight = tabMaxWidth;
        } else {
          if (maxHeight === tabMaxWidth) {
            maxHeight = null;
          }
          maxWidth = tabMaxWidth;
        }
      }
      me.minWidth = minWidth;
      me.minHeight = minHeight;
      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
    }
  }
  onItemBeforeChangeHidden({ source: hidingChild, hidden }) {
    if (!hidingChild.$isDeactivating && !hidingChild.$isActivating) {
      const { tabPanel } = this;
      this.hidden = hidden;
      if (hidden && hidingChild === tabPanel.activeItem) {
        tabPanel.activateAvailableTab(hidingChild);
      }
    }
  }
  onItemBeforeHide() {
    if (!this.item.$isDeactivating) {
      this.hide();
    }
  }
  onItemBeforeUpdateDisabled({ source: disablingChild, disabled }) {
    const { tabPanel } = this;
    this.disabled = disabled;
    if (disablingChild === tabPanel.activeItem) {
      tabPanel.activateAvailableTab(disablingChild);
    }
  }
  onItemConfigChange({ name, value }) {
    if (name === this.titleSource) {
      this[this.titleProperty] = value;
    }
  }
};
//region Config
__publicField(Tab, "$name", "Tab");
__publicField(Tab, "type", "tab");
Tab.initClass();
Tab._$name = "Tab";

// ../Core/lib/Core/widget/TabBar.js
var isTab = (t) => t.isTab;
var TabBar = class extends Toolbar {
  static get configurable() {
    return {
      defaultType: "tab",
      overflow: "scroll",
      role: "tablist",
      ignoreParentReadOnly: true
    };
  }
  get firstTab() {
    return this.tabAt(0);
  }
  get lastTab() {
    return this.tabAt(-1);
  }
  get tabCount() {
    return this._items.countOf(isTab);
  }
  get tabs() {
    return ArrayHelper.from(this._items, isTab);
  }
  compose() {
    return {
      children: {
        toolbarContent: {
          class: {
            "b-tabpanel-tabs": 1
          }
        }
      }
    };
  }
  indexOfTab(tab) {
    return this._items.indexOf(tab, isTab);
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (child.index == null) {
      this.syncTabs();
    }
  }
  onChildRemove(child) {
    super.onChildRemove(child);
    this.syncTabs();
  }
  onFocusIn() {
    const { activeIndex } = this.owner;
    if (!isNaN(activeIndex)) {
      this.tabs[activeIndex].focus();
    }
  }
  syncTabs() {
    const { tabs } = this;
    for (let i = 0, n = tabs.length; i < n; ++i) {
      tabs[i].index = i;
      tabs[i].isFirst = !i;
      tabs[i].isLast = i === n - 1;
    }
  }
  tabAt(index) {
    return this._items.find(isTab, index) || null;
  }
};
__publicField(TabBar, "$name", "TabBar");
__publicField(TabBar, "type", "tabbar");
TabBar.initClass();
TabBar._$name = "TabBar";

// ../Core/lib/Core/widget/layout/Card.js
var animationClasses = [
  "b-slide-out-left",
  "b-slide-out-right",
  "b-slide-in-left",
  "b-slide-in-right"
];
var Card = class extends Layout {
  onChildAdd(item) {
    super.onChildAdd(item);
    const me = this, {
      activeItem,
      owner
    } = me, activeIndex = owner.activeIndex != null ? owner.activeIndex : me.activeIndex || 0, itemIndex = owner.items.indexOf(item), isActive = activeItem != null ? item === activeItem : itemIndex === activeIndex;
    item.ion({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
    if (isActive) {
      me._activeIndex = itemIndex;
      me._activeItem = item;
      item.show();
    } else {
      item.$isDeactivating = true;
      item.hide();
      item.$isDeactivating = false;
    }
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    const me = this;
    if (me._activeItem === item) {
      me.activateSiblingOf(item);
    }
    me._activeIndex = me.owner.items.indexOf(me._activeItem);
    item.un({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
  }
  /**
   * Detect external code showing a child. We veto that show and activate it through the API.
   * @internal
   */
  onBeforeChildShow({ source: showingChild }) {
    if (!this.owner.isConfiguring && !showingChild.$isActivating) {
      this.activeItem = showingChild;
      return false;
    }
  }
  /**
   * Detect external code hiding a child. We veto that show and activate an immediate sibling through the API.
   * @internal
   */
  onBeforeChildHide({ source: hidingChild }) {
    if (!this.owner.isConfiguring && !hidingChild.$isDeactivating) {
      this.activateSiblingOf(hidingChild);
      return false;
    }
  }
  activateSiblingOf(item) {
    const { owner } = this, items2 = owner.items.slice(), removeAt = items2.indexOf(item);
    items2.splice(removeAt, 1);
    this.activeIndex = Math.min(removeAt, items2.length - 1);
  }
  /**
   * Get/set active item, using index or the Widget to activate
   * @param {Core.widget.Widget|Number} activeIndex
   * @param {Number} [prevActiveIndex]
   * @param {Object} [options]
   * @param {Boolean} [options.animation] Pass `false` to disable animation
   * @param {Boolean} [options.silent] Pass `true` to not fire transition events
   * @returns {Object} An object describing the card change containing the following properties:
   *  - `prevActiveIndex` The previously active index.
   *  - `prevActiveItem ` The previously active child item.
   *  - `activeIndex    ` The newly active index.
   *  - `activeItem     ` The newly active child item.
   *  - `promise        ` A promise which completes when the slide-in animation finishes and the child item contains
   * focus if it is focusable.
   * @internal
   */
  setActiveItem(activeIndex, prevActiveIndex = this.activeIndex, options) {
    var _a4;
    const me = this, { owner } = me, { items: items2 } = owner, widgetPassed = activeIndex instanceof Widget, prevActiveItem = items2[prevActiveIndex], newActiveItem = owner.items[activeIndex = widgetPassed ? items2.indexOf(activeIndex) : parseInt(activeIndex, 10)], animation = (options == null ? void 0 : options.animation) !== false, chatty = !(options == null ? void 0 : options.silent), event = {
      prevActiveIndex,
      prevActiveItem
    };
    if (newActiveItem && !newActiveItem.$isActivating && newActiveItem !== prevActiveItem) {
      const prevItemElement = prevActiveItem && prevActiveItem.element, newActiveElement = newActiveItem && newActiveItem.element;
      if (me.animateDetacher) {
        const activeCardChange = me.animateDetacher.event;
        if (activeCardChange.activeItem === newActiveItem) {
          return activeCardChange.promise;
        }
        me.animateDetacher();
        activeCardChange.prevActiveItem.element.classList.remove(...animationClasses);
        activeCardChange.activeItem.element.classList.remove(...animationClasses);
        me.animateDetacher = null;
      }
      event.activeIndex = activeIndex;
      event.activeItem = newActiveItem;
      if (chatty && owner.trigger("beforeActiveItemChange", event) === false) {
        return null;
      }
      const reset = me._activeIndex !== event.activeIndex;
      if (reset) {
        me._activeIndex = event.activeIndex;
      }
      chatty && ((_a4 = owner.onBeginActiveItemChange) == null ? void 0 : _a4.call(owner, event));
      if (reset) {
        me._activeIndex = event.prevActiveIndex;
      }
      if (animation && prevItemElement && owner.isVisible && me.animateCardChange) {
        event.promise = me.cardChangeAnimation = new Promise((resolve, reject) => {
          const wasMonitoringSize = prevActiveItem.monitorResize;
          prevActiveItem.monitorResize = false;
          me.contentElement.style.overflowX = "hidden";
          prevActiveItem._hidden = true;
          newActiveItem.$isActivating = true;
          newActiveItem.show();
          newActiveItem.$isActivating = false;
          prevItemElement.classList.add(activeIndex > prevActiveIndex ? "b-slide-out-left" : "b-slide-out-right");
          newActiveElement.classList.add(activeIndex < prevActiveIndex ? "b-slide-in-left" : "b-slide-in-right");
          owner.isAnimating = true;
          me.animateDetacher = EventHelper.onTransitionEnd({
            mode: "animation",
            element: newActiveElement,
            // onTransitionEnd protects us from being called
            // after the thisObj is destroyed.
            thisObj: prevActiveItem,
            handler() {
              owner.isAnimating = me.cardChangeAnimation = false;
              if (!me.animateDetacher) {
                me.setActiveItem(activeIndex, prevActiveIndex, options);
                return;
              }
              me.animateDetacher = null;
              newActiveElement.classList.remove(...animationClasses);
              if (prevItemElement) {
                prevItemElement.classList.remove(...animationClasses);
                prevActiveItem.$isDeactivating = true;
                prevActiveItem._hidden = false;
                prevActiveItem.hide();
                prevActiveItem.monitorResize = wasMonitoringSize;
                prevActiveItem.$isDeactivating = false;
              }
              me.contentElement.style.overflowX = "";
              me.onActiveItemChange(event, resolve, !chatty);
            }
          });
          me.animateDetacher.reject = reject;
          me.animateDetacher.event = event;
        });
      } else {
        newActiveItem.$isActivating = true;
        newActiveItem.show();
        newActiveItem.focus();
        newActiveItem.$isActivating = false;
        if (prevActiveItem) {
          prevActiveItem.$isDeactivating = true;
          prevActiveItem.hide();
          prevActiveItem.$isDeactivating = false;
        }
        me.onActiveItemChange(event, null, !chatty);
      }
    }
    return event;
  }
  onActiveItemChange(event, resolve, silent) {
    const me = this;
    me._activeItem = event.activeItem;
    me._activeIndex = event.activeIndex;
    !silent && me.owner.trigger("activeItemChange", event);
    me.owner.containsFocus && event.activeItem.focus();
    resolve == null ? void 0 : resolve(event);
  }
  renderChildren() {
    const { owner } = this;
    owner.contentElement.classList.toggle(this.hideChildHeaderCls, owner.suppressChildHeaders);
    super.renderChildren();
  }
  changeActiveIndex(activeIndex) {
    const { owner } = this;
    return owner.isConfiguring && !owner._items ? activeIndex : Math.min(activeIndex, owner.items.length - 1);
  }
  updateActiveIndex(activeIndex, oldActiveIndex) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeIndex, oldActiveIndex);
    }
  }
  updateActiveItem(activeItem) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeItem, this.activeIndex);
    }
  }
  /**
   * If the layout is set to {@link #config-animateCardChange}, then this property
   * will be `true` during the animated card change.
   * @property {Boolean}
   * @readonly
   */
  get isChangingCard() {
    return Boolean(this.animateDetacher);
  }
};
__publicField(Card, "$name", "Card");
__publicField(Card, "type", "card");
__publicField(Card, "configurable", {
  containerCls: "b-card-container",
  itemCls: "b-card-item",
  hideChildHeaderCls: "b-hide-child-headers",
  /**
   * Specifies whether to slide tabs in and out of visibility.
   * @config {Boolean}
   * @default
   */
  animateCardChange: true,
  /**
   * The active child item.
   * @config {Core.widget.Widget}
   */
  activeItem: null,
  /**
   * The active child index.
   * @config {Number}
   */
  activeIndex: null
});
Card.initClass();
Card._$name = "Card";

// ../Core/lib/Core/widget/TabPanel.js
var isMaximized = (w) => w.maximized;
var TabPanel = class extends Panel {
  static get configurable() {
    return {
      /**
       * The index of the initially active tab.
       * @member {Number} activeTab
       */
      /**
       * The index of the initially active tab.
       * @config {Number}
       * @default
       */
      activeTab: 0,
      /**
       * Specifies whether to slide tabs in and out of visibility.
       * @config {Boolean}
       * @default
       */
      animateTabChange: true,
      /**
       * Set the height of all tabs to match the tab with the highest content.
       * @config {Boolean}
       * @default
       */
      autoHeight: false,
      defaultType: "container",
      focusable: false,
      itemCls: "b-tabpanel-item",
      layout: {
        type: "card"
      },
      // Prevent child panels from displaying a header unless explicitly configured with one
      suppressChildHeaders: true,
      tabBar: {
        type: "tabbar",
        weight: -2e3
      },
      /**
       * Min width of a tab title. 0 means no minimum width. This is default.
       * @config {Number}
       * @default
       */
      tabMinWidth: null,
      /**
       * Max width of a tab title. 0 means no maximum width. This is default.
       * @config {Number}
       * @default
       */
      tabMaxWidth: null
    };
  }
  //endregion
  //region Init
  /**
   * The active tab index. Setting must be done through {@link #property-activeTab}
   * @property {Number}
   * @readonly
   */
  get activeIndex() {
    return this.layout.activeIndex;
  }
  /**
   * The active child widget. Setting must be done through {@link #property-activeTab}
   * @property {Core.widget.Widget}
   * @readonly
   */
  get activeItem() {
    return this.layout.activeItem;
  }
  get activeTabItemIndex() {
    var _a4;
    const { activeTab, items: items2, tabBar } = this;
    return items2.indexOf((_a4 = tabBar.tabs[activeTab]) == null ? void 0 : _a4.item);
  }
  get bodyConfig() {
    return ObjectHelper.merge({
      className: {
        "b-tabpanel-body": 1
      }
    }, super.bodyConfig);
  }
  get focusElement() {
    var _a4;
    const activeTab = this.items[this.activeTab || 0];
    return (activeTab == null ? void 0 : activeTab.focusElement) || ((_a4 = activeTab == null ? void 0 : activeTab.tab) == null ? void 0 : _a4.focusElement);
  }
  get tabPanelBody() {
    return this.bodyElement;
  }
  finalizeInit() {
    super.finalizeInit();
    const me = this, { activeTab, layout } = me, { activeIndex } = layout, { tabs } = me.tabBar, activeTabItemIndex = activeTab >= 0 && activeTab < tabs.length && me.items.indexOf(tabs[activeTab].item);
    if (tabs.length > 0 && (activeTabItemIndex === false || activeTabItemIndex < 0)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabs.length} tabs)`);
    }
    if (activeTabItemIndex !== activeIndex) {
      layout.setActiveItem(activeTabItemIndex, activeIndex, {
        animation: false,
        silent: true
      });
    }
    layout.animateCardChange = me.animateTabChange;
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (!this.initialItems) {
      const me = this, { tabBar } = me, config = me.makeTabConfig(child), firstTab = config && (tabBar == null ? void 0 : tabBar.firstTab), tabBarItems = firstTab && tabBar._items, tabItems = firstTab && ArrayHelper.from(me._items, (it) => it.tab || it === child), index = firstTab ? tabItems.indexOf(child) + tabBarItems.indexOf(firstTab) : 0;
      if (config && tabBar) {
        if (firstTab && child.weight == null && index < tabBarItems.count - 1) {
          tabBar.insert(config, index);
        } else {
          tabBar.add(config);
        }
      }
    }
  }
  onChildRemove(child) {
    const { tab } = child, { items: items2 } = this;
    if (tab) {
      this.tabBar.remove(tab);
      tab.destroy();
    }
    if (child === this.activeItem) {
      this._activeTab = null;
      if (items2.length) {
        this.activeTab = items2[Math.min(this.activeIndex, items2.length - 1)];
      }
    }
    super.onChildRemove(child);
  }
  //endregion
  //region Tabs
  isDisabledOrHiddenTab(tabIndex) {
    const { tabs } = this.tabBar, tab = tabs == null ? void 0 : tabs[tabIndex];
    return tab && (tab.disabled || tab.hidden);
  }
  findAvailableTab(item, delta = 1) {
    const { tabs } = this.tabBar, tabCount = tabs.length, itemIndex = Math.max(0, tabs.indexOf(item.tab));
    if (itemIndex) {
      delta = -delta;
    }
    let activeTab;
    for (let n = 1; n <= tabCount; ++n) {
      activeTab = (itemIndex + (delta < 0 ? tabCount : 0) + n * delta) % tabCount;
      if (!this.isDisabledOrHiddenTab(activeTab)) {
        break;
      }
    }
    return activeTab;
  }
  activateAvailableTab(item, delta = 1) {
    this.activeTab = this.findAvailableTab(item, delta);
  }
  changeActiveTab(activeTab, oldActiveTab) {
    const me = this, {
      tabBar,
      layout
    } = me, { tabCount } = tabBar;
    if (activeTab.isWidget || ObjectHelper.isObject(activeTab)) {
      if (me.items.indexOf(activeTab) === -1) {
        activeTab = me.add(activeTab);
      }
      activeTab = tabBar.indexOfTab(activeTab.tab);
    } else {
      activeTab = parseInt(activeTab, 10);
    }
    if (!me.initialItems && tabCount > 0 && (activeTab < -1 || activeTab >= tabCount)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabCount} tabs)`);
    }
    if (me.isDisabledOrHiddenTab(activeTab)) {
      activeTab = me.findAvailableTab(activeTab);
    }
    if (layout.animateCardChange && layout.cardChangeAnimation) {
      layout.cardChangeAnimation.then((cardChange) => {
        if ((cardChange == null ? void 0 : cardChange.activeIndex) !== activeTab) {
          me._activeTab = activeTab;
          me.updateActiveTab(activeTab, oldActiveTab);
        }
      });
    } else {
      return activeTab;
    }
  }
  async updateActiveTab(activeTab, was) {
    var _a4;
    if (!this.initialItems) {
      const { activeTabItemIndex, layout } = this;
      if (activeTabItemIndex > -1) {
        const oldActiveItem = this.items[was], newActiveItem = this.items[activeTabItemIndex];
        if (layout.activeItem !== newActiveItem) {
          if (layout.animateCardChange) {
            await this.tabSelectionPromise;
          }
          if (oldActiveItem == null ? void 0 : oldActiveItem.containsFocus) {
            oldActiveItem.tab.focus();
          }
          this.tabSelectionPromise = (_a4 = layout.setActiveItem(newActiveItem)) == null ? void 0 : _a4.promise;
        }
      }
    }
  }
  changeTabBar(bar) {
    this.getConfig("strips");
    this.strips = {
      tabBar: bar
    };
    return this.strips.tabBar;
  }
  makeTabConfig(item) {
    const { tab } = item, config = {
      item,
      type: "tab",
      tabPanel: this,
      disabled: Boolean(item.disabled),
      hidden: item.initialConfig.hidden,
      weight: item.weight || 0,
      internalListeners: {
        click: "onTabClick",
        thisObj: this
      },
      localizableProperties: {
        // our tabs copy their text from the item's title and so are not directly localized
        text: false
      }
    };
    if (tab === false) {
      return null;
    }
    return ObjectHelper.isObject(tab) ? Tab.mergeConfigs(config, tab) : config;
  }
  updateItems(items2, was) {
    const me = this, { activeTab, initialItems } = me;
    let index = 0, tabs;
    super.updateItems(items2, was);
    if (initialItems) {
      tabs = Array.from(items2, (it) => me.makeTabConfig(it)).filter((it) => {
        if (it) {
          it.index = index++;
          return true;
        }
      });
      if (index) {
        tabs[0].isFirst = true;
        tabs[index - 1].isLast = true;
        tabs[activeTab].active = true;
        me.tabBar.add(tabs);
        me.activeTab = activeTab;
      }
    }
  }
  updateTabMinWidth(tabMinWidth) {
    var _a4;
    (_a4 = this.tabBar) == null ? void 0 : _a4.items.forEach((tab) => {
      if (tab.isTab) {
        tab.minWidth = tabMinWidth;
      }
    });
  }
  updateTabMaxWidth(tabMaxWidth) {
    var _a4;
    (_a4 = this.tabBar) == null ? void 0 : _a4.items.forEach((tab) => {
      if (tab.isTab) {
        tab.maxWidth = tabMaxWidth;
      }
    });
  }
  //endregion
  //region Auto height
  updateAutoHeight(autoHeight) {
    this.detachListeners("themeAutoHeight");
    autoHeight && GlobalEvents_default.ion({
      name: "themeAutoHeight",
      theme: "internalOnThemeChange",
      thisObj: this
    });
    this.$measureHeight = autoHeight;
  }
  applyAutoHeight() {
    const me = this, { layout, activeTab, element } = me, { animateCardChange } = layout;
    layout.animateCardChange = false;
    me.height = null;
    if (!me.up(isMaximized)) {
      const maxContentHeight = me.height = Math.max(...me.items.map((tab) => {
        me.activeTab = tab;
        return element.clientHeight;
      })) + 1;
      me.flex = `1 1 ${maxContentHeight}px`;
    }
    me.activeTab = activeTab;
    layout.animateCardChange = animateCardChange;
    me.$measureHeight = false;
  }
  internalOnThemeChange() {
    if (this.isVisible) {
      this.applyAutoHeight();
    } else {
      this.$measureHeight = true;
    }
  }
  //endregion
  //region Events
  // Called after beforeActiveItemChange has fired and not been vetoed before animation and activeItemChange
  onBeginActiveItemChange(activeItemChangeEvent) {
    const tabs = this.tabBar.tabs, { activeItem, prevActiveItem } = activeItemChangeEvent;
    this.activeTab = tabs.indexOf(activeItem == null ? void 0 : activeItem.tab);
    if (prevActiveItem == null ? void 0 : prevActiveItem.tab) {
      prevActiveItem.tab.active = false;
    }
    if (activeItem == null ? void 0 : activeItem.tab) {
      activeItem.tab.active = true;
      activeItem.tab.show();
    }
  }
  // Auto called because Card layout triggers the beforeActiveItemChange on its owner
  onBeforeActiveItemChange(activeItemChangeEvent) {
    return this.trigger("beforeTabChange", activeItemChangeEvent);
  }
  // Auto called because Card layout triggers the activeItemChange on its owner
  onActiveItemChange(activeItemChangeEvent) {
    this.trigger("tabChange", activeItemChangeEvent);
  }
  onTabClick(event) {
    this.activeTab = event.source.item;
  }
  onInternalPaint() {
    super.onInternalPaint(...arguments);
    if (this.$measureHeight) {
      this.applyAutoHeight();
    }
  }
  //endregion
};
//region Config
__publicField(TabPanel, "$name", "TabPanel");
__publicField(TabPanel, "type", "tabpanel");
__publicField(TabPanel, "alias", "tabs");
TabPanel.initClass();
TabPanel._$name = "TabPanel";

// ../Core/lib/Core/widget/TextAreaField.js
var TextAreaField = class extends Field {
  static get configurable() {
    return {
      /**
       * The resize style to apply to the `<textarea>` element.
       * @config {'none'|'both'|'horizontal'|'vertical'}
       * @default
       */
      resize: "none",
      inputAttributes: {
        tag: "textarea"
      }
    };
  }
  updateResize(resize) {
    this.input.style.resize = resize;
  }
};
__publicField(TextAreaField, "$name", "TextAreaField");
__publicField(TextAreaField, "type", "textareafield");
__publicField(TextAreaField, "alias", "textarea");
TextAreaField.initClass();
TextAreaField._$name = "TextAreaField";

// ../Core/lib/Core/widget/TextAreaPickerField.js
var _TextAreaPickerField = class _TextAreaPickerField extends PickerField {
  static get configurable() {
    return {
      picker: {
        type: "widget",
        tag: "textarea",
        cls: "b-textareapickerfield-picker",
        scrollAction: "realign",
        align: {
          align: "t-b",
          axisLock: true
        },
        autoShow: false
      },
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      /**
       * The resize style to apply to the `<textarea>` element.
       * @config {'none'|'both'|'horizontal'|'vertical'}
       * @default
       */
      resize: "none",
      inputType: null
    };
  }
  startConfigure(config) {
    if (typeof config.inline === "boolean") {
      VersionHelper.deprecate("Core", "6.0.0", "TextAreaPickerField.inline config is no longer supported");
    }
    super.startConfigure(config);
  }
  get inputElement() {
    const result = super.inputElement;
    result.readOnly = "readonly";
    result.reference = "displayElement";
    this.ariaElement = "displayElement";
    return result;
  }
  get focusElement() {
    var _a4;
    return ((_a4 = this._picker) == null ? void 0 : _a4.isVisible) ? this.input : this.displayElement;
  }
  get needsInputSync() {
    var _a4;
    return this.displayElement[this.inputValueAttr] !== String((_a4 = this.inputValue) != null ? _a4 : "");
  }
  showPicker() {
    const me = this, { picker } = me;
    if (!me.inline) {
      picker.width = me.pickerWidth || me[me.pickerAlignElement].offsetWidth;
      super.showPicker(true);
    }
  }
  focusPicker() {
    this.input.focus();
  }
  onPickerKeyDown(keyEvent) {
    const me = this, realInput = me.input;
    switch (keyEvent.key.trim() || keyEvent.code) {
      case "Escape":
        me.picker.hide();
        return;
      case "Enter":
        if (keyEvent.ctrlKey) {
          me.syncInputFieldValue();
          me.picker.hide();
        }
        break;
    }
    me.input = me.displayElement;
    const result = super.onPickerKeyDown(keyEvent);
    me.input = realInput;
    return result;
  }
  syncInputFieldValue(skipHighlight) {
    if (this.displayElement) {
      this.displayElement.value = this.inputValue;
    }
    super.syncInputFieldValue(skipHighlight);
  }
  changeValue(value) {
    return value == null ? "" : value;
  }
  changePicker(picker, oldPicker) {
    var _a4;
    const me = this, pickerWidth = me.pickerWidth || (picker == null ? void 0 : picker.width);
    picker = _TextAreaPickerField.reconfigure(oldPicker, picker ? Objects.merge({
      owner: me,
      forElement: me[me.pickerAlignElement],
      align: {
        matchSize: pickerWidth == null,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      id: me.id + "-input",
      style: {
        resize: me.resize
      },
      html: (_a4 = me.value) != null ? _a4 : ""
    }, picker) : null, me);
    if (picker) {
      const input = me.input = picker.element;
      me.inputListenerRemover = EventHelper.on({
        element: input,
        thisObj: me,
        focus: "internalOnInputFocus",
        change: "internalOnChange",
        input: "internalOnInput",
        keydown: "internalOnKeyEvent",
        keypress: "internalOnKeyEvent",
        keyup: "internalOnKeyEvent"
      });
    }
    return picker;
  }
};
__publicField(_TextAreaPickerField, "$name", "TextAreaPickerField");
__publicField(_TextAreaPickerField, "type", "textareapickerfield");
var TextAreaPickerField = _TextAreaPickerField;
TextAreaPickerField.initClass();
TextAreaPickerField._$name = "TextAreaPickerField";

// ../Core/lib/Core/widget/mixin/Minifiable.js
var Minifiable_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    compose() {
      const { minified } = this;
      return {
        class: {
          "b-minified": minified
        }
      };
    }
    get widgetClass() {
    }
  }, __publicField(_a4, "$name", "Minifiable"), __publicField(_a4, "configurable", {
    /**
     * Set to `false` to prevent this widget from assuming its {@link #config-minified} form automatically (for
     * example, due to {@link Core.widget.Toolbar#config-overflow} handling.
     *
     * When this value is `true` (the default), the minifiable widget's {@link #config-minified} config may be
     * set to `true` to reduce toolbar overflow.
     *
     * @config {Boolean}
     * @default
     */
    minifiable: true,
    /**
     * Set to `true` to present this widget in its minimal form.
     * @config {Boolean}
     * @default false
     */
    minified: null
  }), _a4;
};

// ../Core/lib/Core/widget/mixin/Responsive.js
var EMPTY = [];
var isStateName = (name) => name[0] !== "*";
var pop = (object, key) => {
  const ret = object[key] || null;
  delete object[key];
  return ret;
};
var responsiveRootFn = (widget) => widget.responsiveRoot;
var scoring = {
  number: (threshold) => ({ width }) => width <= threshold && threshold
};
var splitConfigs = (configs) => {
  delete configs.once;
  return {
    callback: pop(configs, "callback"),
    configs,
    when: pop(configs, "when")
  };
};
var splitMergedConfigs = (cls, ...parts) => {
  const once = parts.flatMap((p) => (p == null ? void 0 : p.once) || EMPTY), configs = cls.mergeConfigs(...parts), ret = splitConfigs(configs);
  ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;
  return ret;
};
var wrapWidget = (widget, handler) => {
  let triggers, desc = Proxy.revocable(widget, {
    get(o, name) {
      if (triggers) {
        triggers[name] = true;
      }
      return widget[name];
    }
  }), detacher2 = FunctionHelper.after(widget, "onConfigChange", (ignore, { name }) => {
    if (triggers == null ? void 0 : triggers[name]) {
      handler();
    }
  }), resizer = widget.ion({
    resize: () => {
      handler();
    }
  });
  widget.monitorResize = true;
  return {
    widget,
    get object() {
      return desc == null ? void 0 : desc.proxy;
    },
    destroy() {
      if (desc) {
        desc.revoke();
        detacher2();
        resizer();
        desc = detacher2 = resizer = null;
      }
    },
    reset() {
      triggers = /* @__PURE__ */ Object.create(null);
    }
  };
};
var Responsive_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base).mixin(Delayable_default, Fencible_default) {
    get isResponsivePending() {
      return this.responsiveUpdateCount === 0 && this.hasConfig("responsive");
    }
    get isResponsiveUpdating() {
      var _a5;
      return this._responsiveUpdating || ((_a5 = this.responsiveWidget) == null ? void 0 : _a5._responsiveUpdating);
    }
    // responsive
    updateResponsive(responsive) {
      var _a5;
      const me = this, cls = me.constructor, { responsiveDefaults } = me, stateNames = Array.from(
        new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))
      ).filter(isStateName);
      let states = null, hasWhen, name, state, when;
      if (responsive) {
        states = {
          "*": splitMergedConfigs(cls, responsiveDefaults["*"], responsive["*"])
        };
        for (name of stateNames) {
          state = responsive[name];
          if (state !== null && state !== false) {
            hasWhen = hasWhen || state && "when" in state;
            states[name] = splitMergedConfigs(
              cls,
              responsiveDefaults["*"],
              responsiveDefaults[name],
              responsive["*"],
              state
            );
            when = states[name].when;
            states[name].when = ((_a5 = scoring[typeof when]) == null ? void 0 : _a5.call(scoring, when)) || when;
          }
        }
      }
      me.$responsiveStates = states;
      me.$responsiveWhen = hasWhen;
      me.syncResponsiveWidget();
    }
    // responsiveState
    updateResponsiveState(state, oldState) {
      var _a5, _b, _c, _d, _e;
      const me = this, { $responsiveStates: states } = me, initial = ++me.responsiveStateChanges === 1, classList = (_a5 = me.element) == null ? void 0 : _a5.classList, defaults = states["*"], def = states[state] || defaults, once = initial && (def.once || defaults.once), isStateful = initial && me.isStateful, target = me.responsiveWidget;
      let config = def.configs, otherConfigs = once == null ? void 0 : once.configs;
      if (otherConfigs) {
        config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
      }
      oldState && (classList == null ? void 0 : classList.remove(`b-responsive-${oldState.toLowerCase()}`));
      state && (classList == null ? void 0 : classList.add(`b-responsive-${state.toLowerCase()}`));
      if (isStateful) {
        otherConfigs = me.loadStatefulData();
        if (otherConfigs) {
          config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
        }
        me.suspendStateful();
      }
      me._responsiveUpdating = true;
      try {
        (_b = me.trigger) == null ? void 0 : _b.call(me, "beforeResponsiveStateChange", { state, oldState, target });
        config && me.setConfig(config);
        (_c = def.callback) == null ? void 0 : _c.call(def, { source: me, state, oldState, target, initial });
        (_d = once == null ? void 0 : once.callback) == null ? void 0 : _d.call(once, { source: me, state, oldState, target, initial });
        (_e = me.trigger) == null ? void 0 : _e.call(me, "responsiveStateChange", { state, oldState, target });
      } finally {
        me._responsiveUpdating = false;
        isStateful && me.resumeStateful();
      }
    }
    // responsiveTarget
    get responsiveTarget() {
      return this.responsiveWidget || this._responsiveTarget;
    }
    updateResponsiveTarget() {
      this.syncResponsiveWidget();
    }
    // responsiveWidget
    updateResponsiveWidget(target) {
      var _a5;
      const me = this, responsiveUpdate = target && me.responsiveUpdate;
      (_a5 = me.$responsiveWrapper) == null ? void 0 : _a5.destroy();
      me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);
      responsiveUpdate == null ? void 0 : responsiveUpdate.now();
    }
    // Support methods
    responsiveUpdate() {
      const me = this, { $responsiveStates: states, $responsiveWrapper: wrapper } = me, responsiveTarget = wrapper == null ? void 0 : wrapper.widget;
      if (states && wrapper) {
        let best = null, bestScore = 0, fromWhen = states, score, state;
        if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {
          responsiveTarget.getConfig("responsive");
          fromWhen = responsiveTarget.$responsiveStates || fromWhen;
        }
        wrapper.reset();
        for (state in states) {
          if (state !== "*") {
            score = fromWhen[state].when(wrapper.object, BrowserHelper);
            if (score != null && score !== false && (!best || score < bestScore)) {
              best = state;
              bestScore = score;
            }
          }
        }
        ++me.responsiveUpdateCount;
        me.responsiveState = best;
      }
    }
    syncResponsiveWidget() {
      var _a5;
      const me = this;
      let widget = null, responsiveTarget;
      if (!me.isDestroying && me.responsive) {
        responsiveTarget = me.responsiveTarget;
        if (!(widget = responsiveTarget)) {
          widget = !me.responsiveRoot && ((_a5 = me.up) == null ? void 0 : _a5.call(me, responsiveRootFn)) || me;
        } else if (typeof responsiveTarget === "string") {
          widget = responsiveTarget === "@" ? me : responsiveTarget[0] === "@" ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget);
          if (!widget) {
            throw new Error(`No match for responsiveTarget="${responsiveTarget}"`);
          }
        }
        if (!widget.isWidget) {
          throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);
        }
      }
      me.responsiveWidget = widget;
      return widget;
    }
    changeBreakpoints(breakpoints) {
      ObjectHelper.assertObject(breakpoints, "breakpoints");
      if (breakpoints == null ? void 0 : breakpoints.width) {
        Object.keys(breakpoints.width).forEach((key) => {
          breakpoints.width[key].maxWidth = key;
        });
      }
      if (breakpoints == null ? void 0 : breakpoints.height) {
        Object.keys(breakpoints.height).forEach((key) => {
          breakpoints.height[key].maxHeight = key;
        });
      }
      return breakpoints;
    }
    updateBreakpoints(breakpoints) {
      if (breakpoints) {
        this.monitorResize = true;
      }
    }
    // Get a width/height breakpoint for the supplied dimension
    getBreakpoint(levels, dimension) {
      const ascendingLevels = Object.keys(levels).map((l) => parseInt(l)).sort(), breakpoint = ascendingLevels.find((bp) => dimension <= bp);
      return levels[breakpoint != null ? breakpoint : levels["*"] && "*"];
    }
    // Apply a breakpoints configs, trigger event and call any callback
    activateBreakpoint(orientation, breakpoint) {
      var _a5, _b;
      const me = this, prevBreakpoint = me[`current${orientation}Breakpoint`];
      if (breakpoint !== prevBreakpoint) {
        me[`current${orientation}Breakpoint`] = breakpoint;
        me.setConfig(breakpoint.configs);
        prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);
        me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);
        me.trigger(`responsive${orientation}Change`, { breakpoint, prevBreakpoint });
        (_a5 = breakpoint.callback) == null ? void 0 : _a5.call(breakpoint, { source: me, breakpoint, prevBreakpoint });
        (_b = me.recompose) == null ? void 0 : _b.call(me);
      }
    }
    // Called on resize to pick and apply a breakpoint, if size changed enough
    applyResponsiveBreakpoints(width, height) {
      var _a5;
      const me = this, {
        width: widths,
        height: heights
      } = (_a5 = me.breakpoints) != null ? _a5 : {};
      if (widths) {
        const breakpoint = me.getBreakpoint(widths, width);
        me.activateBreakpoint("Width", breakpoint);
      }
      if (heights) {
        const breakpoint = me.getBreakpoint(heights, height);
        me.activateBreakpoint("Height", breakpoint);
      }
    }
    onInternalResize(element, width, height, oldWidth, oldHeight) {
      super.onInternalResize(element, width, height, oldWidth, oldHeight);
      this.applyResponsiveBreakpoints(width, height);
    }
  }, __publicField(_a4, "$name", "Responsive"), __publicField(_a4, "configurable", {
    /**
     * Specifies the various responsive state objects keyed by their name. Each key (except `'*'`, see below) in
     * this object is a state name (see {@link #config-responsiveState}) and its corresponding value is the
     * associated {@link #typedef-ResponsiveState} object.
     *
     * Some properties of a `ResponsiveState` object are special, for example `when` and `callback`. All other
     * properties of the state object are config properties to apply when that state is active.
     *
     * The `when` property can be a function that computes the score for the state. The state whose `when` function
     * returns the lowest score is selected and its non-special properties will be assigned to the instance. If
     * `when` is a number, it will be converted into a scoring function (see below).
     *
     * A `when` function accepts two readonly parameters and returns either a numeric score if the state should be
     * considered, or `false` or `null` if the state should be ignored (i.e., it does match with the current state).
     *
     * The first parameter is a readonly proxy for the {@link #config-responsiveTarget widget} whose size and other
     * properties determine the state's score. The proxy tracks property access to that widget in order to update
     * the responsive state should any of those properties change.
     *
     * The second argument to a `when` function is the {@link Core.helper.BrowserHelper} singleton. This allows
     * a `when` function to conveniently test platform and browser information.
     *
     * The state whose `when` function returns the lowest score is selected as the new
     * {@link #config-responsiveState} and its config object (minus the `when` function and other special
     * properties) is applied to the instance.
     *
     * If `when` is a number, it is converted to function. The following two snippets produce the same `when`
     * scoring:
     *
     * ```javascript
     *      small : {
     *          when : 400,
     *          ...
     *      }
     * ```
     *
     * The above converted to:
     *
     * ```javascript
     *      small : {
     *          when : ({ width }) => width <= 400 && 400,
     *          ...
     *      }
     * ```
     * Selecting the lowest score as the winner allows for the simple conversion of width threshold to score value,
     * such that the state with the smallest matching width is selected.
     *
     * If the `responsive` config object has an asterisk key (`'*'`), its value is used as the default set of config
     * properties to apply all other states. This will be the only config properties to apply if no `when` function
     * returns a score. In this way, this special state object acts as a default state as well as a set of
     * default values for other states to share. This state object has no `when` function.
     *
     * The default for this config is:
     * ```javascript
     *  {
     *      small : {
     *          when : 400
     *      },
     *
     *      medium : {
     *          when : 800
     *      },
     *
     *      large : {
     *          when : () => Infinity
     *      },
     *
     *      '*' : {}
     *  }
     * ```
     *
     * A derived class (or instance) can use these states by populating other config properties, define
     * additional states, and/or adjust the `when` properties to use different size thresholds.
     *
     * @config {Object}
     */
    responsive: {
      $config: {
        lazy: "paint"
      },
      value: null
    },
    /**
     * The defaults for the {@link #config-responsive} config. These are separated so that the act of setting the
     * {@link #config-responsive} config is what triggers additional processing.
     * @config {Object}
     * @internal
     * @default
     */
    responsiveDefaults: {
      small: {
        when: 400
      },
      medium: {
        when: 800
      },
      large: {
        when: () => Infinity
      },
      "*": {}
    },
    /**
     * Set to `true` to mark this instance as the default {@link #config-responsiveTarget} for descendants that do
     * not specify an explicit {@link #config-responsiveTarget} of their own.
     * @config {Boolean}
     * @default false
     */
    responsiveRoot: null,
    /**
     * The name of the active state of the {@link #config-responsive} config. This is assigned internally
     * and should not be assigned directly.
     *
     * @config {String}
     * @readonly
     */
    responsiveState: null,
    /**
     * The widget whose size and other properties drive this object's responsive behavior. If this config is not
     * specified, the closest ancestor that specified {@link #config-responsiveRoot responsiveRoot=true} will be
     * used. If there is no such ancestor, then the instance using this mixin is used.
     *
     * If this value is set to `'@'`, then this instance is used even if there is a {@link #config-responsiveRoot}
     * ancestor.
     *
     * If this config is a string that starts with `'@'`, the text following the first character is the name of the
     * property on this instance that holds the target to use. For example, `'@owner'` to use the value of the
     * `owner` property as the responsive target.
     *
     * If this config is a string that does not start with `'@'`, that string is passed to
     * {@link Core.widget.Widget#function-up} to find the closest matching ancestor.
     *
     * If another widget is used as the `responsiveTarget` and if this instance does not specify any explicit `when`
     * properties in its {@link #config-responsive} config, then the `when` definitions of the `responsiveTarget`
     * will be used for this instance.
     * @config {String|Core.widget.Widget}
     */
    responsiveTarget: {
      value: null,
      $config: {
        lazy: "paint"
      }
    },
    responsiveWidget: {
      value: null,
      $config: {
        nullify: true
      }
    },
    /**
     * Defines responsive breakpoints, based on max-width or max-height.
     *
     * When the widget is resized, the defined breakpoints are queried to find the closest larger or equal
     * breakpoint for both width and height. If the found breakpoint differs from the currently applied, it is
     * applied.
     *
     * Applying a breakpoint triggers an event that applications can catch to react to the change. It also
     * optionally applies a set of configs and calls a configured callback.
     *
     * ```javascript
     * breakpoints : {
     *     width : {
     *         50 : { name : 'small', configs : { text : 'Small', ... } }
     *         100 : { name : 'medium', configs : { text : 'Medium', ... } },
     *         '*' : { name : 'large', configs : { text : 'Large', ... } }
     *     }
     * }
     * ```
     *
     * @config {Object}
     * @param {Object} width Max-width breakpoints, with keys as numerical widths (or '*' for larger widths than the
     * largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}
     * @param {Object} height Max-height breakpoints, with keys as numerical heights (or '*' for larger widths than
     * the largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}
     * @deprecated 5.0 Use {@link #config-responsive} instead.
     */
    breakpoints: null
  }), __publicField(_a4, "delayable", {
    responsiveUpdate: "raf"
  }), __publicField(_a4, "fenced", {
    syncResponsiveWidget: true
  }), __publicField(_a4, "prototypeProperties", {
    responsiveStateChanges: 0,
    responsiveUpdateCount: 0
  }), _a4;
};

// ../Core/lib/Core/widget/mixin/Styleable.js
var Styleable_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    changeCssVarPrefix(prefix) {
      ObjectHelper.assertString(prefix, "prefix");
      if (prefix && !prefix.endsWith("-")) {
        prefix = prefix + "-";
      }
      return prefix || "";
    }
    changeCss(css) {
      ObjectHelper.assertObject(css, "css");
      const me = this;
      if (!globalThis.Proxy) {
        throw new Error("Proxy not supported");
      }
      const proxy = new Proxy({}, {
        get(target, property) {
          var _a5;
          const styles = getComputedStyle(me.element || document.documentElement);
          return (_a5 = styles.getPropertyValue(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`)) == null ? void 0 : _a5.trim();
        },
        set(target, property, value) {
          const element = me.element || document.documentElement;
          element.style.setProperty(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`, value);
          return true;
        }
      });
      if (css) {
        if (me._element) {
          ObjectHelper.assign(proxy, css);
        } else {
          me.$initialCSS = css;
        }
      }
      return proxy;
    }
    // Apply any initially supplied CSS when we have an element
    updateElement(element, ...args) {
      super.updateElement(element, ...args);
      if (this.$initialCSS) {
        ObjectHelper.assign(this.css, this.$initialCSS);
      }
    }
    get widgetClass() {
    }
  }, __publicField(_a4, "$name", "Styleable"), __publicField(_a4, "configurable", {
    /**
     * CSS variable prefix, appended to the keys used in {@link #config-css}.
     *
     * For example:
     *
     * ```javascript
     * {
     *    cssVarPrefix : 'taskboard',
     *
     *    css : {
     *        cardBackground : '#333'
     *    }
     * }
     * ```
     *
     * Results in the css var `--taskboard-card-background` being set to `#333`.
     * @config {String}
     * @category CSS
     */
    cssVarPrefix: "",
    /**
     * Allows runtime manipulating of CSS variables.
     *
     * See {@link #config-css} for more information.
     *
     * ```javascript
     * taskBoard.css.columnBackground = '#ccc';
     *
     * // Will set "--taskboard-column-background : #ccc"
     * ```
     *
     * @member {Proxy} css
     * @typings {typeof Proxy}
     * @category DOM
     */
    /**
     * Initial CSS variables to set.
     *
     * Each key will be applied as a CSS variable to the target elements style. Key names are hyphenated and
     * prefixed with {@link #config-cssVarPrefix} in the process. For example:
     *
     * ```javascript
     * {
     *    cssVarPrefix : 'taskboard',
     *
     *    css : {
     *        cardBackground : '#333'
     *    }
     * }
     * ```
     *
     * Results in the css var `--taskboard-card-background` being set to `#333`.
     *
     * @config {Object<String,String>}
     * @category CSS
     */
    css: {}
  }), _a4;
};

// ../Core/lib/Core/widget/graph/Histogram.js
var ns = "http://www.w3.org/2000/svg";
var typePrio = {
  bar: 1,
  outline: 2,
  text: 3
};
var byOrder = (l, r) => parseInt(l.order, 10) - parseInt(r.order, 10);
var byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10);
var getField = (s) => s.field;
var returnFalse = () => false;
var classesDelimiter = /\s+/;
var Histogram = class extends Widget {
  static get configurable() {
    return {
      /**
       * An array of data objects used to drive the histogram. The property/properties used
       * are defined in the {@link #config-series} option.
       * @config {Object[]}
       * @default
       */
      data: null,
      /**
       * The values to represent in bar form.
       * @config {Number[]}
       */
      values: null,
      /**
       * Object enumerating data series for the histogram.
       * The object keys are treated as series identifiers and values are objects that
       * can contain the following properties:
       *  - `type` A String, either `'bar'` or `'outline'`
       *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.
       * If the value is omitted the series identifier is used as the property name.
       * @config {Object<String, HistogramSeries>}
       */
      series: null,
      /**
       * By default, the bars are scaled based upon the detected max value across all the series.
       * A specific top value to represent the 100% height may be configured.
       * @config {Number}
       */
      topValue: null,
      element: {
        children: [{
          ns,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns,
            tag: "g",
            reference: "scaledSvgGroup"
          }, {
            ns,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      /**
       * By default, all bars are rendered, even those with zero height. Configure this as `true`
       * to omit zero height bars.
       * @config {Boolean}
       * @default
       */
      omitZeroHeightBars: false,
      /**
       * By default, the histogram calls {@link #config-getBarText} once per each datum.
       * So the function is supposed to output all the series values the way it needs.
       * Configure this as `false` to call the function for each series value
       * if you need to display the values separately or having different styling.
       * @config {Boolean}
       * @default
       */
      singleTextForAllBars: true,
      monitorResize: true,
      /**
       * A Function which returns a CSS class name to add to a rectangle element.
       * The following parameters are passed:
       * @config {Function}
       * @param {HistogramSeries} series The series being rendered
       * @param {Object} rectConfig The rectangle configuration object
       * @param {Object} datum The datum being rendered
       * @param {Number} index The index of the datum being rendered
       * @returns {String} CSS class name of the rectangle element
       */
      getRectClass(series, rectConfig, datum, index) {
        return "";
      },
      /**
       * A Function which returns a CSS class name to add to a path element
       * built for an `outline` type series.
       * The following parameters are passed:
       * @param {HistogramSeries} series The series being rendered
       * @param {Object[]} data The series data
       * @returns {String} CSS class name of the path element
       * @config {Function}
       */
      getOutlineClass(series, data) {
        return "";
      },
      /**
       * A Function which returns the tooltip text to display when hovering a bar.
       * The following parameters are passed:
       *
       * @config {Function}
       * @param {HistogramSeries} series The series being rendered
       * @param {Object} rectConfig The rectangle configuration object
       * @param {Object} datum The datum being rendered
       * @param {Number} index The index of the datum being rendered
       * @returns {String} Tip for the the bar.
       */
      getBarTip(series, rectConfig, datum, index) {
      },
      /**
       * A Function which returns the text to render inside a bar.
       * The following parameters are passed:
       * @param {Object} datum The datum being rendered
       * @param {Number} index The index of the datum being rendered
       * @param {HistogramSeries} [series] The series (provided if {@link #config-singleTextForAllBars}
       * is `false`)
       * @returns {String} Text to render in the bar.
       * @config {Function}
       */
      getBarText(datum, index, series) {
        return "";
      },
      getRectConfig: null,
      getBarTextRenderData(renderData, datum, index, series) {
        return renderData;
      },
      getBarTextTip(renderData, datum, index, series) {
      }
    };
  }
  //endregion
  //region Init
  construct(config) {
    const me = this;
    super.construct(config);
    me.scheduleRefresh = me.createOnFrame(me.refresh, [], me, true);
    me.refresh();
  }
  set tip(tip) {
    var _a4;
    const me = this;
    (_a4 = me.tip) == null ? void 0 : _a4.destroy();
    if (tip) {
      me._tip = Tooltip.new({
        owner: me,
        forElement: me.svgElement,
        forSelector: "rect",
        internalListeners: {
          beforeShow: "up.onBeforeTipShow"
        }
      }, tip);
    } else {
      me._tip = null;
    }
  }
  onElementResize() {
    super.onElementResize(...arguments);
    const svgRect = this.svgElement.getBoundingClientRect();
    this.scaledSvgGroup.setAttribute("transform", `scale(${svgRect.width} ${svgRect.height})`);
  }
  onBeforeTipShow({ source: tip }) {
    const index = parseInt(tip.activeTarget.dataset.index);
    tip.html = tip.contentTemplate({
      histogram: this,
      index
    });
  }
  updateSeries(value) {
    const me = this, series = me._series = {};
    let index = 0, barSeriesCount = 0;
    for (const id in value) {
      if (value[id] !== false) {
        const data = series[id] = Objects.merge({}, value[id]);
        if (!data.field) {
          data.field = id;
        }
        if (!data.type) {
          data.type = "bar";
        }
        if (!("order" in data)) {
          data.order = typePrio[data.type] * 10 + index;
        }
        if (!("index" in data)) {
          data.index = index;
        }
        if (data.type === "bar") {
          data.index = barSeriesCount++;
        }
        data.id = id;
        index++;
      }
    }
    if (!me.topValue && me._data) {
      me.topValue = me.getDataTopValue(me._data);
    }
    if (!me.refreshSuspended) {
      me.scheduleRefresh();
    }
  }
  getDataTopValue(data, series) {
    const fields = Object.values(series || this.series).map(getField);
    let result = 0, datum;
    for (let i = 0, { length } = data; i < length; i++) {
      datum = data[i];
      for (let j = 0, { length: length2 } = fields; j < length2; j++) {
        result = Math.max(result, datum[fields[j]]);
      }
    }
    return result;
  }
  updateData(data) {
    const me = this;
    me._data = data;
    if (!me.topValue && me._data && me._series) {
      me.topValue = me.getDataTopValue(data);
    }
    if (!me.refreshSuspended) {
      me.scheduleRefresh();
    }
  }
  updateTopValue(value) {
    const me = this;
    me._topValue = value;
    if (!value && me._data) {
      me._topValue = me.getDataTopValue(me._data);
    }
    if (!me.refreshSuspended) {
      me.scheduleRefresh();
    }
  }
  // Must exist from the start because configuration setters call it.
  // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.
  scheduleRefresh() {
  }
  suspendRefresh() {
    this.refreshSuspended++;
  }
  resumeRefresh() {
    if (this.refreshSuspended) {
      this.refreshSuspended--;
    }
  }
  refresh(params) {
    const me = this, {
      series,
      _tip,
      topValue,
      singleTextForAllBars
    } = me, extraArgs = (params == null ? void 0 : params.args) || [], histogramElements = [], textElements = [];
    if (!series) {
      return;
    }
    for (const data of Object.values(series).sort(byOrder)) {
      const elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data, ...extraArgs);
      if (Array.isArray(elConfig)) {
        histogramElements.push.apply(histogramElements, elConfig);
      } else {
        histogramElements.push(elConfig);
      }
      if (!singleTextForAllBars && data.type === "bar") {
        textElements.push(...me.drawText(data, ...extraArgs));
      }
    }
    histogramElements.sort(byDatasetOrder);
    if (singleTextForAllBars) {
      textElements.push(...me.drawText(null, ...extraArgs));
    } else {
      textElements.sort(byDatasetOrder);
    }
    DomSync.sync({
      domConfig: {
        width: "100%",
        height: "100%",
        preserveAspectRatio: "none",
        dataset: {
          topValue
        },
        children: [
          {
            ns,
            tag: "g",
            reference: "scaledSvgGroup",
            children: histogramElements
          },
          {
            ns,
            tag: "g",
            reference: "unscaledSvgGroup",
            children: textElements
          }
        ]
      },
      configEquality: returnFalse,
      targetElement: me.svgElement
    });
    if (_tip && _tip.isVisible) {
      me.onBeforeTipShow({ source: _tip });
    }
  }
  drawBar(series, ...args) {
    const me = this, {
      topValue,
      data,
      omitZeroHeightBars,
      barStyle
    } = me, {
      field,
      order,
      stretch
    } = series, { length } = data, defaultWidth = 1 / length, children = [], seriesId = StringHelper.createId(series.id), seriesIndex = series.index, forceHeight = stretch ? 1 : void 0;
    let width;
    for (let index = 0, x = 0, { length: length2 } = data; index < length2; index++, x += width) {
      const datum = data[index];
      let rectConfig = datum.rectConfig = {
        ns,
        tag: "rect",
        dataset: {}
      };
      const value = datum[field], height = value ? forceHeight || datum.height || (value > topValue ? topValue : value) / topValue : 0, y = 1 - height, barTip = me.callback("getBarTip", me, [series, rectConfig, datum, index, ...args]);
      width = datum.width || defaultWidth;
      if (barStyle) {
        rectConfig.style = barStyle;
      } else {
        delete rectConfig.style;
      }
      Object.assign(rectConfig.dataset, {
        index,
        order,
        series: seriesId
      });
      const rectClass = {
        [`b-series-${seriesId}`]: 1,
        [`b-series-index-${seriesIndex}`]: 1
      }, classes = me.callback("getRectClass", me, [series, rectConfig, datum, index, ...args]);
      if (classes) {
        classes.split(classesDelimiter).forEach((cls) => rectClass[cls] = 1);
      }
      Object.assign(rectConfig, {
        x,
        y,
        width,
        height,
        class: rectClass
      });
      if (barTip) {
        rectConfig.dataset.btip = barTip;
      } else {
        delete rectConfig.dataset.btip;
      }
      if (me.getRectConfig) {
        rectConfig = me.getRectConfig(rectConfig, datum, index, series, ...args);
      }
      if (rectConfig && (rectConfig.height || !omitZeroHeightBars)) {
        children.push(rectConfig);
      }
    }
    return children;
  }
  changeGetRectConfig(fn) {
    return fn ? this.bindCallback(fn) : null;
  }
  drawOutline(series, ...args) {
    const me = this, {
      topValue,
      data
    } = me, {
      field,
      order,
      id
    } = series, defaultWidth = 1 / data.length, coords = ["M 0,1"], result = {
      ns,
      tag: "path",
      dataset: {
        order,
        id
      }
    };
    let barWidth, command1 = "M", command2 = "L";
    for (let i = 0, x = 0, { length } = data; i < length; i++) {
      const barHeight = 1 - data[i][field] / topValue;
      barWidth = data[i].width || defaultWidth;
      coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);
      command1 = command2 = "";
    }
    result.class = `b-series-${series.id} b-series-index-${series.index} ` + me.callback("getOutlineClass", me, [series, data, ...args]);
    result.d = coords.join(" ");
    return result;
  }
  drawText(series, ...args) {
    const me = this, { data } = me, defaultWidth = 1 / data.length, defaultY = "100%", unscaledSvgGroups = [];
    for (let index = 0, width, x = 0, { length } = data; index < length; index++, x += width) {
      width = data[index].width || defaultWidth;
      const barText = me.callback("getBarText", me, [data[index], index, series, ...args]);
      if (barText) {
        const renderData = me.callback("getBarTextRenderData", me, [{
          ns,
          tag: "text",
          className: "b-bar-legend",
          html: barText,
          left: x,
          width,
          x: `${(x + width / 2) * 100}%`,
          y: data[index].y !== void 0 ? data[index].y : defaultY,
          dataset: {
            index,
            series
          }
        }, data[index], index, series, ...args]);
        const barTip = me.callback("getBarTextTip", me, [renderData, data[index], index, series, ...args]);
        if (barTip) {
          renderData.dataset.btip = barTip;
        } else {
          delete renderData.dataset.btip;
        }
        unscaledSvgGroups.push(renderData);
      }
    }
    return unscaledSvgGroups;
  }
  //endregion
};
//region Config
__publicField(Histogram, "type", "histogram");
__publicField(Histogram, "$name", "Histogram");
__publicField(Histogram, "properties", {
  refreshSuspended: 0
});
Histogram.initClass();
Histogram._$name = "Histogram";

// ../Core/lib/Core/widget/graph/Scale.js
var ns2 = "http://www.w3.org/2000/svg";
var Scale = class extends Widget {
  static get configurable() {
    return {
      scalePoints: null,
      // Padding after the max scale point.
      // Expressed as the share of the height.
      scaleMaxPadding: 0.1,
      /**
       * Configure as `true` to create a horizontal scale. Scales are vertical by default.
       * @config {Boolean}
       */
      horizontal: false,
      /**
       * Side to align the scale to. Defaults to `bottom` for {@link #config-horizontal} Scales
       * and `right` for vertical Scales.
       * @config {String}
       */
      align: {
        value: false,
        $config: {
          merge: "replace"
        }
      },
      element: {
        children: [{
          ns: ns2,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns: ns2,
            tag: "g",
            reference: "scaledSvgGroup",
            children: [{
              ns: ns2,
              tag: "path",
              reference: "pathElement"
            }]
          }, {
            ns: ns2,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      monitorResize: true
    };
  }
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);
    this.refresh();
  }
  changeAlign(align) {
    if (!align) {
      align = this.horizontal ? "bottom" : "right";
    }
    return align;
  }
  updateAlign(align, oldAlign) {
    this.element.classList.remove(`b-align-${oldAlign}`);
    this.element.classList.add(`b-align-${align}`);
  }
  updateHorizontal(horizontal, oldHorizontal) {
    this.element.classList.remove(`b-scale-${oldHorizontal ? "horizontal" : "vertical"}`);
    this.element.classList.add(`b-scale-${horizontal ? "horizontal" : "vertical"}`);
  }
  onElementResize() {
    super.onElementResize(...arguments);
    this.scheduleRefresh();
  }
  // Must exist from the start because configuration setters call it.
  // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.
  scheduleRefresh() {
  }
  refresh() {
    var _a4;
    if (!this.scalePoints) {
      return;
    }
    const me = this, {
      horizontal,
      width,
      height,
      align,
      scalePoints,
      scaleMaxPadding
    } = me, scaleMax = (_a4 = scalePoints[scalePoints.length - 1]) == null ? void 0 : _a4.value, path = [], labels = [];
    const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);
    me.scaledSvgGroup.setAttribute("transform", `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);
    for (const point of scalePoints) {
      const isLabelStep = Boolean(point.text), pos = posFactor * point.value;
      if (isLabelStep) {
        const label = {
          ns: ns2,
          tag: "text",
          className: "b-scale-tick-label",
          html: point.text,
          dataset: {
            tick: point.value
          }
        };
        if (horizontal) {
          label.x = `${pos * 100}%`;
          label.y = align === "top" ? "1.6em" : height - 12;
        } else {
          label.x = align === "left" ? "12" : `${width - 12}`;
          label.y = `${(1 - pos) * 100}%`;
        }
        labels.push(label);
      }
      if (horizontal) {
        if (align === "top") {
          path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);
        } else {
          path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);
        }
      } else {
        if (align === "left") {
          path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);
        } else {
          path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);
        }
      }
    }
    me.pathElement.setAttribute("d", path.join(""));
    DomSync.syncChildren({
      domConfig: { children: labels }
    }, me.unscaledSvgGroup);
  }
  //endregion
};
//region Config
__publicField(Scale, "$name", "Scale");
__publicField(Scale, "type", "scale");
Scale.initClass();
Scale._$name = "Scale";

// ../Core/lib/Core/widget/util/AvatarRendering.js
var _AvatarRendering = class _AvatarRendering extends Base {
  static get configurable() {
    return {
      /**
       * Element used to listen for load errors. Normally the owning widgets own element.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * Prefix prepended to a supplied color to create a CSS class applied when showing initials.
       * @config {String}
       * @default
       */
      colorPrefix: "b-sch-",
      /**
       * A tooltip config object to enable using a custom tooltip for the avatars. Listen for `beforeShow` and set
       * your html there.
       * @config {TooltipConfig}
       */
      tooltip: null,
      size: null
    };
  }
  doDestroy() {
    var _a4;
    (_a4 = this.tooltip) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  updateElement(element) {
    EventHelper.on({
      element,
      delegate: ".b-resource-image",
      error: "onImageErrorEvent",
      thisObj: this,
      capture: true
    });
  }
  changeTooltip(config) {
    return Tooltip.new({
      forElement: this.element,
      forSelector: ".b-resource-avatar",
      cls: "b-resource-avatar-tooltip"
    }, config);
  }
  static get failedUrls() {
    return this._failedUrls || (this._failedUrls = /* @__PURE__ */ new Set());
  }
  /**
   * Returns a DOM config object containing a resource avatar, icon or resource initials. Display priority in that
   * order.
   * @param {AvatarConfig|AvatarConfig[]} options A single avatar config object or an array of the same.
   * @returns {DomConfig}
   */
  getResourceAvatar(options) {
    if (Array.isArray(options)) {
      return options.map((item) => this.getResourceAvatar(item));
    }
    const { initials, color, iconCls, imageUrl, defaultImageUrl, dataset = {}, resourceRecord, alt: alt2 = StringHelper.encodeHtml(resourceRecord == null ? void 0 : resourceRecord.name) } = options, config = this.getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) || this.getIconConfig(iconCls, dataset, alt2) || this.getResourceInitialsConfig(initials, color, dataset, alt2), { size } = this;
    Object.assign(config.style, {
      ...size ? { height: size, width: size } : void 0
    });
    return config;
  }
  getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) {
    imageUrl = _AvatarRendering.failedUrls.has(imageUrl) ? defaultImageUrl : imageUrl || defaultImageUrl;
    if (imageUrl) {
      return {
        tag: "img",
        draggable: "false",
        loading: "lazy",
        class: {
          "b-resource-avatar": 1,
          "b-resource-image": 1
        },
        style: {},
        alt: alt2,
        "aria-label": alt2,
        elementData: {
          defaultImageUrl,
          imageUrl,
          initials,
          color,
          dataset
        },
        src: imageUrl,
        dataset
      };
    }
  }
  getIconConfig(iconCls, dataset, name) {
    if (iconCls) {
      return iconCls && {
        tag: "i",
        style: {},
        "aria-label": name,
        class: {
          "b-resource-avatar": 1,
          "b-resource-icon": 1,
          [iconCls]: 1
        },
        dataset
      };
    }
  }
  getResourceInitialsConfig(initials, color, dataset, name) {
    const namedColor = DomHelper.isNamedColor(color) && color, hexColor = !namedColor && color, { size } = this;
    return {
      tag: "div",
      "aria-label": name,
      class: {
        "b-resource-avatar": 1,
        "b-resource-initials": 1,
        [`${this.colorPrefix}${namedColor}`]: namedColor
      },
      style: {
        backgroundColor: hexColor || null,
        ...size ? { height: size, width: size } : void 0
      },
      text: initials,
      dataset
    };
  }
  onImageErrorEvent({ target }) {
    if (!target.matches(".b-resource-avatar")) {
      return;
    }
    const { defaultImageUrl, initials, color, imageUrl, dataset } = target.elementData;
    if (defaultImageUrl && !target.src.endsWith(defaultImageUrl.replace(/^[./]*/gm, ""))) {
      target.src = defaultImageUrl;
    } else {
      const { parentElement } = target, targetIdx = Array.from(parentElement.childNodes).indexOf(target), domConfig = this.getResourceInitialsConfig(initials, color, dataset, target.alt), initialsEl = DomHelper.createElement(domConfig);
      initialsEl.elementData = target.elementData;
      initialsEl.lastDomConfig = domConfig;
      parentElement.lastDomConfig && (parentElement.lastDomConfig.children[targetIdx] = domConfig);
      parentElement.replaceChild(initialsEl, target);
    }
    _AvatarRendering.failedUrls.add(imageUrl);
  }
};
__publicField(_AvatarRendering, "$name", "AvatarRendering");
var AvatarRendering = _AvatarRendering;
AvatarRendering._$name = "AvatarRendering";

// ../Core/bundle/entry.thin.js
if (window && !window.bryntum) {
  window.bryntum = {};
}

// lib/Grid/util/Location.js
var Location = class _Location {
  /**
   * The grid which this Location references.
   * @config {Grid.view.Grid} grid
   */
  /**
   * The record which this Location references. (unless {@link #config-rowIndex} is used to configure)
   * @config {Core.data.Model} record
   */
  /**
   * The row index which this Location references. (unless {@link #config-record} is used to configure).
   *
   * `-1` means the header row, in which case the {@link #config-record} will be `null`.
   * @config {Number} rowIndex
   */
  /**
   * The Column which this location references. (unless {@link #config-columnIndex} or {@link #config-columnId} is used to configure)
   * @config {Grid.column.Column} column
   */
  /**
   * The column id which this location references. (unless {@link #config-column} or {@link #config-columnIndex} is used to configure)
   * @config {String|Number} columnId
   */
  /**
   * The column index which this location references. (unless {@link #config-column} or {@link #config-columnId} is used to configure)
   * @config {Number} columnIndex
   */
  /**
   * The field of the column index which this location references. (unless another column identifier is used to configure)
   * @config {String} field
   */
  /**
   * Initializes a new Location.
   * @param {LocationConfig|HTMLElement} location A grid location specifier. This may be:
   *  * An element inside a grid cell or a grid cell.
   *  * An object identifying a cell location using the following properties:
   *    * grid
   *    * record
   *    * rowIndex
   *    * column
   *    * columnIndex
   * @function constructor
   */
  constructor(location) {
    if (location) {
      if (location.isLocation) {
        return location;
      }
      if (location.nodeType === Node.ELEMENT_NODE) {
        const grid = Widget.fromElement(location, "gridbase"), cell = grid && location.closest(grid.focusableSelector);
        if (cell) {
          const { dataset } = cell.parentNode;
          this.init({
            grid,
            // A .b-grid-row will have a data-index
            // If it' a column header, we use rowIndex -1
            rowIndex: grid.store.includes(dataset.id) ? grid.store.indexOf(dataset.id) : dataset.index || -1,
            columnId: cell.dataset.columnId
          });
          this.initialTarget = location;
        }
      } else {
        this.init(location);
      }
    }
  }
  init(config) {
    var _a4, _b;
    const me = this;
    const grid = me.grid = config.grid, { store, columns } = grid, { visibleColumns } = columns;
    if (config.target) {
      me.actionTargets = [me._target = config.target];
    }
    if (config.record) {
      me._id = config.record.id;
    } else if ("id" in config) {
      me._id = config.id;
      if (config.id == null) {
        me._rowIndex = -1;
      }
    } else {
      const rowIndex = !isNaN(config.row) ? config.row : !isNaN(config.rowIndex) ? config.rowIndex : NaN;
      me._rowIndex = Math.max(Math.min(Number(rowIndex), store.count - 1), grid.hideHeaders ? 0 : -1);
      me._id = (_a4 = store.getAt(me._rowIndex)) == null ? void 0 : _a4.id;
    }
    if (!("_rowIndex" in me)) {
      me._rowIndex = store.indexOf(me.id);
    }
    me.isSpecialRow = (_b = me.record) == null ? void 0 : _b.isSpecialRow;
    if ("columnId" in config) {
      me._column = columns.getById(config.columnId);
    } else if ("field" in config) {
      me._column = columns.get(config.field);
    } else {
      const columnIndex = !isNaN(config.column) ? config.column : !isNaN(config.columnIndex) ? config.columnIndex : NaN;
      if (!isNaN(columnIndex)) {
        me._columnIndex = Math.min(Number(columnIndex), visibleColumns.length - 1);
        me._column = visibleColumns[me._columnIndex];
      } else {
        me._column = "column" in config ? isNaN(config.column) ? config.column : visibleColumns[config.column] : visibleColumns[0];
      }
    }
    if (!("_columnIndex" in me)) {
      me._columnIndex = visibleColumns.indexOf(me._column);
    }
  }
  // Class identity indicator. Usually added by extending Base, but we don't do that for perf.
  get isLocation() {
    return true;
  }
  equals(other, shallow = false) {
    const me = this;
    return (other == null ? void 0 : other.isLocation) && other.grid === me.grid && // For a more performant check, use the shallow param
    (shallow ? me.id === other.id && me._column === other._column : other.record === me.record && other.column === me.column && other.target === me.target);
  }
  /**
   * Yields the row index of this location.
   * @property {Number}
   * @readonly
   */
  get rowIndex() {
    const { _id } = this, { store } = this.grid;
    return store.includes(_id) ? store.indexOf(_id) : Math.min(this._rowIndex, store.count - 1);
  }
  /**
   * Used by GridNavigation.
   * @private
   */
  get visibleRowIndex() {
    const { rowManager } = this.grid, { rowIndex } = this;
    return rowIndex === -1 ? rowIndex : Math.max(Math.min(rowIndex, rowManager.lastFullyVisibleTow.dataIndex), rowManager.firstFullyVisibleTow.dataIndex);
  }
  /**
   * Yields `true` if the cell and row are selectable.
   *
   * That is if the record is present in the grid's store and it's not a group summary or group header record.
   * @property {Boolean}
   * @readonly
   */
  get isSelectable() {
    return this.grid.store.includes(this._id) && !this.isSpecialRow;
  }
  get record() {
    if (this._rowIndex > -1) {
      const { store } = this.grid;
      if (!store.includes(this._id)) {
        return store.getAt(this._rowIndex);
      }
      return store.getById(this._id);
    }
  }
  get id() {
    return this._id;
  }
  get column() {
    const { visibleColumns } = this.grid.columns;
    if (!(visibleColumns == null ? void 0 : visibleColumns.includes(this._column))) {
      return visibleColumns == null ? void 0 : visibleColumns[this.columnIndex];
    }
    return this._column;
  }
  get columnId() {
    var _a4;
    return (_a4 = this.column) == null ? void 0 : _a4.id;
  }
  /**
   * Yields the column index of this location.
   * @property {Number}
   * @readonly
   */
  get columnIndex() {
    var _a4;
    return Math.min(this._columnIndex, ((_a4 = this.grid.columns.visibleColumns) == null ? void 0 : _a4.length) - 1);
  }
  /**
   * Returns a __*new *__ `Location` instance having moved from the current location in the
   * mode specified.
   * @param {Number} where Where to move from this Location. May be:
   *
   *  - `Location.UP`
   *  - `Location.NEXT_CELL`
   *  - `Location.DOWN`
   *  - `Location.PREV_CELL`
   *  - `Location.FIRST_COLUMN`
   *  - `Location.LAST_COLUMN`
   *  - `Location.FIRST_CELL`
   *  - `Location.LAST_CELL`
   *  - `Location.PREV_PAGE`
   *  - `Location.NEXT_PAGE`
   * @returns {Grid.util.Location} A Location object encapsulating the target location.
   */
  move(where) {
    const me = this, {
      record,
      column,
      grid
    } = me, { store } = grid, columns = grid.columns.visibleColumns, result = new _Location();
    let rowIndex = store.includes(record) ? store.indexOf(record) : me.rowIndex, columnIndex = columns.includes(column) ? columns.indexOf(column) : me.columnIndex;
    const rowMin = grid.hideHeaders ? 0 : -1, rowMax = store.count - 1, colMax = columns.length - 1, atFirstRow = rowIndex === rowMin, atLastRow = rowIndex === rowMax, atFirstColumn = columnIndex === 0, atLastColumn = columnIndex === colMax;
    switch (where) {
      case _Location.PREV_CELL:
        if (atFirstColumn) {
          if (!atFirstRow) {
            columnIndex = colMax;
            rowIndex--;
          }
        } else {
          columnIndex--;
        }
        break;
      case _Location.NEXT_CELL:
        if (atLastColumn) {
          if (!atLastRow) {
            columnIndex = 0;
            rowIndex++;
          }
        } else {
          columnIndex++;
        }
        break;
      case _Location.UP:
        if (!atFirstRow) {
          rowIndex--;
        }
        break;
      case _Location.DOWN:
        if (!atLastRow) {
          if (rowIndex === -1) {
            rowIndex = grid.rowManager.firstFullyVisibleRow.dataIndex;
          } else {
            rowIndex++;
          }
        }
        break;
      case _Location.FIRST_COLUMN:
        columnIndex = 0;
        break;
      case _Location.LAST_COLUMN:
        columnIndex = colMax;
        break;
      case _Location.FIRST_CELL:
        rowIndex = rowMin;
        columnIndex = 0;
        break;
      case _Location.LAST_CELL:
        rowIndex = rowMax;
        columnIndex = colMax;
        break;
      case _Location.PREV_PAGE:
        rowIndex = Math.max(rowMin, rowIndex - Math.floor(grid.scrollable.clientHeight / grid.rowHeight));
        break;
      case _Location.NEXT_PAGE:
        rowIndex = Math.min(rowMax, rowIndex + Math.floor(grid.scrollable.clientHeight / grid.rowHeight));
        break;
    }
    result.init({
      grid,
      rowIndex,
      columnIndex
    });
    return result;
  }
  /**
   * The cell DOM element which this Location references.
   * @property {HTMLElement}
   * @readonly
   */
  get cell() {
    var _a4, _b;
    const me = this, {
      grid,
      id,
      _cell
    } = me;
    if (_cell) {
      return _cell;
    }
    if (id == null) {
      return (_a4 = grid.columns.getById(me.columnId)) == null ? void 0 : _a4.element;
    } else {
      const { row } = me;
      if (row) {
        return row.getCell(me.columnId) || row.getCell((_b = grid.columns.getAt(me.columnIndex)) == null ? void 0 : _b.id);
      }
    }
  }
  get row() {
    return this.grid.getRowById(this.id) || this.grid.getRow(this.rowIndex);
  }
  /**
   * The DOM element which encapsulates the focusable target of this Location.
   *
   * This is usually the {@link #property-cell}, but if this is an actionable location, this
   * may be another DOM element within the cell.
   * @property {HTMLElement}
   * @readonly
   */
  get target() {
    const { cell, _target } = this, { focusableFinder } = this.grid;
    if (cell) {
      if (_target) {
        return _target;
      }
      focusableFinder.currentNode = this.grid.focusableFinderCell = cell;
      return focusableFinder.nextNode() || cell;
    }
  }
  /**
   * This property is `true` if the focus target is not the cell itself.
   * @property {Boolean}
   * @readonly
   */
  get isActionable() {
    const { cell, _target } = this, activeEl = cell && DomHelper.getActiveElement(cell), containsFocus = activeEl && cell.compareDocumentPosition(activeEl) & Node.DOCUMENT_POSITION_CONTAINED_BY;
    return Boolean(containsFocus || _target && _target !== this.cell);
  }
  /**
   * This property is `true` if this location represents a column header.
   * @property {Boolean}
   * @readonly
   */
  get isColumnHeader() {
    return this.cell && this.rowIndex === -1;
  }
  /**
   * This property is `true` if this location represents a cell in the grid body.
   * @property {Boolean}
   * @readonly
   */
  get isCell() {
    return this.cell && this.record;
  }
};
Location.UP = 1;
Location.NEXT_CELL = 2;
Location.DOWN = 3;
Location.PREV_CELL = 4;
Location.FIRST_COLUMN = 5;
Location.LAST_COLUMN = 6;
Location.FIRST_CELL = 7;
Location.LAST_CELL = 8;
Location.PREV_PAGE = 9;
Location.NEXT_PAGE = 10;
Location._$name = "Location";

// lib/Grid/column/Column.js
var validWidth = (value) => typeof value === "number" || (value == null ? void 0 : value.endsWith("px"));
var _Column = class _Column extends Model.mixin(Events_default, Localizable_default) {
  //region Config
  /**
   * Default settings for the column, applied in constructor. None by default, override in subclass.
   * @member {Object} defaults
   * @returns {Object}
   * @readonly
   */
  static get fields() {
    return [
      //region Common
      "type",
      /**
       * Header text
       * @prp {String} text
       * @category Common
       */
      "text",
      /**
       * The {@link Core.data.field.DataField#config-name} of the {@link Core.data.Model data model} field to
       * read a cells value from.
       *
       * Also accepts dot notation to read nested or related data, for example `'address.city'`.
       *
       * @prp {String} field
       * @readonly
       * @category Common
       */
      "field",
      // NOTE: This is duplicated in WidgetColumn and partly in TreeColumn so remember to change there too if
      // changing the signature of this function
      /**
       * Renderer function, used to format and style the content displayed in the cell. Return the cell text you
       * want to display. Can also affect other aspects of the cell, such as styling.
       *
       * **NOTE:** If you mutate `cellElement`, and you want to prevent cell content from being reset during
       * rendering, please return `undefined` from the renderer (or just omit the `return` statement) and make
       * sure that the {@link #config-alwaysClearCell} config is set to `false`.
       *
       * ```javascript
       * new Grid({
       *     columns : [
       *         // Returns an empty string if status field value is undefined
       *         { text : 'Status', renderer : ({ record }) => record.status ?? '' },
       *
       *         // From Grid v6.0 there is no need for the undefined check
       *         // { text : 'Status', renderer : ({ record }) => record.status }
       *     ]
       * });
       * ```
       *
       * You can also return a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup
       * ```javascript
       * new Grid({
       *     columns : [
       *         {
       *              text : 'Status',
       *              renderer : ({ record }) => {
       *                  return {
       *                      class : 'myClass',
       *                      children : [
       *                          {
       *                              tag : 'i',
       *                              class : 'fa fa-pen'
       *                          },
       *                          {
       *                              tag : 'span',
       *                              text : record.name
       *                          }
       *                      ]
       *                  };
       *              }
       *         }
       *     ]
       * });
       * ```
       *
       * You can modify the row element too from inside a renderer to add custom CSS classes:
       *
       * ```javascript
       * new Grid({
       *     columns : [
       *         {
       *             text     : 'Name',
       *             renderer : ({ record, row }) => {
       *                // Add special CSS class to new rows that have not yet been saved
       *               row.cls.newRow = record.isPhantom;
       *
       *               return record.name;
       *         }
       *     ]
       * });
       * ```
       *
       * @config {Function} renderer
       * @param {Object} renderData Object containing renderer parameters
       * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc. Can be `null` in case of export
       * @param {*} renderData.value Value to be displayed in the cell
       * @param {Core.data.Model} renderData.record Record for the row
       * @param {Grid.column.Column} renderData.column This column
       * @param {Grid.view.Grid} renderData.grid This grid
       * @param {Grid.row.Row} renderData.row Row object. Can be null in case of export.
       *   Use the {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.
       * @param {Object} renderData.size Set `size.height` to specify the desired row height for the current
       *   row. Largest specified height is used, falling back to configured {@link Grid/view/Grid#config-rowHeight}
       *   in case none is specified. Can be null in case of export
       * @param {Number} renderData.size.height Set this to request a certain row height
       * @param {Number} renderData.size.configuredHeight Row height that will be used if none is requested
       * @param {Boolean} renderData.isExport True if record is being exported to allow special handling during export.
       * @param {Boolean} renderData.isMeasuring True if the column is being measured for a `resizeToFitContent` call.
       *   In which case an advanced renderer might need to take different actions.
       * @returns {String|DomConfig|DomConfig[]|null}
       *
       * @category Rendering
       */
      "renderer",
      //'reactiveRenderer',
      /**
       * Column width. If value is Number then width is in pixels
       * @config {Number|String} width
       * @category Common
       */
      "width",
      /**
       * Column width as a flex weight. All columns with flex specified divide the available space (after
       * subtracting fixed widths) between them according to the flex value. Columns that have `flex : 2` will be
       * twice as wide as those with `flex : 1` (and so on)
       * @prp {Number|String} flex
       * @category Common
       */
      "flex",
      /**
       * This config sizes a column to fits its content. It is used instead of `width` or `flex`.
       *
       * This config requires the {@link Grid.feature.ColumnAutoWidth} feature which responds to changes in the
       * grid's store and synchronizes the widths' of all `autoWidth` columns.
       *
       * If this config is not a Boolean value, it is passed as the only argument to the `resizeToFitContent`
       * method to constrain the column's width.
       *
       * @config {Boolean|Number|Number[]} autoWidth
       * @category Common
       */
      "autoWidth",
      /**
       * This config enables automatic height for all cells in this column. It is achieved by measuring the height
       * a cell after rendering it to DOM, and then sizing the row using that height (if it is greater than other
       * heights used for the row).
       *
       * Heads up if you render your Grid on page load, if measurement happens before the font you are using is
       * loaded you might get slightly incorrect heights. For browsers that support it we detect that
       * and remeasure when fonts are available.
       *
       * **NOTE:** Enabling this config comes with a pretty big performance hit. To maintain good performance,
       * we recommend not using it. You can still set the height of individual rows manually, either through
       * {@link Grid.data.GridRowModel#field-rowHeight data} or via {@link #config-renderer renderers}.
       *
       * Also note that this setting only works fully as intended with non-flex columns.
       *
       * Rows will always be at least {@link Grid.view.Grid#config-rowHeight} pixels tall
       * even if an autoHeight cell contains no data.
       *
       * Manually setting a height from a {@link #config-renderer} in this column will take precedence over this
       * config.
       *
       * @config {Boolean} autoHeight
       * @category Common
       */
      "autoHeight",
      /**
       * Mode to use when measuring the contents of this column in calls to {@link #function-resizeToFitContent}.
       * Available modes are:
       *
       * * 'exact'       - Most precise, renders and measures all cells (Default, slowest)
       * * 'textContent' - Renders all cells but only measures the one with the longest `textContent`
       * * 'value'       - Renders and measures only the cell with the longest data (Fastest)
       * * 'none'/falsy  - Resize to fit content not allowed, a call does nothing
       *
       * @config {'exact'|'textContent'|'value'|'none'|null} fitMode
       * @default 'exact'
       * @category Common
       */
      { name: "fitMode", defaultValue: "exact" },
      //endregion
      //region Interaction
      /**
       * Set this to `true` to not allow any type of editing in this column.
       * @prp {Boolean} readOnly
       */
      "readOnly",
      /**
       * A config object used to create the input field which will be used for editing cells in the
       * column. Used when {@link Grid.feature.CellEdit} feature is enabled. The Editor refers to
       * {@link #config-field} for a data source.
       *
       * Configure this as `false` or `null` to prevent cell editing in this column.
       *
       * All subclasses of {@link Core.widget.Field} can be used as editors. The most popular are:
       * - {@link Core.widget.TextField}
       * - {@link Core.widget.NumberField}
       * - {@link Core.widget.DateField}
       * - {@link Core.widget.TimeField}
       * - {@link Core.widget.Combo}
       *
       * If record has method set + capitalized field, method will be called, e.g. if record has method named
       * `setFoobar` and the {@link #config-field} is `foobar`, then instead of `record.foobar = value`,
       * `record.setFoobar(value)` will be called.
       *
       * `Function` may be used for React application parameter for using JSX components as editors.
       *
       * ```javascript
       *  columns : [
       *         {
       *             type   : 'name',
       *             field  : 'name',
       *             width  : 250,
       *             editor : ref => <TextEditor ref={ref}/>
       *         },
       *         ...
       * ]
       * ```
       *
       * NOTE: React editor component must implement `setValue` method which usually internally calls `setState`.
       * React `setState` is asynchronous so we need to return Promise which will be resolved when `setState`
       * finishes. A typical example of `setValue` method implemented in a React editor is:
       *
       * ```javascript
       * setValue(value) {
       *     return new Promise(resolve => this.setState({ value }, () => resolve(value)));
       * }
       * ```
       *
       * @config {Boolean|String|InputFieldConfig|Core.widget.Field|Function|null} editor
       * @param {*} ref React `RefObject` for editor JSX component.
       * @returns {*} Returns React editor JSX component template
       *
       * @category Interaction
       */
      { name: "editor", defaultValue: {} },
      /**
       * A config object used to configure an {@link Core.widget.Editor} which contains this Column's
       * {@link #config-editor input field} if {@link Grid.feature.CellEdit} feature is enabled.
       * @config {EditorConfig} cellEditor
       * @category Interaction
       */
      "cellEditor",
      /**
       * A function which is called when a cell edit is requested to finish.
       *
       * This may be an `async` function which performs complex validation. The return value should be:
       * - `false` - To indicate a generic validation error
       * - `true` - To indicate a successful validation, which will complete the editing
       * - a string - To indicate an error message of the failed validation. This error message will be cleared
       * upon any subsequent user input.
       *
       * The action for the failed validation is defined with the {@link #config-invalidAction} config.
       *
       * For example for synchronous validation:
       *
       * ```javascript
       * const grid = new Grid({
       *    columns : [
       *       {
       *          type : 'text',
       *          text : 'The column',
       *          field : 'someField',
       *          flex : 1,
       *          finalizeCellEdit : ({ value }) => {
       *              return value.length < 4 ? 'Value length should be at least 4 characters' : true;
       *          }
       *       }
       *    ]
       * });
       * ```
       * Here we've defined a validation `finalizeCellEdit` function, which marks all edits with new value
       * less than 4 characters length as invalid.
       *
       * For asynchronous validation you can make the validation function async:
       *
       * ```javascript
       * finalizeCellEdit : async ({ value }) => {
       *     return await performRemoteValidation(value);
       * }
       * ```
       *
       * @config {Function} finalizeCellEdit
       * @param {Object} context An object describing the state of the edit at completion request time.
       * @param {Core.widget.Field} context.inputField The field configured as the column's `editor`.
       * @param {Core.data.Model} context.record The record being edited.
       * @param {*} context.oldValue The old value of the cell.
       * @param {*} context.value The new value of the cell.
       * @param {Grid.view.Grid} context.grid The host grid.
       * @param {Object} context.editorContext The {@link Grid.feature.CellEdit} context object.
       * @param {Grid.column.Column} context.editorContext.column The column being edited.
       * @param {Core.data.Model} context.editorContext.record The record being edited.
       * @param {HTMLElement} context.editorContext.cell The cell element hosting the editor.
       * @param {Core.widget.Editor} context.editorContext.editor The floating Editor widget which is hosting the input field.
       * @returns {Boolean|void}
       * @async
       *
       * @category Interaction
       */
      "finalizeCellEdit",
      /**
       * By default, cell editing is finalized when the editor is blurred or if the user taps outside the editor.
       * For complex custom editors, focus or tapping might be expected outside the Bryntum owned editor. In such
       * cases, supply `false` for this config to take manual control over when cell editing in the column should
       * be finalized.
       *
       * To accept changes, call {@link Grid.feature.CellEdit#function-finishEditing}. To reject, call
       * {@link Grid.feature.CellEdit#function-cancelEditing}.
       *
       * ```javascript
       * // Setup
       * const grid = new Grid({
       *   columns : [
       *     {
       *       text               : 'Skills',
       *       field              : 'skills',
       *       managedCellEditing : false
       *     }
       *   ]
       * });
       *
       * // From your custom editor, when you are ready to accept changes
       * grid.finishEditing();
       * ```
       *
       * @config {Boolean} managedCellEditing
       * @default true
       * @category Interaction
       * @advanced
       */
      { name: "managedCellEditing", defaultValue: true },
      /**
       * Setting this option means that pressing the `ESCAPE` key after editing the field will
       * revert the field to the value it had when the edit began. If the value is _not_ changed
       * from when the edit started, the input field's {@link Core.widget.Field#config-clearable}
       * behaviour will be activated. Finally, the edit will be canceled.
       * @config {Boolean} revertOnEscape
       * @default true
       * @category Interaction
       */
      { name: "revertOnEscape", defaultValue: true },
      /**
       * How to handle a request to complete a cell edit in this column if the field is invalid.
       * There are three choices:
       *  - `block` The default. The edit is not exited, the field remains focused.
       *  - `allow` Allow the edit to be completed.
       *  - `revert` The field value is reverted and the edit is completed.
       * @config {'block'|'allow'|'revert'} invalidAction
       * @default 'block'
       * @category Interaction
       */
      { name: "invalidAction", defaultValue: "block" },
      /**
       * Allow sorting of data in the column. You can pass true/false to enable/disable sorting, or provide a
       * custom sorting function, or a config object for a {@link Core.util.CollectionSorter}
       *
       * ```javascript
       * const grid = new Grid({
       *     columns : [
       *          {
       *              // Disable sorting for this column
       *              sortable : false
       *          },
       *          {
       *              field : 'name',
       *              // Custom sorting for this column
       *              sortable(user1, user2) {
       *                  return user1.name < user2.name ? -1 : 1;
       *              }
       *          },
       *          {
       *              // A config object for a Core.util.CollectionSorter
       *              sortable : {
       *                  property         : 'someField',
       *                  direction        : 'DESC',
       *                  useLocaleCompare : 'sv-SE'
       *              }
       *          }
       *     ]
       * });
       * ```
       * When providing a custom sorting function, if the sort feature is configured with
       * `prioritizeColumns : true` that function will also be used for programmatic sorting of the store:
       *
       * ```javascript
       * const grid = new Grid({
       *     features : {
       *       sort : {
       *           prioritizeColumns : true
       *       }
       *     },
       *
       *     columns : [
       *          {
       *              field : 'name',
       *              // Custom sorting for this column
       *              sortable(user1, user2) {
       *                  return user1.name < user2.name ? -1 : 1;
       *              }
       *          }
       *     ]
       * });
       *
       * // Will use sortable() from the column definition above
       * grid.store.sort('name');
       * ```
       *
       * @config {Boolean|Function|CollectionSorterConfig} sortable
       * @param {Core.data.Model} left Left side model to compare
       * @param {Core.data.Model} right Right side model to compare
       * @returns {Number}
       * @default true
       * @category Interaction
       */
      {
        name: "sortable",
        defaultValue: true,
        // Normalize function/object forms
        convert(value, data, column) {
          if (!value) {
            return false;
          }
          if (value === true) {
            return true;
          }
          const sorter = {};
          if (typeof value === "function") {
            sorter.originalSortFn = value;
            sorter.sortFn = value.bind(column);
          } else if (typeof value === "object") {
            Object.assign(sorter, value);
            if (sorter.fn) {
              sorter.sortFn = sorter.fn;
              delete sorter.fn;
            }
          }
          return sorter;
        }
      },
      /**
       * Allow searching in the column (respected by QuickFind and Search features)
       * @config {Boolean} searchable
       * @default true
       * @category Interaction
       */
      { name: "searchable", defaultValue: true },
      /**
       * If `true`, this column will show a collapse/expand icon in its header, only applicable for parent columns
       * @config {Boolean} collapsible
       * @default false
       * @category Interaction
       */
      { name: "collapsible", defaultValue: false },
      /**
       * The collapsed state of this column, only applicable for parent columns
       * @config {Boolean} collapsed
       * @default false
       * @category Interaction
       */
      { name: "collapsed", defaultValue: false },
      /**
       * The collapse behavior when collapsing a parent column. Specify "toggleAll" or "showFirst".
       * * "showFirst" toggles visibility of all but the first columns.
       * * "toggleAll" toggles all children, useful if you have a special initially hidden column which gets shown
       * in collapsed state.
       * @config {String} collapseMode
       * @default 'showFirst'
       * @category Interaction
       */
      { name: "collapseMode" },
      /**
       * Allow filtering data in the column (if {@link Grid.feature.Filter} or {@link Grid.feature.FilterBar}
       * feature is enabled).
       *
       * Also allows passing a custom filtering function that will be called for each record with a single
       * argument of format `{ value, record, [operator] }`. Returning `true` from the function includes the
       * record in the filtered set.
       *
       * Configuration object may be used for {@link Grid.feature.FilterBar} feature to specify `filterField`. See
       * an example in the code snippet below or check {@link Grid.feature.FilterBar} page for more details.
       *
       * ```
       * const grid = new Grid({
       *     columns : [
       *          {
       *              field : 'name',
       *              // Disable filtering for this column
       *              filterable : false
       *          },
       *          {
       *              field : 'age',
       *              // Custom filtering for this column
       *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10
       *          },
       *          {
       *              field : 'start',
       *              // Changing default field type
       *              filterable: {
       *                  filterField : {
       *                      type : 'datetime'
       *                  }
       *              }
       *          },
       *          {
       *              field : 'city',
       *              // Filtering for a value out of a list of values
       *              filterable: {
       *                  filterField : {
       *                      type  : 'combo',
       *                      value : '',
       *                      items : [
       *                          'Paris',
       *                          'Dubai',
       *                          'Moscow',
       *                          'London',
       *                          'New York'
       *                      ]
       *                  }
       *              }
       *          },
       *          {
       *              field : 'score',
       *              filterable : {
       *                  // This filter fn doesn't return 0 values as matching filter 'less than'
       *                  filterFn : ({ record, value, operator, property }) => {
       *                      switch (operator) {
       *                          case '<':
       *                              return record[property] === 0 ? false : record[property] < value;
       *                          case '=':
       *                              return record[property] == value;
       *                          case '>':
       *                              return record[property] > value;
       *                      }
       *                  }
       *              }
       *          }
       *     ]
       * });
       * ```
       *
       * When providing a custom filtering function, if the filter feature is configured with
       * `prioritizeColumns : true` that function will also be used for programmatic filtering of the store:
       *
       * ```javascript
       * const grid = new Grid({
       *     features : {
       *         filter : {
       *             prioritizeColumns : true
       *         }
       *     },
       *
       *     columns : [
       *          {
       *              field : 'age',
       *              // Custom filtering for this column
       *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10
       *          }
       *     ]
       * });
       *
       * // Will use filterable() from the column definition above
       * grid.store.filter({
       *     property : 'age',
       *     value    : 50
       * });
       * ```
       *
       * To use custom `FilterField` combo `store` it should contain one of these
       * {@link Core.data.Store#config-data} or {@link Core.data.AjaxStore#config-readUrl} configs.
       * Otherwise combo will get data from owner Grid store.
       *
       * ```javascript
       * const grid = new Grid({
       *     columns : [
       *          {
       *              field : 'name',
       *              filterable: {
       *                  filterField {
       *                      type  : 'combo',
       *                      store : new Store({
       *                          data : ['Adam', 'Bob', 'Charlie']
       *                      })
       *                  }
       *              }
       *          }
       *     ]
       * });
       * ```
       *
       * or
       *
       * ```javascript
       * const grid = new Grid({
       *     columns : [
       *          {
       *              field : 'name',
       *              filterable: {
       *                  filterField : {
       *                     type  : 'combo',
       *                     store : new AjaxStore({
       *                         readUrl  : 'data/names.json',
       *                         autoLoad : true
       *                     })
       *                  }
       *              }
       *          }
       *     ]
       * });
       * ```
       *
       * @config {Boolean|Function|Object} filterable
       * @param {Object} data Data object
       * @param {*} data.value Record value
       * @param {Core.data.Model} data.record Record instance
       * @returns {Boolean} Returns `true` if value matches condition
       * @default true
       * @category Interaction
       */
      {
        name: "filterable",
        defaultValue: true,
        // Normalize function/object forms
        convert(value) {
          if (!value) {
            return false;
          }
          if (value === true) {
            return true;
          }
          const filter = {
            columnOwned: true
          };
          if (typeof value === "function") {
            filter.filterFn = value;
          } else if (typeof value === "object") {
            Object.assign(filter, value);
          }
          return filter;
        }
      },
      /**
       * Setting this flag to `true` will prevent dropping child columns into a group column
       * @config {Boolean} sealed
       * @default false
       * @category Interaction
       */
      { name: "sealed" },
      /**
       * Allow column visibility to be toggled through UI
       * @config {Boolean} hideable
       * @default true
       * @category Interaction
       */
      { name: "hideable", defaultValue: true },
      /**
       * Set to false to prevent this column header from being dragged
       * @config {Boolean} draggable
       * @category Interaction
       */
      { name: "draggable", defaultValue: true },
      /**
       * Set to false to prevent grouping by this column
       * @config {Boolean} groupable
       * @category Interaction
       */
      { name: "groupable", defaultValue: true },
      /**
       * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.
       * @config {Boolean} resizable
       * @default true
       * @category Interaction
       */
      { name: "resizable", defaultValue: true },
      //endregion
      //region Rendering
      /**
       * Renderer function for group headers (when using Group feature).
       * ```javascript
       * const grid = new Grid({
       *     columns : [
       *         {
       *             text : 'ABC',
       *             groupRenderer(renderData) {
       *                 return {
       *                      class : {
       *                          big   : true,
       *                          small : false
       *                      },
       *                      children : [
       *                          { tag : 'img', src : 'img.png' },
       *                          renderData.groupRowFor
       *                      ]
       *                 };
       *             }
       *         }
       *     ]
       * });
       * ```
       *
       * @config {Function} groupRenderer
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc.
       * @param {*} renderData.groupRowFor Current group value
       * @param {Core.data.Model} renderData.record Record for the row
       * @param {Core.data.Model[]} renderData.groupRecords Records in the group
       * @param {Grid.column.Column} renderData.column Current rendering column
       * @param {Grid.column.Column} renderData.groupColumn Column that the grid is grouped by
       * @param {Number} renderData.count Number of records in the group
       * @param {Grid.view.Grid} renderData.grid This grid
       * @returns {DomConfig|String|null} The header grouping text or DomConfig object representing the HTML markup
       *
       * @category Rendering
       */
      "groupRenderer",
      /**
       * Renderer function for the column header.
       *
       * @config {Function} headerRenderer
       * @param {Object} renderData
       * @param {Grid.column.Column} renderData.column This column
       * @param {HTMLElement} renderData.headerElement The header element
       * @returns {String|null} The text or markup to show in the column header
       *
       * @category Rendering
       */
      "headerRenderer",
      /**
       * A tooltip string to show when hovering the column header, or a config object which can
       * reconfigure the shared tooltip by setting boolean, numeric and string config values.
       * @config {String|TooltipConfig} tooltip
       * @category Rendering
       */
      "tooltip",
      /**
       * Renderer function for the cell tooltip (used with {@link Grid.feature.CellTooltip} feature).
       * Specify `false` to disable tooltip for this column.
       *
       * @config {Function|Boolean} tooltipRenderer
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cellElement Cell element
       * @param {Core.data.Model} renderData.record Record for cell row
       * @param {Grid.column.Column} renderData.column Cell column
       * @param {Grid.feature.CellTooltip} renderData.cellTooltip Feature instance, used to set tooltip content async
       * @param {MouseEvent} renderData.event The event that triggered the tooltip
       * @returns {String|DomConfig|null}
       *
       * @category Rendering
       */
      "tooltipRenderer",
      /**
       * CSS class added to each cell in this column
       * @prp {String} cellCls
       * @category Rendering
       */
      "cellCls",
      /**
       * CSS class added to the header of this column
       * @config {String} cls
       * @category Rendering
       */
      "cls",
      /**
       * Icon to display in header. Specifying an icon will render a `<i>` element with the icon as value for the
       * class attribute
       * @prp {String} icon
       * @category Rendering
       */
      "icon",
      //endregion
      //region Layout
      /**
       * Text align. Accepts `'left'`/`'center'`/`'right'` or direction neutral `'start'`/`'end'`
       * @config {'left'|'center'|'right'|'start'|'end'} align
       * @category Layout
       */
      "align",
      /**
       * Column minimal width. If value is `Number`, then minimal width is in pixels
       * @config {Number|String} minWidth
       * @default 60
       * @category Layout
       */
      { name: "minWidth", defaultValue: 60 },
      /**
       * Column maximal width. If value is Number, then maximal width is in pixels
       * @config {Number|String} maxWidth
       * @category Common
       */
      "maxWidth",
      /**
       * Columns hidden state. Specify `true` to hide the column, `false` to show it.
       * @prp {Boolean} hidden
       * @category Layout
       */
      { name: "hidden", defaultValue: false },
      /**
       * Convenient way of putting a column in the "locked" region. Same effect as specifying region: 'locked'.
       * If you have defined your own regions (using {@link Grid.view.Grid#config-subGridConfigs}) you should use
       * {@link #config-region} instead of this one.
       * @config {Boolean} locked
       * @default false
       * @category Layout
       */
      { name: "locked" },
      /**
       * Region (part of the grid, it can be configured with multiple) where to display the column. Defaults to
       * {@link Grid.view.Grid#config-defaultRegion}.
       *
       * A column under a grouped header automatically belongs to the same region as the grouped header.
       *
       * @config {String} region
       * @category Layout
       */
      { name: "region" },
      /**
       * Specify `true` to merge cells within the column whose value match between rows, making the first
       * occurrence of the value span multiple rows.
       *
       * Only applies when using the {@link Grid/feature/MergeCells MergeCells feature}.
       *
       * This setting can also be toggled using the column header menu.
       *
       * @config {Boolean} mergeCells
       * @category Merge cells
       */
      { name: "mergeCells", type: "boolean" },
      /**
       * Set to `false` to prevent merging cells in this column using the column header menu.
       *
       * Only applies when using the {@link Grid/feature/MergeCells MergeCells feature}.
       *
       * @config {Boolean} mergeable
       * @default true
       * @category Merge cells
       */
      { name: "mergeable", type: "boolean", defaultValue: true },
      /**
       * An empty function by default, but provided so that you can override it. This function is called each time
       * a merged cell is rendered. It allows you to manipulate the DOM config object used before it is synced to
       * DOM, thus giving you control over styling and contents.
       *
       * NOTE: The function is intended for formatting, you should not update records in it since updating records
       * triggers another round of rendering.
       *
       * ```javascript
       * const grid = new Grid({
       *   columns : [
       *     {
       *       field      : 'project',
       *       text       : 'Project',
       *       mergeCells : 'true,
       *       mergedRenderer({ domConfig, value, fromIndex, toIndex }) {
       *         domConfig.className.highlight = value === 'Important project';
       *       }
       *    }
       *  ]
       * });
       * ```
       *
       * @config {Function}
       * @param {Object} detail An object containing the information needed to render a task.
       * @param {*} detail.value Value that will be displayed in the merged cell
       * @param {Number} detail.fromIndex Index in store of the first row of the merged cell
       * @param {Number} detail.toIndex Index in store of the last row of the merged cell
       * @param {Core.helper.DomHelper#typedef-DomConfig} detail.domConfig DOM config object for the merged cell
       * element
       * @category Merge cells
       */
      "mergedRenderer",
      //endregion
      // region Menu
      /**
       * Show column picker for the column
       * @config {Boolean} showColumnPicker
       * @default true
       * @category Menu
       */
      { name: "showColumnPicker", defaultValue: true },
      /**
       * false to prevent showing a context menu on the column header element
       * @config {Boolean} enableHeaderContextMenu
       * @default true
       * @category Menu
       */
      { name: "enableHeaderContextMenu", defaultValue: true },
      /**
       * Set to `false` to prevent showing a context menu on the cell elements in this column
       * @config {Boolean} enableCellContextMenu
       * @default true
       * @category Menu
       */
      { name: "enableCellContextMenu", defaultValue: true },
      /**
       * Extra items to show in the header context menu for this column.
       *
       * ```javascript
       * headerMenuItems : {
       *     customItem : { text : 'Custom item' }
       * }
       * ```
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>} headerMenuItems
       * @category Menu
       */
      "headerMenuItems",
      /**
       * Extra items to show in the cell context menu for this column, `null` or `false` to not show any menu items
       * for this column.
       *
       * ```javascript
       * cellMenuItems : {
       *     customItem : { text : 'Custom item' }
       * }
       * ```
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>} cellMenuItems
       * @category Menu
       */
      "cellMenuItems",
      //endregion
      //region Summary
      /**
       * Summary type (when using Summary feature). Valid types are:
       *
       * * `'sum'` - Sum of all values in the column
       * * `'add'` - Alias for sum
       * * `'count'` - Number of rows
       * * `'countNotEmpty'` - Number of rows containing a value
       * * `'average'` - Average of all values in the column
       * * `callbackFn` - A custom function, used with `store.reduce`. Its return value becomes the value of the accumulator parameter on the next invocation of callbackFn
       * </dl>
       * @config {'sum'|'add'|'count'|'countNotEmpty'|'average'|Function} sum
       * @param {Number|*} result The value resulting from the previous call to callbackFn. On the first call, its value is initialValue if the latter is specified; otherwise its value is first element.
       * @param {Core.data.Model} value The value of the current element.
       * @param {Number} index The index position of currentValue. On the first call, its value is 0 if initialValue is specified, otherwise 1.
       * @returns {Number|*}
       * @category Summary
       */
      "sum",
      /**
       * Summary configs, use if you need multiple summaries per column. Replaces {@link #config-sum} and
       * {@link #config-summaryRenderer} configs.
       * @config {ColumnSummaryConfig[]} summaries
       * @category Summary
       */
      "summaries",
      /**
       * Renderer function for summary (when using Summary feature). The renderer is called with an object having
       * the calculated summary `sum` parameter. Function returns a string value to be rendered.
       *
       * Example:
       *
       * ```javascript
       * columns : [{
       *     type            : 'number',
       *     text            : 'Score',
       *     field           : 'score',
       *     sum             : 'sum',
       *     summaryRenderer : ({ sum }) => `Total amount: ${sum}`
       * }]
       * ```
       *
       * @config {Function} summaryRenderer
       * @param {Object} data Object containing renderer parameters
       * @param {Number|*} data.sum The sum parameter
       * @returns {String|DomConfig|null}
       * @category Summary
       */
      "summaryRenderer",
      //endregion
      //region Misc
      /**
       * Column settings at different responsive levels, see responsive demo under examples/
       * @config {Object} responsiveLevels
       * @category Misc
       */
      "responsiveLevels",
      /**
       * Tags, may be used by ColumnPicker feature for grouping columns by tag in the menu
       * @config {String[]} tags
       * @category Misc
       */
      "tags",
      /**
       * Column config to apply to normal config if viewed on a touch device
       * @config {GridColumnConfig} touchConfig
       * @category Misc
       */
      "touchConfig",
      /**
       * When using the tree feature, exactly one column should specify { tree: true }
       * @config {Boolean} tree
       * @category Misc
       */
      "tree",
      /**
       * Determines which type of filtering to use for the column. Usually determined by the column type used,
       * but may be overridden by setting this field.
       * @config {'text'|'date'|'number'|'duration'} filterType
       * @category Misc
       */
      "filterType",
      /**
       * By default, any rendered column cell content is HTML-encoded. Set this flag to `false` disable this and
       * allow rendering html elements
       * @config {Boolean} htmlEncode
       * @default true
       * @category Misc
       */
      { name: "htmlEncode", defaultValue: true },
      /**
       * By default, the header text is HTML-encoded. Set this flag to `false` disable this and allow html
       * elements in the column header
       * @config {Boolean} htmlEncodeHeaderText
       * @default true
       * @category Misc
       */
      { name: "htmlEncodeHeaderText", defaultValue: true },
      /**
       * Set to `true`to automatically call DomHelper.sync for html returned from a renderer. Should in most cases
       * be more performant than replacing entire innerHTML of cell and also allows CSS transitions to work. Has
       * no effect unless {@link #config-htmlEncode} is disabled. Returned html must contain a single root element
       * (that can have multiple children). See PercentColumn for example usage.
       * @config {Boolean} autoSyncHtml
       * @default false
       * @category Misc
       */
      { name: "autoSyncHtml", defaultValue: false },
      /**
       * Set to `false` to not always clear cell content if the {@link #config-renderer} returns `undefined`
       * or has no `return` statement. This is useful when you mutate the cellElement, and want to prevent
       * cell content from being reset during rendering. **This is the default behaviour until 6.0.**
       *
       * Set to `true` to always clear cell content regardless of renderer return value. **This will be default
       * behaviour from 6.0.**
       * @config {Boolean} alwaysClearCell
       * @default false
       * @category Misc
       */
      { name: "alwaysClearCell", defaultValue: false },
      /**
       * An array of the widgets to append to the column header
       * ```javascript
       * columns : [
       * {
       *     text          : 'Name',
       *     field         : 'name',
       *     flex          : 1,
       *     headerWidgets : [
       *         {
       *             type   : 'button',
       *             text   : 'Add row',
       *             cls    : 'b-raised b-blue',
       *             async onAction() {
       *                 const [newRecord] = grid.store.add({
       *                     name : 'New user'
       *                 });
       *
       *                 await grid.scrollRowIntoView(newRecord);
       *
       *                 await grid.features.cellEdit.startEditing({
       *                     record : newRecord,
       *                     field  : 'name'
       *                 });
       *             }
       *         }
       *     ]
       * }]
       * ```
       * @config {ContainerItemConfig[]} headerWidgets
       * @private
       * @category Misc
       */
      { name: "headerWidgets" },
      /**
       * Set to `true` to have the {@link Grid.feature.CellEdit} feature update the record being edited live upon
       * field edit instead of when editing is finished by using `TAB` or `ENTER`
       * @config {Boolean} instantUpdate
       * @category Misc
       */
      { name: "instantUpdate", defaultValue: false },
      { name: "repaintOnResize", defaultValue: false },
      /**
       * An optional query selector to select a sub element within the cell being
       * edited to align a cell editor's `X` position and `width` to.
       * @config {String} editTargetSelector
       * @category Misc
       */
      "editTargetSelector",
      //endregion
      //region Export
      /**
       * Used by the Export feature. Set to `false` to omit a column from an exported dataset
       * @config {Boolean} exportable
       * @default true
       * @category Export
       */
      { name: "exportable", defaultValue: true },
      /**
       * Column type which will be used by {@link Grid.util.TableExporter}. See list of available types in
       * TableExporter docs. Returns undefined by default, which means column type should be read from the record
       * field.
       * @config {String} exportedType
       * @category Export
       */
      { name: "exportedType" },
      //endregion
      /**
       * The `aria-label` to use for this Column`s header element
       * @config {String} ariaLabel
       * @category Accessibility
       */
      {
        name: "ariaLabel",
        defaultValue: "L{Column.columnLabel}"
      },
      /**
       * The `aria-label` to use for cells in this Column
       * @config {String} cellAriaLabel
       * @category Accessibility
       */
      {
        name: "cellAriaLabel",
        defaultValue: "L{cellLabel}"
      }
    ];
  }
  // prevent undefined fields from being exposed, to simplify spotting errors
  static get autoExposeFields() {
    return false;
  }
  //endregion
  //region Init
  construct(data, store) {
    var _a4;
    const me = this;
    me.masterStore = store;
    if (store) {
      me._grid = Array.isArray(store) ? store[0].grid : store.grid;
    }
    me.localizableProperties = Config.mergeMethods.distinct(data.localizableProperties, ["text", "ariaLabel", "cellAriaLabel"]);
    if (data.localeClass) {
      me.localeClass = data.localeClass;
    }
    super.construct(...arguments);
    if (me.isLeaf && !("field" in me.data)) {
      me.setData("field", "_" + (me.type || "") + ++_Column.emptyCount);
      me.noFieldSpecified = true;
    }
    if (!me.width && !me.flex && !me.children) {
      me.setData({
        width: _Column.defaultWidth,
        flex: null
      }, null, true);
    }
    me.headerWidgets && me.initHeaderWidgets(me.headerWidgets);
    if (me.isParent) {
      me.meta.visibleChildren = /* @__PURE__ */ new Set();
      if (me.collapsible) {
        me.grid.once("paint", () => me.collapsible = true);
      }
    }
    me.rendererReturningContent = (_a4 = me.renderer) == null ? void 0 : _a4.toString().includes("return ");
    if (me.defaultRenderer && me.renderer && me.renderer !== me.defaultRenderer) {
      me.externalRenderer = me.renderer;
      me.renderer = me.defaultRenderer;
    } else if (!me.renderer) {
      me.renderer = me.defaultRenderer;
    }
  }
  /**
   * Checks whether the other column is in the same position and configured the same as this Column.
   * @param {Grid.column.Column} other The partner column to check
   * @returns {Boolean} `true` if these two Columns should be kept in sync.
   * @private
   */
  shouldSync(other) {
    return other.isColumn && other.text === this.text && (other.field === this.field || String(other.renderer) === String(this.renderer)) && (!other.previousSibling && !this.previousSibling || other.previousSibling.shouldSync(this.previousSibling));
  }
  get isCollapsible() {
    var _a4;
    return ((_a4 = this.children) == null ? void 0 : _a4.length) > 1 && this.collapsible;
  }
  get collapsed() {
    return this.get("collapsed");
  }
  set collapsed(collapsed) {
    this.set("collapsed", collapsed, true);
    this.onCollapseChange(!collapsed);
    this.trigger("toggleCollapse", { collapsed });
  }
  onCellFocus(location) {
    this.location = location;
    this.updateHeaderAriaLabel(this.localizeProperty("ariaLabel"));
    if (location.rowIndex !== -1) {
      this.updateCellAriaLabel(this.localizeProperty("cellAriaLabel"));
    }
  }
  updateHeaderAriaLabel(headerAriaLabel) {
    DomHelper.setAttributes(this.element, {
      "aria-label": headerAriaLabel
    });
  }
  updateCellAriaLabel(cellAriaLabel) {
    var _a4, _b;
    if (!((_a4 = this.location) == null ? void 0 : _a4.isSpecialRow) && ((_b = this.location) == null ? void 0 : _b.cell)) {
      if (!(cellAriaLabel == null ? void 0 : cellAriaLabel.length)) {
        cellAriaLabel = this.location.column.text;
      }
      DomHelper.setAttributes(this.location.cell, {
        "aria-label": cellAriaLabel
      });
    }
  }
  doDestroy() {
    var _a4, _b, _c;
    (_c = (_b = (_a4 = this.data) == null ? void 0 : _a4.editor) == null ? void 0 : _b.destroy) == null ? void 0 : _c.call(_b);
    this.destroyHeaderWidgets();
    super.doDestroy();
  }
  //endregion
  //region Header widgets
  set headerWidgets(widgets) {
    this.initHeaderWidgets(widgets);
    this.set("headerWidgets", widgets);
  }
  get headerWidgets() {
    return this.get("headerWidgets");
  }
  initHeaderWidgets(widgets) {
    this.destroyHeaderWidgets();
    const headerWidgetMap = this.headerWidgetMap = {};
    for (const config of widgets) {
      const widget = Widget.create({ owner: this, ...config });
      headerWidgetMap[widget.ref || widget.id] = widget;
    }
  }
  destroyHeaderWidgets() {
    var _a4;
    for (const widget of Object.values(this.headerWidgetMap || {})) {
      (_a4 = widget.destroy) == null ? void 0 : _a4.call(widget);
    }
  }
  //endregion
  //region Fields
  // Yields the automatic cell tagging class, eg b-number-cell from NumberColumn etc
  static generateAutoCls() {
    const classes = [];
    for (let c = this; c !== _Column; c = c.superclass) {
      c.type && c.type !== c.superclass.type && classes.push(`b-${c.type.toLowerCase()}-cell`);
    }
    const columnAutoCls = classes.join(" ");
    (_Column.autoClsMap || (_Column.autoClsMap = /* @__PURE__ */ new Map())).set(this, columnAutoCls);
    return columnAutoCls;
  }
  /**
   * Returns the full CSS class set for a cell at the passed {@link Grid.util.Location}
   * as an object where property keys with truthy values denote a class to be added
   * to the cell.
   * @param {Grid.util.Location} cellContext
   * @returns {Object} An object in which property keys with truthy values are used as
   * the class names on the cell element.
   * @internal
   */
  getCellClass(cellContext) {
    var _a4;
    const { record, column } = cellContext, {
      cellCls,
      internalCellCls,
      grid,
      constructor,
      align,
      field
    } = column, modelField = record.fieldMap[field], autoCls = ((_a4 = _Column.autoClsMap) == null ? void 0 : _a4.get(constructor)) || constructor.generateAutoCls(), isEditing = cellContext.cell.classList.contains("b-editing"), result = {
      [grid.cellCls]: grid.cellCls,
      [autoCls]: autoCls,
      [cellCls]: cellCls,
      [internalCellCls]: internalCellCls,
      "b-cell-dirty": field && !(modelField == null ? void 0 : modelField.calculated) && record.isFieldModified(field) && (column.compositeField || (modelField == null ? void 0 : modelField.persist) !== false),
      [`b-grid-cell-align-${align}`]: align,
      "b-selected": grid.selectionMode.cell && grid.isCellSelected(cellContext),
      "b-focused": grid.isFocused(cellContext),
      "b-auto-height": column.autoHeight,
      "b-editing": isEditing
    };
    if (record.isSpecialRow && result["b-checkbox-selection"]) {
      result["b-checkbox-selection"] = false;
    }
    return result;
  }
  get locked() {
    return this.data.region === "locked";
  }
  set locked(locked) {
    this.region = locked ? "locked" : "normal";
  }
  // Children of grouped header always uses same region as the group
  get region() {
    if (!this.parent.isRoot) {
      return this.parent.region;
    }
    return this.get("region");
  }
  set region(region) {
    this.set("region", region);
  }
  // column can only be sorted if a `field` is provided, or a custom sort function is provided as `sortable`
  get sortable() {
    const { sortable } = this.data;
    if (!sortable || (this.noFieldSpecified || !this.field) && !sortable.sortFn) {
      return false;
    }
    return sortable;
  }
  set sortable(sortable) {
    this.set("sortable", sortable);
  }
  // column can only be grouped if a `field` is provided
  get groupable() {
    return Boolean(!(this.noFieldSpecified || !this.field) && this.data.groupable);
  }
  set groupable(groupable) {
    this.set("groupable", groupable);
  }
  get filterable() {
    return this.isLeaf && this.data.filterable;
  }
  /**
   * The Field to use as editor for this column
   * @private
   * @readonly
   */
  get editor() {
    const me = this;
    let { editor } = me.data;
    if (editor && !editor.isWidget) {
      const result = me.grid.processCellEditor({ editor, field: me.field });
      if (result) {
        editor = me.data.editor = result.editor;
      } else {
        if (typeof editor === "string") {
          editor = {
            type: editor
          };
        }
        editor = me.data.editor = Widget.create(ObjectHelper.merge(me.defaultEditor, {
          owner: me.grid,
          // Field labels must be present for A11Y purposes, but are clipped out of visibility.
          // Screen readers will be able to access them and announce them.
          label: StringHelper.encodeHtml(me.text)
        }, editor));
      }
    }
    return editor;
  }
  set editor(editor) {
    this.data.editor = editor;
  }
  /**
   * A config object specifying the editor to use to edit this column.
   * @private
   * @readonly
   */
  get defaultEditor() {
    return {
      type: "textfield",
      name: this.field
    };
  }
  //endregion
  //region Grid, SubGrid & Element
  /**
   * Extracts the value from the record specified by this Column's {@link #config-field} specification
   * in a format that can be used as a value to match by a {@link Grid.feature.Filter filtering} operation.
   *
   * The default implementation returns the {@link #function-getRawValue} value, but this may be
   * overridden in subclasses.
   * @param {Core.data.Model} record The record from which to extract the field value.
   * @returns {*} The value of the referenced field if any.
   */
  getFilterableValue(record) {
    return this.getRawValue(record);
  }
  // Create an ownership hierarchy which links columns up to their SubGrid if no owner injected.
  get owner() {
    return this._owner || this.subGrid;
  }
  set owner(owner) {
    this._owner = owner;
  }
  get grid() {
    var _a4;
    return this._grid || ((_a4 = this.parent) == null ? void 0 : _a4.grid);
  }
  // Private, only used in tests where standalone Headers are created with no grid
  // from which to lookup the associate SubGrid.
  set subGrid(subGrid) {
    this._subGrid = subGrid;
  }
  /**
   * Get the SubGrid to which this column belongs
   * @property {Grid.view.SubGrid}
   * @readonly
   */
  get subGrid() {
    var _a4;
    return this._subGrid || ((_a4 = this.grid) == null ? void 0 : _a4.getSubGridFromColumn(this));
  }
  /**
   * Get the element for the SubGrid to which this column belongs
   * @property {HTMLElement}
   * @readonly
   * @private
   */
  get subGridElement() {
    return this.subGrid.element;
  }
  /**
   * The header element for this Column. *Only available after the grid has been rendered*.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get element() {
    return this.grid.getHeaderElement(this);
  }
  get previousVisibleSibling() {
    const region = this.region;
    let prev = this.previousSibling;
    while (prev && (prev.hidden || prev.region !== region)) {
      prev = prev.previousSibling;
    }
    return prev;
  }
  get nextVisibleSibling() {
    const region = this.region;
    let next = this.nextSibling;
    while (next && (next.hidden || next.region !== region)) {
      next = next.nextSibling;
    }
    return next;
  }
  get isLastInSubGrid() {
    return !this.nextVisibleSibling && (this.parent.isRoot || this.parent.isLastInSubGrid);
  }
  get allowDrag() {
    return !this.parent.isRoot || Boolean(this.nextVisibleSibling || this.previousVisibleSibling);
  }
  /**
   * The text wrapping element for this Column. *Only available after the grid has been rendered*.
   *
   * This is the full-width element which *contains* the text-bearing element and any icons.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get textWrapper() {
    return DomHelper.getChild(this.element, ".b-grid-header-text");
  }
  /**
   * The text containing element for this Column. *Only available after the grid has been rendered*.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get textElement() {
    return DomHelper.down(this.element, ".b-grid-header-text-content");
  }
  /**
   * The child element into which content should be placed. This means where any
   * contained widgets such as filter input fields should be rendered. *Only available after the grid has been
   * rendered*.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get contentElement() {
    return DomHelper.down(this.element, ".b-grid-header-children");
  }
  //endregion
  //region Misc properties
  get isSorted() {
    return this.grid.store.sorters.some((s) => s.field === this.field);
  }
  get isFocusable() {
    return this.isLeaf;
  }
  static get text() {
    return this.$meta.fields.defaults.text;
  }
  /**
   * Returns header text based on {@link #config-htmlEncodeHeaderText} config value.
   * @returns {String}
   * @internal
   */
  get headerText() {
    return this.htmlEncodeHeaderText ? StringHelper.encodeHtml(this.text) : this.text;
  }
  /**
   * An object which contains a map of the header widgets keyed by their {@link Core.widget.Widget#config-ref ref}.
   * @property {Object<String,Core.widget.Widget>} headerWidgetMap
   * @private
   * @readonly
   */
  //endregion
  //region Show/hide
  get isVisible() {
    return !this.hidden && (!this.parent || this.parent.isVisible);
  }
  /**
   * Hides this column.
   */
  hide(silent = false, hidingParent = false) {
    const me = this, { parent } = me;
    if (!me.hidden) {
      me.hidden = true;
      if (parent && !parent.isRoot && !parent.isTogglingAll) {
        const anyVisible = parent.children.some((child) => child.hidden !== true);
        if (!anyVisible && !parent.hidden) {
          silent = true;
          parent.hide();
        }
      }
      if (me.isParent) {
        me.children.forEach((child) => child.hide(true, true));
      } else if (!parent.isRoot) {
        parent.meta.visibleChildren[hidingParent ? "add" : "delete"](me);
      }
      if (!silent) {
        me.stores.forEach((store) => store.trigger("columnHide", { column: me }));
      }
    }
  }
  /**
   * Shows this column.
   */
  show(silent = false) {
    var _a4;
    const me = this, { parent } = me;
    if (me.hidden) {
      me.hidden = false;
      if (parent == null ? void 0 : parent.hidden) {
        parent.show();
      }
      if (me.isParent) {
        (_a4 = me.meta.visibleChildren) == null ? void 0 : _a4.forEach((child) => child.show(true));
      }
      if (!silent) {
        me.stores.forEach((store) => store.trigger("columnShow", { column: me }));
      }
    }
  }
  /**
   * Toggles the column visibility.
   * @param {Boolean} [force] Set to true (visible) or false (hidden) to force a certain state
   */
  toggle(forceVisible) {
    if (this.hidden && forceVisible === void 0 || forceVisible === true) {
      return this.show();
    }
    if (!this.hidden && forceVisible === void 0 || forceVisible === false) {
      return this.hide();
    }
  }
  /**
   * Toggles the column visibility of all children of a parent column.
   * @param {Grid.column.Column[]} [columns] The set of child columns to toggle, defaults to all children
   * @param {Boolean} [force] Set to true (visible) or false (hidden) to force a certain state
   */
  toggleChildren(columns = this.children, force = void 0) {
    var _a4, _b;
    const me = this;
    (_a4 = me.grid.columns) == null ? void 0 : _a4.beginBatch();
    me.isTogglingAll = true;
    columns.forEach((childColumn) => childColumn.toggle(force));
    me.isTogglingAll = false;
    (_b = me.grid.columns) == null ? void 0 : _b.endBatch();
  }
  /**
   * Toggles the collapsed state of the column. Based on the {@link #config-collapseMode}, this either hides all
   * but the first child column, or toggles the visibility state of all children (if you want to have a special
   * column shown in collapsed mode).
   *
   * Only applicable for columns with child columns.
   * @private
   * @param {Boolean} [force] Set to true (expanded) or false (collapsed) to force a certain state
   */
  onCollapseChange(force = void 0) {
    var _a4, _b;
    const me = this;
    if (me.collapseMode === "toggleAll") {
      me.toggleChildren();
    } else {
      const { firstChild } = me;
      if (firstChild.flex != null && me.collapsed) {
        firstChild.oldFlex = firstChild.flex;
        firstChild.width = firstChild.element.offsetWidth;
      } else if (!me.collapsed && firstChild.oldFlex) {
        firstChild.flex = firstChild.oldFlex;
        firstChild.oldFlex = null;
      }
      (_a4 = me.grid.columns) == null ? void 0 : _a4.beginBatch();
      me.isTogglingAll = true;
      me.children.slice(1).forEach((childColumn) => childColumn.toggle(force));
      me.isTogglingAll = false;
      (_b = me.grid.columns) == null ? void 0 : _b.endBatch();
    }
  }
  set collapsible(collapsible) {
    const me = this;
    me.set("collapsible", collapsible);
    if (me.isParent) {
      const { headerWidgets = [] } = me;
      if (collapsible) {
        headerWidgets.push({
          type: "button",
          ref: "collapseExpand",
          toggleable: true,
          pressed: me.collapsed,
          icon: `b-icon-collapse-${me.grid.rtl ? "right" : "left"}`,
          pressedIcon: `b-icon-collapse-${me.grid.rtl ? "left" : "right"}`,
          cls: "b-grid-header-collapse-button b-transparent",
          onToggle: ({ pressed }) => me.collapsed = pressed
        });
      } else {
        const index = headerWidgets.findIndex((w) => w.ref === "collapseExpand");
        index > -1 && headerWidgets.splice(index, 1);
      }
      me.headerWidgets = headerWidgets;
      if (me.collapsed) {
        me.onCollapseChange(false);
      }
    }
  }
  get collapsible() {
    return this.get("collapsible");
  }
  //endregion
  //region Index & id
  /**
   * Generates an id for the column when none is set. Generated ids are 'col1', 'col2' and so on. If a field is
   * specified (as it should be in most cases) the field name is used instead: 'name1', 'age2' ...
   * @private
   * @returns {String}
   */
  generateId() {
    var _a4, _b, _c;
    const { grid } = this, parts = [(_b = (_a4 = this.field) == null ? void 0 : _a4.replace(/\./g, "-")) != null ? _b : "col"];
    if (grid) {
      parts.unshift((_c = grid.stateId) != null ? _c : grid.id);
      if (!grid.generatedIdIndex) {
        grid.generatedIdIndex = 0;
      }
      parts.push(grid.generatedIdIndex += 1);
    } else {
      if (!_Column.generatedIdIndex) {
        _Column.generatedIdIndex = 0;
      }
      parts.push(_Column.generatedIdIndex += 1);
    }
    return this.meta.generatedId = parts.join("-");
  }
  /**
   * Index among all flattened columns
   * @property {Number}
   * @readOnly
   * @internal
   */
  get allIndex() {
    return this.masterStore.indexOf(this);
  }
  //endregion
  //region Width
  // Returns size in pixels for measured value
  measureSize(value) {
    var _a4;
    return DomHelper.measureSize(value, (_a4 = this.subGrid) == null ? void 0 : _a4.element);
  }
  /**
   * Returns minimal width in pixels for applying to style according to the current `width` and `minWidth`.
   * @internal
   */
  get calcMinWidth() {
    const { width, minWidth } = this.data;
    if (validWidth(width) && validWidth(minWidth)) {
      return Math.max(parseInt(width) || 0, parseInt(minWidth) || 0);
    } else {
      return width;
    }
  }
  /**
   * Get/set columns width in px. If column uses flex, width will be undefined.
   * Setting a width on a flex column cancels out flex.
   *
   * **NOTE:** Grid might be configured to always stretch the last column, in which case the columns actual width
   * might deviate from the configured width.
   *
   * ```javascript
   * let grid = new Grid({
   *     appendTo : 'container',
   *     height   : 200,
   *     width    : 400,
   *     columns  : [{
   *         text  : 'First column',
   *         width : 100
   *     }, {
   *         text  : 'Last column',
   *         width : 100 // last column in the grid is always stretched to fill the free space
   *     }]
   * });
   *
   * grid.columns.last.element.offsetWidth; // 300 -> this points to the real element width
   * ```
   * @property {Number|String}
   */
  get width() {
    return this.data.width;
  }
  set width(width) {
    const data = { width };
    if (width && "flex" in this.data) {
      data.flex = null;
    }
    this.set(data);
  }
  set flex(flex) {
    const data = { flex };
    if (flex && "width" in this.data) {
      data.width = null;
    }
    this.set(data);
  }
  get flex() {
    return this.data.flex;
  }
  // This method is used to calculate minimum row width for edge and safari
  // It calculates minimum width of the row taking column hierarchy into account
  calculateMinWidth() {
    const me = this, width = me.measureSize(me.width), minWidth = me.measureSize(me.minWidth);
    let minChildWidth = 0;
    if (me.children) {
      minChildWidth = me.children.reduce((result, column) => {
        return result + column.calculateMinWidth();
      }, 0);
    }
    return Math.max(width, minWidth, minChildWidth);
  }
  /**
   * Resizes the column to match the widest string in it. By default it also measures the column header, this
   * behaviour can be configured by setting {@link Grid.view.Grid#config-resizeToFitIncludesHeader}.
   *
   * Called internally when you double click the edge between
   * column headers, but can also be called programmatically. For performance reasons it is limited to checking 1000
   * rows surrounding the current viewport.
   *
   * @param {Number|Number[]} widthMin Minimum allowed width. If content width is less than this, this width is used
   * instead. If this parameter is an array, the first element is `widthMin` and the seconds is `widthMax`.
   * @param {Number} widthMax Maximum allowed width. If the content width is greater than this number, this width
   * is used instead.
   */
  resizeToFitContent(widthMin, widthMax, batch = false) {
    var _a4;
    const me = this, {
      grid,
      element,
      fitMode
    } = me, { rowManager, store } = grid, { count } = store;
    if (count <= 0 || me.fitMode === "none" || !me.fitMode || ((_a4 = me.data) == null ? void 0 : _a4.vue)) {
      return;
    }
    const [row] = rowManager.rows, {
      rowElement,
      cellElement
    } = grid.beginGridMeasuring(), cellContext = new Location({
      grid,
      column: me,
      id: null
    });
    let maxWidth = 0, start, end, i, record, value, length, longest = { length: 0, record: null };
    cellElement._domData = {
      columnId: me.id,
      row,
      rowElement
    };
    cellContext._cell = cellElement;
    cellContext.updatingSingleRow = true;
    cellContext.isMeasuring = true;
    cellElement.innerHTML = "";
    if (grid.resizeToFitIncludesHeader && !grid.hideHeaders) {
      if (!grid.$headerPadding) {
        const style = globalThis.getComputedStyle(element);
        grid.$headerPadding = parseInt(style.paddingLeft);
      }
      const headerText = element.querySelector(".b-grid-header-text-content");
      headerText.style.cssText = "flex: none; width: auto";
      maxWidth = headerText.offsetWidth + grid.$headerPadding * 2 + 2;
      headerText.style.cssText = "";
    }
    if (count > 1e3) {
      start = Math.max(Math.min(rowManager.topIndex + Math.round(rowManager.rowCount / 2) - 500, count - 1e3), 0);
      end = start + 1e3;
    } else {
      start = 0;
      end = count;
    }
    for (i = start; i < end; i++) {
      record = store.getAt(i);
      value = me.getRawValue(record);
      if (fitMode === "value") {
        length = String(value).length;
      } else {
        cellContext._record = longest.record;
        cellContext._id = record.id;
        cellContext._rowIndex = i;
        row.renderCell(cellContext);
        if (fitMode === "textContent") {
          length = cellElement.textContent.length;
        } else {
          const width = cellElement.offsetWidth;
          if (width > maxWidth) {
            maxWidth = width;
          }
        }
      }
      if (length > longest.length) {
        longest = { record, length, rowIndex: i };
      }
    }
    if (longest.length > 0 && (fitMode === "value" || fitMode === "textContent")) {
      cellContext._record = longest.record;
      cellContext._id = longest.record.id;
      cellContext._rowIndex = longest.rowIndex;
      row.renderCell(cellContext);
      maxWidth = Math.max(maxWidth, cellElement.offsetWidth);
    }
    if (Array.isArray(widthMin)) {
      [widthMin, widthMax] = widthMin;
    }
    maxWidth = Math.max(maxWidth, widthMin || 0);
    maxWidth = Math.min(maxWidth, widthMax || 1e6);
    if (!batch) {
      grid.endGridMeasuring();
    }
    me.width = me.maxWidth ? maxWidth = Math.min(maxWidth, me.maxWidth) : maxWidth;
    return maxWidth;
  }
  //endregion
  //region State
  /**
   * Get column state, used by State mixin
   * @private
   */
  getState() {
    const me = this, { parentId } = me, state = {
      id: me.id,
      // State should only store column attributes which user can modify via UI (except column index).
      // User can hide column, resize or move it to neighbor region
      hidden: me.hidden,
      region: me.region,
      locked: me.locked,
      text: me.text
    };
    if (!me.noFieldSpecified) {
      state.field = me.field;
    }
    if (parentId != null) {
      state.parentId = parentId;
    }
    if (!me.children) {
      state[me.flex ? "flex" : "width"] = me.flex || me.width;
    }
    if (me.isCollapsible) {
      state.collapsed = me.collapsed;
    }
    return state;
  }
  /**
   * Apply state to column, used by State mixin
   * @private
   */
  applyState(state) {
    const me = this;
    me.beginBatch();
    if ("locked" in state) {
      me.locked = state.locked;
    }
    if ("width" in state) {
      me.width = state.width;
    }
    if ("flex" in state) {
      me.flex = state.flex;
    }
    if ("width" in state && me.flex) {
      me.flex = void 0;
    } else if ("flex" in state && me.width) {
      me.width = void 0;
    }
    if ("region" in state) {
      me.region = state.region;
    }
    if ("text" in state) {
      me.text = state.text;
    }
    me.endBatch();
    if ("hidden" in state) {
      me.toggle(state.hidden !== true);
    }
    if ("collapsed" in state) {
      me.collapsed = state.collapsed;
    }
  }
  //endregion
  //region Other
  remove() {
    const { subGrid, grid } = this, focusedCell = subGrid && (grid == null ? void 0 : grid.focusedCell);
    if ((focusedCell == null ? void 0 : focusedCell.columnId) === this.id) {
      if (grid.owns(DomHelper.getActiveElement(grid))) {
        grid.navigateRight();
      } else {
        grid._focusedCell = new Location({
          grid,
          rowIndex: focusedCell.rowIndex,
          column: subGrid.columns.getAdjacentVisibleLeafColumn(this.id, true, true)
        });
      }
    }
    super.remove();
  }
  /**
   * Extracts the value from the record specified by this Column's {@link #config-field} specification.
   *
   * This will work if the field is a dot-separated path to access fields in associated records, eg
   *
   * ```javascript
   *  field : 'resource.calendar.name'
   * ```
   *
   * **Note:** This is the raw field value, not the value returned by the {@link #config-renderer}.
   * @param {Core.data.Model} record The record from which to extract the field value.
   * @returns {*} The value of the referenced field if any.
   */
  getRawValue(record) {
    return record.getValue(this.field);
  }
  /**
   * Refresh the cell for supplied record in this column, if that cell is rendered.
   * @param {Core.data.Model} record Record used to get row to update the cell in
   */
  refreshCell(record) {
    this.grid.rowManager.refreshCell(record, this.id);
  }
  /**
   * Rerender the header for this column
   */
  refreshHeader() {
    this.grid.refreshHeader(this);
  }
  /**
   * Clear cell contents. Base implementation which just sets innerHTML to blank string.
   * Should be overridden in subclasses to clean up for examples widgets.
   * @param {HTMLElement} cellElement
   * @internal
   */
  clearCell(cellElement) {
    cellElement.innerHTML = "";
    delete cellElement._content;
  }
  /**
   * Override in subclasses to allow/prevent editing of certain rows.
   * @param {Core.data.Model} record
   * @internal
   */
  canEdit(record) {
    if (record.isEditable) {
      const isEditable = record.isEditable(this.field);
      if (isEditable !== void 0) {
        return isEditable;
      }
    }
    return true;
  }
  /**
   * Insert a child column(s) before an existing child column. Returns `null` if the parent column is
   * {@link #config-sealed}
   * @param {Core.data.Model|Core.data.Model[]} childColumn Column or array of columns to insert
   * @param {Core.data.Model} [before] Optional column to insert before, leave out to append to the end
   * @param {Boolean} [silent] Pass `true` to not trigger events during insert
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  insertChild(childColumn, before = null, silent = false) {
    childColumn = Array.isArray(childColumn) ? childColumn : [childColumn];
    childColumn.forEach((col) => {
      const { parent } = col;
      if ((parent == null ? void 0 : parent.collapsed) && col === parent.firstChild && parent.children.length > 1 && parent.children.filter((child) => !child.hidden).length === 1) {
        col.nextSibling.hidden = false;
      }
    });
    return this.sealed && !this.inProcessChildren ? null : super.insertChild(...arguments);
  }
  /**
   * Override in subclasses to prevent this column from being filled with the {@link Grid.feature.FillHandle} feature
   * @param {Object} data Object containing information about current cell and fill value
   * @param {Grid.util.Location} data.cell Current cell data
   * @param {Grid.util.Location[]} data.range Range from where to calculate values
   * @param {Core.data.Model} data.record Current cell record
   * @returns {Boolean}
   * @internal
   */
  canFillValue() {
    return true;
  }
  //endregion
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs (fields) for the column, with special handling for sortable, editor, renderer and
  // headerRenderer
  getCurrentConfig(options) {
    var _a4;
    const result = super.getCurrentConfig(options);
    if ((_a4 = this.sortable) == null ? void 0 : _a4.originalSortFn) {
      result.sortable = this.sortable.originalSortFn;
    }
    if (result.renderer === this.defaultRenderer) {
      delete result.renderer;
    }
    if (result.headerRenderer === this.internalHeaderRenderer) {
      delete result.headerRenderer;
    }
    delete result.ariaLabel;
    delete result.cellAriaLabel;
    return result;
  }
  get readOnly() {
    var _a4;
    return this.field && ((_a4 = this.grid.store.modelClass.getFieldDefinition(this.field)) == null ? void 0 : _a4.calculated) || this.get("readOnly");
  }
  set readOnly(value) {
    this.set("readOnly", value);
  }
  get activeRenderer() {
    return this.renderer || this.defaultRenderer;
  }
};
__publicField(_Column, "$name", "Column");
/**
 * Column name alias which you can use in the `columns` array of a Grid.
 *
 * ```javascript
 * class MyColumn extends Column {
 *     static get type() {
 *        return 'mycolumn';
 *     }
 * }
 * ```
 *
 * ```javascript
 * const grid = new Grid({
 *    columns : [
 *       { type : 'mycolumn', text : 'The column', field : 'someField', flex : 1 }
 *    ]
 * });
 * ```
 *
 * @static
 * @member {String} type
 */
__publicField(_Column, "type", "column");
var Column = _Column;
Column.emptyCount = 0;
Column.defaultWidth = 100;
Column.exposeProperties();
Column._$name = "Column";

// lib/Grid/data/ColumnStore.js
var columnDefinitions = {
  boolean: {
    type: "check"
  },
  date: {
    type: "date"
  },
  integer: {
    type: "number",
    format: {
      maximumFractionDigits: 0
    }
  },
  number: {
    type: "number"
  }
};
var lockedColumnSorters = [{
  field: "region"
}];
var ColumnStore = class _ColumnStore extends Localizable_default(Store) {
  //region Events
  /**
   * Fires when a column is shown.
   * @event columnShow
   * @param {Grid.data.ColumnStore} source The store which triggered the event.
   * @param {Grid.column.Column} column The column which status has been changed.
   */
  /**
   * Fires when a column has been hidden.
   * @event columnHide
   * @param {Grid.data.ColumnStore} source The store which triggered the event.
   * @param {Grid.column.Column} column The column which status has been changed.
   */
  //endregion
  static get defaultConfig() {
    return {
      modelClass: Column,
      tree: true,
      /**
       * Automatically adds a field definition to the store used by the Grid when adding a new Column displaying a
       * non-existing field.
       *
       * To enable this behaviour:
       *
       * ```javascript
       * const grid = new Grid({
       *     columns : {
       *         autoAddField : true,
       *         data         : [
       *             // Column definitions here
       *         ]
       *     }
       * }
       *
       * @config {Boolean}
       * @default
       */
      autoAddField: false,
      /**
       * `ColumnStore` uses `syncDataOnLoad` by default (with `threshold : 1`), to ensure good performance when
       * binding to columns in frameworks.
       *
       * See {@link Core/data/Store#config-syncDataOnLoad} for more information.
       *
       * @config {Boolean|SyncDataOnLoadOptions}
       * @default true
       * @readonly
       */
      syncDataOnLoad: {
        threshold: 1
      },
      // Locked columns must sort to before non-locked
      sorters: lockedColumnSorters,
      // Make sure regions stick together when adding columns
      reapplySortersOnAdd: true
    };
  }
  construct(config) {
    const me = this, { grid } = config;
    if (grid) {
      grid._columnStore = me;
      me.id = `${grid.id}-columns`;
      grid.ion({
        subGridCollapse: "clearSubGridCaches",
        subGridExpand: "clearSubGridCaches",
        thisObj: me
      });
    }
    super.construct(config);
    me.ion({
      change: me.onStoreChange,
      sort: () => me.updateChainedStores(),
      thisObj: me,
      prio: 1
    });
  }
  doDestroy() {
    const allColumns = [];
    if (!this.isChained) {
      this.traverse((column) => allColumns.push(column));
    }
    super.doDestroy();
    if (!this.isChained) {
      allColumns.forEach((column) => column.destroy());
    }
  }
  // Overridden because the flat collection only contains top level columns,
  // not leaves - group columns are *not* expanded.
  /**
   * Get column by id.
   * @param {String|Number} id
   * @returns {Grid.column.Column}
   */
  getById(id) {
    return super.getById(id) || this.idRegister[id];
  }
  forEach(fn, thisObj = this) {
    this.traverseWhile((n, i) => fn.call(thisObj, n, i), true);
  }
  get totalFixedWidth() {
    let result = 0;
    for (const col of this) {
      if (!col.hidden) {
        if (col.children) {
          col.children.forEach((childCol) => result += this.calculateFixedWidth(childCol));
        } else {
          result += this.calculateFixedWidth(col);
        }
      }
    }
    return result;
  }
  get hasFlex() {
    return this.visibleColumns.some((column) => column.flex);
  }
  calculateFixedWidth(column) {
    if (column.flex) {
      return column.measureSize(Column.defaultWidth);
    } else {
      return Math.max(column.measureSize(column.width), column.measureSize(column.minWidth));
    }
  }
  /**
   * Returns the top level columns. If using grouped columns, this is the top level columns. If no grouped
   * columns are being used, this is the leaf columns.
   * @property {Grid.column.Column[]}
   * @readonly
   */
  get topColumns() {
    return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children;
  }
  /**
   * Returns the visible leaf headers which drive the rows' cell content.
   * @property {Grid.column.Column[]}
   * @readonly
   */
  get visibleColumns() {
    const me = this;
    if (!me._visibleColumns) {
      me._visibleColumns = me.leaves.filter((column) => column.isVisible && (!column.subGrid || !column.subGrid.collapsed));
    }
    return me._visibleColumns;
  }
  onStoreChange({ action, changes }) {
    if (action === "update" && !("hidden" in changes)) {
      return;
    }
    this.clearCaches();
  }
  clearSubGridCaches({ subGrid }) {
    subGrid.columns.clearCaches();
    this.clearCaches();
  }
  clearCaches() {
    var _a4;
    this._visibleColumns = null;
    (_a4 = this.masterStore) == null ? void 0 : _a4.clearCaches();
  }
  onMasterDataChanged(event) {
    super.onMasterDataChanged(event);
    if (event.action !== "update" || "hidden" in event.changes) {
      this.clearCaches();
    }
  }
  getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {
    const columns = this.visibleColumns, column = columnOrId instanceof Column ? columnOrId : this.getById(columnOrId);
    let idx = columns.indexOf(column) + (next ? 1 : -1);
    if (!columns[idx]) {
      if (wrap) {
        idx = next ? 0 : columns.length - 1;
      } else {
        return null;
      }
    }
    return columns[idx];
  }
  /**
   * Bottom columns are the ones displayed in the bottom row of a grouped header, or all columns if not using a grouped
   * header. They are the columns that actually display any data.
   * @property {Grid.column.Column[]}
   * @readonly
   */
  get bottomColumns() {
    return this.leaves;
  }
  /**
   * Get column by field. To be sure that you are getting exactly the intended column, use {@link Core.data.Store#function-getById Store#getById()} with the
   * columns id instead.
   * @param {String} field Field name
   * @returns {Grid.column.Column}
   */
  get(field) {
    return this.findRecord("field", field, true);
  }
  lookupStateColumn(config) {
    let column = this.getById(config.id);
    if (!column && config.field) {
      const hits = this.query((col) => col.field === config.field);
      if (hits.length === 1) {
        column = hits[0];
      }
    }
    return column;
  }
  /**
   * Used internally to create a new record in the store. Creates a column of the correct type by looking up the
   * specified type among registered columns.
   * @private
   */
  createRecord(data) {
    var _a4, _b;
    const { grid = {} } = this, { store } = grid, dataField = (_b = (_a4 = store == null ? void 0 : store.modelClass) == null ? void 0 : _a4.fieldMap) == null ? void 0 : _b[data.field];
    let columnClass = this.modelClass;
    if (dataField == null ? void 0 : dataField.column) {
      data = Objects.merge({}, dataField.column, data);
    }
    if (data.type) {
      columnClass = _ColumnStore.getColumnClass(data.type);
      if (!columnClass) {
        throw new Error(`Column type '${data.type}' not registered`);
      }
    }
    if (data.locked) {
      data.region = "locked";
      delete data.locked;
    }
    const column = new columnClass(data, this);
    if (!column.data.region) {
      column.data.region = grid.defaultRegion || "normal";
    }
    if (this.autoAddField && !column.noFieldSpecified && store && !dataField) {
      let fieldDefinition = column.field;
      if (column.constructor.fieldType) {
        fieldDefinition = {
          name: column.field,
          type: column.constructor.fieldType
        };
      }
      store.modelClass.addField(fieldDefinition);
    }
    return column;
  }
  /**
   * indexOf extended to also accept a columns field, for backward compatibility.
   * ```
   * grid.columns.indexOf('name');
   * ```
   * @param {Core.data.Model|String} recordOrId
   * @returns {Number}
   */
  indexOf(recordOrId) {
    if (recordOrId == null) {
      return -1;
    }
    const index = super.indexOf(recordOrId);
    if (index > -1)
      return index;
    return this.records.findIndex((r) => r.field === recordOrId);
  }
  /**
   * Removes all columns.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`
   * @fires beforeRemove
   * @fires removeAll
   * @fires Core.data.Store#event-change
   * @category CRUD
   */
  removeAll(silent = false) {
    const me = this, isTimeAxis = me.some((i) => i.isTimeAxisColumn);
    if (isTimeAxis) {
      return me.remove(me.query((i) => !i.isTimeAxisColumn), silent);
    }
    return super.removeAll(silent);
  }
  /**
   * Checks if any column uses autoHeight
   * @internal
   * @property {Boolean}
   * @readonly
   */
  get usesAutoHeight() {
    return this.some((column) => column.autoHeight);
  }
  /**
   * Checks if any flex column uses autoHeight
   * @internal
   * @property {Boolean}
   * @readonly
   */
  get usesFlexAutoHeight() {
    return this.some((column) => column.autoHeight && column.flex != null);
  }
  // Let syncDataOnLoad match on id, field or type (in that order)
  resolveSyncNode(rawData) {
    if (rawData.id) {
      return super.resolveSyncNode(rawData);
    }
    if (rawData.field) {
      return {
        id: rawData.field,
        node: this.allRecords.find((r) => r.field === rawData.field)
      };
    }
    if (rawData.type) {
      return {
        id: rawData.type,
        node: this.allRecords.find((r) => r.type === rawData.type)
      };
    }
    return { id: null, node: null };
  }
  //region Column types
  /**
   * Call from custom column to register it with ColumnStore. Required to be able to specify type in column config.
   * @param {Function} columnClass The {@link Grid.column.Column} subclass to register.
   * @param {Boolean} simpleRenderer Pass `true` if its default renderer does *not* use other fields from the passed
   * record than its configured {@link Grid.column.Column#config-field}. This enables more granular cell updating
   * upon record mutation.
   *
   * ```javascript
   * // create and register custom column
   * class CustomColumn {
   *  static get type() {
   *      return 'custom';
   *  }
   * }
   * ColumnStore.registerColumnType(CustomColumn, true);
   * // now possible to specify in column config
   * let grid = new Grid({
   *   columns: [
   *     { type: 'custom', field: 'id' }
   *   ]
   * });
   * ```
   */
  static registerColumnType(columnClass, simpleRenderer = false) {
    columnClass.simpleRenderer = simpleRenderer;
    (_ColumnStore.columnTypes || (_ColumnStore.columnTypes = {}))[columnClass.type] = columnClass;
  }
  /**
   * Returns registered column class for specified type.
   * @param type Type name
   * @returns {Grid.column.Column}
   * @internal
   */
  static getColumnClass(type) {
    return _ColumnStore.columnTypes && _ColumnStore.columnTypes[type];
  }
  /**
   * Generates a <strong>new </strong> {@link Grid.column.Column} instance which may be subsequently added to this
   * store to represent the passed {@link Core.data.field.DataField} of the owning Grid's store.
   * @param {Core.data.field.DataField|String} dataField The {@link Core.data.field.DataField field}
   * instance or field name to generate a new {@link Grid.column.Column} for.
   *
   * ```javascript
   * // Add column for the "team" field.
   * grid.columns.add(grid.columns.generateColumnForField('team', {
   *     width : 200
   * }));
   * ```
   *
   * @param {Object} [defaults] Defaults to apply to the new column.
   * @returns {Grid.column.Column} A new Column which will render and edit the field correctly.
   * @internal
   */
  generateColumnForField(dataField, defaults) {
    var _a4;
    if (typeof dataField === "string" && this.grid) {
      dataField = (_a4 = this.grid.store) == null ? void 0 : _a4.modelClass.fieldMap[dataField];
    }
    let column = dataField.column || columnDefinitions[dataField.type] || {};
    if (typeof column === "string") {
      column = { type: column };
    }
    column = Object.assign({
      text: dataField.text || StringHelper.separate(dataField.name),
      field: dataField.name
    }, defaults, column);
    if (dataField.precision != null) {
      column.format.maximumFractionDigits = dataField.precision;
    }
    if (dataField.columnType) {
      column.type = dataField.columnType;
    }
    return this.createRecord(column);
  }
  //endregion
};
var columnResizeEvent = (handler, thisObj) => ({
  update: ({ store, record, changes }) => {
    let result = true;
    if ("width" in changes || "minWidth" in changes || "maxWidth" in changes || "flex" in changes) {
      result = handler.call(thisObj, { store, record, changes });
    }
    return result;
  }
});
ColumnStore.registerColumnType(Column, true);
ColumnStore._$name = "ColumnStore";

// lib/Grid/column/ActionColumn.js
var ActionColumn = class extends Column {
  get groupHeaderReserved() {
    return true;
  }
  construct(config, store) {
    const me = this;
    super.construct(...arguments);
    if (!config.width && !config.flex) {
      me.grid.ion({ paint: "updateAutoWidth", thisObj: me });
    }
    if (me.disableIfGridReadOnly) {
      me.grid.element.classList.add("b-actioncolumn-readonly");
    }
  }
  /**
   * Renderer that displays action icon(s) in the cell.
   * @private
   */
  defaultRenderer({ grid, column, record, isExport, callExternalRenderer = true }) {
    var _a4;
    const inGroupTitle = record && "groupRowFor" in record.meta, { subGrid } = column, renderConfig = {
      className: { "b-action-ct": 1 },
      children: (_a4 = column.actions) == null ? void 0 : _a4.map((actionConfig, index) => {
        var _a5, _b;
        if ("visible" in actionConfig) {
          if (typeof actionConfig.visible === "function" && actionConfig.visible({ record }) === false || actionConfig.visible === false) {
            return "";
          }
        }
        if (inGroupTitle && !actionConfig.showForGroup || !inGroupTitle && actionConfig.showForGroup) {
          return "";
        }
        const {
          tooltip,
          renderer
        } = actionConfig, btip = typeof tooltip === "function" || ((_a5 = tooltip == null ? void 0 : tooltip.startsWith) == null ? void 0 : _a5.call(tooltip, "up.")) ? subGrid.callback(tooltip, subGrid, [{ record }]) : tooltip || "";
        if (renderer) {
          const customRendererData = (_b = subGrid.callback(renderer, subGrid, [{
            index,
            record,
            column,
            isExport,
            tooltip: btip,
            action: actionConfig
          }])) != null ? _b : "";
          if (typeof customRendererData === "string") {
            return {
              tag: "span",
              class: "b-action-item b-tool",
              dataset: {
                ...Tooltip.encodeConfig(btip),
                index
              },
              html: customRendererData
            };
          } else {
            customRendererData.dataset = customRendererData.dataset || {};
            customRendererData.dataset.index = index;
            return customRendererData;
          }
        } else {
          return {
            tag: "button",
            dataset: {
              ...Tooltip.encodeConfig(btip),
              index
            },
            "aria-label": btip,
            className: {
              "b-tool": 1,
              "b-action-item": 1,
              [actionConfig.cls]: actionConfig.cls
            }
          };
        }
      })
    };
    if (isExport) {
      return renderConfig.children.flatMap((configItem) => configItem.html || []).join(",");
    }
    return renderConfig;
  }
  /**
   * Handle icon click and call action handler.
   * @private
   */
  onCellClick({ grid, column, record, target }) {
    var _a4;
    let actionEl;
    if (column !== this || !(actionEl = target.closest(".b-action-item[data-index]"))) {
      return;
    }
    const actionIndex = actionEl.dataset.index, action = (_a4 = column.actions) == null ? void 0 : _a4[actionIndex], actionHandler = action == null ? void 0 : action.onClick;
    if (actionHandler) {
      this.callback(actionHandler, column, [{ record, action, target, grid, column }]);
    }
  }
  /**
   * Update width for actions column to fit content.
   * @private
   */
  updateAutoWidth() {
    const me = this, groupActions = [], {
      actions: oldActions
    } = me;
    if (!me.element) {
      return;
    }
    const actions6 = me.actions = [];
    oldActions == null ? void 0 : oldActions.forEach((actionOriginal) => {
      const action = { ...actionOriginal };
      delete action.visible;
      if (action.showForGroup) {
        delete action.showForGroup;
        groupActions.push(action);
      } else {
        actions6.push(action);
      }
    });
    if (groupActions.length > actions6.length) {
      me._actions = groupActions;
    }
    const actionsHtml = DomHelper.createElement(me.defaultRenderer({
      column: me,
      record: new me.grid.store.modelClass(),
      callExternalRenderer: false
    })).outerHTML;
    me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);
    me.actions = oldActions;
  }
};
__publicField(ActionColumn, "type", "action");
__publicField(ActionColumn, "$name", "ActionColumn");
__publicField(ActionColumn, "fields", [
  /**
   * An array of action config objects, see {@link #typedef-ActionConfig} for details.
   *
   * ```javascript
   * new Grid({
   *     columns  : [{
   *         type    : 'action',
   *         text    : 'Actions',
   *         actions : [{
   *             cls      : 'b-fa b-fa-plus',
   *             visible  : ({ record }) => record.canAdd,
   *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)
   *         }, {
   *             cls     : 'b-fa b-fa-pencil',
   *             tooltip : 'Edit note',
   *             onClick : ({ record }) => console.log(`Editing ${record.name}`)
   *         }]
   *     }]
   * });
   * ```
   *
   * @config {ActionConfig[]} actions List of action configs
   * @category Common
   */
  { name: "actions", type: "array" },
  /**
   * Set true to hide disable actions in this column if the grid is {@link Core.widget.Widget#config-readOnly}
   * @config {Boolean} disableIfGridReadOnly
   * @default
   * @category Common
   */
  { name: "disableIfGridReadOnly", defaultValue: false },
  "externalRenderer"
]);
__publicField(ActionColumn, "defaults", {
  /**
   * @hideconfigs filterable, groupable, sortable, editor, searchable, htmlEncode, resizable
   */
  filterable: false,
  groupable: false,
  sortable: false,
  editor: false,
  searchable: false,
  htmlEncode: false,
  resizable: false,
  /**
   * Column minimal width. If value is Number then minimal width is in pixels.
   * @config {Number|String} minWidth
   * @default 30
   * @category Layout
   */
  minWidth: 30
});
ColumnStore.registerColumnType(ActionColumn);
ActionColumn.exposeProperties();
ActionColumn._$name = "ActionColumn";

// lib/Grid/column/NumberColumn.js
var NumberColumn = class extends Column {
  static get defaults() {
    return {
      filterType: "number",
      /**
       * The format to use for rendering numbers.
       *
       * By default, the locale's default number formatter is used. For `en-US`, the
       * locale default is a maximum of 3 decimal digits, using thousands-based grouping.
       * This would render the number `1234567.98765` as `'1,234,567.988'`.
       *
       * @config {String|NumberFormatConfig}
       */
      format: ""
    };
  }
  //endregion
  //region Init
  get defaultEditor() {
    const { format, name, max, min: min2, step, largeStep, align } = this;
    return ObjectHelper.cleanupProperties({
      type: "numberfield",
      format,
      name,
      max,
      min: min2,
      step,
      largeStep,
      textAlign: align
    });
  }
  get formatter() {
    const me = this, { format } = me;
    let formatter = me._formatter;
    if (!formatter || me._lastFormat !== format) {
      me._formatter = formatter = NumberFormat.get(me._lastFormat = format);
    }
    return formatter;
  }
  formatValue(value) {
    if (value != null) {
      value = this.formatter.format(value);
      if (this.unit) {
        value = `${value}${this.unit}`;
      }
    }
    return value != null ? value : "";
  }
  /**
   * Renderer that displays a formatted number in the cell. If you create a custom renderer, and want to include the
   * formatted number you can call `defaultRenderer` from it.
   *
   * ```javascript
   * new Grid({
   *     columns: [
   *         {
   *             type   : 'number',
   *             text   : 'Total cost',
   *             field  : 'totalCost',
   *             format : {
   *                 style    : 'currency',
   *                 currency : 'USD'
   *             },
   *             renderer({ value }) {
   *                  return `Total cost: ${this.defaultRenderer({ value })}`;
   *             }
   *         }
   *     ]
   * }
   * ```
   *
   * @param {Object} rendererData The data object passed to the renderer
   * @param {Number} rendererData.value The value to display
   * @returns {String} Formatted number
   * @typings {String|DomConfig}
   */
  defaultRenderer({ value }) {
    return this.formatValue(value);
  }
};
//region Config
__publicField(NumberColumn, "type", "number");
// Type to use when auto adding field
__publicField(NumberColumn, "fieldType", "number");
__publicField(NumberColumn, "fields", [
  "format",
  /**
   * The minimum value for the field used during editing.
   * @config {Number} min
   * @category Common
   */
  "min",
  /**
   * The maximum value for the field used during editing.
   * @config {Number} max
   * @category Common
   */
  "max",
  /**
   * Step size for the field used during editing.
   * @config {Number} step
   * @category Common
   */
  "step",
  /**
   * Large step size for the field used during editing. In effect for `SHIFT + click/arrows`
   * @config {Number} largeStep
   * @category Common
   */
  "largeStep",
  /**
   * Unit to append to displayed value.
   * @config {String} unit
   * @category Common
   */
  "unit"
]);
ColumnStore.registerColumnType(NumberColumn, true);
NumberColumn.exposeProperties();
NumberColumn._$name = "NumberColumn";

// lib/Grid/column/AggregateColumn.js
var AggregateColumn = class extends NumberColumn {
  static get defaults() {
    return {
      /**
       * Math Function name, or function name prepended by `"up."` that is resolvable in an
       * ancestor component (such as the owning Grid, or a height Container), or a function to
       * use to aggregate child record values for this column, or a function.
       *
       * This Column is provided with a `sum` and `avg` function. The default function is `sum`
       * which is used for the aggregation.
       *
       * The function is passed a set of child node values, each value in a separate argument
       * and should return a single value based upon the value set passed.
       * @config {'sum'|'avg'|'min'|'max'|Function}
       * @param {Core.data.Model[]} records Records for aggregation
       * @returns {*} Aggregated value
       * @category Common
       */
      function: "sum",
      /**
       * Set to `true` to include changes to parent (aggregate) rows in the store's modification tracking.
       * @config {Boolean} includeParentInChangeSet
       * @category Common
       */
      includeParentInChangeSet: false
    };
  }
  construct(data, columnStore) {
    const me = this;
    me.configuredAlign = "align" in data;
    me.configuredEditor = "editor" in data;
    super.construct(...arguments);
    const { grid } = columnStore;
    if (me.function === "sum") {
      me.function = "sumChildren";
    }
    if (grid) {
      me.store = grid.store;
    }
  }
  set store(store) {
    const me = this, storeListeners = {
      update: "onRecordUpdate",
      thisObj: me,
      prio: 1e3
    }, oldStore = me._store;
    if (store !== oldStore) {
      if (oldStore) {
        oldStore.un(storeListeners);
      }
      me._store = store;
      const { modelClass } = store, field = modelClass.fieldMap[me.field];
      if (field && field.type === "number") {
        if (!me.configuredAlign) {
          me.align = "end";
        }
        if (!me.configuredEditor) {
          me.editor = "number";
        }
      }
      store.ion(storeListeners);
    }
  }
  canEdit(record) {
    return record.isLeaf;
  }
  get store() {
    return this._store;
  }
  sumChildren(...args) {
    let result = 0;
    for (let i = 0, { length } = args; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result;
  }
  avg(...args) {
    let result = 0;
    const { length } = args;
    for (let i = 0; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result / length;
  }
  onRecordUpdate({ record, changes }) {
    const me = this, { rowManager } = me.grid;
    if (me.field in changes) {
      if (record.isLeaf) {
        record.bubble((rec) => {
          const row = rowManager.getRowFor(rec);
          if (row) {
            const cellElement = row.getCell(me.field);
            if (cellElement) {
              row.renderCell(cellElement);
            }
          }
        }, true);
      }
    }
  }
  getRawValue(record) {
    var _a4;
    let value;
    const me = this, { field } = me;
    if ((_a4 = record.children) == null ? void 0 : _a4.length) {
      const fn = me.function, isMathFn = typeof fn === "string" && typeof Math[fn] === "function", {
        handler,
        thisObj
      } = isMathFn ? {
        handler: Math[fn],
        thisObj: Math
      } : me.resolveCallback(fn);
      value = handler.apply(thisObj, record.children.map((r) => me.getRawValue(r)));
      if (me.includeParentInChangeSet) {
        record.set(field, value, true);
      } else {
        record.setData(field, value);
      }
    } else {
      value = record.getValue(field);
    }
    return value;
  }
  canFillValue({ record }) {
    return record.isLeaf;
  }
};
//region Config
__publicField(AggregateColumn, "type", "aggregate");
__publicField(AggregateColumn, "fields", [
  "function",
  "includeParentInChangeSet"
]);
ColumnStore.registerColumnType(AggregateColumn, true);
AggregateColumn.exposeProperties();
AggregateColumn._$name = "AggregateColumn";

// lib/Grid/column/WidgetColumn.js
var onWidgetChange = ({ source, value, userAction }) => {
  if (userAction) {
    source.cellInfo.record.setValue(source.name, value);
  }
};
var WidgetColumn = class extends Column {
  /**
   * A renderer function, which gives you access to render data like the current `record`, `cellElement` and the
   * {@link #config-widgets} of the column. See {@link #config-renderer}
   * for more information.
   *
   * ```javascript
   * new Grid({
   *     columns : [
   *         {
   *              type: 'check',
   *              field: 'allow',
   *              // In the column renderer, we get access to the record and column widgets
   *              renderer({ record, widgets }) {
   *                  // Hide checkboxes in certain rows
   *                  widgets[0].hidden = record.readOnly;
   *              }
   *         }
   *     ]
   * });
   * ```
   *
   * @config {Function} renderer
   * @param {Object} renderData Object containing renderer parameters
   * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc. Can be `null` in case of export
   * @param {*} renderData.value Value to be displayed in the cell
   * @param {Core.data.Model} renderData.record Record for the row
   * @param {Grid.column.Column} renderData.column This column
   * @param {Core.widget.Widget[]} renderData.widgets An array of the widgets rendered into this cell
   * @param {Grid.view.Grid} renderData.grid This grid
   * @param {Grid.row.Row} renderData.row Row object. Can be null in case of export.
   *   Use the {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.
   * @param {Object} renderData.size Set `size.height` to specify the desired row height for the current row.
   *   Largest specified height is used, falling back to configured {@link Grid/view/Grid#config-rowHeight}
   *   in case none is specified. Can be null in case of export
   * @param {Number} renderData.size.height Set this to request a certain row height
   * @param {Number} renderData.size.configuredHeight Row height that will be used if none is requested
   * @param {Boolean} renderData.isExport True if record is being exported to allow special handling during export
   * @param {Boolean} renderData.isTreeGroup True if record is a generated tree group parent record
   * @param {Boolean} renderData.isMeasuring True if the column is being measured for a `resizeToFitContent` call.
   *   In which case an advanced renderer might need to take different actions.
   * @returns {void}
   *
   * @category Rendering
   */
  static get defaults() {
    return {
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      fitMode: false,
      alwaysClearCell: false
    };
  }
  //endregion
  //region Init / Destroy
  construct() {
    super.construct(...arguments);
    const me = this, { grid } = me;
    if (grid) {
      if (grid.widgetColumnCache) {
        me.widgetColumnCache = grid.widgetColumnCache;
      } else {
        me.widgetColumnCache = grid.widgetColumnCache = /* @__PURE__ */ new Map();
        grid.ion({
          removeRows: "onRemoveGridRows",
          thisObj: this
        });
      }
    }
  }
  onRemoveGridRows({ rows }) {
    rows.forEach(({ columnWidgets }) => {
      if (columnWidgets) {
        this.freeWidgets([...columnWidgets.values()].flat());
        columnWidgets.clear();
      }
    });
  }
  freeWidgets(widgets) {
    widgets == null ? void 0 : widgets.forEach((widget) => {
      var _a4;
      const { widgetColumnCache } = this, { column } = widget.cellInfo, key = `${column.id}-${widget.widgetColumnIndex}`;
      (_a4 = column.onAfterWidgetDerendered) == null ? void 0 : _a4.call(column, widget);
      widget.cellInfo = widget.__boundRecordId = widget.owner = null;
      widget.element.remove();
      (widgetColumnCache.get(key) || widgetColumnCache.set(key, []).get(key)).push(widget);
    });
    widgets.length = 0;
  }
  freeColumnWidgets() {
    const { id } = this;
    this.grid.rowManager.forEach((row) => {
      var _a4;
      const widgets = (_a4 = row.columnWidgets) == null ? void 0 : _a4.get(id);
      if (widgets == null ? void 0 : widgets.length) {
        this.freeWidgets(widgets);
      }
    });
  }
  hide() {
    this.freeColumnWidgets();
    super.hide(...arguments);
  }
  getWidget(widgetConfig, renderData) {
    var _a4;
    const me = this, {
      grid,
      widgetColumnCache
    } = me, key = `${renderData.column.id}-${widgetConfig.widgetColumnIndex}`, widgets = widgetColumnCache.get(key) || widgetColumnCache.set(key, []).get(key);
    let result, { length } = widgets;
    if (length) {
      result = widgets[--length];
      delete result.onBeforeDestroy;
      widgets.length = length;
      widgetConfig.owner = grid;
      Widget.reconfigure(result, widgetConfig);
    } else {
      me.onBeforeWidgetCreate(widgetConfig, renderData);
      widgetConfig.recomposeAsync = false;
      widgetConfig.owner = grid;
      result = Widget.create(widgetConfig);
      me.onAfterWidgetCreate(result, renderData);
      if (result.name) {
        result.ion({ change: onWidgetChange });
      }
    }
    (_a4 = me.onBeforeWidgetRender) == null ? void 0 : _a4.call(me, result);
    return result;
  }
  doDestroy() {
    if (this.grid.isDestroying) {
      [...this.widgetColumnCache.values()].flat().forEach((widget) => widget.destroy());
      this.widgetColumnCache.clear();
    } else {
      this.freeColumnWidgets();
    }
    super.doDestroy();
  }
  // Called by grid when its read-only state is toggled
  updateReadOnly(readOnly) {
    this.grid.rowManager.forEach((row) => {
      var _a4, _b;
      (_b = (_a4 = row.columnWidgets) == null ? void 0 : _a4.get(this.id)) == null ? void 0 : _b.forEach((widget) => {
        if (!widget.cellInfo.record.readOnly) {
          widget.readOnly = readOnly;
        }
      });
    });
  }
  //endregion
  //region Render
  /**
   * Renderer that displays a widget in the cell.
   * @param {Object} renderData Render data
   * @param {Grid.column.Column} renderData.column Rendered column
   * @param {Core.data.Model} renderData.record Rendered record
   * @private
   */
  defaultRenderer(renderData) {
    const me = this, { grid } = me, {
      cellElement,
      column,
      record,
      row,
      isExport
    } = renderData, { widgets } = column;
    if (!isExport && widgets) {
      const columnWidgets = row.columnWidgets || (row.columnWidgets = /* @__PURE__ */ new Map()), cellWidgets = columnWidgets.get(me.id);
      [...cellElement.childNodes].forEach((e) => {
        var _a4;
        if (!((_a4 = e.classList) == null ? void 0 : _a4.contains("b-widget"))) {
          e.remove();
        }
      });
      renderData.widgets = column.widgets.map((widgetCfg, i) => {
        var _a4, _b;
        widgetCfg.widgetColumnIndex = i;
        const widget = (cellWidgets == null ? void 0 : cellWidgets[i]) || me.getWidget(widgetCfg, renderData);
        widget.cellInfo = renderData;
        if (!widget.element.isConnected) {
          if (widget.rendered) {
            cellElement.appendChild(widget.element);
          } else {
            widget.render(cellElement);
          }
        }
        if (!me.meta.isSelectionColumn) {
          widget.readOnly = grid.readOnly || record.readOnly || me.readOnly;
        }
        if (((_a4 = me.onBeforeWidgetSetValue) == null ? void 0 : _a4.call(me, widget, renderData)) !== false) {
          const valueProperty = widgetCfg.valueProperty || "value" in widget && "value" || widget.defaultBindProperty;
          if (valueProperty && (column.widgets.length === 1 || widget.name)) {
            const value = widget.name ? record.getValue(widget.name) : renderData.value;
            if (typeof value == "object" && widget.__boundRecordId !== record.id) {
              widget[`_${valueProperty}`] = NaN;
            }
            widget.suspendEvents();
            widget[valueProperty] = value;
            widget.resumeEvents();
            widget.__boundRecordId = record.id;
          }
        }
        (_b = me.onAfterWidgetSetValue) == null ? void 0 : _b.call(me, widget, renderData);
        return widget;
      });
      columnWidgets.set(me.id, renderData.widgets);
    }
    if (!widgets) {
      return "";
    }
  }
  //endregion
  //region Other
  /**
   * Called before widget is created on rendering
   * @param {ContainerItemConfig} widgetCfg Widget config
   * @param {Object} renderData Render data
   * @private
   */
  onBeforeWidgetCreate(widgetCfg, renderData) {
  }
  /**
   * Called after widget is created on rendering
   * @param {Core.widget.Widget} widget Created widget
   * @param {Object} renderData Render data
   * @private
   */
  onAfterWidgetCreate(widget, renderData) {
  }
  /**
   * Called before the widget gets its value on rendering. Pass `false` to skip value setting while rendering
   * @preventable
   * @function onBeforeWidgetSetValue
   * @param {Core.widget.Widget} widget Created widget
   * @param {Object} renderData Render data
   * @param {Grid.column.Column} renderData.column Rendered column
   * @param {Core.data.Model} renderData.record Rendered record
   */
  /**
   * Called after the widget gets its value on rendering.
   * @function onAfterWidgetSetValue
   * @param {Core.widget.Widget} widget Created widget
   * @param {Object} renderData Render data
   * @param {Grid.column.Column} renderData.column Rendered column
   * @param {Core.data.Model} renderData.record Rendered record
   */
  // Null implementation because there is no way of ascertaining whether the widgets get their width from
  // the column, or the column shrinkwraps the Widget.
  // Remember that the widget could have a width from a CSS rule which we cannot read.
  // It might have width: 100%, or a flex which would mean it is sized by us, but we cannot read that -
  // getComputedStyle would return the numeric width.
  resizeToFitContent() {
  }
  //endregion
};
//region Config
__publicField(WidgetColumn, "$name", "WidgetColumn");
__publicField(WidgetColumn, "type", "widget");
__publicField(WidgetColumn, "fields", [
  /**
   * An array of {@link Core.widget.Widget} config objects
   * @config {ContainerItemConfig[]} widgets
   * @category Common
   */
  "widgets"
]);
ColumnStore.registerColumnType(WidgetColumn);
WidgetColumn.exposeProperties();
WidgetColumn._$name = "WidgetColumn";

// lib/Grid/column/CheckColumn.js
var CheckColumn = class extends WidgetColumn {
  construct(config, store) {
    var _a4;
    super.construct(...arguments);
    const me = this;
    me.widgets[0].cls = me.checkCls;
    Object.assign(me, {
      externalHeaderRenderer: me.headerRenderer,
      externalOnBeforeWidgetSetValue: me.onBeforeWidgetSetValue,
      externalOnAfterWidgetSetValue: me.onAfterWidgetSetValue
    });
    me.setData({
      onBeforeWidgetSetValue: me.internalOnBeforeWidgetSetValue,
      onAfterWidgetSetValue: me.internalOnAfterWidgetSetValue,
      headerRenderer: me.internalHeaderRenderer
    });
    if (!me.meta.isSelectionColumn) {
      const modelClass = (_a4 = me.grid) == null ? void 0 : _a4.store.modelClass;
      if (!me.field) {
        console.warn("CheckColumn MUST be configured with a field, otherwise the checked state will not be persistent. Widgets are recycled and reused");
      } else if (modelClass && !modelClass.fieldMap[me.field] && !me.constructor.suppressNoModelFieldWarning) {
        console.warn(me.$$name + " is configured with a field, but this is not part of your Model `fields` collection.");
        modelClass.addField({ name: me.field, type: "boolean" });
      }
    }
  }
  doDestroy() {
    var _a4;
    (_a4 = this.headerCheckbox) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  internalHeaderRenderer({ headerElement, column }) {
    let returnValue;
    headerElement.classList.add("b-check-header");
    if (column.showCheckAll) {
      headerElement.classList.add("b-check-header-with-checkbox");
      if (column.headerCheckbox) {
        headerElement.appendChild(column.headerCheckbox.element);
      } else {
        column.headerCheckbox = new Checkbox({
          appendTo: headerElement,
          owner: this.grid,
          ariaLabel: "L{Checkbox.toggleSelection}",
          internalListeners: {
            change: "onCheckAllChange",
            thisObj: column
          }
        });
      }
    } else {
      returnValue = column.headerText;
    }
    returnValue = column.externalHeaderRenderer ? column.externalHeaderRenderer.call(this, ...arguments) : returnValue;
    return column.showCheckAll ? void 0 : returnValue;
  }
  updateCheckAllState(value) {
    if (this.headerCheckbox) {
      this.headerCheckbox.suspendEvents();
      this.headerCheckbox.checked = value;
      this.headerCheckbox.resumeEvents();
    }
  }
  onCheckAllChange({ checked }) {
    const me = this;
    if (me.field) {
      const { store } = me.grid;
      store.beginBatch();
      store.forEach((record) => me.updateRecord(record, me.field, checked));
      store.endBatch();
    }
    me.trigger("toggleAll", { checked });
  }
  //endregion
  defaultRenderer(renderData) {
    var _a4;
    const {
      value,
      isExport,
      record
    } = renderData, result = super.defaultRenderer(renderData), checkbox = (_a4 = renderData.widgets) == null ? void 0 : _a4[0];
    if (isExport) {
      return result != null ? result : value == null ? "" : value;
    }
    checkbox.readOnly = this.readOnly || record.readOnly && !this.meta.isSelectionColumn;
    if (value) {
      checkbox.input.setAttribute("checked", true);
    } else {
      checkbox.input.removeAttribute("checked");
    }
    return result;
  }
  //region Widget rendering
  onBeforeWidgetRender(widget, event) {
    widget.ion({
      beforeChange: "onBeforeCheckboxChange",
      change: "onCheckboxChange",
      thisObj: this
    });
  }
  onAfterWidgetDerendered(widget, event) {
    widget.un({
      beforeChange: "onBeforeCheckboxChange",
      change: "onCheckboxChange",
      thisObj: this
    });
  }
  internalOnBeforeWidgetSetValue(widget, { cellElement }) {
    var _a4;
    cellElement.widget = widget;
    widget.record = widget.cellInfo.record;
    (_a4 = this.externalOnBeforeWidgetSetValue) == null ? void 0 : _a4.call(this, ...arguments);
  }
  internalOnAfterWidgetSetValue(widget) {
    var _a4;
    (_a4 = this.externalOnAfterWidgetSetValue) == null ? void 0 : _a4.call(this, ...arguments);
  }
  //endregion
  //region Events
  onBeforeCheckboxChange({ source, checked, userAction }) {
    const me = this, { grid } = me, { record } = source.cellInfo;
    if (userAction && me.field && (!grid.features.cellEdit || grid.features.cellEdit.disabled) || me.meta.isSelectionColumn && !grid.isSelectable(record) && checked) {
      return false;
    }
    return me.trigger("beforeToggle", { record, checked });
  }
  onCheckboxChange({ source, checked }) {
    const me = this, { record } = source.cellInfo, { field } = me;
    if (field) {
      me.updateRecord(record, field, checked);
      if (checked) {
        me.updateCheckAllState(me.grid.store.every((r) => r[field], null, true));
      } else {
        me.updateCheckAllState(false);
      }
    }
    me.trigger("toggle", { record, checked, checkbox: source });
  }
  updateRecord(record, field, checked) {
    record.setValue(field, checked);
  }
  //endregion
  onCellKeyDown({ event, cellElement, record }) {
    if (event.key === " ") {
      const { target } = event, checkbox = cellElement.widget;
      if (target.matches(".b-grid-cell") && !((record == null ? void 0 : record.readOnly) || checkbox.disabled || checkbox.readOnly)) {
        checkbox == null ? void 0 : checkbox.toggle();
        event.preventDefault();
        event.handled = true;
      }
    }
  }
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs (fields) for the column, with special handling for the hooks
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    delete result.onBeforeWidgetSetValue;
    delete result.onAfterWidgetSetValue;
    if (this.externalOnBeforeWidgetSetValue) {
      result.onBeforeWidgetSetValue = this.externalOnBeforeWidgetSetValue;
    }
    if (this.externalOnAfterWidgetSetValue) {
      result.onAfterWidgetSetValue = this.externalOnAfterWidgetSetValue;
    }
    return result;
  }
};
//region Config
__publicField(CheckColumn, "$name", "CheckColumn");
__publicField(CheckColumn, "type", "check");
__publicField(CheckColumn, "fields", [
  "checkCls",
  "showCheckAll",
  "onAfterWidgetSetValue",
  "onBeforeWidgetSetValue",
  "callOnFunctions",
  "onBeforeToggle",
  "onToggle",
  "onToggleAll"
]);
__publicField(CheckColumn, "defaults", {
  align: "center",
  /**
   * CSS class name to add to checkbox
   * @config {String}
   * @category Rendering
   */
  checkCls: null,
  /**
   * True to show a checkbox in the column header to be able to select/deselect all rows
   * @config {Boolean}
   */
  showCheckAll: false,
  sortable: true,
  filterable: true,
  widgets: [{
    type: "checkbox",
    valueProperty: "checked"
  }]
});
ColumnStore.registerColumnType(CheckColumn, true);
CheckColumn._$name = "CheckColumn";

// lib/Grid/column/ColorColumn.js
var ColorColumn = class extends Column {
  construct() {
    var _a4;
    super.construct(...arguments);
    const me = this, { grid } = me;
    me.menu = new Menu({
      owner: grid,
      rootElement: grid.rootElement,
      autoShow: false,
      align: "t50-b50",
      anchor: true,
      internalListeners: {
        hide() {
          me.picker.navigator.activeItem = null;
          delete me._editingRecord;
        }
      },
      items: [
        Object.assign({
          type: me.colorEditorType,
          ref: "list",
          addNoColorItem: me.addNoColorItem,
          colorSelected({ color }) {
            var _a5;
            (_a5 = me._editingRecord) == null ? void 0 : _a5.set(me.field, color);
            me.menu.hide();
          }
        }, ((_a4 = me.colors) == null ? void 0 : _a4.length) ? { colors: me.colors } : {})
      ]
    });
  }
  applyValue(useProp, field, value) {
    if (!this.isConstructing) {
      const { picker } = this;
      if (field === "colors") {
        picker.colors = value;
      } else if (field === "addNoColorItem") {
        picker.addNoColorItem = value;
      }
    }
    super.applyValue(...arguments);
  }
  get picker() {
    return this.menu.widgetMap.list;
  }
  renderer({ value }) {
    let colorClass = "b-empty", backgroundColor = value;
    if (value) {
      const colorClassName = this.picker.getColorClassName(value);
      if (colorClassName) {
        colorClass = colorClassName;
        backgroundColor = null;
      } else {
        colorClass = "";
      }
    }
    return {
      className: "b-color-cell-inner " + colorClass,
      style: {
        backgroundColor
      },
      "data-btip": value
    };
  }
  onCellClick({ grid, record, target }) {
    if (target.classList.contains("b-color-cell-inner") && !this.readOnly && !grid.readOnly && !record.isSpecialRow && !record.readOnly) {
      const { picker, menu } = this, value = record.get(this.field);
      this._editingRecord = record;
      picker.deselectAll();
      picker.select(value);
      picker.refresh();
      menu.showBy(target);
    }
  }
};
__publicField(ColorColumn, "$name", "ColorColumn");
__publicField(ColorColumn, "type", "color");
__publicField(ColorColumn, "fields", [
  { name: "colorEditorType", defaultValue: "colorpicker" },
  /**
   * Array of CSS color strings to be able to chose from. This will override the
   * {@link Core.widget.ColorPicker#config-colors pickers default colors}.
   *
   * Provide an array of string CSS colors:
   * ```javascript
   * new Grid({
   *    columns : [
   *       {
   *          type   : 'color',
   *          field  : 'color',
   *          text   : 'Color',
   *          colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']
   *       }
   *    ]
   * });
   * ```
   * @prp {String[]}
   */
  "colors",
  /**
   * Adds an option in the picker to set no background color
   * @prp {Boolean}
   * @default true
   */
  { name: "addNoColorItem", defaultValue: true }
]);
__publicField(ColorColumn, "defaults", {
  align: "center",
  editor: null
});
ColumnStore.registerColumnType(ColorColumn);
ColorColumn._$name = "ColorColumn";

// lib/Grid/column/DateColumn.js
var DateColumn = class extends Column {
  static get defaults() {
    return {
      /**
       * Min value for the cell editor
       * @config {String|Date} min
       */
      /**
       * Max value for the cell editor
       * @config {String|Date} max
       */
      /**
       * The {@link Core.data.field.DateDataField#config-name} of the data model date field to read data from.
       * @config {String} field
       * @category Common
       */
      /**
       * Date format to convert a given date object into a string to display. By default `L` format is used, which
       * contains the following info: full year, 2-digit month, and 2-digit day. Depending on the browser locale,
       * the formatted date might look different. [Intl.DateTimeFormat API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat)
       * is used to format the date. Here is an example of possible outputs depending on the browser locale:
       *
       * ```javascript
       * // These options represent `L` format
       * const options = { year : 'numeric', month : '2-digit', day : '2-digit' };
       *
       * new Intl.DateTimeFormat('en-US', options).format(new Date(2021, 6, 1)); // "07/01/2021"
       * new Intl.DateTimeFormat('ru-RU', options).format(new Date(2021, 6, 1)); // "01.07.2021"
       *
       * // Formatting using Bryntum API
       * LocaleManager.applyLocale('En');
       * DateHelper.format(new Date(2021, 6, 1), 'L'); // "07/01/2021"
       * LocaleManager.applyLocale('Ru');
       * DateHelper.format(new Date(2021, 6, 1), 'L'); // "01.07.2021"
       * ```
       *
       * To learn more about available formats check out {@link Core.helper.DateHelper} docs.
       *
       * Note, the {@link Core.data.field.DateDataField field} this column reads data from should be a type of date.
       * @config {String}
       * @default
       * @category Common
       */
      format: "L",
      /**
       * Time increment duration value to apply when clicking the left / right trigger icons. See
       * {@link Core.widget.DateField#config-step} for more information
       * Set to `null` to hide the step triggers.
       * @config {String|Number|DurationConfig}
       * @default
       * @category Common
       */
      step: 1,
      minWidth: 85,
      filterType: "date"
    };
  }
  //endregion
  //region Display
  /**
   * Renderer that displays the date with the specified format. Also adds cls 'date-cell' to the cell.
   * @private
   */
  defaultRenderer({ value }) {
    return value ? this.formatValue(value) : "";
  }
  /**
   * Group renderer that displays the date with the specified format.
   * @private
   */
  groupRenderer({ cellElement, groupRowFor }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }
  //endregion
  //region Formatter
  /**
   * Used by both renderer and groupRenderer to do the actual formatting of the date
   * @private
   * @param value
   * @returns {String}
   */
  formatValue(value) {
    if (typeof value === "string") {
      value = DateHelper.parse(value, this.format || void 0);
    }
    return DateHelper.format(value, this.format || void 0);
  }
  //endregion
  //region Getters/setters
  /**
   * Get/Set format for date displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)
   * @property {String}
   */
  set format(value) {
    const { editor } = this.data;
    this.set("format", value);
    if (editor) {
      editor.format = value;
    }
  }
  get format() {
    return this.get("format");
  }
  get defaultEditor() {
    const me = this, { min: min2, max, step, format } = me;
    return {
      name: me.field,
      type: "date",
      calendarContainerCls: "b-grid-cell-editor-related",
      weekStartDay: me.grid.weekStartDay,
      format,
      max,
      min: min2,
      step
    };
  }
  //endregion
};
//region Config
__publicField(DateColumn, "$name", "DateColumn");
__publicField(DateColumn, "type", "date");
// Type to use when auto adding field
__publicField(DateColumn, "fieldType", "date");
__publicField(DateColumn, "fields", ["format", "pickerFormat", "step", "min", "max"]);
ColumnStore.registerColumnType(DateColumn, true);
DateColumn.exposeProperties();
DateColumn._$name = "DateColumn";

// lib/Grid/column/PercentColumn.js
var PercentColumn = class extends NumberColumn {
  static get defaults() {
    return {
      min: 0,
      max: 100,
      /**
       * Set to `true` to render the number value inside the bar, for example `'15%'`.
       * @config {Boolean}
       * @default
       * @category Rendering
       */
      showValue: false,
      /**
       * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.
       * @config {Number}
       * @default
       * @category Rendering
       */
      lowThreshold: 20,
      htmlEncode: false,
      searchable: false,
      summaryRenderer: ({ sum }) => `${sum}%`,
      fitMode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = "b-percent-bar-cell";
  }
  /**
   * Renderer that displays a progress bar in the cell. If you create a custom renderer, and want to include the
   * default markup you can call `defaultRenderer` from it.
   *
   * ```javascript
   * new Grid({
   *     columns: [
   *         {
   *             type: 'percent',
   *             text : 'Percent',
   *             field : 'percent',
   *             renderer({ value }) {
   *                 const domConfig = this.defaultRenderer();
   *
   *                 if (value > 100) {
   *                     domConfig.className = b-percent-bar-outer over-allocated';
   *                 }
   *
   *                 return domConfig;
   *             }
   *         }
   *     ]
   * }
   * ```
   *
   * @param {Object} rendererData The data object passed to the renderer
   * @param {Number} rendererData.value The value to display
   * @returns {DomConfig} DomConfig object representing the default markup for the cells content
   */
  defaultRenderer({ value }) {
    value = value || 0;
    return {
      className: "b-percent-bar-outer",
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": value,
      "aria-label": value + "%",
      tabIndex: 0,
      children: [
        {
          tag: "div",
          className: {
            "b-percent-bar": 1,
            "b-zero": value === 0,
            "b-low": value < this.lowThreshold
          },
          style: {
            width: value + "%"
          },
          children: [
            this.showValue ? {
              tag: "span",
              text: value + "%"
            } : void 0
          ]
        }
      ]
    };
  }
  // Null implementation because the column width drives the width of its content.
  // So the concept of sizing to content is invalid here.
  resizeToFitContent() {
  }
};
__publicField(PercentColumn, "type", "percent");
// Type to use when auto adding field
__publicField(PercentColumn, "fieldType", "number");
__publicField(PercentColumn, "fields", ["showValue", "lowThreshold"]);
PercentColumn.sum = "average";
ColumnStore.registerColumnType(PercentColumn, true);
PercentColumn._$name = "PercentColumn";

// lib/Grid/column/RatingColumn.js
var RatingColumn = class extends NumberColumn {
  static get defaults() {
    return {
      min: 0,
      max: 5,
      /**
       * The empty rating icon to show
       * @config {String}
       * @category Rendering
       */
      emptyIcon: "b-icon b-icon-star",
      /**
       * The filled rating icon to show
       * @config {String}
       * @category Rendering
       */
      filledIcon: "b-icon b-icon-star",
      /**
       * Allow user to click an icon to change the value
       * @config {Boolean}
       * @category Interaction
       */
      editable: true,
      filterType: "number",
      searchable: false,
      width: "11.2em",
      htmlEncode: false,
      minWidth: "11.2em",
      editor: false,
      fitMode: "value"
    };
  }
  /**
   * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.
   * @private
   */
  renderer({ value }) {
    return {
      className: {
        "b-rating-cell-inner": 1,
        "b-not-editable": !this.editable
      },
      children: ArrayHelper.populate(this.max, (i) => {
        const filled = i < value;
        return {
          tag: "i",
          className: {
            "b-rating-icon": true,
            "b-filled": filled,
            "b-empty": !filled,
            [filled ? this.filledIcon : this.emptyIcon]: true
          }
        };
      })
    };
  }
  onCellClick({ grid, column, record, target, event }) {
    if (target.classList.contains("b-rating-icon") && !grid.readOnly && column.editable) {
      let starIndex = [].indexOf.call(target.parentNode.childNodes, target);
      if (target.classList.contains("b-filled") && (event.metaKey || event.shiftKey)) {
        starIndex = starIndex - 1;
      }
      if (record.getValue(column.field) === 1 && starIndex === 0) {
        starIndex = -1;
      }
      record.set(column.field, starIndex + 1);
    }
  }
};
__publicField(RatingColumn, "$name", "RatingColumn");
__publicField(RatingColumn, "type", "rating");
// Type to use when auto adding field
__publicField(RatingColumn, "fieldType", "number");
__publicField(RatingColumn, "fields", ["emptyIcon", "filledIcon", "editable"]);
ColumnStore.registerColumnType(RatingColumn, true);
RatingColumn.exposeProperties();
RatingColumn._$name = "RatingColumn";

// lib/Grid/column/RowNumberColumn.js
var RowNumberColumn = class extends Column {
  static get defaults() {
    return {
      /**
       * @hideconfigs groupable, sortable, filterable, searchable, resizable, draggable, cellEditor,
       * editTargetSelector, editor, field, finalizeCellEdit, instantUpdate, invalidAction, mergeCells,
       * mergeable, revertOnEscape
       */
      groupable: false,
      sortable: false,
      filterable: false,
      searchable: false,
      resizable: false,
      draggable: false,
      mergeable: false,
      minWidth: 50,
      width: 50,
      align: "right",
      text: "#",
      editor: false,
      readOnly: true
    };
  }
  construct(config) {
    super.construct(...arguments);
    const me = this, { grid } = me;
    me.internalCellCls = "b-row-number-cell";
    me.externalHeaderRenderer = me.headerRenderer;
    me.setData("headerRenderer", me.internalHeaderRenderer);
    if (grid) {
      grid.ion({
        bindStore: "bindStore",
        thisObj: me
      });
      me.bindStore({ store: grid.store, initial: true });
      if (grid.store.count && !grid.rendered) {
        grid.ion({
          paint: "resizeToFitContent",
          thisObj: me,
          once: true
        });
      }
    }
  }
  get groupHeaderReserved() {
    return true;
  }
  bindStore({ store, initial }) {
    const me = this;
    me.detachListeners("grid");
    store.ion({
      name: "grid",
      [`change${me.grid.asyncEventSuffix}`]: "onStoreChange",
      thisObj: me
    });
    if (!initial && !me.resizeToFitContent()) {
      me.measureOnRender();
    }
  }
  onStoreChange({ action, isMove }) {
    if (action === "dataset" || action === "add" || action === "remove" || action === "removeall") {
      if (action === "remove" && isMove) {
        return;
      }
      const result = this.resizeToFitContent();
      if (action === "dataset" && !result && this.grid.store.count) {
        this.measureOnRender();
      }
    }
  }
  measureOnRender() {
    this.grid.rowManager.ion({
      renderDone() {
        this.resizeToFitContent();
      },
      once: true,
      thisObj: this
    });
  }
  /**
   * Renderer that displays the row number in the cell.
   * @private
   */
  renderer({ record, grid }) {
    return record.isSpecialRow ? "" : grid.store.indexOf(record, true) + 1;
  }
  /**
   * Resizes the column to match the widest string in it. Called when you double click the edge between column
   * headers
   */
  resizeToFitContent() {
    const me = this, { store, element } = me.grid, { count } = store;
    if (count && !me.hidden) {
      const cellElement = element.querySelector(`.b-grid-cell[data-column-id="${me.id}"]`);
      if (cellElement) {
        const cellPadding = cellElement.isConnected ? parseInt(DomHelper.getStyleValue(cellElement, "padding-left")) : me._cachedCellPadding || 0, maxWidth = DomHelper.measureText(count, cellElement);
        me.width = Math.max(me.minWidth, maxWidth + 2 * cellPadding);
        me._cachedCellPadding = cellPadding;
        return true;
      }
    }
    return false;
  }
  set flex(f) {
  }
  internalHeaderRenderer({ headerElement, column }) {
    var _a4;
    headerElement.classList.add("b-rownumber-header");
    return ((_a4 = column.externalHeaderRenderer) == null ? void 0 : _a4.call(this, ...arguments)) || column.headerText;
  }
};
__publicField(RowNumberColumn, "$name", "RowNumberColumn");
__publicField(RowNumberColumn, "type", "rownumber");
ColumnStore.registerColumnType(RowNumberColumn, true);
RowNumberColumn._$name = "RowNumberColumn";

// lib/Grid/column/TemplateColumn.js
var TemplateColumn = class extends Column {
  static get defaults() {
    return {
      htmlEncode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    const me = this;
    if (!me.template) {
      throw new Error("TemplateColumn needs a template");
    }
    if (typeof me.template !== "function") {
      throw new Error("TemplateColumn.template must be a function");
    }
  }
  /**
   * Renderer that uses a template for cell content.
   * @private
   */
  renderer(renderData) {
    if (!renderData.record.isSpecialRow) {
      return this.template({
        value: renderData.value,
        record: renderData.record,
        field: this.field
      });
    }
  }
};
__publicField(TemplateColumn, "type", "template");
__publicField(TemplateColumn, "fields", [
  /**
   * Template function used to generate a value displayed in the cell. Called with arguments `{ value, record, field }`
   *
   * @config {Function} template
   * @param {Object} data An object that contains data about the cell being rendered.
   * @param {*} data.value The value (only present when you set a `field` on the column)
   * @param {Core.data.Model} data.record The record representing the row
   * @param {String} data.field The column field name
   * @returns {DomConfig|String|null} String or DomConfig object representing the HTML markup
   * @category Common
   */
  "template"
]);
ColumnStore.registerColumnType(TemplateColumn, true);
TemplateColumn.exposeProperties();
TemplateColumn._$name = "TemplateColumn";

// lib/Grid/column/TimeColumn.js
var TimeColumn = class extends Column {
  static get defaults() {
    return {
      /**
       * Time format
       * @config {String}
       * @category Common
       * @default
       */
      format: "LT",
      minWidth: 140,
      filterType: "time"
    };
  }
  //endregion
  //region Display
  /**
   * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.
   * @private
   */
  defaultRenderer({ value }) {
    return value ? this.formatValue(value) : "";
  }
  /**
   * Group renderer that displays the time with the specified format.
   * @private
   */
  groupRenderer({ cellElement, groupRowFor }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }
  //endregion
  //region Formatter
  /**
   * Used by both renderer and groupRenderer to do the actual formatting of the time
   * @private
   * @param value
   * @returns {String}
   */
  formatValue(value) {
    if (typeof value === "string") {
      value = DateHelper.parse(value, this.format);
    }
    return DateHelper.format(value, this.format);
  }
  //endregion
  //region Getters/Setters
  /**
   * Get/Set format for time displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)
   * @property {String}
   */
  set format(value) {
    const { editor } = this;
    this.set("format", value);
    if (editor) {
      editor.format = value;
    }
  }
  get format() {
    return this.get("format");
  }
  get defaultEditor() {
    return {
      name: this.field,
      type: "time",
      format: this.format
    };
  }
  //endregion
};
//region Config
__publicField(TimeColumn, "type", "time");
// Type to use when auto adding field
__publicField(TimeColumn, "fieldType", "date");
__publicField(TimeColumn, "fields", ["format"]);
ColumnStore.registerColumnType(TimeColumn, true);
TimeColumn.exposeProperties();
TimeColumn._$name = "TimeColumn";

// lib/Grid/column/TreeColumn.js
var TreeColumn = class extends Column {
  static get defaults() {
    return {
      tree: true,
      hideable: false,
      minWidth: 150
    };
  }
  static get fields() {
    return [
      /**
       * The icon to use for the collapse icon in collapsed state
       * @config {String|null} expandIconCls
       */
      { name: "expandIconCls", defaultValue: "b-icon b-icon-tree-expand" },
      /**
       * The icon to use for the collapse icon in expanded state
       * @config {String|null} collapseIconCls
       */
      { name: "collapseIconCls", defaultValue: "b-icon b-icon-tree-collapse" },
      /**
       * The icon to use for the collapse icon in expanded state
       * @config {String|null} collapsedFolderIconCls
       */
      { name: "collapsedFolderIconCls" },
      /**
       * The icon to use for the collapse icon in expanded state
       * @config {String|null} expandedFolderIconCls
       */
      { name: "expandedFolderIconCls" },
      /**
       * Size of the child indent in em. Resulting indent is indentSize multiplied by child level.
       * @config {Number} indentSize
       * @default 1.7
       */
      { name: "indentSize", defaultValue: 1.7 },
      /**
       * The icon to use for the leaf nodes in the tree
       * @config {String|null} leafIconCls
       */
      { name: "leafIconCls", defaultValue: "b-icon b-icon-tree-leaf" },
      { name: "editTargetSelector", defaultValue: ".b-tree-cell-value" },
      /**
       * Renderer function, used to format and style the content displayed in the cell. Return the cell text you
       * want to display. Can also affect other aspects of the cell, such as styling.
       *
       * <div class="note">
       * As the TreeColumn adds its own cell content to the column, there is a limit to what is supported in the
       * renderer function in comparison with an ordinary
       * {@link Grid.column.Column#config-renderer Column renderer}. Most notably is that changing `cellElement`
       * content can yield unexpected results as it will be updated later in the rendering process.
       * </div>
       *
       * You can also return a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup
       * ```javascript
       * new Grid({
       *     columns : [
       *         {
       *              type  : 'tree',
       *              field : 'name'
       *              text  : 'Name',
       *              renderer : ({ record }) => {
       *                  return {
       *                      class : 'myClass',
       *                      children : [
       *                          {
       *                              tag : 'i',
       *                              class : 'fa fa-pen'
       *                          },
       *                          {
       *                              tag : 'span',
       *                              text : record.name
       *                          }
       *                      ]
       *                  };
       *              }
       *         }
       *     ]
       * });
       * ```
       *
       * You can modify the row element too from inside a renderer to add custom CSS classes:
       *
       * ```javascript
       * new Grid({
       *     columns : [
       *         {
       *             type     : 'tree',
       *             field    : 'name',
       *             text     : 'Name',
       *             renderer : ({ record, row }) => {
       *                // Add special CSS class to new rows that have not yet been saved
       *               row.cls.newRow = record.isPhantom;
       *
       *               return record.name;
       *         }
       *     ]
       * });
       * ```
       *
       * @config {Function} renderer
       * @param {Object} renderData Object containing renderer parameters
       * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc. Can be `null` in case of export
       * @param {*} renderData.value Value to be displayed in the cell
       * @param {Core.data.Model} renderData.record Record for the row
       * @param {Grid.column.Column} renderData.column This column
       * @param {Grid.view.Grid} renderData.grid This grid
       * @param {Grid.row.Row} renderData.row Row object. Can be null in case of export. Use the
       *   {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.
       * @param {Object} renderData.size Set `size.height` to specify the desired row height for the current row.
       *   Largest specified height is used, falling back to configured {@link Grid/view/Grid#config-rowHeight}
       *   in case none is specified. Can be null in case of export
       * @param {Number} renderData.size.height Set this to request a certain row height
       * @param {Number} renderData.size.configuredHeight Row height that will be used if none is requested
       * @param {Boolean} renderData.isExport True if record is being exported to allow special handling during export.
       * @param {Boolean} renderData.isMeasuring True if the column is being measured for a `resizeToFitContent` call.
       *   In which case an advanced renderer might need to take different actions.
       * @returns {String|DomConfig|null}
       *
       * @category Rendering
       */
      "renderer"
    ];
  }
  constructor(config, store) {
    super(...arguments);
    const me = this;
    me.shouldHtmlEncode = me.htmlEncode;
    me.setData("htmlEncode", false);
    if (me.renderer) {
      me.originalRenderer = me.renderer;
    }
    me.renderer = me.treeRenderer.bind(me);
  }
  /**
   * A column renderer that is automatically added to the column with { tree: true }. It adds padding and node icons
   * to the cell to make the grid appear to be a tree. The original renderer is called in the process.
   * @private
   */
  treeRenderer(renderData) {
    var _a4, _b, _c, _d, _e, _f, _g;
    const me = this, {
      grid,
      cellElement,
      row,
      record,
      isExport
    } = renderData, gridMeta = record.instanceMeta(grid.store), isCollapsed = !record.isLeaf && gridMeta.collapsed, innerConfig = {
      className: "b-tree-cell-value"
    }, children = [innerConfig], result = {
      className: {
        "b-tree-cell-inner": 1
      },
      tag: record.href ? "a" : "div",
      href: record.href,
      target: record.target,
      children
    };
    let outputIsObject, iconCls, { value } = renderData, renderingColumn = me;
    const parentRenderer = grid.isTreeGrouped && !record.isLeaf && grid.features.treeGroup.parentRenderer;
    if (me.originalRenderer || parentRenderer) {
      let rendererHtml;
      if (parentRenderer) {
        if (record.field) {
          renderingColumn = grid.columns.get(record.field);
          if (renderingColumn) {
            value = renderingColumn.isWidgetColumn ? value : (_b = (_a4 = renderingColumn.activeRenderer) == null ? void 0 : _a4.call(renderingColumn, {
              ...renderData,
              column: renderingColumn,
              value: record.name,
              isTreeGroup: true
            })) != null ? _b : record.name;
          } else {
            value = record.name;
          }
        }
        rendererHtml = grid.features.treeGroup.parentRenderer({
          field: record.field,
          value,
          column: renderingColumn,
          record: record.firstGroupChild,
          grid
        });
      } else {
        rendererHtml = me.originalRenderer(renderData);
      }
      const hasFrameworkRenderer = (_c = grid.hasFrameworkRenderer) == null ? void 0 : _c.call(grid, {
        cellContent: rendererHtml,
        renderingColumn
      });
      outputIsObject = typeof rendererHtml === "object" && !hasFrameworkRenderer;
      value = hasFrameworkRenderer ? "" : rendererHtml === false ? cellElement.innerHTML : rendererHtml;
      renderData.rendererHtml = rendererHtml;
    }
    if (!outputIsObject) {
      value = String(value != null ? value : "");
    }
    if (isExport) {
      return value;
    }
    if (!record.isLeaf) {
      const isCollapsed2 = !record.isExpanded(grid.store), expanderIconCls = isCollapsed2 ? me.expandIconCls : me.collapseIconCls, folderIconCls = isCollapsed2 ? me.collapsedFolderIconCls : me.expandedFolderIconCls;
      cellElement.classList.add("b-tree-parent-cell");
      children.unshift({
        tag: "i",
        className: {
          "b-tree-expander": 1,
          [expanderIconCls]: 1,
          "b-empty-parent": !gridMeta.isLoadingChildren && (record.children !== true && !((_d = record.children) == null ? void 0 : _d.length))
        }
      });
      record.meta.hasIcon = iconCls = renderData.iconCls || record.iconCls || folderIconCls;
    } else {
      cellElement.classList.add("b-tree-leaf-cell");
      iconCls = renderData.iconCls || record.iconCls || me.leafIconCls;
    }
    if (iconCls) {
      children.splice(children.length - 1, 0, {
        tag: "i",
        className: {
          "b-tree-icon": 1,
          [iconCls]: 1
        }
      });
    }
    if (row.isRow && !record.isLeaf) {
      row.setAttribute("aria-expanded", !isCollapsed);
      if (isCollapsed) {
        row.removeAttribute("aria-owns");
      } else {
        for (const region in grid.subGrids) {
          const el = row.elements[region];
          DomHelper.setAttributes(el, {
            "aria-owns": ((_e = record.children) == null ? void 0 : _e.length) ? (_f = record.children) == null ? void 0 : _f.map((r) => `${grid.id}-${region}-${r.id}`).join(" ") : null
          });
        }
      }
    }
    if (Array.isArray(value)) {
      innerConfig.children = value;
    } else if (outputIsObject) {
      Object.assign(innerConfig, value);
    } else if ((renderingColumn == null ? void 0 : renderingColumn.shouldHtmlEncode) || !value.includes("<")) {
      result.className["b-text-value"] = 1;
      innerConfig.text = value;
    } else {
      innerConfig.html = value;
    }
    let padding = record.childLevel * me.indentSize;
    if (record.isLeaf) {
      padding += ((_g = record.parent) == null ? void 0 : _g.meta.hasIcon) ? 2.2 : iconCls ? 0.5 : 0.4;
    } else {
      padding += iconCls ? -0.15 : 0;
    }
    result.style = `padding-inline-start:${padding}em`;
    return result;
  }
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs (fields) for the column, with special handling for the renderer
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    result.renderer = this.originalRenderer;
    return result;
  }
};
__publicField(TreeColumn, "$name", "TreeColumn");
__publicField(TreeColumn, "type", "tree");
ColumnStore.registerColumnType(TreeColumn, true);
TreeColumn.exposeProperties();
TreeColumn._$name = "TreeColumn";

// lib/Grid/data/GridRowModel.js
var GridRowModel = class extends Model {
  static get fields() {
    return [
      /**
       * Icon for row (used automatically in tree, feel free to use it in renderer in other cases)
       * @field {String} iconCls
       * @category Styling
       */
      {
        name: "iconCls",
        internal: true
      },
      /**
       * CSS class (or several classes divided by space) to append to row elements
       * @field {String} cls
       * @category Styling
       */
      {
        name: "cls",
        internal: true
      },
      /**
       * Used by the default implementation of {@link Grid.view.GridBase#config-getRowHeight} to determine row
       * height. Set it to use another height than the default for a the records row.
       * @field {Number} rowHeight
       * @category Styling
       */
      {
        name: "rowHeight",
        internal: true
      },
      /**
       * A link to use for this record when rendered into a {@link Grid.column.TreeColumn}.
       * @field {String} href
       * @category Tree
       */
      {
        name: "href",
        internal: true
      },
      /**
       * The target to use if this tree node provides a value for the {@link #field-href} field.
       * @field {'_self'|'_blank'|'_parent'|'_top'|null} target
       * @category Tree
       */
      {
        name: "target",
        internal: true
      }
    ];
  }
};
GridRowModel.exposeProperties();
GridRowModel._$name = "GridRowModel";

// lib/Grid/feature/base/CopyPasteBase.js
var CopyPasteBase = class extends InstancePlugin.mixin(Clipboardable_default) {
  // Internal backwards compatibility
  get clipboardRecords() {
    return this.clipboardData || [];
  }
  /**
   * Used by CellCopyPaste and RowCopyPaste to generate string representations of grid records
   * @param cells
   * @returns {String}
   * @private
   */
  cellsToString(cells) {
    var _a4;
    const me = this;
    let lastRowIndex = 0, lastColIndex = 0, stringData = "";
    cells.sort((c1, c2) => c1.rowIndex === c2.rowIndex ? c1.columnIndex - c2.columnIndex : c1.rowIndex - c2.rowIndex);
    for (const cell of cells) {
      const { record, _column: column, rowIndex, columnIndex } = cell;
      if (rowIndex > lastRowIndex) {
        if (stringData.length > 0) {
          stringData += "\n".repeat(rowIndex - lastRowIndex);
        }
        lastRowIndex = rowIndex;
        lastColIndex = columnIndex;
      } else if (columnIndex > lastColIndex) {
        if (stringData.length > 0) {
          stringData += "	".repeat(columnIndex - lastColIndex);
        }
        lastColIndex = columnIndex;
      }
      let cellValue = (_a4 = column == null ? void 0 : column.toClipboardString) == null ? void 0 : _a4.call(column, cell);
      if (cellValue === void 0) {
        cellValue = record.getValue(column.field);
        if (cellValue instanceof Date) {
          cellValue = DateHelper.format(cellValue, me.dateFormat);
        } else {
          cellValue = cellValue == null ? void 0 : cellValue.toString();
        }
      }
      if (me.toCopyString) {
        cellValue = me.toCopyString({ currentValue: cellValue, column, record });
      }
      cellValue = cellValue == null ? void 0 : cellValue.replace(/[\n\t]/, " ");
      stringData += cellValue || me.emptyValueChar;
    }
    return stringData;
  }
  /**
   * Sets tab and new-line separated string data into records.
   * Used by CellCopyPaste to set values into existing records.
   * Used by RowCopyPaste to create new records from values
   * @param clipboardData
   * @param createNewRecords If `false`, a selected cell is required and data will be set to existing records
   * @param store The store which to set/create new data to. Defaults to the clients default store.
   * @param fields Provide an array of string fields to create records instead of using columns
   * @returns {Object} modificationData
   * @private
   */
  setFromStringData(clipboardData, createNewRecords = false, store = this.client.store, fields) {
    var _a4;
    const me = this, { client } = me, {
      columns,
      _shiftSelectRange
    } = client, modifiedRecords = /* @__PURE__ */ new Set(), rows = me.stringAs2dArray(clipboardData), selectedCell = client.selectedCells[0], targetCells = [], affectedCells = [];
    if (!createNewRecords && (_shiftSelectRange == null ? void 0 : _shiftSelectRange.some((cell) => cell.equals(selectedCell)))) {
      const cellRows = me.cellSelectorsAs2dArray(_shiftSelectRange);
      if ((cellRows == null ? void 0 : cellRows.length) % rows.length === 0 && cellRows.columnCount % rows.columnCount === 0) {
        for (let curI = 0; curI < cellRows.length; curI += rows.length) {
          for (let curX = 0; curX < cellRows.columnCount; curX += rows.columnCount) {
            targetCells.push(cellRows[curI][curX]);
          }
        }
      }
    }
    if (!targetCells.length) {
      targetCells.push(selectedCell);
    }
    for (const targetCell of targetCells) {
      for (let rI = 0; rI < rows.length; rI++) {
        const row = rows[rI], targetRecord = createNewRecords ? new store.modelClass() : store.getAt(targetCell.rowIndex + rI);
        if (targetRecord && !targetRecord.readOnly) {
          for (let cI = 0; cI < row.length; cI++) {
            const targetColumn = fields ? null : columns.visibleColumns[createNewRecords ? cI : targetCell.columnIndex + cI], targetField = (targetColumn == null ? void 0 : targetColumn.field) || (fields == null ? void 0 : fields[cI]);
            let value = row[cI];
            if (targetField && value && !(targetColumn == null ? void 0 : targetColumn.readOnly)) {
              if (value === me.emptyValueChar) {
                value = null;
              }
              if (targetColumn == null ? void 0 : targetColumn.fromClipboardString) {
                value = targetColumn.fromClipboardString({
                  string: value,
                  record: targetRecord
                });
              }
              if (me.toPasteValue) {
                value = me.toPasteValue({
                  currentValue: value,
                  record: targetRecord,
                  column: targetColumn,
                  field: targetField
                });
              }
              if (typeof value === "string" && ((_a4 = targetRecord.getFieldDefinition(targetField)) == null ? void 0 : _a4.isDateDataField)) {
                const parsedDate = DateHelper.parse(value, me.dateFormat);
                if (!isNaN(parsedDate.getTime())) {
                  value = parsedDate;
                }
              }
              targetRecord.set(targetField, value, false, false, false, true);
              affectedCells.push(client.normalizeCellContext({ column: targetColumn, record: targetRecord }));
            }
          }
          modifiedRecords.add(targetRecord);
        }
      }
    }
    return {
      modifiedRecords: [...modifiedRecords],
      targetCells: affectedCells
    };
  }
  /**
   * Converts an array of Location objects to a two-dimensional array where first level is rows and second level is
   * columns. If the array is inconsistent in the number of columns present for each row, the function will return
   * false.
   * @param {Grid.util.Location[]} locations
   * @private
   */
  cellSelectorsAs2dArray(locations) {
    const rows = [];
    let rId = null, columns;
    for (const location of locations) {
      if (location.id !== rId) {
        rId = location.id;
        columns = [];
        rows.push(columns);
      }
      columns.push(location);
    }
    rows.columnCount = rows[0].length;
    if (rows.some((row) => row.length !== rows.columnCount)) {
      return false;
    }
    return rows;
  }
  /**
   * Converts a new-line- and tab-separated string to a two-dimensional array where first level is rows and second
   * level is columns. If the string is inconsistent in the number of columns present for each row, the function will
   * return false.
   * @param {String} string String values separated with new-line(\n,\r or similar) and tabs (\t)
   * @private
   */
  stringAs2dArray(string2) {
    const rows = [], stringRows = string2.split(/\r\n|(?!\r\n)[\n-\r\x85\u2028\u2029]/).filter((s) => s.length);
    for (const row of stringRows) {
      const columns = row.split("	");
      if (rows.columnCount && columns.length !== rows.columnCount) {
        return false;
      }
      rows.columnCount = columns.length;
      rows.push(columns);
    }
    return rows;
  }
};
__publicField(CopyPasteBase, "configurable", {
  /**
   * If `true` this prevents cutting and pasting. Will default to `true` if {@link Grid/feature/CellEdit} feature
   * is disabled. Set to `false` to prevent this behaviour.
   * @config {Boolean}
   */
  copyOnly: null,
  /**
   * Default keyMap configuration: Ctrl/Cmd+c to copy, Ctrl/Cmd+x to cut and Ctrl/Cmd+v to paste. These keyboard
   * shortcuts require a selection to be made.
   * @config {Object<String,String>}
   */
  keyMap: {
    "Ctrl+C": "copy",
    "Ctrl+X": "cut",
    "Ctrl+V": "paste"
  },
  /**
   * Set this to `false` to not use native Clipboard API even if it is available
   * @config {Boolean}
   * @default
   */
  useNativeClipboard: false,
  /**
   * Provide a function to be able to customize the string value which is copied
   *
   * ````javascript
   * new Grid({
   *     features : {
   *         cellCopyPaste : {
   *             toCopyString({currentValue, column, record}) {
   *                 if(record.isAvatar){
   *                     return record.fullName;
   *                 }
   *                 return currentValue;
   *             }
   *         }
   *     }
   * });
   * ````
   *
   * Note that this function is only called when copying cell values or copying values from other Bryntum
   * component instances or from native clipboard.
   *
   * @config {Function}
   * @param {Object} data
   * @param {String} data.currentValue
   * @param {Grid.column.Column} data.column
   * @param {Core.data.Model} data.record
   * @returns {String}
   */
  toCopyString: null,
  /**
   * Provide a function to be able to customize the value which will be set onto the record
   *
   * ````javascript
   * new Grid({
   *     features : {
   *         cellCopyPaste : {
   *             toPasteValue({currentValue, column, record, field}) {
   *                 if(typeof currentValue === 'string'){
   *                     return currentValue.replace('$', '');
   *                 }
   *                 return currentValue;
   *             }
   *         }
   *     }
   * });
   * ````
   *
   * Note that this function is only called when pasting string values, either from CellCopyPaste or copying
   * values from other Bryntum component instances or from native clipboard.
   *
   * @config {Function}
   * @param {Object} data
   * @param {String} data.currentValue
   * @param {Grid.column.Column} data.column
   * @param {Core.data.Model} data.record
   * @returns {String}
   */
  toPasteValue: null,
  /**
   * If an empty value (null or empty string) is copied or cut, this config will replace that value.
   * This allows for clipboard data to skip columns.
   *
   * For example, look at these two selections
   * |  ROW  |   0  |      1       |       2      |   3  |
   * |-------|------|--------------|--------------|------|
   * | ROW 1 | SEL1 | not selected | not selected | SEL2 |
   * | ROW 2 | SEL3 | SEL4 (empty) | SEL5 (empty) | SEL6 |
   *
   * The clipboardData for `ROW 1` will look like this:
   `* SEL1\t\t\SEl2\nSEL3\t\t\SEL4`
   *
   * And `ROW 2` will look like this:
   * `SEL3\t\u{0020}\t\u{0020}\tSEL6`
   *
   * `ROW 1` will set value `SEL1` at column index 0 and `SEL2` at column index 3. This leaves column index 1 and
   * 2 untouched.
   *
   * `ROW 2` will set value `SEL3` at column index 0, `u{0020}` at column index 1 and 2, and `SEL`6 at column
   * index 3.
   *
   * The default `u{0020}` is a blank space.
   *
   * Note that this only applies when copy-pasting cell values or copying rows from other Bryntum component
   * instances or from native clipboard.
   *
   * @config {String}
   * @default
   */
  emptyValueChar: " ",
  /**
   * The format a copied date value should have when converted to a string. To learn more about available formats,
   * check out {@link Core.helper.DateHelper} docs.
   * @config {String}
   */
  dateFormat: "lll"
});
CopyPasteBase._$name = "CopyPasteBase";

// lib/Grid/feature/GridFeatureManager.js
var consumerToFeatureMap = /* @__PURE__ */ new Map();
var consumerToDefaultFeatureMap = /* @__PURE__ */ new Map();
var DEFAULT_FOR_TYPE = "Grid";
var remapToBase = {
  Grid: "GridBase",
  Scheduler: "SchedulerBase",
  SchedulerPro: "SchedulerProBase",
  Gantt: "GanttBase"
};
var classNameFix = /\$\d+$/;
var GridFeatureManager = class {
  /**
   * Register a feature class with the Grid. Enables it to be created and configured using config Grid#features.
   * @param {Function} featureClass The feature class constructor to register
   * @param {Boolean} [onByDefault] Specify true to have the feature enabled per default
   * @param {String|String[]} [forType] Specify a type to let the class applying the feature to determine if it should
   * use it
   */
  static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {
    as = StringHelper.uncapitalize(as || Object.prototype.hasOwnProperty.call(featureClass, "$name") && featureClass.$$name || featureClass.name);
    as = as.replace(classNameFix, "");
    if (!Array.isArray(forType)) {
      forType = [forType || DEFAULT_FOR_TYPE];
    }
    forType.forEach((forType2) => {
      const type = remapToBase[forType2] || forType2, consumerFeaturesMap = consumerToFeatureMap.get(type) || /* @__PURE__ */ new Map(), consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type) || /* @__PURE__ */ new Map();
      consumerFeaturesMap.set(as, featureClass);
      consumerDefaultFeaturesMap.set(featureClass, onByDefault);
      consumerToFeatureMap.set(type, consumerFeaturesMap);
      consumerToDefaultFeatureMap.set(type, consumerDefaultFeaturesMap);
    });
  }
  /**
   * Get all the features registered for the given type name in an object where keys are feature names and values are
   * feature constructors.
   *
   * @param {String} [forType]
   * @returns {Object}
   */
  static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerFeaturesMap = consumerToFeatureMap.get(type), features = {};
    if (consumerFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => features[as] = featureClass);
    }
    return features;
  }
  /**
   * Get all the default features registered for the given type name in an object where keys are feature names and
   * values are feature constructors.
   *
   * @param {String} [forType]
   * @returns {Object}
   */
  static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerFeaturesMap = consumerToFeatureMap.get(type), consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    const features = {};
    if (consumerFeaturesMap && consumerDefaultFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => {
        if (consumerDefaultFeaturesMap.get(featureClass)) {
          features[as] = featureClass;
        }
      });
    }
    return features;
  }
  /**
   * Gets all the features registered for the given instance type name chain. First builds the type name chain then
   * queries for features for each type name and combines them into one object, see
   * {@link #function-getTypeNameFeatures-static}() for returned object description.
   *
   * If feature is registered for both parent and child type name then feature for child overrides feature for parent.
   *
   * @param {Object} instance
   * @returns {Object}
   */
  static getInstanceFeatures(instance) {
    return instance.$meta.names.reduce(
      (features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)),
      {}
    );
  }
  /**
   * Gets all the *default* features registered for the given instance type name chain. First builds the type name
   * chain then queries for features for each type name and combines them into one object, see
   * {@link #function-getTypeNameFeatures-static}() for returned object description.
   *
   * If feature is registered for both parent and child type name then feature for child overrides feature for parent.
   *
   * @param {Object} instance
   * @returns {Object}
   */
  static getInstanceDefaultFeatures(instance) {
    return instance.$meta.names.reduce(
      (features, typeName) => Object.entries(
        this.getTypeNameFeatures(typeName)
      ).reduce(
        (features2, [as, featureClass]) => {
          if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {
            features2[as] = featureClass;
          } else {
            delete features2[as];
          }
          return features2;
        },
        features
      ),
      {}
    );
  }
  /**
   * Checks if the given feature class is default for the type name
   *
   * @param {Core.mixin.InstancePlugin} featureClass Feature to check
   * @param {String} [forType]
   * @returns {Boolean}
   */
  static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    return consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass) || false;
  }
  /**
   * Checks if the given feature class is default for the given instance type name chain. If the feature is not
   * default for the parent type name but it is for the child type name, then the child setting overrides the parent
   * one.
   *
   * @param {Core.mixin.InstancePlugin} featureClass Feature to check
   * @param {String} [forType]
   * @returns {Boolean}
   */
  static isDefaultFeatureForInstance(featureClass, instance) {
    const typeChain = instance.$meta.names.slice().reverse();
    let result = null;
    for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {
      const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);
      if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {
        result = consumerDefaultFeaturesMap.get(featureClass);
      }
    }
    return result || false;
  }
  /**
   * Resets feature registration date, used in tests to reset state after test
   *
   * @internal
   */
  static reset() {
    consumerToFeatureMap.clear();
    consumerToDefaultFeatureMap.clear();
  }
};

// lib/Grid/feature/CellCopyPaste.js
var actions = {
  cut: 1,
  copy: 1,
  paste: 1
};
var CellCopyPaste = class extends CopyPasteBase {
  constructor() {
    super(...arguments);
    // Used in events to separate events from different features from each other
    __publicField(this, "entityName", "cell");
  }
  afterConstruct() {
    super.afterConstruct();
    this.afterSelectionModeChange();
  }
  afterSelectionModeChange() {
    const me = this;
    if (!me.client.selectionMode.cell) {
      me.disabled = true;
    } else if (me._disabledBySelectionMode) {
      me.disabled = false;
      delete me._disabledBySelectionMode;
    }
  }
  set copyOnly(value) {
    this._copyOnly = value;
  }
  get copyOnly() {
    var _a4;
    if (this._copyOnly == null) {
      return !((_a4 = this.client.features.cellEdit) == null ? void 0 : _a4.enabled);
    }
    return Boolean(this._copyOnly);
  }
  get canCopy() {
    var _a4;
    const { client } = this;
    return Boolean(!this.disabled && client.selectedCells.length && (!client._selectedRows.length || ((_a4 = client.features.rowCopyPaste) == null ? void 0 : _a4.disabled) || client.focusedCell && client.isCellSelected(client.focusedCell)));
  }
  get canCutPaste() {
    var _a4;
    return this.canCopy && !this.copyOnly && !((_a4 = this.client.features.cellEdit) == null ? void 0 : _a4.isEditing) && !this.client.readOnly;
  }
  // Called from keyMap. Also used internally here
  isActionAvailable({ actionName }) {
    if (actions[actionName]) {
      return globalThis.getSelection().toString().length === 0 && this.canCopy && (actionName === "copy" || this.canCutPaste);
    }
  }
  /**
   * Cuts selected cells to clipboard (native if accessible) to paste later
   * @async
   */
  async cut() {
    await this.copy(true);
  }
  /**
   * Copies selected cells to clipboard (native if accessible) to paste later
   * @async
   */
  async copy(isCut = false) {
    if (typeof isCut != "boolean") {
      isCut = false;
    }
    const me = this, { selectedCells } = me.client, cells = isCut ? selectedCells.filter((r) => {
      var _a4;
      return !((_a4 = r.record) == null ? void 0 : _a4.readOnly);
    }) : selectedCells;
    if (cells) {
      if (isCut ? !me.canCutPaste : !me.canCopy) {
        return;
      }
      const copiedDataString = me.cellsToString(cells);
      await me.writeToClipboard(copiedDataString, isCut, { cells });
      if (isCut === true) {
        for (const cell of cells) {
          const { column, record } = cell;
          if (!column.readOnly) {
            let string2 = null;
            if (column.fromClipboardString) {
              string2 = column.fromClipboardString({ string: string2, record });
            }
            cell.record.set(cell.column.field, string2);
          }
        }
      }
      me.client.trigger("copy", { cells, copiedDataString, isCut, entityName: me.entityName });
    }
  }
  // Called from Clipboardable before writing to the clipboard
  async beforeCopy({ data, isCut, cells }) {
    return await this.client.trigger("beforeCopy", { cells, data, isCut, entityName: this.entityName });
  }
  /**
   * Pastes string data into a cell or a range of cells. Either from native clipboard if that is accessible or from a
   * fallback clipboard that is only available to the owner Grid.
   *
   * The string data will be split on `\n` and `\t` and put in different rows and columns accordingly.
   *
   * Note that there must be a selected cell to paste the data into.
   * @async
   */
  async paste() {
    const me = this, { client, entityName } = me, targetCell = client.selectedCells[0];
    if (!me.canCutPaste || !targetCell) {
      return;
    }
    const clipboardData = await me.readFromClipboard({}, true);
    if (!clipboardData) {
      return;
    }
    const { modifiedRecords, targetCells } = me.setFromStringData(clipboardData);
    if (client.selectedCells.length === 1 && targetCells.length > 1) {
      client.selectCellRange(targetCells[0], targetCells[targetCells.length - 1]);
    }
    client.trigger("paste", { clipboardData, targetCell, modifiedRecords: [...modifiedRecords], entityName });
  }
  // Called from Clipboardable before finishing the clipboard read
  async beforePaste({ data }) {
    return await this.client.trigger("beforePaste", {
      clipboardData: data,
      targetCell: this.client.selectedCell,
      entityName: this.entityName
    });
  }
  populateCellMenu({ record, items: items2 }) {
    const me = this;
    if (me.canCopy) {
      items2.cutCell = {
        text: me.cutText,
        localeClass: me,
        icon: "b-icon b-icon-cut",
        weight: 115,
        disabled: record.readOnly || !me.canCutPaste,
        onItem: () => me.cut()
      };
      items2.pasteCell = {
        text: me.pasteText,
        localeClass: me,
        icon: "b-icon b-icon-paste",
        weight: 120,
        disabled: record.readOnly || !me.canCutPaste || me.hasClipboardData() === false,
        onItem: () => me.paste()
      };
      items2.copyCell = {
        text: me.copyText,
        localeClass: me,
        cls: "b-separator",
        icon: "b-icon b-icon-copy",
        weight: 110,
        onItem: () => me.copy()
      };
    }
  }
};
__publicField(CellCopyPaste, "$name", "CellCopyPaste");
__publicField(CellCopyPaste, "pluginConfig", {
  chain: [
    "populateCellMenu",
    "afterSelectionModeChange"
  ]
});
__publicField(CellCopyPaste, "configurable", {
  useNativeClipboard: !VersionHelper.isTestEnv,
  copyText: "L{copy}",
  cutText: "L{cut}",
  pasteText: "L{paste}"
});
CellCopyPaste._$name = "CellCopyPaste";
GridFeatureManager.registerFeature(CellCopyPaste);

// lib/Grid/feature/CellEdit.js
var editingActions = {
  finishAndEditNextRow: 1,
  finishAndEditPrevRow: 1,
  finishEditing: 1,
  cancelEditing: 1,
  finishAndEditNextCell: 1,
  finishAndEditPrevCell: 1
};
var allActions = {
  ...editingActions,
  startEditingFromKeyMap: 1,
  finishAllSelected: 1
};
var CellEdit = class extends Delayable_default(InstancePlugin) {
  // Default configuration
  static get defaultConfig() {
    return {
      /**
       * Set to true to select the field text when editing starts
       * @config {Boolean}
       * @default
       */
      autoSelect: true,
      /**
       * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.
       * May be `'complete'` or `'cancel`'.
       * @config {'complete'|'cancel'}
       * @default
       */
      blurAction: "complete",
      /**
       * Set to `false` to stop editing when clicking another cell after a cell edit.
       * @config {Boolean}
       * @default
       */
      continueEditingOnCellClick: true,
      /**
       * Set to true to have TAB key on the last cell (and ENTER anywhere in the last row) in the data set create
       * a new record and begin editing it at its first editable cell.
       *
       * If a customized {@link #config-keyMap} is used, this setting will affect the customized keys instead of
       * ENTER and TAB.
       *
       * If this is configured as an object, it is used as the default data value set for each new record.
       * @config {Boolean|Object}
       */
      addNewAtEnd: null,
      /**
       * Set to `true` to add record to the parent of the last record, when configured with {@link #config-addNewAtEnd}.
       * Only applicable when using a tree view and store.
       *
       * By default, it adds records to the root.
       * @config {Boolean}
       * @default false
       */
      addToCurrentParent: false,
      /**
       * Set to `true` to start editing when user starts typing text on a focused cell (as in Excel)
       * @config {Boolean}
       * @default false
       */
      autoEdit: null,
      /**
       * Set to `false` to not start editing next record when user presses enter inside a cell editor (or previous
       * record if SHIFT key is pressed). This is set to `false` when {@link #config-autoEdit} is `true`. Please
       * note that these key combinations could be different if a customized {@link #config-keyMap} is used.
       * @config {Boolean}
       * @default
       */
      editNextOnEnterPress: true,
      /**
       * Class to use as an editor. Default value: {@link Core.widget.Editor}
       * @config {Core.widget.Widget}
       * @typings {typeof Widget}
       * @internal
       */
      editorClass: Editor,
      /**
       * The name of the grid event that will trigger cell editing. Defaults to
       * {@link Grid.view.mixin.GridElementEvents#event-cellDblClick celldblclick} but can be changed to any other event,
       * such as {@link Grid.view.mixin.GridElementEvents#event-cellClick cellclick}.
       *
       * ```javascript
       * features : {
       *     cellEdit : {
       *         triggerEvent : 'cellclick'
       *     }
       * }
       * ```
       *
       * @config {String}
       * @default
       */
      triggerEvent: "celldblclick",
      // To edit a cell using a touch gesture, at least 300ms should have passed since last cell tap
      touchEditDelay: 300,
      focusCellAnimationDuration: false,
      /**
       * If set to `true` (which is default) this will make it possible to edit current column in multiple rows
       * simultaneously.
       *
       * This is achieved by:
       * 1. Select multiple rows or row's cells
       * 2. Start editing simultaneously as selecting the last row or cell
       * 3. When finished editing, press Ctrl+Enter to apply the new value to all selected rows.
       *
       * If a customized {@link #config-keyMap} is used, the Ctrl+Enter combination could map to something else.
       *
       * @config {Boolean}
       * @default
       */
      multiEdit: true,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>}
       */
      keyMap: {
        Enter: ["startEditingFromKeyMap", "finishAndEditNextRow"],
        "Ctrl+Enter": ["finishAllSelected", "finishEditing"],
        "Shift+Enter": "finishAndEditPrevRow",
        "Alt+Enter": "finishEditing",
        F2: ["startEditingFromKeyMap", "finishEditing"],
        Escape: "cancelEditing",
        Tab: { handler: "finishAndEditNextCell", weight: 100 },
        "Shift+Tab": { handler: "finishAndEditPrevCell", weight: 100 }
      },
      /**
       * A CSS selector for elements that when clicked, should not trigger editing. Useful if you render actionable
       * icons or buttons into a grid cell.
       * @config {String}
       * @default
       */
      ignoreCSSSelector: "button,.b-icon,.b-fa,svg",
      /**
       * A callback which returns a `blurAction` value depending on the tap out event and the editing context.
       *
       * If specified, it is passed the mousedown event and the editing context object.
       * @internal
       */
      validateTapOut: null
    };
  }
  // Plugin configuration. This plugin chains some functions in Grid.
  static get pluginConfig() {
    return {
      assign: ["startEditing", "finishEditing", "cancelEditing"],
      before: ["onElementKeyDown", "onElementPointerUp"],
      chain: ["onElementClick", "bindStore"]
    };
  }
  //endregion
  //region Init
  construct(grid, config) {
    super.construct(grid, config);
    const me = this, gridListeners = {
      renderRows: "onGridRefreshed",
      cellClick: "onCellClick",
      thisObj: me
    };
    me.grid = grid;
    if (me.triggerEvent !== "cellclick") {
      gridListeners[me.triggerEvent] = "onTriggerEditEvent";
    }
    if (me.autoEdit && !("editNextOnEnterPress" in config)) {
      me.editNextOnEnterPress = false;
    }
    grid.ion(gridListeners);
    grid.rowManager.ion({
      changeTotalHeight: "onGridRefreshed",
      thisObj: me
    });
    me.bindStore(grid.store);
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      update: "onStoreUpdate",
      beforeSort: "onStoreBeforeSort",
      thisObj: this
    });
  }
  /**
   * Displays an OK / Cancel confirmation dialog box owned by the current Editor. This is intended to be
   * used by {@link Grid.column.Column#config-finalizeCellEdit} implementations. The returned promise resolves passing
   * `true` if the "OK" button is pressed, and `false` if the "Cancel" button is pressed. Typing `ESC` rejects.
   *
   * @param {Object} options An options object for what to show.
   * @param {String} [options.title] The title to show in the dialog header.
   * @param {String} [options.message] The message to show in the dialog body.
   * @param {String|Object} [options.cancelButton] A text or a config object to apply to the Cancel button.
   * @param {String|Object} [options.okButton] A text or config object to apply to the OK button.
   * @returns {Boolean}
   */
  async confirm(options) {
    let result = true;
    if (this.editorContext) {
      MessageDialog_default.owner = this.editorContext.editor.inputField;
      options.rootElement = this.grid.rootElement;
      result = await MessageDialog_default.confirm(options);
      MessageDialog_default.owner = null;
    }
    return result === MessageDialog_default.yesButton;
  }
  doDestroy() {
    this.grid.columns.allRecords.forEach((column) => {
      var _a4;
      (_a4 = column._cellEditor) == null ? void 0 : _a4.destroy();
    });
    super.doDestroy();
  }
  doDisable(disable) {
    if (disable && !this.isConfiguring) {
      this.cancelEditing(true);
    }
    super.doDisable(disable);
  }
  set disabled(disabled) {
    super.disabled = disabled;
  }
  get disabled() {
    const { grid } = this;
    return Boolean(super.disabled || grid.disabled || grid.readOnly);
  }
  //endregion
  //region Editing
  /**
   * Is any cell currently being edited?
   * @readonly
   * @property {Boolean}
   */
  get isEditing() {
    return Boolean(this.editorContext);
  }
  /**
   * Returns the record currently being edited, or `null`
   * @readonly
   * @property {Core.data.Model}
   */
  get activeRecord() {
    var _a4;
    return ((_a4 = this.editorContext) == null ? void 0 : _a4.record) || null;
  }
  /**
   * Internal function to create or get existing editor for specified cell.
   * @private
   * @param cellContext Cell to get or create editor for
   * @returns {Core.widget.Editor} An Editor container which displays the input field.
   * @category Internal
   */
  getEditorForCell({ id, cell, column, columnId, editor }) {
    const me = this, {
      grid,
      editorClass
    } = me;
    let cellEditor = column.cellEditor, leftOffset = 0;
    if (column.editTargetSelector) {
      const editorTarget = cell.querySelector(column.editTargetSelector);
      leftOffset = editorTarget.offsetLeft;
    }
    editor.autoSelect = me.autoSelect;
    if (!(cellEditor == null ? void 0 : cellEditor.isEditor)) {
      cellEditor = column.data.cellEditor = editorClass.create(editorClass.mergeConfigs({
        type: editorClass.type,
        constrainTo: null,
        cls: "b-cell-editor",
        inputField: editor,
        blurAction: "none",
        invalidAction: column.invalidAction,
        completeKey: false,
        cancelKey: false,
        owner: grid,
        align: {
          align: "t0-t0",
          offset: [leftOffset, 0]
        },
        internalListeners: me.getEditorListeners(column.managedCellEditing),
        // Listen for cell edit control keys from the Editor
        onInternalKeyDown: me.onEditorKeydown.bind(me),
        // React editor wrapper code uses this flag to enable mouse events pass through to editor
        allowMouseEvents: editor.allowMouseEvents,
        instantUpdate: column.instantUpdate
      }, cellEditor));
    }
    cellEditor.minHeight = grid.rowHeight;
    if (cellEditor.inputField !== editor) {
      cellEditor.remove(cellEditor.items[0]);
      cellEditor.add(editor);
    }
    const inputField = cellEditor.inputField, instantUpdate = column.instantUpdate && !editor.cellEditValueSetter;
    cellEditor.instantUpdate = instantUpdate;
    cellEditor.align.offset[0] = leftOffset;
    if (instantUpdate) {
      ObjectHelper.wrapProperty(editor, "value", null, (value) => {
        const { editorContext } = me;
        if (editorContext) {
          const { record } = editorContext, { field } = editorContext.column;
          if (editorContext.editor.isValid && !ObjectHelper.isEqual(record.getValue(field), value)) {
            if (!(inputField == null ? void 0 : inputField.isDateField) || (inputField == null ? void 0 : inputField._isPickerInput)) {
              record.setValue(field, value);
              inputField._outstandingUpdate = false;
            } else {
              inputField._outstandingUpdate = true;
            }
          }
        }
      });
      editor.cellEditValueSetter = true;
    }
    Object.assign(cellEditor.element.dataset, {
      rowId: id,
      columnId,
      field: column.field
    });
    cellEditor.inputField.revertOnEscape = column.revertOnEscape;
    return me.editor = cellEditor;
  }
  // Turned into function to allow overriding in Gantt, and make more configurable in general
  getEditorListeners(managedCellEditing) {
    return {
      focusOut: managedCellEditing ? "onEditorFocusOut" : null,
      focusIn: "onEditorFocusIn",
      start: "onEditorStart",
      beforeComplete: "onEditorBeforeComplete",
      complete: "onEditorComplete",
      beforeCancel: "onEditorBeforeCancel",
      cancel: "onEditorCancel",
      beforeHide: "onBeforeEditorHide",
      finishEdit: "onEditorFinishEdit",
      thisObj: this
    };
  }
  onEditorStart({ source: editor }) {
    var _a4;
    const me = this, editorContext = me.editorContext = editor.cellEditorContext;
    if (editorContext) {
      const { grid } = me;
      if (me.triggerEvent !== "cellclick") {
        me.detachListeners("cellClickWhileEditing");
        grid.ion({
          name: "cellClickWhileEditing",
          cellclick: "onCellClickWhileEditing",
          thisObj: me
        });
      }
      (_a4 = me.removeEditingListeners) == null ? void 0 : _a4.call(me);
      if (editorContext.column.managedCellEditing) {
        me.removeEditingListeners = GlobalEvents_default.addListener({
          globaltap: "onTapOut",
          thisObj: me
        });
      }
      grid.trigger("startCellEdit", { grid, editorContext });
    }
  }
  onEditorBeforeComplete(context) {
    const { grid } = this, editor = context.source, editorContext = editor.cellEditorContext;
    context.grid = grid;
    context.editorContext = editorContext;
    return grid.trigger("beforeFinishCellEdit", context);
  }
  onEditorComplete({ source: editor }) {
    var _a4;
    const { grid } = this, editorContext = editor.cellEditorContext;
    editorContext.value = editor.inputField.value;
    if (editor.dataField.includes(".")) {
      const relationName = editor.dataField.split(".")[0];
      if ((_a4 = editor.record.constructor.relations) == null ? void 0 : _a4[relationName]) {
        grid.rowManager.refresh();
      }
    }
    grid.trigger("finishCellEdit", { grid, editorContext });
  }
  onEditorBeforeCancel() {
    const { editorContext } = this;
    return this.grid.trigger("beforeCancelCellEdit", { editorContext });
  }
  onEditorCancel({ event }) {
    const { editorContext, muteEvents, grid } = this;
    if (!muteEvents) {
      grid.trigger("cancelCellEdit", { grid, editorContext, event });
    }
  }
  onBeforeEditorHide({ source }) {
    var _a4;
    const me = this, {
      row,
      cell
    } = source.cellEditorContext;
    cell == null ? void 0 : cell.classList.remove("b-editing");
    row == null ? void 0 : row.removeCls("b-editing");
    me.detachListeners("cellClickWhileEditing");
    (_a4 = me.removeEditingListeners) == null ? void 0 : _a4.call(me);
  }
  onEditorFinishEdit({ source }) {
    source.cellEditorContext = this.editorContext = null;
  }
  /**
   * Find the next succeeding or preceding cell which is editable (column.editor != false)
   * @param {Grid.util.Location} cellInfo
   * @param {Boolean} isForward
   * @returns {Object}
   * @private
   * @category Internal
   */
  getAdjacentEditableCell(cellInfo, isForward) {
    const { grid } = this, { store, columns } = grid, { visibleColumns } = columns;
    let rowId = cellInfo.id, column = columns.getAdjacentVisibleLeafColumn(cellInfo.columnId, isForward);
    while (rowId) {
      if (column) {
        if (column.editor && column.canEdit(cellInfo.record)) {
          return { id: rowId, columnId: column.id };
        }
        column = columns.getAdjacentVisibleLeafColumn(column, isForward);
      } else {
        const record = store.getAdjacent(cellInfo.id, isForward, false, true);
        rowId = record == null ? void 0 : record.id;
        if (record) {
          column = isForward ? visibleColumns[0] : visibleColumns[visibleColumns.length - 1];
        }
      }
    }
    return null;
  }
  /**
   * Adds a new, empty record at the end of the TaskStore with the initial
   * data specified by the {@link Grid.feature.CellEdit#config-addNewAtEnd} setting.
   *
   * @private
   * @returns {Core.data.Model} Newly added record
   */
  doAddNewAtEnd() {
    const newRecordConfig = typeof this.addNewAtEnd === "object" ? ObjectHelper.clone(this.addNewAtEnd) : {}, { grid: { store, rowManager }, addToCurrentParent } = this;
    let record;
    if (store.tree && addToCurrentParent) {
      record = store.last.parent.appendChild(newRecordConfig);
    } else {
      record = store.add(newRecordConfig)[0];
    }
    if (!rowManager.getRowFor(record)) {
      rowManager.displayRecordAtBottom();
    }
    return record;
  }
  /**
   * Creates an editing context object for the passed cell context (target cell must be in the DOM).
   *
   * If the referenced cell is editable, a {@link Grid.util.Location} will
   * be returned containing the following extra properties:
   *
   *     - editor
   *     - value
   *
   * If the referenced cell is _not_ editable, `false` will be returned.
   * @param {Object} cellContext an object which encapsulates a cell.
   * @param {String} cellContext.id The record id of the row to edit
   * @param {String} cellContext.columnId The column id of the column to edit
   * @returns {Grid.util.Location}
   * @private
   */
  getEditingContext(cellContext) {
    cellContext = this.grid.normalizeCellContext(cellContext);
    const { column, record } = cellContext;
    if ((column == null ? void 0 : column.isVisible) && column.editor && !column.readOnly && record && !record.isSpecialRow && !record.readOnly && column.canEdit(record)) {
      const value = record ? column.getRawValue(record) : record;
      Object.assign(cellContext, {
        value: value === void 0 ? null : value,
        editor: column.editor
      });
      return cellContext;
    } else {
      return false;
    }
  }
  startEditingFromKeyMap() {
    return this.startEditing(this.grid.focusedCell);
  }
  /**
   * Start editing specified cell. If no cellContext is given it starts with the first cell in the first row.
   * This function is exposed on Grid and can thus be called as `grid.startEditing(...)`
   * @param {Object} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See
   * {@link Grid.view.Grid#function-getCell} for details.
   * @fires startCellEdit
   * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an {@link Core.widget.Editor#event-beforeStart} listener
   * has vetoed the edit.
   * @category Editing
   * @on-owner
   */
  async startEditing(cellContext = {}) {
    var _a4, _b, _c;
    const me = this;
    if (!me.disabled) {
      const { grid } = me;
      if (cellContext == null ? void 0 : cellContext.fromKeyMap) {
        cellContext = me.grid.focusedCell;
      }
      if (ObjectHelper.isEmpty(cellContext)) {
        cellContext.id = grid.firstVisibleRow.id;
      }
      if (grid.store.isTree && grid.features.tree) {
        const record2 = cellContext.id ? grid.store.getById(cellContext.id) : (_a4 = cellContext.record) != null ? _a4 : grid.store.getAt(cellContext.row);
        if (record2) {
          await grid.expandTo(record2);
        } else {
          return false;
        }
      }
      const editorContext = me.getEditingContext(cellContext);
      if (!editorContext) {
        return false;
      }
      if (me.editorContext) {
        if (me.cancelEditing() === false) {
          return false;
        }
        ;
      }
      if (!((_b = grid.focusedCell) == null ? void 0 : _b.equals(editorContext))) {
        grid.focusCell(editorContext);
      }
      if (grid.trigger("beforeCellEditStart", { grid, editorContext }) === false) {
        return false;
      }
      const editor = editorContext.editor = me.getEditorForCell(editorContext), {
        row,
        cell,
        record
      } = editorContext;
      editor.inputField.highlightExternalChange = false;
      editor.cellEditorContext = editorContext;
      editor.render(cell);
      cell.classList.add("b-editing");
      row.addCls("b-editing");
      if (!await editor.startEdit({
        target: cell,
        field: editor.inputField.name || editorContext.column.field,
        value: editorContext.value,
        record
      })) {
        cell.classList.remove("b-editing");
        row.removeCls("b-editing");
      }
      (_c = me.onCellEditStart) == null ? void 0 : _c.call(me);
      return true;
    }
    return false;
  }
  /**
   * Cancel editing, destroys the editor
   * This function is exposed on Grid and can thus be called as `grid.cancelEditing(...)`
   * @param {Boolean} silent Pass true to prevent method from firing event
   * @fires cancelCellEdit
   * @category Editing
   * @on-owner
   */
  cancelEditing(silent = false, triggeredByEvent) {
    var _a4;
    const me = this, { editor } = me;
    if (!me.isEditing) {
      return;
    }
    if (silent.fromKeyMap) {
      triggeredByEvent = silent;
      silent = false;
    }
    me.muteEvents = silent;
    const cancelResult = editor.cancelEdit(triggeredByEvent);
    me.muteEvents = false;
    if (cancelResult === false) {
      editor.inputField.focus();
    } else {
      me.finishEditingPromise = false;
      (_a4 = me.afterCellEdit) == null ? void 0 : _a4.call(me);
    }
    return cancelResult;
  }
  /**
   * Finish editing, update the underlying record and destroy the editor
   * This function is exposed on Grid and can thus be called as `grid.finishEditing(...)`
   * @fires finishCellEdit
   * @category Editing
   * @returns {Promise} Resolved promise returns `false` if the edit could not be finished due to the value being invalid or the
   * Editor's `complete` event was vetoed.
   * @on-owner
   */
  async finishEditing() {
    var _a4;
    const me = this, { editorContext, grid } = me;
    let result = false;
    if (me.finishEditingPromise) {
      return me.finishEditingPromise;
    }
    if (editorContext) {
      const { column } = editorContext;
      me.finishEditingPromise = editorContext.editor.completeEdit(column.bindCallback(column.finalizeCellEdit));
      result = await me.finishEditingPromise;
      await grid.waitForAnimations();
      me.finishEditingPromise = null;
      if (result) {
        (_a4 = me.afterCellEdit) == null ? void 0 : _a4.call(me);
      }
    }
    return result;
  }
  //endregion
  //region Events
  /**
   * Event handler added when editing is active called when user clicks a cell in the grid during editing.
   * It finishes editing and moves editor to the selected cell instead.
   * @private
   * @category Internal event handling
   */
  async onCellClickWhileEditing({ event, cellSelector }) {
    const me = this;
    if (event.target.closest(".b-editor")) {
      return;
    }
    if (DomHelper.isTouchEvent || event.target.matches(me.ignoreCSSSelector)) {
      await me.finishEditing();
      return;
    }
    if (me.finishEditingPromise) {
      return;
    }
    if (me.editorContext && !me.editorContext.editor.owns(event.target)) {
      if (me.getEditingContext(cellSelector)) {
        if (await me.finishEditing()) {
          if (me.continueEditingOnCellClick) {
            await me.startEditing(cellSelector);
          }
        } else {
          me.grid.focusCell(me.editorContext);
          me.editor.inputField.focus();
        }
      } else {
        await me.finishEditing();
      }
    }
  }
  /**
   * Starts editing if user taps selected cell again on touch device. Chained function called when user clicks a cell.
   * @private
   * @category Internal event handling
   */
  async onCellClick({ cellSelector, target, event, column }) {
    if (column.onCellClick) {
      return;
    }
    const me = this, { focusedCell } = me.client;
    if (target.closest(".b-tree-expander")) {
      return false;
    } else if (DomHelper.isTouchEvent && me._lastCellClicked === (focusedCell == null ? void 0 : focusedCell.cell) && event.timeStamp - me.touchEditDelay > me._lastCellClickedTime) {
      await me.startEditing(cellSelector);
    } else if (this.triggerEvent === "cellclick") {
      await me.onTriggerEditEvent({ cellSelector, target });
    }
    me._lastCellClicked = focusedCell == null ? void 0 : focusedCell.cell;
    me._lastCellClickedTime = event.timeStamp;
  }
  // onElementPointerUp should be used to cancel editing before toggleCollapse handled
  // otherwise data collisions may be happened
  onElementPointerUp(event) {
    if (event.target.closest(".b-tree-expander")) {
      this.cancelEditing(void 0, event);
    }
  }
  /**
   * Called when the user triggers the edit action in {@link #config-triggerEvent} config. Starts editing.
   * @private
   * @category Internal event handling
   */
  async onTriggerEditEvent({ cellSelector, target, event }) {
    var _a4;
    const { editorContext, client } = this;
    if (target.closest(".b-tree-expander") || DomHelper.isTouchEvent && event.type === "dblclick") {
      return;
    }
    if (event && ((_a4 = client.features.cellMenu) == null ? void 0 : _a4.triggerEvent) === event.type) {
      return;
    }
    if (editorContext) {
      if (editorContext.equals(this.grid.normalizeCellContext(cellSelector)) || !await this.finishEditing()) {
        return;
      }
    }
    await this.startEditing(cellSelector);
  }
  /**
   * Update the input field if underlying data changes during edit.
   * @private
   * @category Internal event handling
   */
  onStoreUpdate({ changes, record }) {
    const { editorContext } = this;
    if (editorContext == null ? void 0 : editorContext.editor.isVisible) {
      if (record === editorContext.record && editorContext.editor.dataField in changes) {
        editorContext.editor.refreshEdit();
      }
    }
  }
  onStoreBeforeSort() {
    var _a4;
    const editor = (_a4 = this.editorContext) == null ? void 0 : _a4.editor;
    if (this.isEditing && !(editor == null ? void 0 : editor.isFinishing) && !editor.isValid) {
      return this.cancelEditing();
    }
  }
  /**
   * Realign editor if grid renders rows while editing is ongoing (as a result to autoCommit or WebSocket data received).
   * @private
   * @category Internal event handling
   */
  onGridRefreshed() {
    const me = this, {
      grid,
      editorContext
    } = me;
    if (editorContext && grid.isVisible && grid.focusedCell) {
      const cell = grid.getCell(grid.focusedCell), { editor } = editorContext;
      if (cell && DomHelper.isInView(cell) && !editor.isFinishing) {
        editorContext._cell = cell;
        GlobalEvents_default.suspendFocusEvents();
        editor.render(cell);
        editor.showBy(cell);
        editor.focus();
        GlobalEvents_default.resumeFocusEvents();
      } else {
        me.cancelEditing();
      }
    }
  }
  // Gets selected records or selected cells records
  get gridSelection() {
    return [...this.grid.selectedRows, ...this.grid.selectedCells];
  }
  // Tells keyMap what actions are available in certain conditions
  isActionAvailable({ actionName, event }) {
    const me = this;
    if (!allActions[actionName]) {
      return;
    }
    if (!me.disabled && !event.target.closest(".b-grid-header")) {
      if (me.isEditing) {
        if (actionName === "finishAllSelected") {
          return me.multiEdit && me.gridSelection.length > 1;
        } else if (editingActions[actionName]) {
          return true;
        }
      } else if (actionName === "startEditingFromKeyMap") {
        return me.grid.focusedCell.cell === event.target;
      }
    }
    return false;
  }
  // Will copy edited field value to all selected records
  async finishAllSelected() {
    const me = this, { dataField, record } = me.editor;
    if (await me.finishEditing() && !me.isDestroyed) {
      const value = record.getValue(dataField);
      for (const selected of me.gridSelection) {
        if (selected.isModel) {
          if (selected !== record) {
            selected.setValue(dataField, value);
          }
        } else {
          selected.record.set(selected.column.field, value);
        }
      }
    }
  }
  // Will finish editing and start editing next row (unless it's a touch device)
  // If addNewAtEnd, it will create a new row and edit that one if currently editing last row
  async finishAndEditNextRow(event, previous = false) {
    const me = this, { grid } = me, { record } = me.editorContext;
    let nextCell;
    if (await me.finishEditing()) {
      if (me.isDestroyed) {
        return;
      }
      if (!me.isEditing) {
        if (previous) {
          nextCell = grid.internalNextPrevRow(false, true, false);
        } else {
          if (me.addNewAtEnd && record === grid.store.last) {
            await me.doAddNewAtEnd();
          }
          if (!me.isDestroyed) {
            nextCell = grid.internalNextPrevRow(true, true);
          }
        }
        if (nextCell && me.editNextOnEnterPress) {
          await me.startEditing(nextCell);
        }
      }
    }
  }
  // Will finish editing and start editing previous row
  finishAndEditPrevRow(event) {
    return this.finishAndEditNextRow(event, true);
  }
  // Will finish editing and start editing next cell
  // If addNewAtEnd, it will create a new row and edit that one if currently editing last row
  async finishAndEditNextCell(event, previous = false) {
    var _a4, _b;
    const me = this, { grid } = me, { focusedCell } = grid;
    if (focusedCell && !me.finishEditingPromise) {
      const {
        rowIndex,
        columnIndex
      } = focusedCell;
      let cellInfo = me.getAdjacentEditableCell(focusedCell, !previous);
      if (!cellInfo && !previous && me.addNewAtEnd) {
        const currentEditableFinalizationResult = await me.finishEditing();
        if (currentEditableFinalizationResult === true) {
          await me.doAddNewAtEnd();
        }
      }
      let finalizationResult = true;
      if (me.isEditing) {
        finalizationResult = await me.finishEditing();
      }
      if (me.isDestroyed) {
        return;
      }
      cellInfo = me.getAdjacentEditableCell(new Location({
        grid,
        rowIndex,
        columnIndex
      }), !previous);
      if (cellInfo) {
        if (finalizationResult) {
          grid.focusCell(cellInfo, {
            animate: me.focusCellAnimationDuration
          });
          if (!await me.startEditing(cellInfo)) {
            await me.finishAndEditNextCell(event, previous);
          }
        } else {
        }
      } else if (grid.isNested && grid.owner && !((_b = (_a4 = grid.owner).catchFocus) == null ? void 0 : _b.call(_a4, { source: grid, navigationDirection: previous ? "up" : "down", editing: true }))) {
        grid.onTab(event);
      }
    }
  }
  // Will finish editing and start editing next cell
  finishAndEditPrevCell(event) {
    return this.finishAndEditNextCell(event, true);
  }
  // Handles autoedit
  async onElementKeyDown(event) {
    const me = this, { grid } = me, { focusedCell } = grid;
    if (event.handled || !me.autoEdit || me.isEditing || !focusedCell || focusedCell.isActionable && DomHelper.isEditable(event.target) || event.ctrlKey) {
      return;
    }
    const { key } = event, isDelete = event.key === "Delete" || event.key === "Backspace", { gridSelection } = isDelete ? me : {}, isMultiDelete = me.multiEdit && (gridSelection == null ? void 0 : gridSelection.length) > 1;
    if ((key.length <= 1 || isDelete && !isMultiDelete) && await me.startEditing(focusedCell)) {
      const { inputField } = me.editor, { input } = inputField;
      if (input) {
        inputField.internalOnKeyEvent(event);
        if (!event.defaultPrevented) {
          input.value = isDelete ? "" : key;
          inputField.internalOnInput(event);
        }
      }
      event.preventDefault();
    } else if (isMultiDelete) {
      if (grid.trigger("beforeCellRangeDelete", { grid, gridSelection }) !== false) {
        for (const selected of gridSelection) {
          if (selected.isModel) {
            grid.columns.visibleColumns.forEach((col) => {
              !col.readOnly && selected.set(col.field, null);
            });
          } else if (!selected.column.readOnly) {
            selected.record.set(selected.column.field, null);
          }
        }
      }
    }
  }
  // Prevents keys which the Grid handles from bubbling to the grid while editing
  onEditorKeydown(event) {
    if (event.key.length !== 1 && this.grid.matchKeyMapEntry(event) && !this.grid.matchKeyMapEntry(event, this.keyMap)) {
      if (!event.key.startsWith("Arrow") && !event.key === "Backspace") {
        event.preventDefault();
      }
      event.handled = true;
      event.stopPropagation();
      return false;
    }
  }
  /**
   * Cancel editing on widget focusout
   * @private
   */
  async onEditorFocusOut(event) {
    const me = this, {
      grid,
      editor,
      editorContext
    } = me, toCell = new Location(event.relatedTarget), isEditableCellClick = toCell.grid === grid && me.getEditingContext(toCell);
    if (editorContext && !editor.isFinishing && editor.owns(event._target)) {
      if (me.blurAction === "cancel" || !grid.store.includes(editorContext.record)) {
        me.cancelEditing(void 0, event);
      } else if (!me.finishEditingPromise && (me.triggerEvent === "cellclick" || me.triggerEvent !== "cellclick" && !isEditableCellClick)) {
        await me.finishEditing();
      }
    }
  }
  onEditorFocusIn(event) {
    const widget = event.toWidget;
    if (widget === this.editor.inputField) {
      if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {
        widget.selectAll();
      }
    }
  }
  /**
   * Cancel edit on touch outside of grid for mobile Safari (focusout not triggering unless you touch something focusable)
   * @private
   */
  async onTapOut({ event }) {
    const me = this, { target } = event;
    if (!target._shadowRoot && !me.editor.owns(target) && (!me.grid.bodyContainer.contains(target) || event.button)) {
      const validateTapOut = me.resolveCallback(me.validateTapOut, me, false), blurAction = (validateTapOut == null ? void 0 : validateTapOut.handler.call(validateTapOut.thisObj, event, me.editorContext)) || me.blurAction;
      me.editingStoppedByTapOutside = true;
      if (blurAction === "cancel") {
        me.cancelEditing(void 0, event);
      } else {
        await me.finishEditing();
      }
      delete me.editingStoppedByTapOutside;
    }
  }
  /**
   * Finish editing if clicking below rows (only applies when grid is higher than rows).
   * Also finish if event target is the subgrid which can happen if the pointer is moved during mouse down.
   * @private
   * @category Internal event handling
   */
  async onElementClick(event) {
    if (event.target.matches(".b-grid-body-container, .b-grid-subgrid") && this.editorContext) {
      await this.finishEditing();
    }
  }
  //endregion
};
//region Config
__publicField(CellEdit, "$name", "CellEdit");
CellEdit._$name = "CellEdit";
GridFeatureManager.registerFeature(CellEdit, true);

// lib/Grid/feature/CellMenu.js
var CellMenu = class extends ContextMenuBase {
  //region Config
  static get $name() {
    return "CellMenu";
  }
  static get defaultConfig() {
    return {
      /**
       * A function called before displaying the menu that allows manipulations of its items.
       * Returning `false` from this function prevents the menu being shown.
       *
       * ```javascript
       * features : {
       *     cellMenu : {
       *         processItems({ items, record, column }) {
       *             // Add or hide existing items here as needed
       *             items.myAction = {
       *                 text   : 'Cool action',
       *                 icon   : 'b-fa b-fa-fw b-fa-ban',
       *                 onItem : () => console.log(`Clicked ${record.name}`),
       *                 weight : 1000 // Move to end
       *             };
       *
       *             if (!record.allowDelete) {
       *                 items.removeRow.hidden = true;
       *             }
       *         }
       *     }
       * },
       * ```
       *
       * @config {Function}
       * @param {Object} context An object with information about the menu being shown.
       * @param {Grid.feature.CellMenu} context.feature A reference to this feature.
       * @param {Event} context.domEvent The initiating event.
       * @param {Event} context.event DEPRECATED: The initiating event.
       * @param {Number[]} context.point The client `X` and `Y` position of the initiating event.
       * @param {HTMLElement} context.targetElement The target to which the menu is being applied.
       * @param {Core.data.Model} context.record The record representing the current row.
       * @param {Grid.column.Column} context.column The current column.
       * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the
       *   {@link Core.widget.MenuItem menu item} configs keyed by their id
       * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown
       * @preventable
       */
      processItems: null,
      /**
       * {@link Core.widget.Menu} items object containing named child menu items to apply to the feature's
       * provided context menu.
       *
       * This may add extra items as below, but you can also configure, or remove any of the default items by
       * configuring the name of the item as `null`:
       *
       * ```javascript
       * features : {
       *     cellMenu : {
       *         // This object is applied to the Feature's predefined default items
       *         items : {
       *             switchToDog : {
       *                 text : 'Dog',
       *                 icon : 'b-fa b-fa-fw b-fa-dog',
       *                 onItem({record}) {
       *                     record.dog = true;
       *                     record.cat = false;
       *                 },
       *                 weight : 500     // Make this second from end
       *             },
       *             switchToCat : {
       *                 text : 'Cat',
       *                 icon : 'b-fa b-fa-fw b-fa-cat',
       *                 onItem({record}) {
       *                     record.dog = false;
       *                     record.cat = true;
       *                 },
       *                 weight : 510     // Make this sink to end
       *             },
       *             removeRow : {
       *                 // Change icon for the delete item
       *                 icon : 'b-fa b-fa-times'
       *             },
       *             secretItem : null
       *         }
       *     }
       * },
       * ```
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>}
       */
      items: null,
      type: "cell"
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>} keyMap
       */
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateCellMenu");
    return config;
  }
  //endregion
  //region Events
  /**
   * This event fires on the owning grid before the context menu is shown for a cell.
   * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.
   *
   * Returning `false` from a listener prevents the menu from being shown.
   *
   * @event cellMenuBeforeShow
   * @preventable
   * @on-owner
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<String,MenuItemConfig>} items Menu item configs
   * @param {Grid.column.Column} column Column
   * @param {Core.data.Model} record Record
   */
  /**
   * This event fires on the owning grid after the context menu is shown for a cell.
   * @event cellMenuShow
   * @on-owner
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<String,MenuItemConfig>} items Menu item configs
   * @param {Grid.column.Column} column Column
   * @param {Core.data.Model} record Record
   */
  /**
   * This event fires on the owning grid when an item is selected in the cell context menu.
   * @event cellMenuItem
   * @on-owner
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Grid.column.Column} column Column
   * @param {Core.data.Model} record Record
   */
  /**
   * This event fires on the owning grid when a check item is toggled in the cell context menu.
   * @event cellMenuToggleItem
   * @on-owner
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Grid.column.Column} column Column
   * @param {Core.data.Model} record Record
   * @param {Boolean} checked Checked or not
   */
  //endregion
  //region Menu handlers
  showContextMenu(eventParams) {
    const me = this, {
      cellSelector,
      event
    } = eventParams;
    me.client.focusCell(cellSelector, {
      doSelect: !me.client.selectedRecordCollection.includes(cellSelector.id),
      event
    });
    super.showContextMenu(eventParams);
  }
  shouldShowMenu({ column }) {
    return column && column.enableCellContextMenu !== false;
  }
  getDataFromEvent(event) {
    const cellData = this.client.getCellDataFromEvent(event);
    if (cellData) {
      return ObjectHelper.assign(super.getDataFromEvent(event), cellData);
    }
  }
  beforeContextMenuShow({ record, items: items2, column }) {
    if (column.cellMenuItems === false) {
      return false;
    }
    if (!record || record.isSpecialRow) {
      items2.removeRow = false;
    }
  }
  //endregion
  //region Getters/Setters
  populateCellMenu({ items: items2, column, record }) {
    const { client } = this;
    if (column == null ? void 0 : column.cellMenuItems) {
      ObjectHelper.merge(items2, column.cellMenuItems);
    }
    if (!client.readOnly) {
      items2.removeRow = {
        text: "L{removeRow}",
        localeClass: this,
        icon: "b-fw-icon b-icon-trash",
        cls: "b-separator",
        weight: 100,
        disabled: record.readOnly,
        onItem: () => {
          var _a4, _b;
          const store = (_b = (_a4 = client.features.treeGroup) == null ? void 0 : _a4.originalStore) != null ? _b : client.store;
          if (client.isCellSelected({ record, column }, true)) {
            store.remove(client.selectedRecords.filter((r) => !r.readOnly).map((r) => r.$original));
          } else {
            store.remove(record);
          }
        }
      };
    }
  }
  get showMenu() {
    return true;
  }
  /**
   * Shows the context menu for the provided cell.
   * @param {LocationConfig|Grid.util.Location} cell The cell descriptor to show the menu for.
   * @param {Object} [options]
   * @param {HTMLElement} [options.targetElement] Element to align context menu to.
   * If provided menu will be aligned to the center of the target element.
   * If omitted, the context menu will be centered relative to the cell element.
   */
  showMenuFor(cellSelector, { targetElement } = {}) {
    cellSelector = this.client.normalizeCellContext(cellSelector);
    DomHelper.triggerMouseEvent(targetElement || this.client.getCell(cellSelector), this.triggerEvent);
  }
  //endregion
};
CellMenu.featureClass = "";
CellMenu._$name = "CellMenu";
GridFeatureManager.registerFeature(CellMenu, true, ["Grid", "Scheduler"]);
GridFeatureManager.registerFeature(CellMenu, false, ["Gantt"]);

// lib/Grid/feature/CellTooltip.js
var CellTooltip = class extends InstancePlugin {
  //endregion
  // region Init
  construct(grid, config) {
    super.construct(grid, this.processConfig(config));
  }
  initTip() {
    const me = this;
    me.tip = Tooltip.new({
      forElement: me.client.element,
      forSelector: ".b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells",
      hoverDelay: 1e3,
      trackMouse: false,
      cls: "b-celltooltip-tip",
      getHtml: me.getTooltipContent.bind(me),
      internalListeners: {
        pointerOver: "onPointerOver",
        thisObj: me
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: me.configuredListeners
    }, me.initialConfig);
    me.relayEvents(me.tip, ["beforeShow", "show"]);
  }
  onPointerOver({ target }) {
    const column = this.client.getColumnFromElement(target);
    return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);
  }
  // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === "function") {
      return {
        tooltipRenderer: config
      };
    }
    return config;
  }
  // override setConfig to process config before applying it (used mainly from ReactGrid)
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  doDestroy() {
    this.tip && this.tip.destroy();
    super.doDestroy();
  }
  doDisable(disable) {
    if (!disable) {
      this.initTip();
    } else if (this.tip) {
      this.tip.destroy();
      this.tip = null;
    }
    super.doDisable(disable);
  }
  //endregion
  //region Content
  /**
   * Called from Tooltip to populate it with html.
   * @private
   */
  getTooltipContent({ tip, activeTarget: cellElement, event }) {
    const me = this, record = me.client.getRecordFromElement(cellElement), column = me.client.getColumnFromElement(cellElement), arg = { cellElement, record, column, event, tip, cellTooltip: me };
    let result;
    if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {
      return me.tip._html;
    }
    me.lastRecord = record;
    me.lastRecordGeneration = record.generation;
    me.lastColumn = column;
    if (column.tooltipRenderer) {
      result = column.tooltipRenderer(arg);
    } else if (me.tooltipRenderer && column.tooltipRenderer !== false) {
      result = me.tooltipRenderer(arg);
    }
    if (Objects.isPromise(result)) {
      me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;
    }
    if (!result) {
      tip.hide();
    }
    return result;
  }
  //endregion
};
//region Config
__publicField(CellTooltip, "$name", "CellTooltip");
__publicField(CellTooltip, "configurable", {
  /**
   * Function called to generate the HTML content for the cell tooltip.
   * The function should return a string (your HTML), or a Promise yielding a string (for remotely loaded
   * content)
   * @prp {Function}
   * @param {Object} context
   * @param {HTMLElement} context.cellElement The cell element
   * @param {Core.data.Model} context.record The row record
   * @param {Grid.column.Column} context.column The column
   * @param {Core.widget.Tooltip} context.tip The Tooltip instance
   * @param {Grid.feature.CellTooltip} context.cellTooltip The feature
   * @param {Event} context.event The raw DOM event
   * @returns {String|Promise}
   * @typings {String|Promise<String>}
   */
  tooltipRenderer: null
});
CellTooltip._$name = "CellTooltip";
GridFeatureManager.registerFeature(CellTooltip);

// lib/Grid/feature/ColumnAutoWidth.js
var storeListenerName = "store";
var ColumnAutoWidth = class extends Delayable_default(InstancePlugin) {
  //endregion
  //region Internals
  static get pluginConfig() {
    return {
      after: {
        bindStore: "bindStore",
        unbindStore: "unbindStore",
        renderRows: "syncAutoWidthColumns",
        onInternalResize: "onInternalResize"
      },
      assign: [
        "columnAutoWidthPending",
        "syncAutoWidthColumns"
      ]
    };
  }
  construct(config) {
    super.construct(config);
    const { store } = this.client;
    store && this.bindStore(store);
  }
  doDestroy() {
    this.unbindStore();
    super.doDestroy();
  }
  bindStore(store) {
    this.lastSync = null;
    store.ion({
      name: storeListenerName,
      [`change${this.client.asyncEventSuffix}`]: "onStoreChange",
      thisObj: this
    });
  }
  unbindStore() {
    this.detachListeners(storeListenerName);
  }
  get columnAutoWidthPending() {
    return this.lastSync === null || this.hasTimeout("syncAutoWidthColumns");
  }
  onStoreChange({ action }) {
    if (action !== "move") {
      const me = this, { cellEdit } = me.client.features;
      ++me.storeGeneration;
      if (action === "filter" || (cellEdit == null ? void 0 : cellEdit.isEditing) && !cellEdit.editingStoppedByTapOutside) {
        me.syncAutoWidthColumns();
      } else if (!me.client.refreshSuspended) {
        me.setTimeout({ fn: "syncAutoWidthColumns", delay: me.delay, cancelOutstanding: true });
      } else {
        me.client.rowManager.once("renderDone", () => me.syncAutoWidthColumns());
      }
    }
  }
  // Handle scenario with Grid being inside DIV with display none, and no width. Sync column widths after being shown
  onInternalResize(element, newWidth, newHeight, oldWidth) {
    if (oldWidth === 0) {
      this.lastSync = null;
      this.syncAutoWidthColumns();
    }
  }
  syncAutoWidthColumns() {
    const me = this, {
      client,
      storeGeneration
    } = me;
    if (client.splitFrom) {
      return;
    }
    if (me.lastSync !== storeGeneration) {
      me.lastSync = storeGeneration;
      let autoWidth, resizingColumns;
      for (const column of client.columns.visibleColumns) {
        autoWidth = column.autoWidth;
        if (autoWidth) {
          if (autoWidth === true) {
            autoWidth = me.default;
          }
          client.resizingColumns = resizingColumns = true;
          column.resizeToFitContent(autoWidth);
        }
      }
      if (resizingColumns) {
        client.resizingColumns = false;
        client.afterColumnsResized();
      }
    }
    if (me.hasTimeout("syncAutoWidthColumns")) {
      me.clearTimeout("syncAutoWidthColumns");
    }
  }
  //endregion
};
__publicField(ColumnAutoWidth, "$name", "ColumnAutoWidth");
//region Config
__publicField(ColumnAutoWidth, "configurable", {
  /**
   * The default `autoWidth` option for columns with `autoWidth: true`. This can
   * be a single number for the minimum column width, or an array of two numbers
   * for the `[minWidth, maxWidth]`.
   * @config {Number|Number[]}
   */
  default: null,
  /**
   * The amount of time (in milliseconds) to delay after a store modification
   * before synchronizing `autoWidth` columns.
   * @config {Number}
   * @default
   */
  delay: 0
});
ColumnAutoWidth.prototype.storeGeneration = 0;
ColumnAutoWidth._$name = "ColumnAutoWidth";
GridFeatureManager.registerFeature(ColumnAutoWidth, true);

// lib/Grid/feature/ColumnDragToolbar.js
var ColumnDragToolbar = class extends Delayable_default(InstancePlugin) {
  //region Config
  static get $name() {
    return "ColumnDragToolbar";
  }
  // Plugin configuration. This plugin chains some of the functions in Grid
  static get pluginConfig() {
    return {
      after: ["render"]
    };
  }
  //endregion
  //region Init
  construct(grid, config) {
    if (grid.features.columnReorder) {
      grid.features.columnReorder.ion({ beforeDestroy: "onColumnReorderBeforeDestroy", thisObj: this });
    }
    this.grid = grid;
    super.construct(grid, config);
  }
  doDestroy() {
    const me = this;
    if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {
      me.detachFromColumnReorder();
    }
    me.element && me.element.remove();
    me.element = null;
    super.doDestroy();
  }
  doDisable(disable) {
    if (this.initialized) {
      if (disable) {
        this.detachFromColumnReorder();
      } else {
        this.init();
      }
    }
    super.doDisable(disable);
  }
  init() {
    const me = this, grid = me.grid;
    if (!grid.features.columnReorder) {
      return;
    }
    me.reorderDetacher = grid.features.columnReorder.ion({
      gridheaderdragstart({ context }) {
        const column = grid.columns.getById(context.element.dataset.columnId);
        me.showToolbar(column);
      },
      gridheaderdrag: ({ context }) => me.onDrag(context),
      gridheaderabort: () => {
        me.hideToolbar();
      },
      gridHeaderDrop: me.onDrop,
      thisObj: me
    });
    me.initialized = true;
  }
  onColumnReorderBeforeDestroy() {
    this.detachFromColumnReorder();
  }
  detachFromColumnReorder() {
    const me = this;
    me.grid.features.columnReorder.un("beforedestroy", me.onColumnReorderBeforeDestroy, me);
    me.reorderDetacher && me.reorderDetacher();
    me.reorderDetacher = null;
  }
  /**
   * Initializes this feature on grid render.
   * @private
   */
  render() {
    if (!this.initialized) {
      this.init();
    }
  }
  //endregion
  //region Toolbar
  showToolbar(column) {
    const me = this, buttons = me.grid.getColumnDragToolbarItems(column, []), groups = [];
    me.clearTimeout(me.buttonHideTimer);
    buttons.forEach((button) => {
      button.text = button.localeClass.L(button.text);
      let group = groups.find((group2) => group2.text === button.group);
      if (!group) {
        group = {
          text: button.localeClass.L(button.group),
          buttons: []
        };
        groups.push(group);
      }
      group.buttons.push(button);
    });
    me.element = DomHelper.append(me.grid.element, me.template(groups));
    me.groups = groups;
    me.buttons = buttons;
    me.column = column;
  }
  async hideToolbar() {
    const me = this, element = me.element;
    if (element) {
      element.classList.add("b-remove");
      await EventHelper.waitForTransitionEnd({
        element,
        mode: "animation",
        thisObj: me.client
      });
      element.remove();
      me.element = null;
    }
  }
  //endregion
  //region Events
  onDrag(info) {
    var _a4;
    const me = this;
    if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {
      me.element.classList.add("b-closer");
    } else {
      me.element.classList.remove("b-closer");
    }
    if (me.hoveringButton) {
      me.hoveringButton.classList.remove("b-hover");
      me.hoveringButton = null;
    }
    if ((_a4 = info.targetElement) == null ? void 0 : _a4.closest(".b-columndragtoolbar")) {
      me.element.classList.add("b-hover");
      const button = info.targetElement.closest(".b-columndragtoolbar  .b-target-button:not([data-disabled=true])");
      if (button) {
        button.classList.add("b-hover");
        me.hoveringButton = button;
      }
    } else {
      me.element.classList.remove("b-hover");
    }
  }
  onDrop({ context }) {
    const me = this, { targetElement } = context;
    if (targetElement && targetElement.matches(".b-columndragtoolbar .b-target-button:not([data-disabled=true])")) {
      const button = me.buttons.find((button2) => button2.ref === targetElement.dataset.ref);
      if (button) {
        targetElement.classList.add("b-activate");
        me.buttonHideTimer = me.setTimeout(() => {
          me.hideToolbar();
          button.onDrop({ column: me.column });
        }, 100);
      }
    } else {
      me.hideToolbar();
    }
  }
  //endregion
  template(groups) {
    return TemplateHelper.tpl`
            <div class="b-columndragtoolbar">     
            <div class="b-title"></div>          
            ${groups.map((group) => TemplateHelper.tpl`
                <div class="b-group">
                    <div class="b-buttons">
                    ${group.buttons.map((btn) => TemplateHelper.tpl`
                        <div class="b-target-button" data-ref="${btn.ref}" data-disabled="${btn.disabled}">
                            <i class="${btn.icon}"></i>
                            ${btn.text}
                        </div>
                    `)}
                    </div>
                    <div class="b-title">${group.text}</div>
                </div>
            `)}
            </div>`;
  }
};
ColumnDragToolbar.featureClass = "b-hascolumndragtoolbar";
ColumnDragToolbar._$name = "ColumnDragToolbar";
GridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);

// lib/Grid/feature/ColumnPicker.js
var ColumnPicker = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["populateHeaderMenu", "getColumnDragToolbarItems"]
    };
  }
  get grid() {
    return this.client;
  }
  //endregion
  //region Context menu
  /**
   * Get menu items, either a straight list of columns or sub menus per subgrid
   * @private
   * @param columnStore Column store to traverse
   * @returns {MenuItemConfig[]} Menu item configs
   */
  getColumnPickerItems(columnStore) {
    const me = this, { createColumnsFromModel } = me;
    let result;
    if (me.groupByRegion) {
      result = me.grid.regions.map((region) => {
        const columns = me.grid.getSubGrid(region).columns.topColumns;
        return {
          text: StringHelper.capitalize(region),
          menu: me.buildColumnMenu(columns),
          disabled: columns.length === 0,
          region
        };
      });
      if (createColumnsFromModel) {
        result.push({
          text: me.L("L{newColumns}"),
          menu: me.createAutoColumnItems()
        });
      }
    } else if (me.groupByTag) {
      const tags = {};
      columnStore.topColumns.forEach((column) => {
        column.tags && Array.isArray(column.tags) && column.hideable !== false && column.tags.forEach((tag) => {
          if (!tags[tag]) {
            tags[tag] = 1;
          }
        });
      });
      result = Object.keys(tags).sort().map((tag) => ({
        text: StringHelper.capitalize(tag),
        menu: me.buildColumnMenu(me.getColumnsForTag(tag)),
        tag,
        onBeforeSubMenu: ({ item, itemEl }) => {
          me.refreshTagMenu(item, itemEl);
        }
      }));
      if (createColumnsFromModel) {
        result.push({
          text: me.L("L{newColumns}"),
          menu: me.createAutoColumnItems()
        });
      }
    } else {
      result = me.buildColumnMenu(columnStore.topColumns);
      if (createColumnsFromModel) {
        result.items.push(...ObjectHelper.transformNamedObjectToArray(me.createAutoColumnItems()));
      }
    }
    return result;
  }
  createAutoColumnItems() {
    const me = this, { grid } = me, {
      columns,
      store
    } = grid, { modelClass } = store, { allFields } = modelClass, result = {};
    for (let i = 0, { length } = allFields; i < length; i++) {
      const field = allFields[i], fieldName = field.name;
      if (!columns.get(fieldName)) {
        if (!field.internal) {
          result[fieldName] = {
            text: field.text || StringHelper.separate(field.name),
            checked: false,
            onToggle: (event) => {
              const column = columns.get(fieldName);
              if (column) {
                column[event.checked ? "show" : "hide"]();
              } else {
                columns.add(columns.generateColumnForField(field, {
                  region: me.forColumn.region
                }));
              }
              event.bubbles = false;
            }
          };
        }
      }
    }
    return result;
  }
  /**
   * Get all columns that has the specified tag.
   * @private
   * @param tag
   * @returns {Grid.column.Column[]}
   */
  getColumnsForTag(tag) {
    return this.grid.columns.records.filter(
      (column) => column.tags && Array.isArray(column.tags) && column.tags.includes(tag) && column.hideable !== false
    );
  }
  /**
   * Refreshes checked status for a tag menu. Needed since columns can appear under multiple tags.
   * @private
   */
  refreshTagMenu(item, itemEl) {
    const columns = this.getColumnsForTag(item.tag);
    columns.forEach((column) => {
      const subItem = item.items.find((subItem2) => subItem2.column === column);
      if (subItem)
        subItem.checked = column.hidden !== true;
    });
  }
  /**
   * Traverses columns to build menu items for the column picker.
   * @private
   */
  buildColumnMenu(columns) {
    let currentRegion = columns.length > 0 && columns[0].region;
    const { grid } = this, items2 = columns.reduce((items3, column) => {
      const visibleInRegion = grid.columns.visibleColumns.filter((col) => col.region === column.region);
      if (column.hideable !== false) {
        const itemConfig = {
          grid,
          column,
          text: column.htmlEncodeHeaderText ? column.text : DomHelper.stripTags(column.text),
          checked: column.hidden !== true,
          disabled: column.hidden !== true && visibleInRegion.length === 1,
          cls: column.region !== currentRegion ? "b-separator" : ""
        };
        currentRegion = column.region;
        if (column.children && !column.isCollapsible) {
          itemConfig.menu = this.buildColumnMenu(column.children);
        }
        items3.push(itemConfig);
      }
      return items3;
    }, []);
    return {
      cls: this.menuCls,
      items: items2
    };
  }
  /**
   * Populates the header context menu items.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateHeaderMenu({ column, items: items2 }) {
    const me = this, { columns } = me.grid;
    me.forColumn = column;
    if (column.showColumnPicker !== false && columns.some((col) => col.hideable)) {
      items2.columnPicker = {
        text: "L{columnsMenu}",
        localeClass: me,
        icon: "b-fw-icon b-icon-columns",
        cls: "b-separator",
        weight: 200,
        menu: me.getColumnPickerItems(columns),
        onToggle: me.onColumnToggle,
        disabled: me.disabled
      };
    }
    if (column.hideable !== false && !column.parent.isCollapsible) {
      items2.hideColumn = {
        text: "L{hideColumn}",
        localeClass: me,
        icon: "b-fw-icon b-icon-hide-column",
        weight: 210,
        disabled: !column.allowDrag || me.disabled,
        onItem: () => column.hide()
      };
    }
  }
  /**
   * Handler for column hide/show menu checkitems.
   * @private
   * @param {Object} event The {@link Core.widget.MenuItem#event-toggle} event.
   */
  onColumnToggle({ menu, item, checked }) {
    var _a4, _b;
    if (Boolean(item.column.hidden) !== !checked) {
      item.column[checked ? "show" : "hide"]();
      const { grid, column } = item, { columns, features } = grid, siblingItems = menu.items, otherHideableCols = columns.visibleColumns.filter((col) => col.region === item.column.region && col.showColumnPicker !== false), hideItem = ((_a4 = features.headerMenu) == null ? void 0 : _a4.enabled) && features.headerMenu.menu.widgetMap.hideColumn;
      if (otherHideableCols.length === 1) {
        const lastVisibleItem = siblingItems.find((menuItem) => menuItem.column === otherHideableCols[0]);
        if (lastVisibleItem) {
          lastVisibleItem.disabled = true;
        }
        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = true;
        }
      } else {
        otherHideableCols.forEach((col) => {
          const siblingItem = siblingItems.find((sibling) => sibling.column === col);
          if (siblingItem) {
            siblingItem.disabled = false;
          }
        });
        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = false;
        }
      }
      (_b = item.menu) == null ? void 0 : _b.eachWidget((subItem) => {
        subItem.checked = checked;
      });
      const parentItem = menu.owner;
      if (parentItem && parentItem.column === column.parent) {
        parentItem.checked = siblingItems.some((subItem) => subItem.checked === true);
      }
    }
  }
  /**
   * Supply items to ColumnDragToolbar
   * @private
   */
  getColumnDragToolbarItems(column, items2) {
    const visibleInRegion = this.grid.columns.visibleColumns.filter((col) => col.region === column.region);
    if (column.hideable !== false && visibleInRegion.length > 1) {
      items2.push({
        text: "L{hideColumnShort}",
        ref: "hideColumn",
        group: "L{column}",
        localeClass: this,
        icon: "b-fw-icon b-icon-hide-column",
        weight: 101,
        onDrop: ({ column: column2 }) => column2.hide()
      });
    }
    return items2;
  }
  //endregion
};
//region Config
__publicField(ColumnPicker, "$name", "ColumnPicker");
__publicField(ColumnPicker, "configurable", {
  /**
   * Groups columns in the picker by region (each region gets its own sub menu)
   * @config {Boolean}
   * @default
   */
  groupByRegion: false,
  /**
   * Groups columns in the picker by tag, each column may be shown under multiple tags. See
   * {@link Grid.column.Column#config-tags}
   * @config {Boolean}
   * @default
   */
  groupByTag: false,
  /**
   * Configure this as `true` to have the fields from the Grid's {@link Core.data.Store}'s
   * {@link Core.data.Store#config-modelClass} added to the menu to create __new__ columns
   * to display the fields.
   *
   * This may be combined with the {@link Grid.view.mixin.GridState stateful} ability of the grid
   * to create a self-configuring grid.
   * @config {Boolean}
   * @default
   */
  createColumnsFromModel: false,
  menuCls: "b-column-picker-menu b-sub-menu"
});
ColumnPicker._$name = "ColumnPicker";
GridFeatureManager.registerFeature(ColumnPicker, true);

// lib/Grid/feature/ColumnRename.js
var ColumnRename = class extends InstancePlugin {
  doDestroy() {
    var _a4;
    (_a4 = this.editor) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  static get pluginConfig() {
    return {
      after: ["populateHeaderMenu"]
    };
  }
  populateHeaderMenu({ items: items2, column }) {
    items2.rename = {
      weight: 215,
      icon: "b-fw-icon b-icon-edit",
      text: this.L("L{rename}"),
      disabled: column.readOnly,
      onItem: () => this.startEdit(column)
    };
  }
  startEdit(column) {
    var _a4;
    if (column instanceof Event) {
      column = (_a4 = this.client.getHeaderDataFromEvent(column)) == null ? void 0 : _a4.column;
    }
    if (column) {
      if (column.readOnly) {
        return false;
      }
      const { textWrapper } = column;
      let { editor } = this;
      if (!editor) {
        this.editor = editor = new Editor({
          owner: this.client,
          align: {
            align: "t0-t0"
          }
        });
      }
      editor.render(textWrapper);
      editor.startEdit({
        target: textWrapper,
        record: column,
        field: "text"
      });
    }
  }
};
__publicField(ColumnRename, "$name", "ColumnRename");
__publicField(ColumnRename, "configurable", {
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    F2: "startEdit"
  }
});
ColumnRename._$name = "ColumnRename";
GridFeatureManager.registerFeature(ColumnRename, false);

// lib/Grid/feature/ColumnReorder.js
var ColumnReorder = class extends Delayable_default(InstancePlugin) {
  constructor() {
    super(...arguments);
    __publicField(this, "ignoreSelectors", [
      ".b-grid-header-resize-handle",
      ".b-field"
    ]);
  }
  /**
   * Initialize drag & drop (called from render)
   * @private
   */
  init() {
    const me = this, { grid } = me, gridEl = grid.element, containers = DomHelper.children(gridEl, ".b-grid-headers");
    containers.push(...DomHelper.children(gridEl, ".b-grid-header-children"));
    if (me.dragHelper) {
      me.dragHelper.containers = containers;
    } else {
      grid.whenVisible(() => me.createDragHelper());
    }
  }
  createDragHelper() {
    const me = this, { grid } = me, gridEl = grid.element, containers = DomHelper.children(gridEl, ".b-grid-headers");
    containers.push(...DomHelper.children(gridEl, ".b-grid-header-children"));
    me.dragHelper = new DragHelper({
      name: "columnReorder",
      mode: "container",
      dragThreshold: 10,
      targetSelector: ".b-grid-header",
      floatRootOwner: grid,
      rtlSource: grid,
      outerElement: grid.headerContainer,
      // Require that we drag inside grid header while dragging if we don't have a drag toolbar or external drop
      // target defined
      dropTargetSelector: ".b-grid-headers, .b-groupbar, .b-columndragtoolbar",
      externalDropTargetSelector: ".b-groupbar, .b-columndragtoolbar",
      monitoringConfig: {
        scrollables: [{
          element: ".b-grid-headers"
        }]
      },
      scrollManager: ScrollManager.new({
        direction: "horizontal",
        element: grid.headerContainer
      }),
      containers,
      isElementDraggable(element) {
        const abort = Boolean(element.closest(me.ignoreSelectors.join(",")));
        if (abort || me.disabled) {
          return false;
        }
        const columnEl = element.closest(this.targetSelector), column = columnEl && grid.columns.getById(columnEl.dataset.columnId), isLast = (column == null ? void 0 : column.childLevel) === 0 && grid.subGrids[column.region].columns.count === 1;
        return Boolean(column) && column.draggable !== false && !isLast;
      },
      ignoreSelector: ".b-filter-icon,.b-grid-header-resize-handle",
      internalListeners: {
        beforeDragStart: me.onBeforeDragStart,
        dragstart: me.onDragStart,
        drag: me.onDrag,
        drop: me.onDrop,
        abort: me.onAbort,
        thisObj: me
      }
    });
    me.relayEvents(me.dragHelper, ["dragStart", "drag", "drop", "abort"], "gridHeader");
    return me.dragHelper;
  }
  //endregion
  //region Plugin config
  doDestroy() {
    var _a4, _b;
    (_a4 = this.dragHelper) == null ? void 0 : _a4.scrollManager.destroy();
    (_b = this.dragHelper) == null ? void 0 : _b.destroy();
    super.doDestroy();
  }
  get grid() {
    return this.client;
  }
  //endregion
  //region Events (drop)
  onBeforeDragStart({ context, event }) {
    const me = this, { element } = context, column = context.column = me.client.columns.getById(element.dataset.columnId);
    me.dragHelper.autoSizeClonedTarget = !me.usingGroupBarWidget;
    return column.allowDrag && me.client.trigger("beforeColumnDragStart", { column, event });
  }
  onDragStart({ context, event }) {
    const me = this, { grid, usingGroupBarWidget } = me, { column, dragProxy } = context;
    if (!grid.features.columnDragToolbar && !usingGroupBarWidget) {
      const headerContainerBox = grid.element.querySelector(".b-grid-header-container").getBoundingClientRect();
      me.dragHelper.minY = headerContainerBox.top;
      me.dragHelper.maxY = headerContainerBox.bottom;
    }
    grid.element.classList.add("b-dragging-header");
    if (usingGroupBarWidget) {
      dragProxy.classList.add("b-grid-reordering-columns-with-groupbar");
    }
    if (grid.features.filterBar && grid.features.filterBar.compactMode) {
      dragProxy.classList.add("b-filter-bar-compact");
    }
    dragProxy.style.fontSize = DomHelper.getStyleValue(context.element, "fontSize");
    grid.trigger("columnDragStart", { column, event });
  }
  onDrag({ context, event }) {
    const me = this, grid = me.client, { column, insertBefore: insertBeforeElement } = context, insertBefore = grid.columns.getById(insertBeforeElement == null ? void 0 : insertBeforeElement.dataset.columnId), targetHeader = Widget.fromElement(event.target, "gridheader");
    if (targetHeader == null ? void 0 : targetHeader.subGrid.sealedColumns) {
      context.valid = false;
    }
    grid.trigger("columnDrag", { column, insertBefore, event, context });
  }
  /**
   * Handle drop
   * @private
   */
  onDrop({ context, event }) {
    var _a4;
    if (!context.valid) {
      return this.onInvalidDrop({ context, event });
    }
    const me = this, { grid } = me, { column } = context, element = context.dragging, onHeader = context.target.closest(".b-grid-header"), droppedInRegion = (_a4 = context.draggedTo) == null ? void 0 : _a4.dataset.region, isReorder = droppedInRegion || onHeader;
    let vetoed, newParent, insertBefore, toRegion, oldParent;
    grid.element.classList.remove("b-dragging-header");
    if (isReorder) {
      const onColumn = onHeader ? grid.columns.getById(onHeader.dataset.columnId) : grid.subGrids[droppedInRegion].columns.last, sibling = context.insertBefore;
      toRegion = droppedInRegion || onColumn.region;
      oldParent = column.parent;
      insertBefore = sibling ? grid.columns.getById(sibling.dataset.columnId) : grid.subGrids[toRegion].columns.last.nextSibling;
      if (insertBefore) {
        newParent = insertBefore.parent;
      } else {
        const groupNode = onHeader == null ? void 0 : onHeader.parentElement.closest(".b-grid-header");
        if (groupNode) {
          newParent = grid.columns.getById(groupNode.dataset.columnId);
        } else {
          newParent = grid.columns.rootNode;
        }
      }
      vetoed = toRegion === column.region && oldParent === newParent && (onColumn === column.previousSibling || insertBefore === column.nextSibling);
      element.remove();
    }
    vetoed = vetoed || grid.trigger("beforeColumnDropFinalize", {
      column,
      newParent,
      insertBefore,
      event,
      region: toRegion
    }) === false;
    if (!vetoed && isReorder) {
      vetoed = !newParent.insertChild(column, insertBefore);
    }
    context.valid = !vetoed;
    if (!vetoed && isReorder) {
      if (column.parent.isRoot && column.region !== toRegion) {
        column.region = toRegion;
      }
      if (oldParent.children.length === 0) {
        oldParent.parent.removeChild(oldParent);
      }
    }
    grid.trigger("columnDrop", { column, newParent, insertBefore, valid: context.valid, event, region: toRegion });
  }
  onAbort({ context, event }) {
    this.onInvalidDrop({ context, event });
  }
  /**
   * Handle invalid drop
   * @private
   */
  onInvalidDrop({ context, event }) {
    const { grid } = this, { column } = context;
    grid.trigger("columnDrop", { column, valid: false, event });
    grid.element.classList.remove("b-dragging-header");
  }
  //endregion
  //region Render
  /**
   * Updates DragHelper with updated headers when grid contents is rerendered
   * @private
   */
  renderContents() {
    this.init();
  }
  /**
   * Initializes this feature on grid paint.
   * @private
   */
  onInternalPaint() {
    this.init();
  }
  /**
   * Returns true if a reorder operation is active
   * @property {Boolean}
   * @readonly
   */
  get isReordering() {
    var _a4;
    return Boolean((_a4 = this.dragHelper) == null ? void 0 : _a4.isDragging);
  }
  //endregion
};
//region Init
__publicField(ColumnReorder, "$name", "ColumnReorder");
// Plugin configuration. This plugin chains some functions in Grid
__publicField(ColumnReorder, "pluginConfig", {
  after: ["onInternalPaint", "renderContents"]
});
ColumnReorder.featureClass = "b-column-reorder";
ColumnReorder._$name = "ColumnReorder";
GridFeatureManager.registerFeature(ColumnReorder, true);

// lib/Grid/feature/ColumnResize.js
var ColumnResize = class extends InstancePlugin {
  //region Init
  construct(grid, config) {
    const me = this;
    super.construct(grid, config);
    me.resizer = new ResizeHelper({
      name: "columnResize",
      targetSelector: ".b-grid-header",
      handleSelector: ".b-grid-header-resize-handle",
      outerElement: grid.element,
      rtlSource: grid,
      constrainToParent: false,
      internalListeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onResize,
        cancel: me.onCancel,
        thisObj: me
      }
    });
  }
  doDestroy() {
    var _a4;
    (_a4 = this.resizer) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  //endregion
  changeLiveResize(liveResize) {
    if (liveResize === "auto") {
      return !BrowserHelper.isMobileSafari;
    }
    return liveResize;
  }
  //region Events
  onBeforeResizeStart({ event, element }) {
    const { client } = this;
    return !this.disabled && client.trigger("beforeColumnResize", {
      column: client.columns.getById(element.dataset.columnId),
      domEvent: event
    });
  }
  onResizeStart({ context }) {
    const { client, resizer } = this, column = context.column = client.columns.getById(context.element.dataset.columnId), { allRecords: siblings } = column.subGrid.columns;
    resizer.minWidth = column.minWidth;
    context.subGridBoundary = column.element.getBoundingClientRect()[client.rtl ? "left" : "right"];
    client.element.classList.add("b-column-resizing");
    siblings.slice(0, siblings.indexOf(column)).forEach((c) => {
      c.flex && c.element && c !== column.parent && c.set({
        width: c.element.offsetWidth,
        flex: ""
      });
    });
    client.trigger("columnResizeStart", {
      column,
      domEvent: context.event
    });
  }
  /**
   * Handle drag event - resize the column live unless it's a touch gesture
   * @private
   */
  onResizing({ context }) {
    if (context.valid && this.liveResize) {
      const { column } = context, { subGrid } = column, { scrollable, columns } = subGrid, { rtl } = this.client;
      this.client.resizingColumns = true;
      column.width = context.newWidth;
      subGrid.refreshFakeScroll();
      if (column === columns.last && (rtl ? context.currentX < context.subGridBoundary : context.currentX > context.subGridBoundary)) {
        scrollable.x = scrollable.maxX;
      }
    }
  }
  /**
   * Handle drop event (only used for touch)
   * @fires columnResize
   * @private
   */
  onResize({ context }) {
    const { client } = this, { column, event } = context;
    client.element.classList.remove("b-column-resizing");
    if (context.valid) {
      if (this.liveResize) {
        client.resizingColumns = false;
        client.afterColumnsResized(column);
      } else {
        column.width = context.newWidth;
      }
      client.trigger("columnResize", { column, domEvent: event });
    }
  }
  /**
   * Restore column width on cancel (ESC)
   * @private
   */
  onCancel({ context }) {
    const { client } = this;
    client.element.classList.remove("b-column-resizing");
    context.column.width = context.elementWidth;
    client.resizingColumns = false;
  }
  //endregion
};
__publicField(ColumnResize, "$name", "ColumnResize");
__publicField(ColumnResize, "configurable", {
  /**
   * Resize all cells below a resizing header during dragging.
   * `'auto'` means `true` on non-mobile platforms.
   * @config {'auto'|Boolean}
   * @default
   */
  liveResize: "auto"
});
ColumnResize._$name = "ColumnResize";
GridFeatureManager.registerFeature(ColumnResize, true);

// lib/Grid/feature/FillHandle.js
var FillHandle = class extends InstancePlugin.mixin(Delayable_default) {
  constructor() {
    super(...arguments);
    __publicField(this, "delayable", {
      handleSelection: "raf"
    });
  }
  afterConstruct() {
    super.afterConstruct();
    const { client } = this;
    if (!client.selectionMode.cell) {
      this.disabled = true;
    }
    client.ion({
      startCellEdit: "onStartCellEdit",
      finishCellEdit: "onFinishCellEdit",
      cancelCellEdit: "onFinishCellEdit",
      thisObj: this
    });
    this._fillListeners = {};
  }
  onContentChange() {
    this.handleSelection(true);
  }
  fixElementHeights() {
    this.handleSelection();
  }
  // This function is called if a subgrid changes width
  syncFlexedSubCols() {
    this.handleSelection();
  }
  // FillHandle elements needs to be removed while resize is calculating overflow
  beforeSubGridInternalResize() {
    this.removeElements();
  }
  onStoreRemove(event) {
    if (event.isCollapse) {
      this.handleSelection(true);
    }
  }
  onStartCellEdit() {
    this.removeElements(false);
  }
  onFinishCellEdit() {
    this.handleSelection();
  }
  getCellDataFromEvent(event, includeSingleAxisMatch) {
    if (includeSingleAxisMatch) {
      includeSingleAxisMatch = !event.target.classList.contains("b-fill-handle");
    }
    return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);
  }
  // region Pattern recognition
  findPatternsIn2dRange(range, horizontal, negative) {
    const values = {};
    for (const cell of range) {
      const id = horizontal ? cell.id : cell.columnId;
      let value = cell.record.getValue(cell.column.field);
      if (value && typeof value === "string" && !isNaN(value)) {
        value = parseFloat(value);
      }
      if (!values[id]) {
        values[id] = [];
      }
      values[id].push(value);
    }
    for (const rowOrCol in values) {
      values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);
    }
    return values;
  }
  findPatternsIn1dRange(range, negative) {
    const lastValue = range[negative ? 0 : range.length - 1], pattern = {
      next: () => lastValue,
      lastValue
    };
    if (range.every((val) => typeof val === "number") || range.every((val) => val instanceof Date)) {
      const diffs = range.map((val, ix) => val - range[ix - 1]);
      diffs.shift();
      if (new Set(diffs).size === 1) {
        pattern.increaseBy = diffs[0] * (negative ? -1 : 1);
        pattern.next = () => {
          if (pattern.lastValue instanceof Date) {
            pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);
          } else {
            pattern.lastValue += pattern.increaseBy;
          }
          return pattern.lastValue;
        };
      }
    } else if (range.length > 1) {
      pattern.stringPattern = [...range];
      pattern.next = () => {
        if (pattern.currentIndex === void 0) {
          pattern.currentIndex = 0;
        } else {
          pattern.currentIndex += 1;
          if (pattern.currentIndex >= pattern.stringPattern.length) {
            pattern.currentIndex = 0;
          }
        }
        return pattern.stringPattern[pattern.currentIndex];
      };
    }
    return pattern;
  }
  // endregion
  afterSelectionChange() {
    const me = this;
    if (me.client.readOnly || me.disabled) {
      me.removeElements();
      return;
    }
    if (GlobalEvents_default.isMouseDown()) {
      me.client.delayUntilMouseUp(() => me.handleSelection(true));
      me.removeElements();
    } else {
      me.handleSelection(true);
    }
  }
  /**
   * Checks selection and sees to it that fill handle and border is drawn.
   * Runs on next animation frame
   * @internal
   */
  handleSelection(clearCache = false) {
    if (this.enabled && !this._isExtending) {
      if (clearCache) {
        this._cachedSelectedRange = null;
      }
      const range = this.rangeSelection;
      if (range) {
        this.drawFillHandleAndBorder(range[0], range[range.length - 1]);
      } else {
        this.removeElements();
      }
    }
  }
  // region Mouse events
  // On fillHandle mouse down only
  onMouseDown(domEvent) {
    const { client } = this;
    if (this.enabled && !client.readOnly && client.trigger("beforeFillHandleDragStart", {
      cell: client.focusedCell,
      domEvent
    }) !== false) {
      this._fillListeners.mouseMoveOrUp = EventHelper.on({
        element: globalThis,
        keydown: "onKeyDown",
        mouseenter: {
          handler: "onMouseOver",
          delegate: ".b-grid-cell",
          element: client.selectionDragMouseEventListenerElement
        },
        capture: true,
        mouseup: "onMouseUp",
        thisObj: this
      });
      domEvent.preventDefault();
      domEvent.stopImmediatePropagation();
      domEvent.handled = true;
      client.trigger("fillHandleDragStart", { cell: client.focusedCell, domEvent });
    }
  }
  // Responsible for doing the filling
  async onMouseUp(domEvent) {
    const result = await this.client.trigger("fillHandleBeforeDragFinalize", { ...this.currentRange, domEvent }) !== false;
    this.finalize(result, domEvent);
  }
  finalize(commit, domEvent = true) {
    var _a4, _b, _c;
    const me = this, {
      client,
      currentRange,
      _isCropping
    } = me, range = me.rangeSelection, selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to), selectedCells = (selectionChange == null ? void 0 : selectionChange.selectedCells) || [], extensionCells = _isCropping ? me.croppingCells : selectedCells.filter((cell) => !range.some((sel) => sel.equals(cell, true)));
    me._isCropping = null;
    if (me._isExtending) {
      client.disableScrollingCloseToEdges(client.items);
      me._isExtending = null;
    }
    if (!(extensionCells == null ? void 0 : extensionCells.length) || !commit) {
      me.currentRange = null;
      me.handleSelection();
      client.trigger("fillHandleDragAbort", { cell: client.focusedCell });
      return;
    }
    client.suspendRefresh();
    if (_isCropping) {
      extensionCells.forEach((cell) => cell.record.set(cell.column.field, null, false, false, false, true));
    } else {
      const [firstCell] = extensionCells, horizontal = range.some((sel) => sel.record === firstCell.record), negative = horizontal ? firstCell.columnIndex < range[0].columnIndex : firstCell.rowIndex < range[0].rowIndex, patterns = me.findPatternsIn2dRange(range, horizontal, negative), changeMap = /* @__PURE__ */ new Map();
      if (negative) {
        extensionCells.reverse();
      }
      for (const cell of extensionCells) {
        const { column, record } = cell;
        if (!record.readOnly && !column.readOnly && column.canFillValue({ range, record, cell }) && ((_a4 = record.isEditable) == null ? void 0 : _a4.call(record, column.field)) !== false) {
          let value = (_b = me.calculateFillValue) == null ? void 0 : _b.call(me, { range, column, record, cell }), changed = changeMap.get(record);
          if (!changed) {
            changed = {};
            changeMap.set(record, changed);
          }
          if (value === void 0) {
            const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;
            value = pattern.next();
          }
          changed[column.field] = ((_c = column.calculateFillValue) == null ? void 0 : _c.call(column, { value, record, range })) || value;
        }
      }
      for (const [record, changes] of changeMap) {
        record.set(changes, null, null, null, null, true);
      }
    }
    client.resumeRefresh(true);
    client.performSelection(selectionChange);
    me.currentRange = null;
    me.handleSelection();
    client.trigger("fillHandleDragEnd", { ...currentRange, domEvent });
  }
  // The fill border and handle should refresh on mouse move
  onMouseOver(domEvent) {
    var _a4;
    const me = this, {
      client,
      rangeSelection
    } = me, first = rangeSelection[0], last = rangeSelection[rangeSelection.length - 1], cellData = client.getCellDataFromEvent(domEvent, true);
    let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);
    if (((_a4 = cellSelector == null ? void 0 : cellSelector._column) == null ? void 0 : _a4.region) === first._column.region) {
      const equalOrSmaller = rangeSelection.some((cs) => cs.equals(cellSelector, true));
      let negative;
      if (!me._isExtending) {
        client.enableScrollingCloseToEdges(client.items);
      }
      if (equalOrSmaller) {
        me._isCropping = me.allowCropping && (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);
      } else {
        if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {
          negative = first.columnIndex > cellSelector.columnIndex;
          cellSelector = new Location({
            grid: client,
            record: negative ? first.record : last.record,
            column: cellSelector.column
          });
        } else {
          negative = first.rowIndex > cellSelector.rowIndex;
          cellSelector = new Location({
            grid: client,
            record: cellSelector.record,
            column: negative ? first.column : last.column
          });
        }
      }
      const from = negative ? cellSelector : first, to = negative || equalOrSmaller && !me._isCropping ? last : cellSelector;
      me.currentRange = { from, to };
      me._isExtending = true;
      me.drawFillHandleAndBorder(from, to, true);
      client.trigger("fillHandleDrag", { from, to, domEvent });
    }
  }
  // endregion
  // region Creating, updating and removing fillhandle and fillborder
  drawFillHandleAndBorder(from, to, keepListeners = false) {
    var _a4;
    const me = this, {
      client,
      currentRange,
      _fillListeners
    } = me, regionEl = client.subGrids[from.column.region].element, { x } = Rectangle.from(from.cell || from.column.element, regionEl), { right } = Rectangle.from(to.cell || to.column.element, regionEl), { y } = client.getRecordCoords(from.record, true), bottom = client.getRecordCoords(to.record, true).bottom - 1;
    let {
      borderElement,
      handleElement
    } = me;
    me.removeElements(keepListeners);
    if (!borderElement) {
      me.borderElement = borderElement = DomHelper.createElement({
        className: "b-fill-selection-border"
      });
      me.handleElement = handleElement = DomHelper.createElement({
        className: "b-fill-handle"
      });
    }
    DomHelper.setRect(borderElement, { y, x, width: right - x, height: bottom - y });
    regionEl.appendChild(borderElement);
    handleElement.classList.toggle("b-fill-handle-right-edge", right >= regionEl.scrollWidth - 1);
    DomHelper.setTopLeft(handleElement, bottom, right);
    regionEl.appendChild(handleElement);
    me.toggleCroppingCls(false);
    me.croppingCells = null;
    if (me._isCropping && ((_a4 = me.rangeSelection) == null ? void 0 : _a4.length)) {
      const newCells = client.getRange(currentRange.from, currentRange.to);
      me.croppingCells = me.rangeSelection.filter((sel) => !newCells.some((cell) => cell.equals(sel, true)));
      me.toggleCroppingCls();
    }
    if (!_fillListeners.handleClick) {
      _fillListeners.handleClick = EventHelper.on({
        element: client.rootElement,
        delegate: ".b-fill-handle",
        mousedown: "onMouseDown",
        thisObj: me
      });
    }
    me.hasFillElements = true;
  }
  toggleCroppingCls(add = true) {
    var _a4;
    (_a4 = this.croppingCells) == null ? void 0 : _a4.forEach((sel) => {
      var _a5;
      return (_a5 = this.client.getCell(sel)) == null ? void 0 : _a5.classList.toggle("b-indicate-crop", add);
    });
  }
  removeElements(keepListeners = false) {
    var _a4, _b;
    const me = this;
    (_a4 = me.handleElement) == null ? void 0 : _a4.remove();
    (_b = me.borderElement) == null ? void 0 : _b.remove();
    if (!keepListeners) {
      me.removeListeners();
    }
    me.hasFillElements = false;
  }
  // Detach listeners
  removeListeners() {
    const me = this;
    for (const listener in me._fillListeners) {
      me._fillListeners[listener]();
    }
    me._fillListeners = {};
  }
  // endregion
  // Gets current selection range. Only allows for single range or single cell.
  get rangeSelection() {
    if (!this._cachedSelectedRange) {
      this._cachedSelectedRange = this.currentSelectedRange;
    }
    return this._cachedSelectedRange;
  }
  // Calculate cell ranges
  get currentSelectedRange() {
    const { client } = this, { store } = client;
    let { selectedCells } = client;
    if (!client._selectedRows.length && selectedCells.length && selectedCells.every(({ record }) => store.indexOf(record) >= 0)) {
      if (selectedCells.length > 1) {
        selectedCells = selectedCells.sort((a, b) => a.rowIndex - b.rowIndex || a.columnIndex - b.columnIndex);
        const [first] = selectedCells, [last] = selectedCells.slice(-1), startRow = first.rowIndex, startCol = first.columnIndex, region = first.region, endRow = last.rowIndex, endCol = last.columnIndex, cellCount = (endCol - startCol + 1) * (endRow - startRow + 1);
        if (selectedCells.length === cellCount && selectedCells.every((cell) => cell.region === region && cell.rowIndex >= startRow && cell.rowIndex <= endRow && cell.columnIndex >= startCol && cell.columnIndex <= endCol)) {
          return selectedCells;
        }
      } else {
        return selectedCells;
      }
    }
  }
  onKeyDown(event) {
    if (event.key === "Escape") {
      this.abort();
    }
  }
  /**
   * Aborts an ongoing FillHandle drag operation
   */
  abort() {
    this.finalize(false);
    this.reset();
  }
  reset() {
    this._isExtending = this._isCropping = this.currentRange = this.croppingCells = null;
  }
  doDisable(disable) {
    this.removeElements();
    this.reset();
    super.doDisable(disable);
  }
};
__publicField(FillHandle, "$name", "FillHandle");
// region Events
/**
 * Fired before dragging of the FillHandle starts, return `false` to prevent the drag operation.
 * @preventable
 * @event beforeFillHandleDragStart
 * @param {Grid.util.Location} cell Information about the column / record
 * @param {MouseEvent} domEvent The raw DOM event
 * @on-owner
 */
/**
 * Fired when dragging of the FillHandle starts.
 * @preventable
 * @event fillHandleDragStart
 * @param {Grid.util.Location} cell Information about the column / record
 * @param {MouseEvent} domEvent The raw DOM event
 * @on-owner
 */
/**
 * Fired while dragging the FillHandle.
 * @event fillHandleDrag
 * @param {Grid.util.Location} from The from cell
 * @param {Grid.util.Location} to The to cell
 * @param {MouseEvent} domEvent The raw DOM event
 * @on-owner
 */
/**
 * Fired before the FillHandle dragging is finalized and values are applied to cells, return `false` to prevent the
 * drag operation from applying data changes.
 * @preventable
 * @async
 * @event fillHandleBeforeDragFinalize
 * @param {Grid.util.Location} from The from cell
 * @param {Grid.util.Location} to The to cell
 * @param {MouseEvent} domEvent The raw DOM event
 * @on-owner
 */
/**
 * Fired after a FillHandle drag operation.
 * @event fillHandleDragEnd
 * @param {Grid.util.Location} from The from cell
 * @param {Grid.util.Location} to The to cell
 * @param {MouseEvent} domEvent The raw DOM event
 * @on-owner
 */
/**
 * Fired when a FillHandle drag operation is aborted.
 * @event fillHandleDragAbort
 * @on-owner
 */
// endregion
__publicField(FillHandle, "configurable", {
  /**
   * Implement this function to be able to customize the value that cells will be filled with.
   * Return `undefined` to use default calculations.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        fillHandle : {
   *           calculateFillValue({cell, column, range, record}) {
   *              if(column.field === 'number') {
   *                 return range.reduce(
   *                    (sum, location) => sum + location.record[location.column.field]
   *                 );
   *              }
   *           }
   *        }
   *    }
   * });
   * ```
   *
   * @param {Object} data Object containing information about current cell and fill value
   * @param {Grid.util.Location} data.cell Current cell data
   * @param {Grid.column.Column} data.column Current cell column
   * @param {Grid.util.Location[]} data.range Range from where to calculate values
   * @param {Core.data.Model} data.record Current cell record
   * @returns {String|Number|Date} Value to fill current cell
   * @config {Function}
   */
  calculateFillValue: null,
  /**
   * Set to `true` to enable the fill range to crop the original selected range. This clears the cells which were
   * a part of the original selected range, but are no longer a part of the smaller range.
   * @config {Boolean}
   */
  allowCropping: false
});
// Plugin configuration. This plugin chains/overrides some functions in Grid.
__publicField(FillHandle, "pluginConfig", {
  before: ["onStoreRemove"],
  chain: [
    "afterSelectionChange",
    "onContentChange",
    "fixElementHeights",
    "syncFlexedSubCols",
    "beforeSubGridInternalResize"
  ],
  override: ["getCellDataFromEvent"]
});
FillHandle._$name = "FillHandle";
GridFeatureManager.registerFeature(FillHandle);

// lib/Grid/widget/GridFieldFilterPicker.js
var _GridFieldFilterPicker = class _GridFieldFilterPicker extends FieldFilterPicker {
  //region Config
  static get $name() {
    return "GridFieldFilterPicker";
  }
  // Factoryable type name
  static get type() {
    return "gridfieldfilterpicker";
  }
  //endregion
  afterConstruct() {
    var _a4;
    const me = this;
    if (!me.grid) {
      throw new Error(`${me.constructor.$name} requires 'grid' to be configured.`);
    }
    me.fields = (_a4 = me.fields) != null ? _a4 : {};
    super.afterConstruct();
  }
  updateGrid(newGrid) {
    var _a4;
    if (!((_a4 = newGrid.store) == null ? void 0 : _a4.modelClass)) {
      throw new Error(`Grid does not have a store with a modelClass defined.`);
    }
    if (!newGrid.columns) {
      throw new Error(`Grid does not have a column store.`);
    }
  }
  /**
   * Gets the filterable fields backing any of the configured `grid`'s columns, for those columns for which
   * it is possible to do so.
   * @private
   * @returns {Object} Filterable fields dictionary of the form { [fieldName]: { title, type } }
   */
  static getColumnFields(columnStore, modelClass, allowedFieldNames) {
    var _a4;
    return Object.fromEntries(
      (_a4 = columnStore == null ? void 0 : columnStore.bottomColumns.reduce(
        (outFields, { field: fieldName, text, filterType, filterable }) => {
          var _a5;
          if (!allowedFieldNames || allowedFieldNames.includes(fieldName)) {
            const field = fieldName && modelClass.getFieldDefinition(fieldName), fieldType = isFilterableField(field) ? field.type : void 0;
            if (fieldType || filterType || filterable) {
              outFields.push([
                fieldName,
                {
                  title: text || fieldName,
                  type: (_a5 = filterType != null ? filterType : isSupportedDurationField(field) ? "duration" : fieldType) != null ? _a5 : "auto"
                }
              ]);
            }
          }
          return outFields;
        },
        []
      )) != null ? _a4 : []
    );
  }
  changeFields(newFields) {
    var _a4;
    let localFields = newFields;
    if (Array.isArray(newFields)) {
      VersionHelper.deprecate("Core", "6.0.0", "FieldOption[] deprecated, use Object<String, FieldOption[]> keyed by field name instead");
      localFields = ArrayHelper.keyBy(localFields, "name");
    }
    const mergedFields = ObjectHelper.merge(
      {},
      _GridFieldFilterPicker.getColumnFields(this.grid.columns, (_a4 = this.grid.store) == null ? void 0 : _a4.modelClass),
      localFields
    );
    return this.allowedFieldNames ? Object.fromEntries(this.allowedFieldNames.map((fieldName) => [fieldName, mergedFields[fieldName]])) : mergedFields;
  }
};
/**
 * @hideconfigs store
 */
__publicField(_GridFieldFilterPicker, "configurable", {
  /**
   * {@link Grid.view.Grid} from which to read the available field list. In order to
   * appear as a selectable property for a filter, a column must have a `field` property.
   * If the column has a `text` property, that will be shown as the displayed text in the
   * selector; otherwise, the `field` property will be shown as-is.
   *
   * The grid's {@link Core.data.Store}'s {@link Core.data.Store#property-modelClass} will be
   * examined to find field data types.
   *
   * You can limit available fields to a subset of the grid's columns using the
   * {@link #config-allowedFieldNames} configuration property.
   *
   * @config {Grid.view.Grid}
   */
  grid: null,
  /**
   * Optional array of field names that are allowed as selectable properties for filters.
   * This is a subset of the field names found in the {@link #config-grid}'s columns. When supplied, only
   * the named fields will be shown in the property selector combo.
   *
   * Note that field names are case-sensitive and should match the data field name in the store
   * model.
   *
   * @config {String[]}
   */
  allowedFieldNames: null
});
var GridFieldFilterPicker = _GridFieldFilterPicker;
GridFieldFilterPicker.initClass();
GridFieldFilterPicker._$name = "GridFieldFilterPicker";

// lib/Grid/widget/GridFieldFilterPickerGroup.js
var GridFieldFilterPickerGroup = class extends FieldFilterPickerGroup {
  //region Config
  static get $name() {
    return "GridFieldFilterPickerGroup";
  }
  // Factoryable type name
  static get type() {
    return "gridfieldfilterpickergroup";
  }
  validateConfig() {
    if (!this.grid) {
      throw new Error(`${this.constructor.$name} requires the 'grid' config property.`);
    }
  }
  getFilterPickerConfig(filter) {
    const { grid, allowedFieldNames, fields } = this;
    return {
      ...super.getFilterPickerConfig(filter),
      fields,
      grid,
      allowedFieldNames
    };
  }
  updateGrid(newGrid) {
    this.store = this.grid.store;
  }
  /**
   * @private
   */
  canManage(filter) {
    const me = this;
    return super.canManage(filter) && (!me.allowedFieldNames || me.allowedFieldNames.includes(filter.property));
  }
};
/**
 * @hideconfigs fields, store
 */
__publicField(GridFieldFilterPickerGroup, "configurable", {
  /**
   * {@link Grid.view.Grid} from which to read the available field list. In order to
   * appear as a selectable property for a filter, a column must have a `field` property.
   * If the column has a `text` property, that will be shown as the displayed text in the
   * selector; otherwise, the `field` property will be shown as-is.
   *
   * The grid's {@link Core.data.Store}'s {@link Core.data.Store#property-modelClass} will be
   * examined to find field data types.
   *
   * You can limit available fields to a subset of the grid's columns using the
   * {@link #config-allowedFieldNames} configuration property.
   *
   * @config {Grid.view.Grid}
   */
  grid: null,
  /**
   * Optional array of field names that are allowed as selectable properties for filters.
   * This should be a subset of the field names found in the {@link #config-grid}'s store. When supplied,
   * only the named fields will be shown in the property selector combo.
   *
   * @config {String[]}
   */
  allowedFieldNames: null
});
//endregion
__publicField(GridFieldFilterPickerGroup, "childPickerType", "gridfieldfilterpicker");
GridFieldFilterPickerGroup.initClass();
GridFieldFilterPickerGroup._$name = "GridFieldFilterPickerGroup";

// lib/Grid/feature/Filter.js
var fieldTypeMap = {
  date: "date",
  int: "number",
  integer: "number",
  number: "number",
  string: "string",
  duration: "duration",
  time: "time",
  auto: "auto"
};
var allowedFilterTypes = {
  ...filterableFieldDataTypes,
  relation: true
};
var menuItemsWithSeparators = {
  filterDateIsToday: true,
  filterDateIsThisWeek: true,
  filterDateIsThisMonth: true,
  filterDateIsThisYear: true
};
var Filter = class extends InstancePlugin {
  //region Init
  static get $name() {
    return "Filter";
  }
  static get configurable() {
    return {
      /**
       * Use custom filtering functions defined on columns also when programmatically filtering by the columns
       * field.
       *
       * ```javascript
       * const grid = new Grid({
       *     columns : [
       *         {
       *             field : 'age',
       *             text : 'Age',
       *             filterable({ record, value }) {
       *               // Custom filtering, return true/false
       *             }
       *         }
       *     ],
       *
       *     features : {
       *         filter : {
       *             prioritizeColumns : true // <--
       *         }
       *     }
       * });
       *
       * // Because of the prioritizeColumns config above, any custom
       * // filterable function on a column will be used when
       * // programmatically filtering by that columns field
       * grid.store.filter({
       *     property : 'age',
       *     value    : 30
       * });
       * ```
       *
       * @config {Boolean}
       * @default
       * @category Common
       */
      prioritizeColumns: false,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>}
       */
      keyMap: {
        f: "showFilterEditorByKey"
      },
      /**
       * Set to `true` to enable the more limited legacy UI mode.
       *
       * @config {Boolean}
       * @default
       * @category Common
       */
      legacyMode: false,
      /**
       * Optional configuration to use when configuring the {@link Grid.widget.GridFieldFilterPickerGroup} shown in the
       * column header popup, when not in legacy mode.
       *
       * @config {GridFieldFilterPickerGroupConfig}
       * @category Common
       */
      pickerConfig: null,
      /**
       * When true, close the popup when the last filter shown in the popup is removed using the remove button. Not
       * applicable in legacy mode.
       *
       * @config {Boolean}
       * @default
       * @category Common
       */
      closeEmptyPopup: false,
      /**
       * The value against which to compare the {@link #config-property} of candidate objects.
       * @config {*}
       */
      value: null,
      /**
       * The name of a property of candidate objects which yields the value to compare.
       * @config {String}
       */
      property: null,
      /**
       * The operator to use when comparing a candidate object's {@link #config-property}.
       * @config {CollectionCompareOperator}
       */
      operator: null,
      /**
       * Which operator to pre-fill for the blank filter shown by default in the filter pop-up, keyed by
       * the column field's data type. See {@link Core.util.CollectionFilter#typedef-CollectionCompareOperator}
       * for available operators.
       *
       * Default value:
       *
       * ```javascript
       * {
       *     date     : '=',
       *     number   : '=',
       *     string   : 'includes',
       *     duration : '=',
       *     relation : null,
       *     auto     : '*'
       * }
       * ```
       *
       * @config {Object}
       */
      defaultOperators: {
        date: "=",
        number: "=",
        string: "includes",
        duration: "=",
        relation: null,
        auto: "*"
      }
    };
  }
  construct(grid, config) {
    if (grid.features.filterBar) {
      throw new Error("Grid.feature.Filter feature may not be used together with Grid.feature.FilterBar. These features are mutually exclusive.");
    }
    const me = this;
    me.grid = grid;
    me.closeFilterEditor = me.closeFilterEditor.bind(me);
    if (config == null ? void 0 : config.isMulti) {
      VersionHelper.deprecate("Grid", "6.0.0", "Filter plugin config isMulti deprecated, use pickerConfig instead");
      if (typeof config.isMulti === "object") {
        config.pickerConfig = config.isMulti;
      }
      delete config.isMulti;
    }
    super.construct(grid, config);
    me.bindStore(grid.store);
    if (config && typeof config === "object") {
      const clone = ObjectHelper.clone(config);
      delete clone.prioritizeColumns;
      delete clone.legacyMode;
      delete clone.pickerConfig;
      delete clone.dateFormat;
      delete clone.closeEmptyPopup;
      delete clone.defaultOperators;
      if (!ObjectHelper.isEmpty(clone)) {
        grid.store.filter(clone, null, grid.isConfiguring);
      }
    }
  }
  doDestroy() {
    var _a4, _b;
    (_a4 = this.filterTip) == null ? void 0 : _a4.destroy();
    (_b = this.filterEditorPopup) == null ? void 0 : _b.destroy();
    super.doDestroy();
  }
  get store() {
    return this.grid.store;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeFilter: "onStoreBeforeFilter",
      filter: "onStoreFilter",
      thisObj: this
    });
    if (this.client.isPainted) {
      this.refreshHeaders(false);
    }
  }
  //endregion
  //region Plugin config
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ["renderHeader", "populateCellMenu", "populateHeaderMenu", "onElementClick", "bindStore"]
    };
  }
  //endregion
  //region Refresh headers
  /**
   * Update headers to match stores filters. Called on store load and grid header render.
   * @param reRenderRows Also refresh rows?
   * @private
   */
  refreshHeaders(reRenderRows) {
    const me = this, grid = me.grid, element = grid.headerContainer;
    if (element) {
      DomHelper.children(element, ".b-filter-icon.b-latest").forEach((iconElement) => iconElement.classList.remove("b-latest"));
      if (!me.filterTip) {
        me.filterTip = new Tooltip({
          forElement: element,
          forSelector: ".b-filter-icon",
          getHtml({ activeTarget }) {
            return activeTarget.dataset.filterText;
          }
        });
      }
      if (!grid.store.isFiltered) {
        me.filterTip.hide();
      }
      grid.columns.visibleColumns.forEach((column) => {
        if (column.filterable !== false) {
          const columnFilters = me.store.filters.allValues.filter(({ property, disabled, internal }) => property === column.field && !disabled && !internal), isColumnFiltered = columnFilters.length > 0, headerEl = column.element;
          if (headerEl) {
            const textEl = column.textWrapper;
            let filterIconEl = textEl == null ? void 0 : textEl.querySelector(".b-filter-icon"), filterText;
            if (isColumnFiltered) {
              const bullet = "&#x2022 ";
              filterText = `${me.L("L{filter}")}: ` + (columnFilters.length > 1 ? "<br/><br/>" : "") + columnFilters.map((columnFilter) => {
                var _a4, _b, _c, _d, _e;
                let value = (_a4 = columnFilter.value) != null ? _a4 : "";
                const isArray3 = Array.isArray(value), relation = (_c = (_b = me.store) == null ? void 0 : _b.modelRelations) == null ? void 0 : _c.find(
                  ({ foreignKey }) => foreignKey === columnFilter.property
                );
                if (columnFilter.displayValue) {
                  value = columnFilter.displayValue;
                } else {
                  if (!me.legacyMode && relation) {
                    const { relatedDisplayField } = (_e = (_d = me.pickerConfig) == null ? void 0 : _d.fields) == null ? void 0 : _e[columnFilter.property];
                    if (relatedDisplayField) {
                      const getDisplayValue = (foreignId) => {
                        var _a5;
                        return (_a5 = relation.foreignStore.getById(foreignId)) == null ? void 0 : _a5[relatedDisplayField];
                      };
                      if (isArray3) {
                        value = value.map(getDisplayValue).sort((a, b) => (a != null ? a : "").localeCompare(b != null ? b : ""));
                      } else {
                        value = getDisplayValue(value);
                      }
                    }
                  } else if (column.formatValue && value) {
                    value = isArray3 ? value.map((val) => column.formatValue(val)) : column.formatValue(value);
                  }
                  if (isArray3) {
                    value = `[ ${value.join(", ")} ]`;
                  }
                }
                return (columnFilters.length > 1 ? bullet : "") + (typeof columnFilter === "string" ? columnFilter : `${columnFilter.operator} ${value}`);
              }).join("<br/><br/>");
            } else {
              filterText = me.L("L{applyFilter}");
            }
            if (!filterIconEl) {
              filterIconEl = DomHelper.createElement({
                parent: textEl,
                tag: "div",
                className: "b-filter-icon",
                dataset: {
                  filterText
                }
              });
            } else {
              filterIconEl.dataset.filterText = filterText;
            }
            if (column.field === me.store.latestFilterField)
              filterIconEl.classList.add("b-latest");
            headerEl.classList.add("b-filterable");
            headerEl.classList.toggle("b-filter", isColumnFiltered);
          }
          column.meta.isFiltered = isColumnFiltered;
        }
      });
      if (reRenderRows) {
        grid.refreshRows();
      }
    }
  }
  //endregion
  //region Filter
  applyFilter(column, filterConfig) {
    const { store } = this;
    column.$filter = store.addFilter(this.injectColumnFilterConfig(column, filterConfig), true);
    store.filter();
  }
  injectColumnFilterConfig(column, filterConfig) {
    const { filterFn } = column.filterable;
    return ObjectHelper.assign(filterConfig, {
      ...column.filterable,
      ...filterConfig,
      property: column.field,
      // Only inject a filterBy configuration if the column has a custom filterBy
      [filterFn ? "filterBy" : "_"]: function(record) {
        return filterFn({ value: this.value, record, operator: this.operator, property: this.property, column });
      }
    });
  }
  removeFilter(column, onlyForOperator) {
    var _a4;
    if (!this.legacyMode && !((_a4 = column.filterable) == null ? void 0 : _a4.filterField)) {
      for (const filter of this.getCurrentMultiFilters(column)) {
        if (!onlyForOperator || filter.operator === onlyForOperator) {
          this.store.removeFilter(filter);
        }
      }
    } else {
      this.store.removeFilter(column.field);
    }
  }
  disableFilter(column) {
    for (const filter of this.getCurrentMultiFilters(column)) {
      filter.disabled = true;
      this.store.filter(filter);
    }
    this.store.filter();
  }
  getCurrentMultiFilters(column) {
    return this.store.filters.values.filter((filter) => filter.property === column.field);
  }
  getPopupDateItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onClose = changeCallback;
    function onClear() {
      me.removeFilter(column);
    }
    function onKeydown({ event }) {
      if (event.key === "Enter") {
        changeCallback();
      }
    }
    function onChange({ source, value }) {
      if (value == null) {
        onClear();
      } else {
        me.clearSiblingsFields(source);
        me.applyFilter(column, { operator: source.operator, value, displayValue: source._value, type: "date" });
      }
    }
    return [
      ObjectHelper.assign({
        type: "date",
        ref: "on",
        placeholder: "L{on}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
        value: (filter == null ? void 0 : filter.operator) === "sameDay" ? filter.value : initialValue,
        operator: "sameDay",
        onKeydown,
        onChange,
        onClose,
        onClear
      }, filterField),
      ObjectHelper.assign({
        type: "date",
        ref: "before",
        placeholder: "L{before}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-before"></i>',
        value: (filter == null ? void 0 : filter.operator) === "<" ? filter.value : null,
        operator: "<",
        onKeydown,
        onChange,
        onClose,
        onClear
      }, filterField),
      ObjectHelper.assign({
        type: "date",
        ref: "after",
        cls: "b-last-row",
        placeholder: "L{after}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-after"></i>',
        value: (filter == null ? void 0 : filter.operator) === ">" ? filter.value : null,
        operator: ">",
        onKeydown,
        onChange,
        onClose,
        onClear
      }, filterField)
    ];
  }
  getPopupNumberItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onEsc = changeCallback;
    function onClear() {
      me.removeFilter(column);
    }
    function onKeydown({ event }) {
      if (event.key === "Enter") {
        changeCallback();
      }
    }
    function onChange({ source, value }) {
      if (value == null) {
        onClear();
      } else {
        me.clearSiblingsFields(source);
        me.applyFilter(column, { operator: source.operator, value });
      }
    }
    return [
      ObjectHelper.assign({
        type: "number",
        placeholder: "L{Filter.equals}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
        value: (filter == null ? void 0 : filter.operator) === "=" ? filter.value : initialValue,
        operator: "=",
        onKeydown,
        onChange,
        onEsc,
        onClear
      }, filterField),
      ObjectHelper.assign({
        type: "number",
        placeholder: "L{lessThan}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-less"></i>',
        value: (filter == null ? void 0 : filter.operator) === "<" ? filter.value : null,
        operator: "<",
        onKeydown,
        onChange,
        onEsc,
        onClear
      }, filterField),
      ObjectHelper.assign({
        type: "number",
        cls: "b-last-row",
        placeholder: "L{moreThan}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-more"></i>',
        value: (filter == null ? void 0 : filter.operator) === ">" ? filter.value : null,
        operator: ">",
        onKeydown,
        onChange,
        onEsc,
        onClear
      }, filterField)
    ];
  }
  clearSiblingsFields(sourceField) {
    var _a4;
    (_a4 = this.filterEditorPopup) == null ? void 0 : _a4.items.forEach((field) => {
      field !== sourceField && (field == null ? void 0 : field.clear());
    });
  }
  getPopupDurationItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onEsc = changeCallback, onClear = () => me.removeFilter(column);
    function onChange({ source, value }) {
      if (value == null) {
        onClear();
      } else {
        me.clearSiblingsFields(source);
        me.applyFilter(column, { operator: source.operator, value });
      }
    }
    return [
      ObjectHelper.assign({
        type: "duration",
        placeholder: "L{Filter.equals}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
        value: (filter == null ? void 0 : filter.operator) === "=" ? filter.value : initialValue,
        operator: "=",
        onChange,
        onEsc,
        onClear
      }, filterField),
      ObjectHelper.assign({
        type: "duration",
        placeholder: "L{lessThan}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-less"></i>',
        value: (filter == null ? void 0 : filter.operator) === "<" ? filter.value : null,
        operator: "<",
        onChange,
        onEsc,
        onClear
      }, filterField),
      ObjectHelper.assign({
        type: "duration",
        cls: "b-last-row",
        placeholder: "L{moreThan}",
        localeClass: me,
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-more"></i>',
        value: (filter == null ? void 0 : filter.operator) === ">" ? filter.value : null,
        operator: ">",
        onChange,
        onEsc,
        onClear
      }, filterField)
    ];
  }
  getPopupStringItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this;
    return [ObjectHelper.assign({
      type: "text",
      cls: "b-last-row",
      placeholder: "L{filter}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: filter ? filter.value || filter : initialValue,
      operator: "*",
      onChange({ source, value }) {
        if (value === "") {
          closeCallback();
        } else {
          me.applyFilter(column, { operator: source.operator, value, displayValue: source.displayField && source.records ? source.records.map((rec) => rec[source.displayField]).join(", ") : void 0 });
          if (!source.multiSelect) {
            changeCallback();
          }
        }
      },
      onClose: changeCallback,
      onClear: closeCallback
    }, filterField)];
  }
  /**
   * Get fields to display in filter popup.
   * @param {Grid.column.Column} column Column
   * @param fieldType Type of field, number, date etc.
   * @param filter Current filter
   * @param initialValue
   * @param store Grid store
   * @param changeCallback Callback for when filter has changed
   * @param closeCallback Callback for when editor should be closed
   * @param filterField filter field
   * @returns {*}
   * @private
   */
  getPopupItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this;
    if (me.useLegacyModeForColumn(column) || filterField) {
      switch (fieldType) {
        case "date":
          return me.getPopupDateItems(...arguments);
        case "number":
          return me.getPopupNumberItems(...arguments);
        case "duration":
          return me.getPopupDurationItems(...arguments);
        default:
          return me.getPopupStringItems(...arguments);
      }
    }
    return [me.getFieldFilterPickerGroup(column)];
  }
  getFieldFilterPickerGroup(column) {
    const me = this;
    return {
      ...me.pickerConfig,
      type: "gridfieldfilterpickergroup",
      ref: "pickerGroup",
      limitToProperty: column.field,
      grid: me.grid,
      propertyFieldCls: "b-transparent property-field",
      operatorFieldCls: "b-transparent operator-field",
      valueFieldCls: "b-transparent value-field",
      internalListeners: {
        beforeAddFilter: ({ filter }) => {
          me.injectColumnFilterConfig(column, filter);
        },
        remove: me.onPopupFilterRemove,
        keydown: me.onPopupKeydown,
        thisObj: me
      },
      triggerChangeOnInput: false
    };
  }
  onPopupFilterRemove() {
    if (this.closeEmptyPopup && this.filterEditorPopup.widgetMap.pickerGroup.filters.length === 0) {
      this.delay(this.closeFilterEditor, 0);
    }
  }
  onPopupKeydown({ event }) {
    if (event.key === "Enter") {
      this.delay(this.closeFilterEditor, 0);
    }
  }
  /**
   * Shows a popup where a filter can be edited.
   * @param {Grid.column.Column|String} column Column to show filter editor for
   * @param {*} [value] The initial value of the filter value input
   * @param {String} [operator] The initial operator of the filter operator selector (non-legacy mode)
   * @param {Boolean} [forceAddBlank] Whether to add a blank filter row even if other filters exist
   *                  (non-legacy mode; default false)
   */
  showFilterEditor(column, value, operator, forceAddBlank = false) {
    var _a4, _b, _c, _d, _e;
    column = this.grid.columns.getById(column);
    const me = this, { store } = me, headerEl = column.element, filter = store.filters.getBy("property", column.field), fieldType = me.getFilterType(column), legacyMode = me.useLegacyModeForColumn(column);
    if (column.filterable === false) {
      return;
    }
    me.closeFilterEditor();
    const items2 = me.getPopupItems(
      column,
      fieldType,
      // Only pass filter if it's not an internal filter
      (filter == null ? void 0 : filter.internal) ? null : filter,
      value,
      store,
      me.closeFilterEditor,
      () => {
        me.removeFilter(column);
        me.closeFilterEditor();
      },
      column.filterable.filterField
    );
    items2.forEach((item) => item.placeholder = item.placeholder ? this.L(item.placeholder) : item.placeholder);
    me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {
      owner: me.grid,
      cls: new DomClassList("b-filter-popup", {
        "b-filter-popup-legacymode": legacyMode
      }),
      scrollAction: "realign",
      layout: {
        type: "vbox",
        align: "stretch"
      },
      items: items2
    });
    if (!legacyMode) {
      if (forceAddBlank || !((_a4 = me.grid.store) == null ? void 0 : _a4.filters.find((filter2) => filter2.property === column.field))) {
        const operatorsByType = (_b = me.filterEditorPopup.widgetMap.pickerGroup.operators) != null ? _b : FieldFilterPicker.configurable.operators, availableOperators = operatorsByType[fieldType], defaultOperator = me.defaultOperators[fieldType];
        me.filterEditorPopup.widgetMap.pickerGroup.addFilter({
          type: fieldType,
          property: column.field,
          operator: (_e = operator != null ? operator : (
            // Use defaultOperator if it's allowed by the picker, otherwise take the first option
            (_c = availableOperators.find(({ value: value2 }) => value2 === defaultOperator)) == null ? void 0 : _c.value
          )) != null ? _e : (_d = availableOperators[0]) == null ? void 0 : _d.value,
          value
        });
      }
      me.filterEditorPopup.items[0].focus();
    }
  }
  /**
   * Close the filter editor.
   */
  closeFilterEditor() {
    var _a4;
    (_a4 = this.filterEditorPopup) == null ? void 0 : _a4.setTimeout(this.filterEditorPopup.destroy);
    this.filterEditorPopup = null;
  }
  //endregion
  //region Context menu
  getFilterType(column) {
    var _a4, _b, _c, _d;
    const fieldName = column.field, field = fieldName && this.client.store.modelClass.getFieldDefinition(fieldName), type = (_b = (_a4 = column.filterType) != null ? _a4 : fieldTypeMap[column.type]) != null ? _b : fieldTypeMap[field == null ? void 0 : field.type], relation = (_d = (_c = this.store) == null ? void 0 : _c.modelRelations) == null ? void 0 : _d.find(({ foreignKey }) => foreignKey === fieldName);
    if (relation) {
      return "relation";
    } else if (type === "auto" && this.store && !this.useLegacyModeForColumn(column)) {
      return FieldFilterPicker.inferFieldType(this.store, fieldName);
    } else if (type) {
      return fieldTypeMap[type];
    }
    return "auto";
  }
  populateCellMenuWithDateItems({ column, record, items: items2 }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "date") {
      const me = this, value = record.getValue(property), filter = (operator) => {
        me.applyFilter(column, {
          operator,
          value,
          displayValue: column.formatValue ? column.formatValue(value) : value,
          type: "date"
        });
      };
      items2.filterDateEquals = {
        text: "L{on}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter("=")
      };
      items2.filterDateBefore = {
        text: "L{before}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-before",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter("<")
      };
      items2.filterDateAfter = {
        text: "L{after}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-after",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter(">")
      };
    }
  }
  populateCellMenuWithNumberItems({ column, record, items: items2 }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "number") {
      const me = this, value = record.getValue(property), filter = (operator) => {
        me.applyFilter(column, { operator, value });
      };
      items2.filterNumberEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter("=")
      };
      items2.filterNumberLess = {
        text: "L{lessThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-less",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter("<")
      };
      items2.filterNumberMore = {
        text: "L{moreThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-more",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter(">")
      };
    }
  }
  addMenuItemsForDataType(menuItems, dataType, filterFn, activeOperators) {
    const allowedOperators = FieldFilterPicker.defaultOperators[dataType].filter(({ argCount, isArrayValued }) => !(argCount > 1 || isArrayValued));
    let weight = 300;
    for (const { value: operator, text, argCount } of allowedOperators) {
      menuItems[`filter${StringHelper.capitalize(dataType)}${StringHelper.capitalize(operator)}`] = {
        text: StringHelper.capitalize(FieldFilterPicker.L(text)),
        weight: weight += 10,
        icon: activeOperators.includes(operator) ? "b-icon b-icon-check" : null,
        disabled: this.disabled,
        onItem: () => filterFn(operator, argCount)
      };
    }
  }
  populateCellMenuWithDurationItems({ column, record, items: items2 }) {
    const type = this.getFilterType(column);
    if (type === "duration") {
      const me = this, value = column.getFilterableValue(record), filter = (operator) => {
        me.applyFilter(column, { operator, value });
      };
      items2.filterDurationEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter("=")
      };
      items2.filterDurationLess = {
        text: "L{lessThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-less",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter("<")
      };
      items2.filterDurationMore = {
        text: "L{moreThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-more",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter(">")
      };
    }
  }
  populateCellMenuWithStringItems({ column, record, items: items2 }) {
    var _a4, _b;
    const type = this.getFilterType(column);
    if (!/(date|number|duration)/.test(type)) {
      const me = this, value = column.getFilterableValue(record), operator = (_b = (_a4 = column.filterable.filterField) == null ? void 0 : _a4.operator) != null ? _b : "*";
      items2.filterStringEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => me.applyFilter(column, { value, operator })
      };
    }
  }
  /**
   * In non-legacy mode, gets the cell/header context menu items: a top-level Filter item having a submenu with
   * operator and edit/remove options). Not used by legacy mode.
   * @private
   */
  getMenuItems(column, record) {
    const me = this, submenuItems = {}, type = me.getFilterType(column);
    if (column.filterable === false) {
      return {};
    }
    if (allowedFilterTypes[type]) {
      const value = record ? column.getFilterableValue(record) : void 0, activeOperators = me.getCurrentMultiFilters(column).filter((filter) => !filter.disabled).map(({ operator }) => operator), maxArgCount = record ? 1 : void 0, allowedOperators = FieldFilterPicker.defaultOperators[type].filter(({ argCount, isArrayValued }) => !(argCount > maxArgCount || isArrayValued));
      let weight = 300;
      for (const { value: operator, text, argCount } of allowedOperators) {
        const key = `filter${StringHelper.capitalize(type)}${StringHelper.capitalize(operator)}`;
        submenuItems[key] = {
          text: StringHelper.capitalize(FieldFilterPicker.L(text)),
          weight: weight += 10,
          icon: activeOperators.includes(operator) ? "b-icon b-icon-check" : null,
          disabled: me.disabled,
          cls: menuItemsWithSeparators[key] ? "b-separator" : null,
          onItem: () => me.onOperatorMenuItem(column, value, operator, argCount)
        };
      }
    }
    if (column.meta.isFiltered) {
      Object.assign(submenuItems, me.getMenuItemsForFilteredColumn(column, record !== void 0));
    }
    return {
      filterMenu: {
        text: "L{filter}",
        localeClass: me,
        menu: submenuItems,
        icon: "b-fw-icon b-icon-filter",
        weight: record ? 400 : 100
      }
    };
  }
  /**
   * Handle clicking on an operator item in the filter submenu.
   * @param {Grid.column.Column} column The column to which the menu belongs
   * @param {*} value The cell value if this context menu belongs to a grid cell, undefined if header menu
   * @param {String} operator The selected operator, e.g. `'='`, `'isToday'`. See `CollectionFilter`.
   * @param {String} type The selected operator, e.g. `'='`, `'isToday'`. See `CollectionFilter`.
   * @param {Number} argCount The number of arguments required by the operator
   * @private
   */
  onOperatorMenuItem(column, value, operator, argCount = 1) {
    const me = this, type = me.getFilterType(column), wasActive = me.getCurrentMultiFilters(column).find((filter) => !filter.disabled && filter.operator === operator);
    if (wasActive) {
      me.removeFilter(column, operator);
    } else {
      if (argCount == 0 || value !== void 0) {
        me.applyFilter(column, {
          property: column.field,
          operator,
          type,
          value: argCount === 1 ? value : null,
          caseSensitive: false,
          disabled: value == null && argCount > 0
          // Can't apply filter yet; incomplete
        });
      } else {
        me.showFilterEditor(column, null, operator, true);
      }
    }
  }
  /**
   * Get the context menu items (cell and header) that apply when the column is already filtered, e.g. edit,
   * remove, disable. Used by both legacy and regular modes.
   * @param {Grid.column.Column} column The column to which the menu pertains
   * @param {Boolean} isCellMenu Whether this is a cell's context menu (not header)
   * @returns {Object<String,MenuItemConfig>} An `items` config containing the appropriate menu item configs
   * @private
   */
  getMenuItemsForFilteredColumn(column, isCellMenu) {
    const me = this, canRemoveFilter = !me.disabled && (me.legacyMode || me.columnHasRemovableFilters(column));
    return {
      // Don't show 'edit' in legacy mode cell menu (legacy mode header menu handled elsewhere)
      editFilter: me.legacyMode ? void 0 : {
        text: "L{editFilter}",
        localeClass: me,
        icon: "b-fw-icon b-icon-edit",
        cls: "b-separator",
        weight: 500,
        disabled: !canRemoveFilter,
        onItem: () => me.showFilterEditor(column)
      },
      [isCellMenu ? "filterRemove" : "removeFilter"]: {
        text: "L{removeFilter}",
        localeClass: me,
        icon: "b-fw-icon b-icon-remove",
        cls: "b-separator",
        weight: 510,
        disabled: !canRemoveFilter,
        onItem: () => me.removeFilter(column)
      },
      disableFilter: {
        text: "L{disableFilter}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-disable",
        weight: 520,
        disabled: me.disabled || !me.columnHasEnabledFilters(column),
        onItem: () => me.disableFilter(column)
      }
    };
  }
  /**
   * Add menu items for filtering.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Core.data.Model} options.record Record for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateCellMenu({ column, record, items: items2, ...rest }) {
    const me = this;
    if (column.filterable !== false && !record.isSpecialRow) {
      if (me.useLegacyModeForColumn(column)) {
        me.populateCellMenuWithDateItems({ column, record, items: items2, ...rest });
        me.populateCellMenuWithNumberItems({ column, record, items: items2, ...rest });
        me.populateCellMenuWithDurationItems({ column, record, items: items2, ...rest });
        me.populateCellMenuWithStringItems({ column, record, items: items2, ...rest });
        if (column.meta.isFiltered) {
          Object.assign(items2, me.getMenuItemsForFilteredColumn(column, true));
        }
      } else {
        Object.assign(items2, me.getMenuItems(column, record));
      }
    }
  }
  /**
   * Used to determine whether the 'remove filters' menu item should be enabled.
   * @internal
   */
  columnHasRemovableFilters(column) {
    const me = this;
    return Boolean(me.getCurrentMultiFilters(column).find((filter) => !me.canDeleteFilter || me.callback(me.canDeleteFilter, me, [filter]) !== false));
  }
  /**
   * Used to determine whether the 'disable filters' menu item should be enabled.
   * @internal
   */
  columnHasEnabledFilters(column) {
    return Boolean(this.getCurrentMultiFilters(column).find((filter) => !filter.disabled));
  }
  /**
   * Add menu item for removing filter if column is filtered.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateHeaderMenu({ column, items: items2 }) {
    const me = this;
    if (me.useLegacyModeForColumn(column)) {
      if (column.meta.isFiltered) {
        items2.editFilter = {
          text: "L{editFilter}",
          localeClass: me,
          weight: 100,
          icon: "b-fw-icon b-icon-filter",
          cls: "b-separator",
          disabled: me.disabled,
          onItem: () => me.showFilterEditor(column)
        };
        items2.removeFilter = {
          text: "L{removeFilter}",
          localeClass: me,
          weight: 110,
          icon: "b-fw-icon b-icon-remove",
          disabled: me.disabled || !me.legacyMode && !me.columnHasRemovableFilters(column),
          onItem: () => me.removeFilter(column)
        };
        items2.disableFilter = {
          text: "L{disableFilter}",
          localeClass: me,
          icon: "b-fw-icon b-icon-filter-disable",
          weight: 115,
          disabled: me.disabled || !me.columnHasEnabledFilters(column),
          onItem: () => me.disableFilter(column)
        };
      } else if (column.filterable !== false) {
        items2.filter = {
          text: "L{filter}",
          localeClass: me,
          weight: 100,
          icon: "b-fw-icon b-icon-filter",
          cls: "b-separator",
          disabled: me.disabled,
          onItem: () => me.showFilterEditor(column)
        };
      }
    } else {
      Object.assign(items2, me.getMenuItems(column));
    }
  }
  useLegacyModeForColumn(column) {
    var _a4, _b, _c;
    return this.legacyMode || ((_c = (_a4 = column.filterable) == null ? void 0 : _a4.filterFn) != null ? _c : (_b = column.filterable) == null ? void 0 : _b.filterField) != void 0;
  }
  //endregion
  //region Events
  // Intercept filtering by a column that has a custom filtering fn, and inject that fn
  onStoreBeforeFilter({ filters }) {
    var _a4;
    const { columns } = this.client;
    for (let i = 0; i < filters.count; i++) {
      const filter = filters.getAt(i);
      if (!filter.internal) {
        const column = (filter.columnOwned || this.prioritizeColumns) && columns.find((col) => col.filterable !== false && col.field === filter.property);
        if ((_a4 = column == null ? void 0 : column.filterable) == null ? void 0 : _a4.filterFn) {
          if (!column.$filter) {
            column.$filter = new CollectionFilter({
              columnOwned: true,
              property: filter.property,
              operator: filter.operator,
              value: filter.value,
              filterBy(record) {
                return column.filterable.filterFn({ value: this.value, record, operator: this.operator, property: this.property, column });
              }
            });
          }
          column.$filter.value = filter.value;
          column.$filter.displayValue = filter.displayValue;
          column.$filter.operator = filter.operator;
          filters.splice(i, 1, column.$filter);
        }
      }
    }
  }
  /**
   * Store filtered; refresh headers.
   * @private
   */
  onStoreFilter() {
    this.refreshHeaders(false);
  }
  /**
   * Called after headers are rendered, make headers match stores initial sorters
   * @private
   */
  renderHeader() {
    this.refreshHeaders(false);
  }
  /**
   * Called when user clicks on the grid. Only care about clicks on the filter icon.
   * @param {MouseEvent} event
   * @private
   */
  onElementClick({ target }) {
    if (this.filterEditorPopup) {
      this.closeFilterEditor();
    }
    if (target.classList.contains("b-filter-icon")) {
      const headerEl = target.closest(".b-grid-header");
      this.showFilterEditor(headerEl.dataset.columnId);
      return false;
    }
  }
  /**
   * Called when user presses F-key grid.
   * @param {MouseEvent} event
   * @private
   */
  showFilterEditorByKey({ target }) {
    const headerEl = target.matches(".b-grid-header") && target;
    if (headerEl) {
      this.showFilterEditor(headerEl.dataset.columnId);
    }
    return Boolean(headerEl);
  }
  // Only care about F key when a filterable header is focused
  isActionAvailable({ event, actionName }) {
    if (actionName === "showFilterEditorByKey") {
      const headerElement = event.target.closest(".b-grid-header"), column = headerElement && this.client.columns.find((col) => col.id === headerElement.dataset.columnId);
      return Boolean(column == null ? void 0 : column.filterable);
    }
  }
  //endregion
};
Filter._$name = "Filter";
GridFeatureManager.registerFeature(Filter);

// lib/Grid/feature/FilterBar.js
var complexOperators = {
  "*": null,
  isIncludedIn: null,
  startsWith: null,
  endsWidth: null
};
var FilterBar = class extends InstancePlugin {
  //region Config
  static get $name() {
    return "FilterBar";
  }
  static get configurable() {
    return {
      /**
       * Use custom filtering functions defined on columns also when programmatically filtering by the columns
       * field.
       *
       * ```javascript
       * const grid = new Grid({
       *     columns : [
       *         {
       *             field : 'age',
       *             text : 'Age',
       *             filterable({ record, value }) {
       *               // Custom filtering, return true/false
       *             }
       *         }
       *     ],
       *
       *     features : {
       *         filterBar : {
       *             prioritizeColumns : true // <--
       *         }
       *     }
       * });
       *
       * // Because of the prioritizeColumns config above, any custom
       * // filterable function on a column will be used when
       * // programmatically filtering by that columns field
       * grid.store.filter({
       *     property : 'age',
       *     value    : 30
       * });
       * ```
       *
       * @config {Boolean}
       * @default
       * @category Common
       */
      prioritizeColumns: false,
      /**
       * The delay in milliseconds to wait after the last keystroke before applying filters.
       * Set to 0 to not trigger filtering from keystrokes, requires pressing ENTER instead
       * @config {Number}
       * @default
       * @category Common
       */
      keyStrokeFilterDelay: 300,
      /**
       * Toggle compact mode. In this mode the filtering fields are styled to transparently overlay the headers,
       * occupying no additional space.
       * @member {Boolean} compactMode
       * @category Common
       */
      /**
       * Specify `true` to enable compact mode for the filter bar. In this mode the filtering fields are styled
       * to transparently overlay the headers, occupying no additional space.
       * @config {Boolean}
       * @default
       * @category Common
       */
      compactMode: false,
      /**
       * By default, column filter is removed when a column is hidden or this feature is disabled. Set this flag
       * to `false` to keep filters in these scenarios.
       * @member {Boolean}
       * @category Common
       * @default
       */
      clearStoreFiltersOnHide: true,
      /**
       * Determines `filterBar` visibility. By default it is set to `false` and to hide the `filterBar` set
       * this flag to `true`.
       * @prp {Boolean}
       * @category Common
       * @default
       */
      hidden: false,
      /**
       * Use to set initial filter.
       *
       * ```javascript
       * const grid = new Grid({
       *   features : {
       *     filterBar : { filter: { property : 'city', value : 'Gavle' } }
       *   }
       * });
       * ```
       *
       * @config {CollectionFilterConfig|Function}
       * @returns {Boolean}
       * @category Common
       */
      filter: null,
      keyMap: {
        // Private
        ArrowUp: { handler: "disableGridNavigation", preventDefault: false },
        ArrowRight: { handler: "disableGridNavigation", preventDefault: false },
        ArrowDown: { handler: "disableGridNavigation", preventDefault: false },
        ArrowLeft: { handler: "disableGridNavigation", preventDefault: false },
        Enter: { handler: "disableGridNavigation", preventDefault: false }
      }
    };
  }
  static get pluginConfig() {
    return {
      before: ["renderContents"],
      chain: ["afterColumnsChange", "renderHeader", "populateHeaderMenu", "bindStore"]
    };
  }
  static get properties() {
    return {
      filterFieldCls: "b-filter-bar-field",
      filterFieldInputCls: "b-filter-bar-field-input",
      filterableColumnCls: "b-filter-bar-enabled",
      filterFieldInputSelector: ".b-filter-bar-field-input",
      filterableColumnSelector: ".b-filter-bar-enabled",
      filterParseRegExp: /^\s*([<>=*])?(.*)$/,
      storeTrackingSuspended: 0
    };
  }
  //endregion
  //region Init
  construct(grid, config) {
    if (grid.features.filter) {
      throw new Error("Grid.feature.FilterBar feature may not be used together with Grid.feature.Filter, These features are mutually exclusive.");
    }
    const me = this;
    me.grid = grid;
    me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);
    super.construct(grid, Array.isArray(config) ? {
      filter: config
    } : config);
    me.bindStore(grid.store);
    if (me.filter) {
      grid.store.filter(me.filter);
    }
    me.gridDetacher = grid.ion({ beforeElementClick: "onBeforeElementClick", thisObj: me });
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeFilter: "onStoreBeforeFilter",
      filter: "onStoreFilter",
      thisObj: this
    });
  }
  doDestroy() {
    var _a4;
    this.destroyFilterBar();
    (_a4 = this.gridDetacher) == null ? void 0 : _a4.call(this);
    super.doDestroy();
  }
  doDisable(disable) {
    const { columns } = this.grid;
    columns == null ? void 0 : columns.forEach((column) => {
      const widget = this.getColumnFilterField(column);
      if (widget) {
        widget.disabled = disable;
      }
    });
    super.doDisable(disable);
  }
  updateHidden(hidden) {
    if (!this.isConfiguring) {
      if (hidden) {
        this.hideFilterBar();
      } else {
        this.showFilterBar();
      }
    }
  }
  updateCompactMode(value) {
    this.client.headerContainer.classList[value ? "add" : "remove"]("b-filter-bar-compact");
    for (const prop in this._columnFilters) {
      const field = this._columnFilters[prop];
      field.placeholder = value ? field.column.headerText : null;
    }
  }
  //endregion
  //region FilterBar
  destroyFilterBar() {
    var _a4;
    (_a4 = this.grid.columns) == null ? void 0 : _a4.forEach(this.destroyColumnFilterField, this);
  }
  /**
   * Hides the filtering fields.
   */
  hideFilterBar() {
    var _a4;
    const me = this;
    me.clearStoreFiltersOnHide && me.suspendStoreTracking();
    (_a4 = me.grid.columns) == null ? void 0 : _a4.forEach((col) => me.hideColumnFilterField(col, true));
    me.grid.store.filter();
    me.clearStoreFiltersOnHide && me.resumeStoreTracking();
    me._hidden = true;
  }
  /**
   * Shows the filtering fields.
   */
  showFilterBar() {
    this.suspendStoreTracking();
    this.renderFilterBar(this.clearStoreFiltersOnHide);
    this.resumeStoreTracking();
    this._hidden = false;
  }
  /**
   * Toggles the filtering fields visibility.
   */
  toggleFilterBar() {
    if (this.hidden) {
      this.showFilterBar();
    } else {
      this.hideFilterBar();
    }
  }
  /**
   * Renders the filtering fields for filterable columns.
   * @private
   */
  renderFilterBar(applyFilter) {
    if (this.grid.hideHeaders) {
      return;
    }
    this.grid.columns.visibleColumns.forEach((column) => this.renderColumnFilterField(column, applyFilter));
    this.rendered = true;
  }
  //endregion
  //region FilterBar fields
  /**
   * Renders text field filter in the provided column header.
   * @param {Grid.column.Column} column Column to render text field filter for.
   * @private
   */
  renderColumnFilterField(column, applyFilters) {
    const me = this, { grid } = me, filterable = me.getColumnFilterable(column);
    if (filterable && column.isVisible) {
      const headerEl = column.element, filter = grid.store.filters.get(column.id) || grid.store.filters.getBy("property", column.field);
      let widget = me.getColumnFilterField(column);
      if (!widget) {
        const type = `${column.filterType || "text"}field`, { filterField } = filterable, externalCls = filterField == null ? void 0 : filterField.cls;
        if (externalCls) {
          delete filterable.filterField.cls;
        }
        widget = WidgetHelper.append(ObjectHelper.assign({
          type,
          cls: {
            [me.filterFieldCls]: 1,
            [externalCls]: externalCls
          },
          // Simplifies debugging / testing
          dataset: {
            column: column.field
          },
          column,
          owner: grid,
          clearable: true,
          revertOnEscape: true,
          name: column.field,
          value: filter && !filter._filterBy && !filter.internal ? me.buildFilterValue(filter) : "",
          inputCls: me.filterFieldInputCls,
          keyStrokeChangeDelay: me.keyStrokeFilterDelay,
          disabled: me.disabled,
          placeholder: me.compactMode ? column.headerText : null,
          // Also copy formats, DateColumn, TimeColumn etc
          format: column.format,
          internalListeners: {
            change: me.onColumnFilterFieldChange,
            clear: me.onColumnFilterFieldChange
          }
        }, filterField), headerEl)[0];
        if (!(filterField == null ? void 0 : filterField.hasOwnProperty("min"))) {
          Object.defineProperty(widget, "min", {
            get: () => {
              var _a4;
              return (_a4 = column.editor) == null ? void 0 : _a4.min;
            },
            set: () => null
          });
        }
        if (!(filterField == null ? void 0 : filterField.hasOwnProperty("max"))) {
          Object.defineProperty(widget, "max", {
            get: () => {
              var _a4;
              return (_a4 = column.editor) == null ? void 0 : _a4.max;
            },
            set: () => null
          });
        }
        if (!(filterField == null ? void 0 : filterField.hasOwnProperty("strictParsing"))) {
          Object.defineProperty(widget, "strictParsing", {
            get: () => {
              var _a4;
              return (_a4 = column.editor) == null ? void 0 : _a4.strictParsing;
            },
            set: () => null
          });
        }
        widget.element.retainElement = true;
        me.setColumnFilterField(column, widget);
        const hasFilterFieldStoreData = (filterField == null ? void 0 : filterField.store) && (filterField.store.readUrl || filterField.store.data || filterField.store.isChained);
        if (widget.isCombo && !hasFilterFieldStoreData && widget.store.count === 0) {
          const configuredValue = widget.value, refreshData = () => {
            if (!(widget.store.readUrl || widget.store.isChained)) {
              widget.store.data = grid.store.getDistinctValues(column.field, true).map((value) => grid.store.modelClass.new({
                id: value,
                [column.field]: value
              }));
            }
          };
          widget.value = null;
          if (!widget.store.isSorted) {
            widget.store.sort({
              field: column.field,
              ascending: true
            });
          }
          widget.picker.ion({ beforeShow: refreshData });
          refreshData();
          widget.value = configuredValue;
        }
        if (!me.filter && widget.value && grid.store.autoLoad !== false) {
          me.onColumnFilterFieldChange({ source: widget, value: widget.value, silent: true });
        }
      } else {
        if (applyFilters) {
          me.onColumnFilterFieldChange({ source: widget, value: widget.value });
        }
        widget.render(headerEl);
        widget.show();
      }
      headerEl.classList.add(me.filterableColumnCls);
    }
  }
  /**
   * Fills in column filter fields with values from the grid store filters.
   * @private
   */
  updateColumnFilterFields() {
    const me = this, { columns, store } = me.grid;
    let field, filter;
    me._updatingFields = true;
    for (const column of columns.visibleColumns) {
      field = me.getColumnFilterField(column);
      if (field && !column.$isApplyingFilter) {
        filter = store.filters.get(column.id) || store.filters.getBy("property", column.field);
        if (filter && !filter.internal) {
          if (!filter._filterBy) {
            field.value = me.buildFilterValue(filter);
          } else {
            field.value = filter.value;
          }
        } else {
          field.value = "";
        }
      }
    }
    me._updatingFields = false;
  }
  getColumnFilterable(column) {
    if (!column.isRoot && column.filterable !== false && column.field && column.isLeaf) {
      if (typeof column.filterable === "function") {
        column.filterable = {
          filterFn: column.filterable
        };
      }
      return column.filterable;
    }
  }
  destroyColumnFilterField(column) {
    const widget = this.getColumnFilterField(column);
    if (widget) {
      this.hideColumnFilterField(column, true);
      widget.destroy();
      this.setColumnFilterField(column, void 0);
    }
  }
  hideColumnFilterField(column, silent) {
    const me = this, { store } = me.grid, columnEl = column.element, widget = me.getColumnFilterField(column);
    if (widget) {
      if (!me.isDestroying) {
        widget.hide();
      }
      const { $filter } = column;
      if (!store.isDestroyed && me.clearStoreFiltersOnHide && $filter) {
        store.removeFilter($filter, silent);
      }
      columnEl == null ? void 0 : columnEl.classList.remove(me.filterableColumnCls);
    }
  }
  /**
   * Returns column filter field instance.
   * @param {Grid.column.Column} column Column to get filter field for.
   * @returns {Core.widget.Widget}
   */
  getColumnFilterField(column) {
    var _a4;
    return (_a4 = this._columnFilters) == null ? void 0 : _a4[column.id];
  }
  setColumnFilterField(column, widget) {
    this._columnFilters = this._columnFilters || {};
    this._columnFilters[column.data.id] = widget;
  }
  //endregion
  //region Filters
  parseFilterValue(column, value, field) {
    var _a4;
    if (Array.isArray(value) || value instanceof Duration) {
      return {
        value
      };
    }
    if (ObjectHelper.isDate(value)) {
      return {
        operator: field.isDateField ? "sameDay" : field.isTimeField ? "sameTime" : "=",
        value
      };
    }
    const match = String(value).match(this.filterParseRegExp);
    return {
      operator: match[1] || ((_a4 = column.filterable) == null ? void 0 : _a4.operator) || "*",
      value: match[2]
    };
  }
  buildFilterValue({ operator, value }) {
    return value instanceof Date || Array.isArray(value) || value instanceof Duration ? value : (operator in complexOperators ? "" : operator) + value;
  }
  //endregion
  // region Events
  // Intercept filtering by a column that has a custom filtering fn, and inject that fn
  onStoreBeforeFilter({ filters }) {
    var _a4;
    const { columns } = this.client;
    for (let i = 0; i < filters.count; i++) {
      const filter = filters.getAt(i), column = (filter.columnOwned || this.prioritizeColumns) && columns.find((col) => col.filterable !== false && col.field === filter.property);
      if ((_a4 = column == null ? void 0 : column.filterable) == null ? void 0 : _a4.filterFn) {
        if (!column.$filter) {
          column.$filter = new CollectionFilter({
            columnOwned: true,
            property: filter.property,
            id: column.id,
            filterBy(record) {
              return column.filterable.filterFn({
                value: this.value,
                record,
                property: this.property,
                column
              });
            }
          });
        }
        column.$filter.value = filter.value;
        filters.splice(i, 1, column.$filter);
      }
    }
  }
  /**
   * Fires when store gets filtered. Refreshes field values in column headers.
   * @private
   */
  onStoreFilter() {
    if (!this.storeTrackingSuspended && this.rendered) {
      this.updateColumnFilterFields();
    }
  }
  afterColumnsChange({ action, changes, column, columns }) {
    if (!this.hidden && (changes == null ? void 0 : changes.hidden)) {
      const hidden = changes.hidden.value;
      if (hidden) {
        this.destroyColumnFilterField(column);
      } else {
        this.renderColumnFilterField(column);
      }
    }
    if (action === "remove") {
      columns.forEach((col) => this.destroyColumnFilterField(col));
    }
  }
  suspendStoreTracking() {
    this.storeTrackingSuspended++;
  }
  resumeStoreTracking() {
    this.storeTrackingSuspended--;
  }
  /**
   * Called after headers are rendered, make headers match stores initial sorters
   * @private
   */
  renderHeader() {
    if (!this.hidden) {
      this.renderFilterBar();
    }
  }
  renderContents() {
    if (this._columnFilters) {
      for (const field of Object.values(this._columnFilters)) {
        field == null ? void 0 : field.element.remove();
      }
    }
  }
  disableGridNavigation(event) {
    return event.target.matches(this.filterFieldInputSelector);
  }
  onBeforeElementClick({ event }) {
    if (event.target.closest(`.${this.filterFieldCls}`)) {
      return false;
    }
  }
  /**
   * Called when a column text filter field value is changed by user.
   * @param  {Core.widget.TextField} field Filter text field.
   * @param  {String} value New filtering value.
   * @private
   */
  onColumnFilterFieldChange({ source: field, value, silent }) {
    var _a4, _b, _c, _d, _e;
    const me = this, { column } = field, { filterFn } = column.filterable, { store } = me.grid, filter = column.$filter || store.filters.find((f) => (f.id === column.id || f.property === column.field) && !f.internal);
    if (me._updatingFields) {
      return;
    }
    const isClearingFilter = value == null || value === "" || Array.isArray(value) && value.length === 0;
    store.removeFilter(filter, true);
    column.$filter = null;
    column.$isApplyingFilter = true;
    if (isClearingFilter) {
      if (!filter) {
        column.$isApplyingFilter = false;
        return;
      }
    } else {
      column.$filter = store.addFilter({
        property: field.name,
        ...me.parseFilterValue(column, value, field),
        [typeof ((_a4 = column.filterable) == null ? void 0 : _a4.caseSensitive) === "boolean" ? "caseSensitive" : void 0]: (_b = column.filterable) == null ? void 0 : _b.caseSensitive,
        // Only inject a filterBy configuration if the column has a custom filterBy
        [filterFn ? "filterBy" : "_"]: function(record) {
          return filterFn({ value: this.value, record, operator: this.operator, property: this.property, column });
        }
      }, true);
    }
    store.filter({ silent });
    column.$isApplyingFilter = false;
    if ((_c = field.picker) == null ? void 0 : _c.isVisible) {
      (_e = (_d = field.picker) == null ? void 0 : _d.realign) == null ? void 0 : _e.call(_d);
    }
  }
  //endregion
  //region Menu items
  /**
   * Adds a menu item to toggle filter bar visibility.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateHeaderMenu({ items: items2 }) {
    items2.toggleFilterBar = {
      text: this.hidden ? "L{enableFilterBar}" : "L{disableFilterBar}",
      localeClass: this,
      weight: 120,
      icon: "b-fw-icon b-icon-filter",
      cls: "b-separator",
      onItem: () => this.toggleFilterBar()
    };
  }
  //endregion
};
FilterBar.featureClass = "b-filter-bar";
FilterBar._$name = "FilterBar";
GridFeatureManager.registerFeature(FilterBar);

// lib/Grid/feature/Group.js
var Group = class extends InstancePlugin {
  static get $name() {
    return "Group";
  }
  static get configurable() {
    return {
      /**
       * The name of the record field to group by.
       * @prp {String}
       */
      field: null,
      /**
       * The sort direction of the groups.
       * @prp {Boolean}
       * @default
       */
      ascending: true,
      /**
       * A function used to sort the groups.
       * When grouping, the records have to be sorted so that records in a group stick together.
       * Technically that means that records having the same {@link #config-field} value
       * should go next to each other.
       * And this function (if provided) is responsible for applying such grouping order.
       * ```javascript
       * const grid = new Grid({
       *     features : {
       *         group : {
       *             // group by category
       *             field       : 'category',
       *             groupSortFn : (a, b) => {
       *                 const
       *                     aCategory = a.category || '',
       *                     bCategory = b.category || '';
       *
       *                 // 1st sort by "calegory" field
       *                 return aCategory > bCategory ? -1 :
       *                     aCategory < bCategory ? 1 :
       *                     // inside calegory groups we sort by "name" field
       *                     (a.name > b.name ? -1 : 1);
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * @config {Function}
       * @param {*} first The first value to compare
       * @param {*} second The second value to compare
       * @returns {Number}  Returns `1` if first value is greater than second value, `-1` if the opposite is true or `0` if they're equal
       */
      groupSortFn: null,
      /**
       * A function which produces the HTML for a group header.
       * The function is called in the context of this Group feature object.
       * Default group renderer displays the `groupRowFor` and `count`.
       *
       * @config {Function}
       * @param {Object} renderData Object containing renderer parameters
       * @param {*} renderData.groupRowFor The value of the `field` for the group. Type depends on `field` used for grouping
       * @param {Core.data.Model} renderData.record The group record representing the group
       * @param {Number} renderData.count Number of records in the group
       * @param {Grid.column.Column} renderData.column The column the renderer runs for
       * @param {Boolean} renderData.isFirstColumn True, if `column` is the first column. If `RowNumberColumn` is the real first column, it's not taken into account
       * @param {Grid.column.Column} renderData.groupColumn The column under which the `field` is shown
       * @param {Object} renderData.size Sizing information for the group header row, only `height` is relevant
       * @param {Number} renderData.size.height The height of the row, set this if you want a custom height for the group header row.
       *   That is UI part, so do not rely on its existence
       * @param {Grid.view.Grid} renderData.grid The owning grid
       * @param {HTMLElement} renderData.rowElement The owning row element
       * @returns {DomConfig|String|null}
       * @default
       *
       * @category Rendering
       */
      renderer: null,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>}
       */
      keyMap: {
        " ": "toggleGroup"
      },
      /**
       * By default, clicking anywhere in a group row toggles its expanded/collapsed state.
       *
       * Configure this as `false` to limit this to only toggling on click of the expanded/collapsed
       * state icon.
       * @prp {Boolean}
       * @default
       */
      toggleOnRowClick: true
    };
  }
  //region Init
  construct(grid, config) {
    const me = this;
    if (grid.features.tree) {
      return;
    }
    me._thisIsAUsedExpression(grid.features.groupSummary);
    config = me.processConfig(config);
    me.grid = grid;
    super.construct(grid, config);
    me.bindStore(grid.store);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      renderCell: "renderCell",
      // The feature gets to see cells being rendered before the GroupSummary feature
      // because this injects header content into group header rows and adds rendering
      // info to the cells renderData which GroupSummary must comply with.
      prio: 1100,
      thisObj: me
    });
  }
  // Group feature handles special config cases, where user can supply a string or a group config object
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === "string") {
      return {
        field: config
      };
    }
    return config;
  }
  // override setConfig to process config before applying it (used mainly from ReactGrid)
  setConfig(config) {
    if (config === null) {
      this.store.clearGroupers();
    } else {
      super.setConfig(this.processConfig(config));
    }
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      group: "onStoreGroup",
      change: "onStoreChange",
      toggleGroup: "onStoreToggleGroup",
      thisObj: this
    });
    this.onStoreGroup({ groupers: store.groupers });
  }
  updateRenderer(renderer) {
    this.groupRenderer = renderer;
  }
  updateField(field) {
    var _a4;
    if (!this.isConfiguring || !((_a4 = this.store.groupers) == null ? void 0 : _a4.some((g) => g.field === field))) {
      this.store.group({
        field,
        ascending: this.ascending,
        fn: this.groupSortFn
      });
    }
  }
  updateGroupSortFn(fn) {
    if (!this.isConfiguring) {
      this.store.group({
        field: this.field,
        ascending: this.ascending,
        fn
      });
    }
  }
  updateAscending(ascending2) {
    const me = this;
    if (!me.isConfiguring) {
      me.store.group({
        field: me.field,
        ascending: ascending2,
        fn: me.groupSortFn
      });
    }
  }
  doDestroy() {
    super.doDestroy();
  }
  doDisable(disable) {
    const { store } = this;
    if (disable && store.isGrouped) {
      const { sorters } = store;
      sorters.unshift(...store.groupers);
      this.currentGroupers = store.groupers;
      store.clearGroupers();
      store.sort(sorters);
    } else if (!disable && this.currentGroupers) {
      store.group(this.currentGroupers[0]);
      this.currentGroupers = null;
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  //endregion
  //region Plugin config
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      assign: ["collapseAll", "expandAll"],
      chain: [
        "renderHeader",
        "populateHeaderMenu",
        "getColumnDragToolbarItems",
        "onElementTouchStart",
        "onElementClick",
        "bindStore"
      ]
    };
  }
  //endregion
  //region Expand/collapse
  refreshGrid(groupRecord) {
    const { store, rowManager } = this.grid;
    if (rowManager.rowCount > store.count || !rowManager.getRowFor(groupRecord)) {
      rowManager.renderFromRow();
    } else {
      rowManager.renderFromRecord(groupRecord);
    }
  }
  /**
   * Collapses or expands a group header record (you can also pass a record that is part of a group) depending on its
   * current state.
   * @param {Core.data.Model|String} recordOrId Record or records id for a group row to collapse or expand
   * @param {Boolean} collapse Force collapse (`true`) or expand (`false`)
   * @fires toggleGroup
   */
  toggleCollapse(recordOrId, collapse) {
    this.internalToggleCollapse(recordOrId, collapse);
  }
  /**
   * Collapses or expands a group depending on its current state
   * @param {Core.data.Model|String} recordOrId Record or records id for a group row to collapse or expand
   * @param {Boolean} collapse Force collapse (true) or expand (true)
   * @param {Boolean} [skipRender] True to not render rows
   * @param {Event} [domEvent] The user interaction event (eg a `click` event) if the toggle request was
   * instigated by user interaction.
   * @param {Boolean} [allRecords] True if this event is part of toggling all groups
   * @internal
   * @fires toggleGroup
   */
  internalToggleCollapse(recordOrId, collapse, skipRender = false, domEvent, allRecords = false) {
    const me = this, { store, grid } = me;
    let groupRecord = store.getById(recordOrId);
    if (!groupRecord.isGroupHeader) {
      groupRecord = store.getGroupHeaderForRecord(groupRecord);
    }
    if (!groupRecord.isGroupHeader) {
      return;
    }
    collapse = collapse === void 0 ? !groupRecord.meta.collapsed : collapse;
    if (grid.trigger("beforeToggleGroup", { groupRecord, collapse, domEvent }) === false) {
      return;
    }
    me.isToggling = true;
    if (collapse) {
      store.collapse(groupRecord);
    } else {
      store.expand(groupRecord);
    }
    me.isToggling = false;
    if (!skipRender) {
      me.refreshGrid(groupRecord);
    }
    grid.trigger("toggleGroup", { groupRecord, collapse, allRecords });
    grid.afterToggleGroup();
  }
  /**
   * Collapse all groups. This function is exposed on Grid and can thus be called as `grid.collapseAll()`
   * @on-owner
   * @typings {Promise<void>}
   */
  collapseAll() {
    const me = this, { store, grid } = me;
    if (store.isGrouped && !me.disabled) {
      store.groupRecords.forEach((r) => me.internalToggleCollapse(r, true, true, void 0, true));
      grid.trigger("collapseAllGroups");
      grid.refreshRows(true);
    }
  }
  /**
   * Expand all groups. This function is exposed on Grid and can thus be called as `grid.expandAll()`
   * @on-owner
   * @typings {Promise<void>}
   */
  expandAll() {
    const me = this, { store, grid } = me;
    if (store.isGrouped && !me.disabled) {
      store.groupRecords.forEach((r) => me.internalToggleCollapse(r, false, true, void 0, true));
      grid.trigger("expandAllGroups");
      grid.refreshRows();
    }
  }
  //endregion
  //region Rendering
  /**
   * Called before rendering row contents, used to reset rows no longer used as group rows
   * @private
   */
  onBeforeRenderRow({ row }) {
    const oldRecord = row.grid.store.getById(row.id);
    row.forceInnerHTML = row.forceInnerHTML || (oldRecord == null ? void 0 : oldRecord.isGroupHeader);
  }
  /**
   * Called when a cell is rendered, styles the group rows first cell.
   * @private
   */
  renderCell(renderData) {
    var _a4;
    const me = this, {
      cellElement,
      row,
      column,
      grid
    } = renderData, { meta } = renderData.record, rowClasses = {
      "b-group-row": 0,
      "b-grid-group-collapsed": 0
    };
    if (!me.disabled && me.store.isGrouped && "groupRowFor" in meta) {
      if (column.type === "action") {
        return;
      }
      column.clearCell(cellElement);
      rowClasses["b-grid-group-collapsed"] = meta.collapsed;
      rowClasses["b-group-row"] = 1;
      if (grid.buildGroupHeader) {
        grid.buildGroupHeader(renderData);
      } else {
        me.buildGroupHeader(renderData);
      }
      if (column === me.groupHeaderColumn) {
        DomHelper.createElement({
          parent: cellElement,
          tag: "i",
          className: "b-group-state-icon",
          nextSibling: cellElement.firstChild
        });
        cellElement.classList.add("b-group-title");
        cellElement.$groupHeader = cellElement._hasHtml = true;
      }
    } else if (cellElement.$groupHeader) {
      (_a4 = cellElement.querySelector(".b-group-state-icon")) == null ? void 0 : _a4.remove();
      cellElement.classList.remove("b-group-title");
      cellElement.$groupHeader = false;
    }
    row.assignCls(rowClasses);
  }
  // renderData.cellElement is required
  buildGroupHeader(renderData) {
    const me = this, {
      record,
      cellElement,
      column,
      persist
    } = renderData, { grid } = me, meta = record.meta, groupRowFor = meta.emptyArray ? grid.L("L{Object.None}") : meta.groupRowFor, { groupSummary } = grid.features, count = meta.childCount - (groupSummary && groupSummary.target !== "header" ? 1 : 0);
    let html = null, applyDefault = true;
    if (persist || column) {
      const groupColumn = grid.columns.get(meta.groupField), isGroupHeaderColumn = renderData.isFirstColumn = column === me.groupHeaderColumn;
      if (groupColumn == null ? void 0 : groupColumn.groupRenderer) {
        if (isGroupHeaderColumn) {
          html = groupColumn.groupRenderer({
            ...renderData,
            groupRowFor,
            groupRecords: record.groupChildren,
            groupColumn,
            count
          });
          applyDefault = false;
        }
      } else if (me.groupRenderer) {
        html = me.groupRenderer({
          ...renderData,
          groupRowFor,
          groupRecords: record.groupChildren,
          groupColumn,
          count,
          isFirstColumn: isGroupHeaderColumn
        });
      }
      if (isGroupHeaderColumn && html == null && applyDefault && DomHelper.getChildElementCount(cellElement) === 0) {
        html = StringHelper.encodeHtml(`${groupRowFor === "__novalue__" ? "" : groupRowFor} (${count})`);
      }
    } else if (me.groupRenderer) {
      html = me.groupRenderer(renderData);
    }
    if (typeof html === "string") {
      cellElement.innerHTML = html;
    } else if (typeof html === "object") {
      DomSync.sync({
        targetElement: cellElement,
        domConfig: {
          onlyChildren: true,
          children: ArrayHelper.asArray(html)
        }
      });
    }
    if (DomHelper.getChildElementCount(cellElement) > 0) {
      cellElement._hasHtml = true;
    }
    return cellElement.innerHTML;
  }
  get groupHeaderColumn() {
    return this.grid.columns.visibleColumns.find((column) => !column.groupHeaderReserved);
  }
  /**
   * Called when a header is rendered, adds grouping icon if grouped by that column.
   * @private
   * @param headerContainerElement
   */
  renderHeader(headerContainerElement = this.grid.headerContainer) {
    var _a4;
    const { store, grid } = this;
    if (headerContainerElement && store.isGrouped) {
      for (const groupInfo of store.groupers) {
        const column = grid.columns.get(groupInfo.field), header = column && grid.getHeaderElement(column.id);
        header == null ? void 0 : header.classList.add("b-group", groupInfo.ascending ? "b-asc" : "b-desc");
        if (header && (!((_a4 = grid.features.sort) == null ? void 0 : _a4.enabled) || column.sortable === false)) {
          const textEl = column.textWrapper;
          if (!(textEl == null ? void 0 : textEl.querySelector(".b-sort-icon"))) {
            DomHelper.createElement({
              parent: textEl,
              className: "b-sort-icon"
            });
          }
        }
      }
    }
  }
  //endregion
  //region Context menu
  /**
   * Supply items for headers context menu.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateHeaderMenu({ column, items: items2 }) {
    const me = this;
    if (column.groupable !== false) {
      items2.groupAsc = {
        text: "L{groupAscending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-group-asc",
        cls: "b-separator",
        weight: 400,
        disabled: me.disabled,
        onItem: () => me.store.group(column.field, true)
      };
      items2.groupDesc = {
        text: "L{groupDescending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-group-desc",
        weight: 410,
        disabled: me.disabled,
        onItem: () => me.store.group(column.field, false)
      };
    }
    if (me.store.isGrouped) {
      items2.groupRemove = {
        text: "L{stopGrouping}",
        localeClass: me,
        icon: "b-fw-icon b-icon-clear",
        cls: column.groupable ? "" : "b-separator",
        weight: 420,
        disabled: me.disabled,
        onItem: () => me.store.clearGroupers()
      };
    }
  }
  /**
   * Supply items to ColumnDragToolbar
   * @private
   */
  getColumnDragToolbarItems(column, items2) {
    var _a4;
    const me = this, { store, disabled } = me;
    items2.push({
      text: "L{groupAscendingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-group-asc",
      ref: "groupAsc",
      cls: "b-separator",
      weight: 110,
      disabled,
      onDrop: ({ column: column2 }) => store.group(column2.field, true)
    });
    items2.push({
      text: "L{groupDescendingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-group-desc",
      ref: "groupDesc",
      weight: 110,
      disabled,
      onDrop: ({ column: column2 }) => store.group(column2.field, false)
    });
    const grouped = ((_a4 = store.groupers) == null ? void 0 : _a4.some((col) => col.field === column.field)) && !disabled;
    items2.push({
      text: "L{stopGroupingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-clear",
      ref: "groupRemove",
      disabled: !grouped,
      weight: 110,
      onDrop: ({ column: column2 }) => store.removeGrouper(column2.field)
    });
    return items2;
  }
  //endregion
  //region Events - Store
  /**
   * Called when store grouping changes. Reflects on header and rerenders rows.
   * @private
   */
  onStoreGroup({ groupers }) {
    const { grid } = this, { element } = grid, curGroupHeaders = element && DomHelper.children(element, ".b-grid-header.b-group");
    if (element) {
      for (const header of curGroupHeaders) {
        header.classList.remove("b-group", "b-asc", "b-desc");
      }
      if (groupers) {
        this.renderHeader();
      }
    }
  }
  onStoreChange({ action, records }) {
    const { client } = this, { rowManager, store } = client;
    if (store.isGrouped && action === "move") {
      const { field } = store.groupers[0], fromRow = Math.min(...records.reduce((result, record) => {
        result.push(store.indexOf(record.groupParent.get(store.id)));
        if (field in record.meta.modified) {
          const oldGroup = store.groupRecords.find((r) => r.meta.groupRowFor === record.meta.modified[field]);
          if (oldGroup) {
            result.push(store.indexOf(oldGroup));
          }
        }
        return result;
      }, []));
      rowManager.renderFromRow(rowManager.getRow(fromRow));
    }
  }
  // React to programmatic expand/collapse
  onStoreToggleGroup({ groupRecord }) {
    if (!this.isToggling) {
      this.refreshGrid(groupRecord);
    }
  }
  //endregion
  //region Events - Grid
  /**
   * Store touches when user touches header, used in onElementTouchEnd.
   * @private
   */
  onElementTouchStart(event) {
    const me = this, { target } = event, header = target.closest(".b-grid-header"), column = header && me.grid.getColumnFromElement(header);
    if (event.touches.length > 1 && column && column.groupable !== false && !me.disabled) {
      me.store.group(column.field);
    }
  }
  /**
   * React to click on headers (to group by that column if [alt] is pressed) and on group rows (expand/collapse).
   * @private
   * @param event
   * @returns {Boolean}
   */
  onElementClick(event) {
    var _a4;
    const me = this, { store } = me, { target } = event, row = target.closest(".b-group-row"), header = target.closest(".b-grid-header"), field = header == null ? void 0 : header.dataset.column;
    if (target.classList.contains("b-resizer") || me.disabled || target.classList.contains("b-action-item") || event.handled) {
      return;
    }
    if (header && field) {
      const columnGrouper = (_a4 = store.groupers) == null ? void 0 : _a4.find((g) => g.field === field);
      if (columnGrouper && !event.shiftKey) {
        columnGrouper.ascending = !columnGrouper.ascending;
        store.group();
        return false;
      } else if (event.shiftKey) {
        const column = me.grid.columns.get(field);
        if (column.groupable !== false) {
          if (event.altKey) {
            store.removeGrouper(field);
          } else {
            store.group(field);
          }
        }
      }
    }
    if (row && (me.toggleOnRowClick || event.target.classList.contains("b-group-state-icon"))) {
      me.internalToggleCollapse(DomDataStore.get(row).id, void 0, void 0, event);
      return false;
    }
  }
  /**
   * Toggle groups with [space].
   * @private
   */
  toggleGroup() {
    var _a4;
    const { grid } = this, { focusedCell } = grid;
    if (!this.disabled && !focusedCell.isActionable && ((_a4 = focusedCell.record) == null ? void 0 : _a4.isGroupHeader)) {
      this.internalToggleCollapse(focusedCell.id);
      return true;
    }
    return false;
  }
  //endregion
};
Group._$name = "Group";
GridFeatureManager.registerFeature(Group, true, ["Grid", "Scheduler"]);
GridFeatureManager.registerFeature(Group, false, ["TreeGrid"]);

// lib/Grid/feature/mixin/SummaryFormatter.js
var SummaryFormatter_default = (Target) => class SummaryFormatter extends (Target || Base) {
  static get $name() {
    return "SummaryFormatter";
  }
  /**
   * Calculates sums and returns as a html table
   * @param {Grid.column.Column} column Column to calculate sum for
   * @param {Core.data.Model[]} records Records to include in calculation
   * @param {String} cls CSS class to apply to summary table
   * @param {Core.data.Model} groupRecord current group row record
   * @param {String} groupField Current groups field name
   * @param {String} groupValue Current groups value
   * @returns {String} html content
   */
  generateHtml(column, records, cls, groupRecord, groupField, groupValue) {
    const store = this.store, summaries = column.summaries || (column.sum ? [{ sum: column.sum, renderer: column.summaryRenderer }] : []);
    let html = `<div class="b-summary-wrap ${cls}">`;
    summaries.forEach((config) => {
      let type = config.sum, sum = null;
      if (type === true)
        type = "sum";
      switch (type) {
        case "sum":
        case "add":
          sum = store.sum(column.field, records);
          break;
        case "max":
          sum = store.max(column.field, records);
          break;
        case "min":
          sum = store.min(column.field, records);
          break;
        case "average":
        case "avg":
          sum = store.average(column.field, records);
          break;
        case "count":
          sum = records.length;
          break;
        case "countNotEmpty":
          sum = records.reduce((sum2, record) => {
            const value = record.getValue(column.field);
            return sum2 + (value != null ? 1 : 0);
          }, 0);
          break;
      }
      if (typeof type === "function") {
        sum = records.reduce(type, "seed" in config ? config.seed : 0);
      }
      if (sum !== null) {
        const valueCls = "b-grid-summary-value", labelHtml = config.label ? `<div class="b-grid-summary-label">${config.label}</div>` : "";
        let valueHtml = config.renderer ? config.renderer({ config, sum }) : sum, summaryHtml;
        if (valueHtml == null) {
          valueHtml = "";
        }
        if (!String(valueHtml).includes("<div>")) {
          summaryHtml = labelHtml ? `${labelHtml}<div class="${valueCls}">${valueHtml}</div>` : `<div class="${valueCls} b-nolabel">${valueHtml}</div>`;
        } else {
          summaryHtml = valueHtml;
        }
        html += summaryHtml;
      }
    });
    return `${html}</div>`;
  }
};

// lib/Grid/feature/GroupSummary.js
var GroupSummary = class extends SummaryFormatter_default(InstancePlugin) {
  //region Init
  static get $name() {
    return "GroupSummary";
  }
  static get configurable() {
    return {
      /**
       * Set to `true` to have group summaries rendered in the group header when a group is collapsed.
       *
       * Only applies when {@link #config-target} is `'footer'` (the default).
       *
       * @member {Boolean} collapseToHeader
       */
      /**
       * Configure as `true` to have group summaries rendered in the group header when a group is collapsed.
       *
       * ```javascript
       * const grid = new Grid({
       *    features : {
       *        groupSummary : {
       *            collapseToHeader : true
       *        }
       *    }
       * });
       * ```
       *
       * Only applies when {@link #config-target} is `'footer'` (the default).
       *
       * @config {Boolean}
       */
      collapseToHeader: null,
      /**
       * Where to render the group summaries to, either `header` to display them in the group header or `footer`
       * to display them in the group footer (the default).
       *
       * @member {'header'|'footer'} target
       */
      /**
       * Where to render the group summaries to, either `header` to display them in the group header or `footer`
       * to display them in the group footer (the default).
       *
       * ```javascript
       * const grid = new Grid({
       *    features : {
       *        groupSummary : {
       *            target : 'header'
       *        }
       *    }
       * });
       * ```
       *
       * @config {'header'|'footer'}
       * @default
       */
      target: "footer"
    };
  }
  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
    if (!grid.features.group) {
      throw new Error("Requires Group feature to work, please enable");
    }
    this.bindStore(grid.store);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      renderCell: "renderCell",
      // The feature gets to see cells being rendered after the Group feature
      // because the Group feature injects header content into group header rows
      // and adds rendering info to the cells renderData which we must comply with.
      // In particular, it calculates the isFirstColumn flag which it adds to
      // the cell renderData which we interrogate.
      prio: 1e3,
      thisObj: this
    });
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      update: "onStoreUpdate",
      // need to run before grids listener, to flag for full refresh
      prio: 1,
      thisObj: this
    });
  }
  get store() {
    return this.grid.store;
  }
  doDisable(disable) {
    this.updateTarget(this.target);
    super.doDisable(disable);
  }
  changeTarget(target) {
    ObjectHelper.assertString(target, "target");
    return target;
  }
  updateTarget(target) {
    this.store.useGroupFooters = !this.disabled && target === "footer";
    if (!this.isConfiguring) {
      this.store.group();
    }
  }
  changeCollapseToHeader(collapseToHeader) {
    ObjectHelper.assertBoolean(collapseToHeader, "collapseToHeader");
    return collapseToHeader;
  }
  updateCollapseToHeader() {
    if (!this.isConfiguring) {
      this.store.group();
    }
  }
  //endregion
  //region Plugin config
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ["bindStore"]
    };
  }
  //endregion
  //region Render
  /**
   * Called before rendering row contents, used to reset rows no longer used as group summary rows
   * @private
   */
  onBeforeRenderRow({ row, record }) {
    if (row.isGroupFooter && !("groupFooterFor" in record.meta)) {
      row.isGroupFooter = false;
      row.forceInnerHTML = true;
    } else if (row.isGroupHeader && !record.meta.collapsed) {
      row.eachElement(this.removeSummaryElements);
    }
  }
  removeSummaryElements(rowEl) {
  }
  /**
   * Called when a cell is rendered, styles the group rows first cell.
   * @private
   */
  renderCell({ column, cellElement, row, record, size, isFirstColumn }) {
    const me = this, { meta } = record, { rowHeight } = me.grid, isGroupHeader = "groupRowFor" in meta, isGroupFooter = "groupFooterFor" in meta, targetsHeader = me.target === "header", rowClasses = {
      "b-group-footer": 0,
      "b-header-summary": 0
    }, isSummaryTarget = (
      // Header cell should have summary content if we are targeting the header or if the group is collapsed
      // and we are configured with collapseToHeader, excluding the first column which holds the group title
      isGroupHeader && (targetsHeader || me.collapseToHeader && meta.collapsed) && !isFirstColumn || // Footer cell should have summary content if we are targeting the footer (won't render if collapsed)
      isGroupFooter && !targetsHeader
    );
    if (isGroupHeader || isGroupFooter) {
      size.height = isGroupHeader ? size.height || rowHeight : rowHeight;
    }
    if (me.store.isGrouped && isSummaryTarget && !me.disabled) {
      column.clearCell(cellElement);
      const groupRecord = isGroupHeader ? record : meta.groupRecord;
      row.isGroupFooter = isGroupFooter;
      row.isGroupHeader = isGroupHeader;
      if (isGroupFooter) {
        rowClasses["b-group-footer"] = 1;
      } else {
        rowClasses["b-header-summary"] = 1;
      }
      const heightSetting = me.updateSummaryHtml(cellElement, column, groupRecord), count = typeof heightSetting === "number" ? heightSetting : heightSetting.count;
      if (count > 1) {
        size.height += meta.collapsed && !targetsHeader ? 0 : count * rowHeight * 0.1;
      }
      if (heightSetting.height) {
        size.height += heightSetting.height;
      }
    }
    row.assignCls(rowClasses);
  }
  updateSummaryHtml(cellElement, column, groupRecord) {
    const records = groupRecord.groupChildren.slice();
    if (records[records.length - 1].isGroupFooter) {
      records.pop();
    }
    const html = this.generateHtml(column, records, "b-grid-group-summary", groupRecord, groupRecord.meta.groupField, groupRecord.meta.groupRowFor);
    if (!cellElement.children.length) {
      cellElement.innerHTML = html;
    } else {
      DomHelper.sync(html, cellElement.firstElementChild);
    }
    return column.summaries ? column.summaries.length : column.sum ? 1 : 0;
  }
  //endregion
  //region Events
  /**
   * Updates summaries on store changes (except record update, handled below)
   * @private
   */
  onStoreUpdate({ source: store, changes }) {
    if (!this.disabled && store.isGrouped) {
      if (changes && store.groupers.find((grouper) => grouper.field in changes)) {
        return;
      }
      const shouldUpdate = Object.keys(changes).some((field) => {
        const colField = this.grid.columns.get(field);
        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
      if (shouldUpdate) {
        this.grid.forceFullRefresh = true;
      }
    }
  }
  //endregion
  /**
   * Refreshes the summaries
   */
  refresh() {
    this.grid.columns.visibleColumns.forEach((column) => {
      if (this.hasSummary(column)) {
        this.grid.refreshColumn(column);
      }
    });
  }
  hasSummary(column) {
    return column.sum || column.summaries;
  }
};
GroupSummary.featureClass = "b-group-summary";
GroupSummary._$name = "GroupSummary";
GridFeatureManager.registerFeature(GroupSummary);

// lib/Grid/feature/HeaderMenu.js
var HeaderMenu = class extends ContextMenuBase {
  //region Config
  static get $name() {
    return "HeaderMenu";
  }
  static get configurable() {
    return {
      type: "header",
      /**
       * This is a preconfigured set of items used to create the default context menu.
       *
       * The `items` provided by this feature are listed in the intro section of this class. You can
       * configure existing items by passing a configuration object to the keyed items.
       *
       * To remove existing items, set corresponding keys to `null`:
       *
       * ```javascript
       * const scheduler = new Scheduler({
       *     features : {
       *         headerMenu : {
       *             items : {
       *                 filter        : null,
       *                 columnPicker  : null
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * See the feature config in the above example for details.
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>} items
       */
      items: null,
      /**
       * Configure as `true` to show two extra menu options to move the selected column to either
       * before its previous sibling, or after its next sibling.
       *
       * This is a keyboard-accessible version of drag/drop column reordering.
       * @config {Boolean}
       * @category Accessibility
       */
      moveColumns: null
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>} keyMap
       */
    };
  }
  static get defaultConfig() {
    return {
      /**
       * A function called before displaying the menu that allows manipulations of its items.
       * Returning `false` from this function prevents the menu being shown.
       *
       * ```javascript
       *   features         : {
       *       headerMenu : {
       *           processItems({ column, items }) {
       *               // Add or hide existing items here as needed
       *               items.myAction = {
       *                   text   : 'Cool action',
       *                   icon   : 'b-fa b-fa-fw b-fa-ban',
       *                   onItem : () => console.log('Some coolness'),
       *                   weight : 300 // Move to end
       *               };
       *
       *               // Hide column picker
       *               items.columnPicker.hidden = true;
       *           }
       *       }
       *   },
       * ```
       *
       * @config {Function}
       * @param {Object} context An object with information about the menu being shown.
       * @param {Grid.feature.HeaderMenu} context.feature A reference to this feature.
       * @param {Event} context.domEvent The initiating event.
       * @param {Event} context.event DEPRECATED: The initiating event.
       * @param {Number[]} context.point The client `X` and `Y` position of the initiating event.
       * @param {HTMLElement} context.targetElement The target to which the menu is being applied.
       * @param {Grid.column.Column} context.column The current column.
       * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the
       *   {@link Core.widget.MenuItem menu item} configs keyed by their id.
       * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown.
       * @preventable
       */
      processItems: null
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateHeaderMenu");
    return config;
  }
  //endregion
  //region Events
  /**
   * This event fires on the owning Grid before the context menu is shown for a header.
   * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.
   *
   * Returning `false` from a listener prevents the menu from being shown.
   *
   * @event headerMenuBeforeShow
   * @on-owner
   * @preventable
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<String,MenuItemConfig>} items Menu item configs
   * @param {Grid.column.Column} column Column
   */
  /**
   * This event fires on the owning Grid after the context menu is shown for a header
   * @event headerMenuShow
   * @on-owner
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<String,MenuItemConfig>} items Menu item configs
   * @param {Grid.column.Column} column Column
   */
  /**
   * This event fires on the owning Grid when an item is selected in the header context menu.
   * @event headerMenuItem
   * @on-owner
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Grid.column.Column} column Column
   */
  /**
   * This event fires on the owning Grid when a check item is toggled in the header context menu.
   * @event headerMenuToggleItem
   * @on-owner
   * @param {Grid.view.Grid} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Grid.column.Column} column Column
   * @param {Boolean} checked Checked or not
   */
  //endregion
  //region Menu handlers
  shouldShowMenu(eventParams) {
    const { column } = eventParams;
    return column && column.enableHeaderContextMenu !== false && column !== this.client.timeAxisColumn;
  }
  getDataFromEvent(event) {
    return ObjectHelper.assign(super.getDataFromEvent(event), this.client.getHeaderDataFromEvent(event));
  }
  populateHeaderMenu({ items: items2, column }) {
    const me = this;
    if (column) {
      if (column.headerMenuItems) {
        ObjectHelper.merge(items2, column.headerMenuItems);
      }
      if (column.isCollapsible) {
        const { collapsed } = column, icon = collapsed ? me.client.rtl ? "left" : "right" : me.client.rtl ? "right" : "left";
        items2.toggleCollapse = {
          weight: 215,
          icon: `b-fw-icon b-icon-collapse-${icon}`,
          text: me.L(collapsed ? "L{expandColumn}" : "L{collapseColumn}"),
          onItem: () => column.collapsed = !collapsed
        };
      }
      if (me.moveColumns) {
        const columnToMoveBefore = me.getColumnToMoveBefore(column), columnToMoveAfter = me.getColumnToMoveAfter(column);
        if (columnToMoveBefore) {
          items2.movePrev = {
            weight: 220,
            icon: "b-fw-icon b-icon-column-move-left",
            text: me.L("L{moveBefore}", StringHelper.encodeHtml(columnToMoveBefore.text)),
            onItem: () => {
              var _a4;
              const { parent: oldParent } = column;
              if (columnToMoveBefore.parent.insertChild(column, columnToMoveBefore)) {
                column.region = columnToMoveBefore.region;
                if (!((_a4 = oldParent.children) == null ? void 0 : _a4.length)) {
                  oldParent.remove();
                }
              }
            }
          };
        }
        if (columnToMoveAfter) {
          items2.moveNext = {
            weight: 230,
            icon: "b-fw-icon b-icon-column-move-right",
            text: me.L("L{moveAfter}", StringHelper.encodeHtml(columnToMoveAfter.text)),
            onItem: () => {
              var _a4;
              const { parent: oldParent } = column;
              if (columnToMoveAfter.parent.insertChild(column, columnToMoveAfter.nextSibling)) {
                column.region = columnToMoveAfter.region;
                if (!((_a4 = oldParent.children) == null ? void 0 : _a4.length)) {
                  oldParent.remove();
                }
              }
            }
          };
        }
      }
    }
    return items2;
  }
  getColumnToMoveBefore(column) {
    const { previousSibling, parent } = column;
    if (previousSibling) {
      return previousSibling.children && !column.children ? previousSibling.children[previousSibling.children.length - 1] : previousSibling;
    }
    if (!parent.isRoot) {
      return parent;
    }
  }
  getColumnToMoveAfter(column) {
    const { nextSibling, parent } = column;
    if (nextSibling) {
      return nextSibling;
    }
    if (!parent.isRoot) {
      return parent;
    }
  }
};
HeaderMenu.featureClass = "";
HeaderMenu._$name = "HeaderMenu";
GridFeatureManager.registerFeature(HeaderMenu, true);

// lib/Grid/feature/MergeCells.js
var camelCase = {
  mousedown: "mouseDown",
  mousemove: "mouseMove",
  mouseup: "mouseUp",
  touchdown: "touchDown",
  touchmove: "touchMove",
  touchup: "touchUp",
  pointerover: "mouseOver",
  mouseout: "mouseOut",
  dblclick: "dblClick",
  keydown: "keyDown",
  keypress: "keyPress",
  keyup: "keyUp",
  contextmenu: "contextMenu"
};
var MergeCells = class extends InstancePlugin {
  constructor() {
    super(...arguments);
    // All current ranges (once rendered)
    __publicField(this, "mergedRanges", []);
    // Ranges indexed by row index & column id -> Each range included multiple times, for easy lookup
    __publicField(this, "mergedMap", {});
  }
  static get pluginConfig() {
    return {
      chain: [
        "beforeRenderCell",
        "afterRenderRow",
        "bindStore",
        "afterColumnsChange",
        "afterRemove",
        "afterToggleGroup",
        "afterToggleSubGrid",
        "handleEvent",
        "populateHeaderMenu",
        // 'setHoveredRow'
        "afterSelectionChange"
      ],
      // Grid must perform its update *after* we do.
      before: [
        "onInternalResize"
      ],
      override: [
        "getColumnFromElement",
        "getRecordFromElement"
      ]
    };
  }
  //endregion
  //region Init
  afterConstruct() {
    const me = this, { client } = me;
    client.eachSubGrid((subGrid) => me.setupSubGrid(subGrid));
    client.rowManager.ion({
      renderDone: "onRenderDone",
      thisObj: me
    });
    me.bindStore(client.store);
  }
  setupSubGrid(subGrid) {
    subGrid.$mergedCellsElement = DomHelper.createElement({
      parent: subGrid.element,
      className: {
        "b-grid-merged-cells-container": 1
      }
    });
    subGrid.ion({
      beforeInternalResize: "refreshBounds",
      thisObj: this
    });
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this.isDisabling = true;
      this.reset();
      this.isDisabling = false;
    }
    super.doDisable(disable);
  }
  updatePassthrough(use) {
    this.client.element.classList.toggle("b-mergecells-passthrough", use);
  }
  updateSortedOnly(sortedOnly) {
    if (!this.isConfiguring) {
      this.reset(true, sortedOnly);
    }
  }
  updateShouldMerge(shouldMerge) {
    if (!this.isConfiguring) {
      this.reset(true, shouldMerge);
    }
  }
  //endregion
  //region Grid hooks
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      change: "onStoreChange",
      // Call our refresh logic before grids
      refresh: {
        prio: 1,
        fn: "onStoreRefresh"
      },
      thisObj: this
    });
  }
  // Refresh all ranges when grid is resized
  onInternalResize() {
    this.refreshBounds();
  }
  // Get / create ranges before cell contents are rendered, redirecting the contents to the range
  beforeRenderCell(renderData) {
    const me = this, { column, record, cellElement } = renderData, subGrid = me.client.subGrids[column.region];
    if (!me.disabled && column.mergeCells && (column.isSorted || !me.sortedOnly) && !record.isSpecialRow && !subGrid.collapsed) {
      const mergedRange = me.getMergeRange(record, column);
      if (mergedRange == null ? void 0 : mergedRange.use) {
        cellElement.classList.add("b-merged-cell");
        cellElement.innerHTML = "";
        renderData.cellElement = mergedRange.cellElement;
      }
    }
  }
  afterRenderRow({ row, oldId, oldHeight }) {
    if (oldId === row.id && oldHeight !== row.height) {
      this.heightChanged = true;
    }
  }
  // Refresh all ranges when a column is resized (since it might affect their position and size)
  afterColumnsChange({ action, changes, column }) {
    if (this.disabled) {
      return;
    }
    if (action === "update" && changes.mergeCells && !column.mergeCells) {
      for (const range of this.mergedRanges.slice()) {
        if (range.column === column) {
          this.removeRange(range);
        }
      }
      this.syncDom();
      return;
    }
    this.refreshBounds();
  }
  // Remove might be transitioned, wait until it finishes before resetting (in the afterRemove hook)
  afterRemove() {
    !this.disabled && this.reset();
  }
  // Group collapsed or expanded
  afterToggleGroup() {
    !this.disabled && this.reset();
  }
  // SubGrid collapsed or expanded
  afterToggleSubGrid() {
    !this.disabled && this.reset();
  }
  // setHoveredRow(row) {
  //     this.$hovered = row && this.mergedRanges.find(r => r.fromIndex <= row.dataIndex && r.toIndex >= row.dataIndex);
  //
  //     this.syncDom();
  // }
  // Selection changed, range is considered selected when all of its rows are selected (only in passthrough mode)
  afterSelectionChange() {
    if (!this.passthrough) {
      const { client } = this, indices = client.selectedRecords.map((r) => client.store.indexOf(r));
      let changed = false;
      for (const range of this.mergedRanges) {
        let allSelected = true;
        for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {
          allSelected = indices.includes(i);
        }
        if (range.isSelected !== allSelected) {
          range.isSelected = allSelected;
          changed = true;
        }
      }
      changed && this.syncDom();
    }
  }
  //endregion
  //region Grid overrides
  // Extract record from merged cells
  getRecordFromElement(element) {
    var _a4;
    if ((_a4 = element.elementData) == null ? void 0 : _a4.range) {
      return this.client.store.getAt(element.elementData.range.fromIndex);
    }
    return this.overridden.getRecordFromElement(element);
  }
  // Extract column from merged cells
  getColumnFromElement(element) {
    var _a4;
    if ((_a4 = element.elementData) == null ? void 0 : _a4.range) {
      return element.elementData.range.column;
    }
    return this.overridden.getColumnFromElement(element);
  }
  //endregion
  //region Header menu
  // Allow toggling merging cells from the column header menu (unless column is explicitly disallowing it)
  populateHeaderMenu({ column, items: items2 }) {
    if (column.mergeable !== false) {
      items2.mergeCells = {
        text: "L{MergeCells.mergeCells}",
        icon: `b-fw-icon ${column.mergeCells ? "b-icon-checked" : "b-icon-unchecked"}`,
        tooltip: "L{MergeCells.menuTooltip}",
        cls: "b-separator",
        weight: 500,
        disabled: this.disabled,
        onItem: () => column.mergeCells = !column.mergeCells
      };
    }
  }
  //endregion
  //region Relaying events
  // Relay pointer events from the merged cell on grid
  async handleEvent(event) {
    var _a4;
    if (!this.passthrough) {
      const mergedCellsElement = event.target.closest(".b-grid-merged-cells");
      if (mergedCellsElement) {
        const { client } = this, { range } = mergedCellsElement.elementData, { cellEdit } = client.features, { column } = range, type = StringHelper.capitalize((_a4 = camelCase[event.type]) != null ? _a4 : event.type), eventData = {
          grid: client,
          records: [],
          column,
          cellElement: mergedCellsElement.firstElementChild,
          target: event.target,
          event
        };
        for (let i = range.fromIndex; i <= range.toIndex; i++) {
          eventData.records.push(client.store.getAt(i));
        }
        client.trigger(`mergedCell${type}`, eventData);
        if ((cellEdit == null ? void 0 : cellEdit.triggerEvent.toLowerCase()) === `cell${type}`.toLowerCase()) {
          const row = client.rowManager.getRowAt(event.clientY);
          await cellEdit.startEditing({ id: row.id, columnId: column.id });
        } else if (event.type === "click") {
          this.onRangeClick({ range });
        }
      }
    }
  }
  //endregion
  //region Event listeners
  // Select ranges rows when clicking a merged cell
  onRangeClick({ range }) {
    const records = [];
    for (let i = range.fromIndex; i <= range.toIndex; i++) {
      records.push(this.client.store.getAt(i));
    }
    this.client.selectedRecords = records;
  }
  // Reset when data changes
  onStoreChange() {
    !this.disabled && this.reset();
  }
  // Reset before grids refresh listener come into play, grid will redraw
  onStoreRefresh({ action }) {
    if (action !== "filter" && action !== "dataset") {
      !this.disabled && this.reset(false);
    }
  }
  //endregion
  //region Render
  // Element is needed early since it is passed to column renderers, and syncing for each rendered cell would give a
  // lot of overhead. Thus creating element directly instead
  createRangeElement(range) {
    var _a4, _b, _c;
    const parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement, syncId = `${range.fromIndex}-@-${range.column.id}`;
    let element = (_c = (_a4 = parent.syncIdMap) == null ? void 0 : _a4[syncId]) != null ? _c : (_b = parent.releasedIdMap) == null ? void 0 : _b[syncId];
    if (parent.releasedIdMap) {
      delete parent.releasedIdMap[syncId];
    }
    if (!element) {
      element = DomHelper.createElement(this.createRangeDomConfig(range));
    }
    DomSync.addChild(parent, element, syncId);
    range.element = element;
    range.cellElement = element.firstElementChild;
    return element;
  }
  // Create a DomConfig object for the supplied range, used initially with DomHelper and thereafter with DomSync
  createRangeDomConfig(range) {
    var _a4;
    const { column, fromIndex, toIndex, top, left, right, width, height } = range, { type } = column, record = this.client.store.getAt(fromIndex), domConfig = {
      className: {
        "b-grid-merged-cells": 1,
        // 'b-hover'             : this.$hovered === range,
        "b-selected": range.isSelected
      },
      elementData: {
        range
      },
      style: {
        top,
        left,
        right,
        height,
        width
      },
      dataset: {
        syncId: `${fromIndex}-@-${column.id}`,
        fromIndex,
        toIndex,
        column: column.field,
        columnId: column.id
      },
      children: [
        // Div for an actual cell
        {
          className: new DomClassList(this.client.cellCls).assign({
            [`b-${type == null ? void 0 : type.toLowerCase()}-cell`]: type,
            [column.cellCls]: column.cellCls,
            [column.internalCellCls]: column.internalCellCls
          }).assign(column.autoCls),
          // Don't touch cell children that might have been added by renderer
          keepChildren: true,
          // Tag along the range for easy resolving later
          elementData: {
            range
          },
          // Dataset expected on cells
          dataset: {
            column: column.field,
            columnId: column.id
          },
          // Size using configured row height, to at least have a chance of lining up with surrounding cells
          style: {
            height: this.client.rowManager.rowHeight
          }
        }
      ]
    };
    (_a4 = column.mergedRenderer) == null ? void 0 : _a4.call(column, { domConfig, value: column.getRawValue(record), record, column, fromIndex, toIndex });
    return domConfig;
  }
  buildMergedCellsConfig(fromIndex, toIndex, rows) {
    var _a4, _b;
    const me = this, { client } = me, { rowManager } = client;
    fromIndex = fromIndex != null ? fromIndex : (_a4 = rowManager.topRow) == null ? void 0 : _a4.dataIndex;
    toIndex = toIndex != null ? toIndex : (_b = rowManager.bottomRow) == null ? void 0 : _b.dataIndex;
    const domConfigMap = client.regions.reduce((map, region) => {
      map[region] = {
        className: {
          "b-grid-merged-cells-container": 1
        },
        children: []
      };
      return map;
    }, {});
    for (const range of me.mergedRanges) {
      if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {
        me.updateRange(range, me.heightChanged, rows);
        domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));
      }
    }
    return domConfigMap;
  }
  syncDom(force = false) {
    const me = this, { client } = me, { rowManager } = client;
    if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {
      return;
    }
    const domConfigMap = this.buildMergedCellsConfig();
    client.eachSubGrid((subGrid) => {
      DomSync.sync({
        targetElement: subGrid.$mergedCellsElement,
        syncIdField: "syncId",
        domConfig: domConfigMap[subGrid.region]
      });
    });
    me.heightChanged = false;
  }
  // Called after rows are updated, sync visible ranges per subgrid
  onRenderDone() {
    this.syncDom();
  }
  //endregion
  //region Ranges
  // Remove range from list and index/column map, leaving no trace it since we don't know if it will ever
  // come back (element will be released by DomSync)
  removeRange(range) {
    ArrayHelper.remove(this.mergedRanges, range);
    for (let index = range.fromIndex; index <= range.toIndex; index++) {
      delete this.mergedMap[`${index}-@-${range.column.id}`];
    }
  }
  // Full reset, regenerating all ranges
  reset(redraw = true, force = false) {
    const me = this, columns = me.client.columns.visibleColumns.filter((c) => c.mergeCells && (c.isSorted || !me.sortedOnly || force), true), hadRanges = me.mergedRanges.length;
    me.mergedRanges = [];
    me.mergedMap = {};
    if (redraw && !me.client.refreshSuspended) {
      for (const row of me.client.rowManager.rows) {
        for (const column of columns) {
          row.renderCell(row.getCell(column.id));
        }
      }
      me.syncDom(hadRanges && !me.client.rowManager.rowCount);
    }
  }
  // Refreshes existing ranges coords
  refreshBounds() {
    var _a4;
    const { mergedRanges } = this, row = this.client.rowManager.topRow, boundsMap = /* @__PURE__ */ new Map(), isRtl = this.client.rtl;
    for (const range of mergedRanges.slice()) {
      const { column } = range, cellElement = row.getCell(column.id);
      if (cellElement) {
        let { rowWidth, bounds } = (_a4 = boundsMap.get(column)) != null ? _a4 : {};
        if (!bounds) {
          rowWidth = cellElement.parentElement.offsetWidth;
          bounds = Rectangle.from(cellElement, cellElement.parentElement);
          boundsMap.set(column, { rowWidth, bounds });
        }
        if (isRtl) {
          range.right = rowWidth - bounds.right;
        } else {
          range.left = bounds.left;
        }
        range.width = bounds.width;
      } else {
        this.removeRange(range);
      }
    }
    this.syncDom();
  }
  // Updates the range as user scrolls, until its start and end coords are fully known
  // Rows argument is required to render merged cells on export. We provide row-like objects there
  updateRange(range, force, rows = null) {
    const { store, rowManager } = this.client, { topRendered, bottomRendered } = range, { rowOffsetHeight } = rowManager;
    let { fromIndex, toIndex } = range, topRow, bottomRow;
    force = rows ? rows.length > 0 : force;
    if (!force && topRendered && bottomRendered) {
      return;
    }
    if (!topRendered || force) {
      if (rows) {
        const index = rows.findIndex((row) => row.dataIndex >= fromIndex);
        topRow = rows[index];
        fromIndex = topRow.dataIndex;
      } else {
        do {
          topRow = rowManager.getRowById(store.getAt(fromIndex));
        } while (!topRow && fromIndex++ < toIndex);
      }
      range.topRendered = fromIndex === range.fromIndex;
      const rowsAbove = fromIndex - range.fromIndex;
      range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);
    }
    if (!bottomRendered || force) {
      if (rows) {
        const index = rows.findIndex((row) => row.dataIndex === toIndex);
        bottomRow = rows[index === -1 ? rows.length - 1 : index];
        fromIndex = bottomRow.dataIndex;
      } else {
        do {
          bottomRow = rowManager.getRowById(store.getAt(toIndex));
        } while (!bottomRow && toIndex-- > fromIndex);
      }
      range.bottomRendered = toIndex === range.toIndex;
      const rowsBelow = range.toIndex - toIndex;
      range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);
    }
    range.height = range.bottom - range.top;
  }
  // Retrieve a range for the specified record / column, creating a new one if none found by walking upwards and
  // downwards until a deviating value is found
  getMergeRange(record, column) {
    if (record.isSpecialRow) {
      return;
    }
    const me = this, { mergedMap } = me, { store } = me.client, row = me.client.rowManager.topRow, columnId = column.id, index = store.indexOf(record), key = `${index}-@-${columnId}`, isRtl = this.client.rtl, value = column.getRawValue(record);
    let range = mergedMap[key];
    if (!range) {
      range = mergedMap[key] = {
        column
      };
      me.mergedRanges.push(range);
      let earlierRecord, earlierValue, earlierIndex = index - 1;
      do {
        earlierRecord = store.getAt(earlierIndex);
        earlierValue = earlierRecord && column.getRawValue(earlierRecord);
        if (mergedMap[`${earlierIndex}-@-${columnId}`]) {
          earlierRecord = null;
        }
        earlierIndex--;
      } while (earlierRecord && !earlierRecord.isSpecialRow && earlierValue === value);
      let laterRecord, laterValue, laterIndex = index + 1;
      do {
        laterRecord = store.getAt(laterIndex);
        laterValue = laterRecord && column.getRawValue(laterRecord);
        if (mergedMap[`${laterIndex}-@-${columnId}`]) {
          laterRecord = null;
        }
        laterIndex++;
      } while (laterRecord && !laterRecord.isSpecialRow && laterValue === value);
      range.fromIndex = earlierIndex + 2;
      range.toIndex = laterIndex - 2;
      if (me.shouldMerge && range.toIndex - range.fromIndex > 0) {
        for (let i = range.fromIndex + 1; i <= range.toIndex; i++) {
          const currentRecord = store.getAt(i), previousRecord = store.getAt(i - 1);
          if (me.shouldMerge({ column, record: currentRecord, previousRecord, value }) === false) {
            range.toIndex = i - 1;
            break;
          }
        }
      }
      if (range.toIndex - range.fromIndex > 0) {
        for (let i = range.fromIndex; i <= range.toIndex; i++) {
          mergedMap[`${i}-@-${columnId}`] = range;
        }
        const cellElement = row.getCell(columnId), rowWidth = cellElement.parentElement.offsetWidth, cellBounds = Rectangle.from(cellElement, cellElement.parentElement);
        if (isRtl) {
          range.right = rowWidth - cellBounds.right;
        } else {
          range.left = cellBounds.left;
        }
        range.width = cellBounds.width;
        range.use = true;
      }
    }
    if ((range == null ? void 0 : range.use) && !range.element) {
      me.createRangeElement(range);
    }
    return range;
  }
  //endregion
};
//region Config
__publicField(MergeCells, "$name", "MergeCells");
__publicField(MergeCells, "configurable", {
  /**
   * By default, merged cells allow pointer events to pass through to the underlying row/cell, to allow selecting
   * a row and editing an individual cell even when they are merged. Configure as `false` to allow merged cells to
   * catch and react to the pointer events instead.
   *
   * ```javascript
   * const grid = new Grid({
   *     features : {
   *         mergeCells : {
   *             // Let merged cells react to pointer events
   *             passthrough : false
   *         }
   *     }
   * });
   * ```
   *
   * @prp {Boolean}
   */
  passthrough: true,
  /**
   * Configure as `false` to allow merging cells in columns that are not sorted.
   *
   * {@note}
   * Note that this will have a slight negative impact on performance, since cells in all columns configured to
   * merge cells have to be iterated.
   * {/@note}
   *
   * @prp {Boolean}
   * @default true
   */
  sortedOnly: true,
  /**
   * Hook used to control which cells should be included in a merged range of cells.
   *
   * The feature first determines the range using its default logic. It then calls this hook for each cell in the
   * range except the first, and if the hook returns `false`, the cell is not included in the range but instead a
   * new range is started. The hook thus controls if a cell should be merged with the cell above it or not.
   *
   * Example usage:
   *
   * ```javascript
   * const grid = new Grid({
   *    features : {
   *        mergeCells : {
   *            shouldMerge({ column, record, previousRecord, value }) {
   *                // Only merge cells in the "Age" column as long as the "Name" matches the previous record
   *                if (column.field === 'age') {
   *                    return record.name === previousRecord.name;
   *                }
   *
   *                // Merge other cells as usual
   *                return true;
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @prp {Function}
   * @param {Object} context
   * @param {Grid.column.Column} context.column Current column (readonly)
   * @param {Core.data.Model} context.record Current record (readonly)
   * @param {Core.data.Model} context.previousRecord Previous record (above current record) (readonly)
   * @param {*} context.value Cell's raw value (readonly)
   * @returns {Boolean} Return `true` to merge with the cell above, `false` to start a new range
   */
  shouldMerge: null
});
MergeCells._$name = "MergeCells";
GridFeatureManager.registerFeature(MergeCells);

// lib/Grid/feature/QuickFind.js
var actions2 = {
  goToNextHit: 1,
  goToPrevHit: 1,
  showFilterEditor: 1,
  clearSearch: 1
};
var QuickFind = class extends InstancePlugin {
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ["onElementKeyPress", "onCellNavigate"]
    };
  }
  //endregion
  //region Init
  static get properties() {
    return {
      hitCls: "b-quick-hit",
      hitCellCls: "b-quick-hit-cell",
      hitCellBadgeCls: "b-quick-hit-cell-badge",
      hitTextCls: "b-quick-hit-text"
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    Object.assign(this, {
      grid,
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
  }
  isActionAvailable({ actionName }) {
    if (actions2[actionName]) {
      const { focusedCell } = this.grid;
      return !this.disabled && (focusedCell == null ? void 0 : focusedCell.record) && !focusedCell.isActionable && this.find.length > 0;
    }
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  //endregion
  //region Show/hide QuickFind
  /**
   * Shows a "searchfield" in the header. Triggered automatically when you have a cell focused and start typing.
   * @private
   */
  showQuickFind() {
    const me = this, { grid } = me, header = grid.getHeaderElement(me.columnId);
    if (header) {
      if (!me.headerField) {
        const [element, field, badge] = DomHelper.createElement({
          tag: "div",
          className: "b-quick-hit-header",
          children: [
            { tag: "div", className: "b-quick-hit-field" },
            { tag: "div", className: "b-quick-hit-badge" }
          ]
        }, { returnAll: true });
        if (me.mode === "header") {
          header.appendChild(element);
        } else {
          element.className += " b-quick-hit-mode-grid";
          grid.element.appendChild(element);
        }
        me.headerField = {
          header: element,
          field,
          badge,
          colHeader: header
        };
      }
      me.headerField.field.innerHTML = me.find;
      me.headerField.badge.innerHTML = me.found.length;
      header.classList.add("b-quick-find-header");
    }
    if ((header || grid.hideHeaders) && !me.renderListenerInitialized) {
      grid.rowManager.ion({
        rendercell: me.renderCell,
        thisObj: me
      });
      me.renderListenerInitialized = true;
    }
  }
  /**
   * Hide the "searchfield" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away
   * the keywords.
   * @private
   */
  hideQuickFind() {
    const me = this, { grid, headerField } = me;
    for (const hit of me.prevFound || me.found) {
      const row = grid.getRowById(hit.id);
      if (row) {
        row.forceInnerHTML = true;
        const cellElement = row.getCell(me.columnId);
        cellElement._content = null;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
    if (headerField) {
      headerField.header.parentNode.removeChild(headerField.header);
      headerField.colHeader.classList.remove("b-quick-find-header");
      me.headerField = null;
    }
    if (me.renderListenerInitialized) {
      grid.rowManager.un({ rendercell: me.renderCell }, me);
      me.renderListenerInitialized = false;
    }
    grid.trigger("hideQuickFind");
  }
  //endregion
  //region Search
  /**
   * Performs a search and highlights hits. If find is empty, QuickFind is closed.
   * @param {String} find Text to search for
   * @param {String} columnFieldOrId Column to search
   */
  search(find, columnFieldOrId = this.columnId, fromSplit = false) {
    var _a4;
    const me = this, { grid } = me, column = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId), found = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      find,
      columnId: column.id,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\s+)?`, "ig")
    });
    if (find) {
      me.showQuickFind();
    } else {
      me.hideQuickFind();
    }
    for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {
      cellElement.classList.remove(me.hitCls, me.hitCellCls);
      if (cellElement._originalContent) {
        cellElement.innerHTML = cellElement._originalContent;
        cellElement._originalContent = null;
      }
    }
    if (!found) {
      return;
    }
    if (found.length > 0 && !fromSplit) {
      me.gotoClosestHit(grid.focusedCell, found);
    }
    for (const hit of found) {
      me.foundMap[hit.id] = i++;
      const row = grid.getRowById(hit.data.id);
      row == null ? void 0 : row.renderCell(row.getCell(column.id));
      if (i > 1e3) {
        break;
      }
    }
    (_a4 = grid.syncSplits) == null ? void 0 : _a4.call(grid, (other) => other.features.quickFind.search(find, columnFieldOrId, true));
    grid.trigger("quickFind", { find, found });
  }
  /**
   * Clears and closes QuickFind.
   */
  clear() {
    var _a4;
    if (this.find || ((_a4 = this.found) == null ? void 0 : _a4.length)) {
      this.search("");
    }
  }
  /**
   * Number of results found
   * @type {Number}
   * @readonly
   */
  get foundCount() {
    var _a4, _b;
    return (_b = (_a4 = this.found) == null ? void 0 : _a4.length) != null ? _b : 0;
  }
  /**
   * Found results (as returned by Store#findByField), an array in format { index: x, data: record }
   * @member {StoreSearchResult[]} found
   * @readonly
   */
  //endregion
  //region Navigation
  /**
   * Go to specified hit.
   * @param {Number} index
   */
  gotoHit(index) {
    const nextHit = this.found[index];
    if (nextHit) {
      this.grid.focusCell({
        columnId: this.columnId,
        id: nextHit.id
      }, { doSelect: true });
    }
    return !!nextHit;
  }
  gotoClosestHit(focusedCell, found) {
    const focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0, foundSorted = found.slice().sort(
      (a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex)
    );
    this.gotoHit(found.indexOf(foundSorted[0]));
  }
  /**
   * Go to the first hit.
   */
  gotoFirstHit() {
    this.gotoHit(0);
  }
  /**
   * Go to the last hit.
   */
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  /**
   * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
   */
  gotoNextHit() {
    var _a4, _b, _c, _d;
    const me = this;
    if (!((_a4 = me.found) == null ? void 0 : _a4.length)) {
      return;
    }
    const { grid } = me, currentId = (_d = (_b = grid._focusedCell) == null ? void 0 : _b.id) != null ? _d : (_c = grid.lastFocusedCell) == null ? void 0 : _c.id, currentIndex = grid.store.indexOf(currentId) || 0, nextHit = me.found.find((hit) => hit.index > currentIndex);
    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      }, { doSelect: true });
    } else {
      me.gotoFirstHit();
    }
  }
  /**
   * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
   */
  gotoPrevHit() {
    var _a4, _b, _c, _d;
    const me = this;
    if (!((_a4 = me.found) == null ? void 0 : _a4.length)) {
      return;
    }
    const { grid, found } = me, currentId = (_d = (_b = grid._focusedCell) == null ? void 0 : _b.id) != null ? _d : (_c = grid.lastFocusedCell) == null ? void 0 : _c.id, currentIndex = grid.store.indexOf(currentId) || 0;
    let prevHit;
    if (!found.length) {
      return;
    }
    for (let i = found.length - 1; i--; i >= 0) {
      if (found[i].index < currentIndex) {
        prevHit = found[i];
        break;
      }
    }
    if (prevHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: prevHit.id
      }, { doSelect: true });
    } else {
      me.gotoLastHit();
    }
  }
  //endregion
  //region Render
  /**
   * Called from SubGrid when a cell is rendered.
   * @private
   */
  renderCell({ cellElement, column, record }) {
    var _a4;
    const me = this, { classList } = cellElement, {
      treeWalker,
      findRe,
      hitTextCls
    } = me, hitIndex = me.columnId === column.id && ((_a4 = me.foundMap) == null ? void 0 : _a4[record.id]);
    if (hitIndex) {
      classList.add(me.hitCls);
      cellElement.isQuickHit = true;
      cellElement._originalContent = cellElement.innerHTML;
      const inner = treeWalker.currentNode = DomHelper.down(cellElement, ".b-grid-cell-value,.b-tree-cell-value") || cellElement;
      for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode); ) {
        const nodeToReplace = textNode, textContent = textNode.nodeValue, newText = ["<span>"];
        textNode = treeWalker.nextNode();
        let offset = findRe.lastIndex;
        for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
          const preamble = textContent.substring(offset, match.index), spaceBefore = match[1] ? "\xA0" : "", v = match[2], spaceAfter = match[3] ? "\xA0" : "";
          newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${v}</span>${spaceAfter}`);
          offset = findRe.lastIndex;
        }
        newText.push(StringHelper.encodeHtml(textContent.substring(offset)), "</span>");
        nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(""), {
          fragment: true
        }), nodeToReplace);
        nodeToReplace.remove();
      }
      DomHelper.createElement({
        parent: cellElement,
        className: me.hitCellBadgeCls,
        text: hitIndex
      });
    }
  }
  //endregion
  //region Events
  onBackspace(event) {
    const me = this;
    if (me.find) {
      me.find = me.find.substr(0, me.find.length - 1);
      me.search(me.find);
      return true;
    }
    return false;
  }
  clearSearch() {
    if (this.find) {
      this.find = "";
      this.search(this.find);
      return true;
    }
    return false;
  }
  showFilterEditor() {
    const me = this, { filter } = me.client.features;
    if (filter && me.columnId && me.foundCount) {
      me.clear();
      filter.showFilterEditor(me.client.columns.getById(me.columnId), me.find);
    }
  }
  /**
   * Chained function called on grids keypress event. Handles input for "searchfield".
   * @private
   * @param event
   */
  onElementKeyPress(event) {
    var _a4;
    const me = this, { grid } = me, { focusedCell } = grid;
    if (!event.handled && !me.disabled && (focusedCell == null ? void 0 : focusedCell.record) && !focusedCell.isActionable && ((_a4 = event.key) == null ? void 0 : _a4.length) === 1) {
      const column = grid.columns.getById(grid._focusedCell.columnId);
      if (column && column.searchable !== false) {
        me.columnId = grid._focusedCell.columnId;
        me.find += event.key;
        me.search(me.find);
      }
    }
  }
  onCellNavigate(grid, fromCellSelector, toCellSelector) {
    const me = this;
    if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {
      me.clear();
    }
  }
  //endregion
};
//region Config
__publicField(QuickFind, "$name", "QuickFind");
__publicField(QuickFind, "configurable", {
  mode: "header",
  find: "",
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    F3: "gotoNextHit",
    "Shift+F3": "gotoPrevHit",
    "Ctrl+g": "gotoNextHit",
    "Ctrl+Shift+g": "gotoPrevHit",
    "Ctrl+Shift+f": "showFilterEditor",
    Escape: "clearSearch",
    //Private
    Backspace: "onBackspace"
  }
});
QuickFind._$name = "QuickFind";
GridFeatureManager.registerFeature(QuickFind);

// lib/Grid/feature/RegionResize.js
var RegionResize = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["onElementPointerDown", "onElementDblClick", "onElementTouchMove", "onSubGridCollapse", "onSubGridExpand", "render"]
    };
  }
  //endregion
  updateShowSplitterButtons(value) {
    this.client.element.classList.toggle("b-hide-splitter-buttons", !value);
  }
  onElementDblClick(event) {
    const me = this, { client } = me, splitterEl = event.target.closest(".b-grid-splitter-collapsed");
    if (splitterEl && !me.expanding) {
      me.expanding = true;
      let region = splitterEl.dataset.region, subGrid = client.getSubGrid(region);
      if (!subGrid.collapsed) {
        region = client.getLastRegions()[1];
        subGrid = client.getSubGrid(region);
      }
      subGrid.expand().then(() => me.expanding = false);
    }
  }
  //region Move splitter
  /**
   * Begin moving splitter.
   * @private
   * @param splitterElement Splitter element
   * @param {Event} domEvent The initiating DOM event.
   */
  startMove(splitterElement, domEvent) {
    const me = this, { clientX } = domEvent, { client } = me, region = splitterElement.dataset.region, gridEl = client.element, nextRegion = client.regions[client.regions.indexOf(region) + 1], nextSubGrid = client.getSubGrid(nextRegion), splitterSubGrid = client.getSubGrid(region);
    if (splitterElement.classList.contains("b-grid-splitter-collapsed")) {
      return;
    }
    let subGrid = splitterSubGrid, flip = 1;
    if (subGrid.flex != null) {
      if (nextSubGrid.flex == null) {
        subGrid = nextSubGrid;
        flip = -1;
      }
    }
    if (client.rtl) {
      flip *= -1;
    }
    const availableWidth = Object.values(client.subGrids).reduce((sum, subGrid2) => {
      return subGrid2.width + sum;
    }, 0);
    client.trigger("splitterDragStart", { subGrid, domEvent });
    me.dragContext = {
      element: splitterElement,
      headerEl: subGrid.header.element,
      subGridEl: subGrid.element,
      subGrid,
      splitterSubGrid,
      originalWidth: subGrid.element.offsetWidth,
      originalX: clientX,
      minWidth: subGrid.minWidth || 0,
      maxWidth: Math.min(availableWidth, subGrid.maxWidth || availableWidth),
      flip
    };
    gridEl.classList.add("b-moving-splitter");
    splitterSubGrid.toggleSplitterCls("b-moving");
    me.pointerDetacher = EventHelper.on({
      element: document,
      pointermove: "onPointerMove",
      pointerup: "onPointerUp",
      thisObj: me
    });
  }
  /**
   * Stop moving splitter.
   * @param {Event} domEvent The initiating DOM event.
   * @private
   */
  endMove(domEvent) {
    const me = this, { dragContext, client } = me;
    if (dragContext) {
      const { subGrid } = dragContext;
      domEvent.preventDefault();
      me.pointerDetacher();
      client.element.classList.remove("b-moving-splitter");
      dragContext.splitterSubGrid.toggleSplitterCls("b-moving", false);
      me.dragContext = null;
      client.trigger("splitterDragEnd", { subGrid, domEvent });
    }
  }
  onCollapseClick(subGrid, splitterEl, domEvent) {
    const me = this, { client } = me, region = splitterEl.dataset.region, regions = client.getLastRegions();
    if (client.trigger("splitterCollapseClick", { subGrid, domEvent }) === false) {
      return;
    }
    if (regions[0] === region) {
      const lastSubGrid = client.getSubGrid(regions[1]);
      if (lastSubGrid.collapsed) {
        lastSubGrid.expand(me.animateCollapseExpand);
        return;
      }
    }
    subGrid.collapse(me.animateCollapseExpand);
  }
  onExpandClick(subGrid, splitterEl, domEvent) {
    const me = this, { client } = me, region = splitterEl.dataset.region, regions = client.getLastRegions();
    if (client.trigger("splitterExpandClick", { subGrid, domEvent }) === false) {
      return;
    }
    if (regions[0] === region) {
      if (!subGrid.collapsed) {
        const lastSubGrid = client.getSubGrid(regions[1]);
        lastSubGrid.collapse(me.animateCollapseExpand);
        return;
      }
    }
    subGrid.expand(me.animateCollapseExpand);
  }
  /**
   * Update splitter position.
   * @private
   * @param newClientX
   */
  updateMove(newClientX) {
    const { dragContext } = this;
    if (dragContext) {
      const diffX = newClientX - dragContext.originalX, newWidth = Math.max(Math.min(dragContext.maxWidth, dragContext.originalWidth + diffX * dragContext.flip), 0);
      dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);
    }
  }
  //endregion
  //region Events
  /**
   * Start moving splitter on mouse down (on splitter).
   * @private
   * @param event
   */
  onElementPointerDown(event) {
    var _a4;
    const me = this, { target } = event, splitter = event.button === 0 && target.closest(":not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter"), subGrid = splitter && me.client.getSubGrid(splitter.dataset.region);
    let toggle;
    if (splitter) {
      if (target.closest(".b-grid-splitter-button-collapse")) {
        me.onCollapseClick(subGrid, splitter, event);
      } else if (target.closest(".b-grid-splitter-button-expand")) {
        me.onExpandClick(subGrid, splitter, event);
      } else if (me.enableDragging) {
        me.startMove(splitter, event);
        toggle = splitter;
      }
    }
    if (event.pointerType === "touch" || ((_a4 = me.touchedSplitter) == null ? void 0 : _a4.classList.contains("b-touching"))) {
      me.toggleTouchSplitter(toggle);
    }
  }
  /**
   * Move splitter on mouse move.
   * @private
   * @param event
   */
  onPointerMove(event) {
    if (this.dragContext) {
      this.updateMove(event.clientX);
      event.preventDefault();
    }
  }
  onElementTouchMove(event) {
    if (this.dragContext) {
      event.preventDefault();
    }
  }
  /**
   * Stop moving splitter on mouse up.
   * @private
   * @param event
   */
  onPointerUp(event) {
    if (this.enableDragging) {
      this.endMove(event);
    }
  }
  onSubGridCollapse({ subGrid }) {
    const splitterEl = this.client.resolveSplitter(subGrid), regions = this.client.getLastRegions();
    if (regions[1] === subGrid.region) {
      splitterEl.classList.add("b-grid-splitter-allow-collapse");
    }
  }
  onSubGridExpand({ subGrid }) {
    const splitterEl = this.client.resolveSplitter(subGrid);
    splitterEl.classList.remove("b-grid-splitter-allow-collapse");
  }
  //endregion
  /**
   * Adds b-touching CSS class to splitterElements when touched. Removes when touched outside.
   * @private
   * @param splitterElement
   */
  toggleTouchSplitter(splitterElement) {
    const me = this, { touchedSplitter } = me;
    if (splitterElement && touchedSplitter && splitterElement.dataset.region !== touchedSplitter.dataset.region) {
      me.toggleTouchSplitter();
    }
    const splitterSubGrid = me.client.getSubGrid(splitterElement ? splitterElement.dataset.region : touchedSplitter == null ? void 0 : touchedSplitter.dataset.region);
    if (splitterSubGrid) {
      splitterSubGrid.toggleSplitterCls("b-touching", Boolean(splitterElement));
      if (splitterElement) {
        splitterSubGrid.startSplitterButtonSyncing();
      } else {
        splitterSubGrid.stopSplitterButtonSyncing();
      }
    }
    me.touchedSplitter = splitterElement;
  }
  render() {
    const { regions, subGrids } = this.client;
    if (regions.length === 2) {
      const firstSubGrid = subGrids[regions[0]];
      if (firstSubGrid.maxWidth && firstSubGrid.width >= firstSubGrid.maxWidth) {
        firstSubGrid.splitterElement.classList.add("b-left-only");
      }
    } else if (regions.length > 2) {
      subGrids[regions[0]].splitterElement.classList.add("b-left-only");
      subGrids[regions[1]].splitterElement.classList.add("b-right-only");
    }
  }
  updateEnableDragging(value) {
    this.client.element.classList.toggle("b-grid-splitter-no-drag", !value);
  }
};
// region Init
__publicField(RegionResize, "$name", "RegionResize");
__publicField(RegionResize, "configurable", {
  /**
   * Set to `false` to hide the splitter's collapse/expand buttons
   * @prp {Boolean}
   * @default
   */
  showSplitterButtons: true,
  /**
   * Set to `false` to not use transitions when expanding or collapsing a sub grid
   * @prp {Boolean}
   * @default false
   */
  animateCollapseExpand: VersionHelper.checkVersion("core", "6.0", ">="),
  /**
   * This flag prevents dragging if set to `false` but the collapse / expand buttons will still be functional.
   * @prp {Boolean}
   * @default
   */
  enableDragging: true
});
RegionResize.featureClass = "b-split";
RegionResize._$name = "RegionResize";
GridFeatureManager.registerFeature(RegionResize);

// lib/Grid/feature/RowCopyPaste.js
var actions3 = {
  cut: 1,
  copy: 1,
  paste: 1
};
var RowCopyPaste = class extends CopyPasteBase {
  constructor() {
    super(...arguments);
    // Used in events to separate events from different features from each other
    __publicField(this, "entityName", "row");
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      thisObj: this
    });
    this.grid = grid;
  }
  onBeforeRenderRow({ row, record }) {
    var _a4;
    row.cls["b-cut-row"] = this.isCut && ((_a4 = this.cutData) == null ? void 0 : _a4.includes(record));
  }
  isActionAvailable({ actionName, event }) {
    var _a4;
    const { grid } = this, { cellEdit } = grid.features, { target } = event;
    if (actions3[actionName]) {
      return !this.disabled && globalThis.getSelection().toString().length === 0 && (!cellEdit || !cellEdit.isEditing) && (actionName === "copy" || !this.copyOnly) && // Do not allow cut or paste if copyOnly flag is set
      ((_a4 = grid.selectedRecords) == null ? void 0 : _a4.length) > 0 && // No key action when no selected records
      (!target || Boolean(target.closest(".b-gridbase:not(.b-schedulerbase) .b-grid-subgrid,.b-grid-subgrid:not(.b-timeaxissubgrid)")));
    }
  }
  async copy(record) {
    await this.copyRows(false, record);
  }
  async cut(record) {
    await this.copyRows(true, record);
  }
  paste(referenceRecord) {
    if (referenceRecord instanceof KeyboardEvent) {
      referenceRecord = this.client.getRecordFromElement(referenceRecord.target);
    }
    return this.pasteRows((referenceRecord == null ? void 0 : referenceRecord.isModel) ? referenceRecord : null);
  }
  /**
   * Copy or cut rows to clipboard to paste later
   *
   * @fires beforeCopy
   * @fires copy
   * @param {Boolean} [isCut] Copies by default, pass `true` to cut
   * @category Common
   * @on-owner
   * @async
   */
  async copyRows(isCut = false, recordOrEvent) {
    var _a4, _b;
    const { client, entityName } = this;
    let records = this.selectedRecords.filter((r) => !r.readOnly || !isCut);
    if (recordOrEvent) {
      let toCopyRecord;
      if (recordOrEvent instanceof KeyboardEvent) {
        toCopyRecord = (_b = (_a4 = client.resolveRowRecord) == null ? void 0 : _a4.call(client, recordOrEvent.target)) != null ? _b : client.getRecordFromElement(recordOrEvent.target);
      } else {
        toCopyRecord = recordOrEvent;
      }
      if (!client.isSelected(toCopyRecord)) {
        records = [toCopyRecord];
      }
    }
    if (!records.length || client.readOnly) {
      return;
    }
    await this.writeToClipboard(records, isCut);
    client.trigger("copy", { records, isCut, entityName });
  }
  // Called from Clipboardable when cutData changes
  setIsCut(record, isCut) {
    var _a4;
    (_a4 = this.grid.rowManager.getRowById(record)) == null ? void 0 : _a4.toggleCls("b-cut-row", isCut);
    record.meta.isCut = isCut;
  }
  // Called from Clipboardable when cutData changes
  handleCutData({ source }) {
    var _a4;
    if (source !== this && ((_a4 = this.cutData) == null ? void 0 : _a4.length)) {
      this.grid.store.remove(this.cutData);
    }
  }
  /**
   * Called from Clipboardable after writing a non-string value to the clipboard
   * @param eventRecords
   * @returns {String}
   * @private
   */
  stringConverter(records) {
    const { rowManager } = this.grid, cells = records.flatMap((r) => {
      var _a4;
      return (_a4 = rowManager.getRowById(r)) == null ? void 0 : _a4.cells.map((c) => new Location(c));
    });
    return this.cellsToString(cells.filter((c) => c));
  }
  // Called from Clipboardable before writing to the clipboard
  async beforeCopy({ data, isCut }) {
    return await this.client.trigger("beforeCopy", { records: data, isCut, entityName: this.entityName });
  }
  /**
   * Paste rows below selected or passed record
   *
   * @fires beforePaste
   * @param {Core.data.Model} [record] Paste below this record, or currently selected record if left out
   * @category Common
   * @on-owner
   */
  async pasteRows(record) {
    var _a4, _b, _c;
    const me = this, { client, isCut, entityName } = me, referenceRecord = record || client.selectedRecord;
    if (client.readOnly || client.isTreeGrouped) {
      return [];
    }
    const records = await me.readFromClipboard({ referenceRecord }, true), isOwn = me.clipboardData === records;
    if (!Array.isArray(records) || !(records == null ? void 0 : records.length) || client.store.tree && isCut && records.some((rec) => rec.contains(referenceRecord, true))) {
      return [];
    }
    me.sortByIndex(records);
    const idMap = {}, recordsToProcess = me.extractParents(records, idMap, isOwn);
    await me.insertCopiedRecords(recordsToProcess, referenceRecord);
    if (client.isDestroying) {
      return;
    }
    if (isCut) {
      await me.clearClipboard();
    } else {
      client.selectedRecords = recordsToProcess;
    }
    client.trigger("paste", {
      records: recordsToProcess,
      originalRecords: records,
      referenceRecord,
      isCut,
      entityName
    });
    me.clipboard.triggerPaste(me);
    (_c = (_b = (_a4 = client.getRowFor(recordsToProcess[recordsToProcess.length - 1])) == null ? void 0 : _a4.cells) == null ? void 0 : _b[0]) == null ? void 0 : _c.focus();
    return recordsToProcess;
  }
  // Called from Clipboardable before finishing the internal clipboard read
  async beforePaste({ referenceRecord, data, text, isCut }) {
    const records = data !== text ? data : [];
    return await this.client.trigger("beforePaste", {
      records,
      referenceRecord,
      isCut,
      entityName: this.entityName,
      data
    });
  }
  /**
   * Called from Clipboardable after reading from clipboard, and it is determined that the clipboard data is
   * "external"
   * @param json
   * @private
   */
  stringParser(clipboardData) {
    return this.setFromStringData(clipboardData, true).modifiedRecords;
  }
  /**
   * A method used to generate the name for a copy-pasted record. By defaults appends "- 2", "- 3" as a suffix. Override
   * it to provide your own naming of pasted records.
   *
   * @param {Core.data.Model} record The new record being pasted
   * @returns {String}
   */
  generateNewName(record) {
    const originalName = record.getValue(this.nameField);
    let counter = 2;
    while (this.client.store.findRecord(this.nameField, `${originalName} - ${counter}`)) {
      counter++;
    }
    return `${originalName} - ${counter}`;
  }
  insertCopiedRecords(toInsert, recordReference) {
    const { store } = this.client, insertAt = store.indexOf(recordReference) + 1;
    if (store.isTree) {
      return recordReference.parent.insertChild(toInsert, recordReference.nextSibling, false, {
        // Specify node to insert before in the ordered tree. It allows to paste to a
        // correct place both ordered and visual.
        // Covered by TaskOrderedWbs.t.js
        orderedBeforeNode: recordReference.nextOrderedSibling
      });
    } else {
      return store.insert(insertAt, toInsert);
    }
  }
  get selectedRecords() {
    const records = [...this.client.selectedRecords];
    this.client.selectedCells.forEach((cell) => {
      if (!records.includes(cell.record)) {
        records.push(cell.record);
      }
    });
    return records;
  }
  getMenuItemText(action, addRowSpecifier = false) {
    const me = this;
    let text = me[action + "RecordText"];
    if (addRowSpecifier) {
      text += ` (${me.selectedRecords.length > 1 ? me.rowSpecifierTextPlural : me.rowSpecifierText})`;
    }
    return text;
  }
  populateCellMenu({ record, items: items2, cellSelector }) {
    var _a4;
    const me = this, {
      client,
      rowOptionsOnCellContextMenu
    } = me, cellCopyPaste = ((_a4 = client.features.cellCopyPaste) == null ? void 0 : _a4.enabled) === true, targetIsCell = cellCopyPaste && client.isCellSelected(cellSelector);
    if (!client.readOnly && !client.isTreeGrouped && (record == null ? void 0 : record.isSpecialRow) === false && (cellCopyPaste ? client.selectedRows.length : client.selectedRecords.length) && (!targetIsCell || me.rowOptionsOnCellContextMenu)) {
      if (!me.copyOnly) {
        items2.cut = {
          text: me.getMenuItemText("cut", targetIsCell && rowOptionsOnCellContextMenu),
          localeClass: me,
          icon: "b-icon b-icon-cut",
          weight: 135,
          disabled: record.readOnly,
          onItem: () => me.cut(record)
        };
        items2.paste = {
          text: me.getMenuItemText("paste", targetIsCell && rowOptionsOnCellContextMenu),
          localeClass: me,
          icon: "b-icon b-icon-paste",
          weight: 140,
          onItem: () => me.paste(record),
          disabled: me.hasClipboardData() === false
        };
      }
      items2.copy = {
        text: me.getMenuItemText("copy", targetIsCell && rowOptionsOnCellContextMenu),
        localeClass: me,
        cls: "b-separator",
        icon: "b-icon b-icon-copy",
        weight: 120,
        onItem: () => me.copy(record)
      };
    }
  }
  /**
   * Sort array of records ASC by its indexes stored in indexPath
   * @param {Core.data.Model[]} array array to sort
   * @private
   */
  sortByIndex(array) {
    const { store } = this.client;
    return array.sort((rec1, rec2) => {
      const idx1 = rec1.indexPath, idx2 = rec2.indexPath;
      if (!array.includes(rec1.parent) && !array.includes(rec2.parent)) {
        return store.indexOf(rec1) - store.indexOf(rec2);
      }
      if (idx1.length === idx2.length) {
        for (let i = 0; i < idx1.length; i++) {
          if (idx1[i] < idx2[i]) {
            return -1;
          }
          if (idx1[i] > idx2[i]) {
            return 1;
          }
        }
        return 0;
      } else {
        return idx1.length - idx2.length;
      }
    });
  }
  /**
   * Iterates over passed pre-sorted list of records and reassembles hierarchy of records.
   * @param {Core.data.Model[]} taskRecords array of records to extract parents from
   * @param {Object} idMap Empty object which will contain map linking original id with copied record
   * @returns {Core.data.Model[]} Returns array of new top-level nodes with children filled
   * @private
   */
  extractParents(taskRecords, idMap, generateNames = true) {
    const me = this, { store } = me.client;
    if (store.tree) {
      taskRecords.forEach((node) => {
        node.traverse((n) => {
          const parents = n.getTopParent(true);
          if (!taskRecords.includes(n) && (!me.isCut || !taskRecords.some((rec) => parents.includes(rec)))) {
            taskRecords.push(n);
          }
        });
      });
    }
    const result = taskRecords.reduce((parents, node) => {
      let copy;
      const parentId = node.parentId || node.meta.modified;
      if (me.isCut) {
        copy = node;
        copy.meta.isCut = false;
      } else {
        copy = node.copy();
        if (generateNames) {
          copy[me.nameField] = me.generateNewName(copy);
        }
        copy.data.expanded = node.isExpanded(me.client.store);
      }
      idMap[node.id] = copy;
      if (node.parent === store.rootNode) {
        parents.push(copy);
      } else if (parentId in idMap) {
        idMap[parentId].appendChild(copy, true);
      } else {
        parents.push(copy);
      }
      return parents;
    }, []);
    result.forEach((parent) => {
      parent.sortOrderedChildren(true, true);
    });
    return result;
  }
};
__publicField(RowCopyPaste, "$name", "RowCopyPaste");
__publicField(RowCopyPaste, "type", "rowCopyPaste");
__publicField(RowCopyPaste, "pluginConfig", {
  assign: [
    "copyRows",
    "pasteRows"
  ],
  chain: [
    "populateCellMenu"
  ]
});
__publicField(RowCopyPaste, "configurable", {
  /**
   * The field to use as the name field when updating the name of copied records
   * @config {String}
   * @default
   */
  nameField: "name",
  keyMap: {
    // Weight to give CellCopyPaste priority
    "Ctrl+C": { weight: 10, handler: "copy" },
    "Ctrl+X": { weight: 10, handler: "cut" },
    "Ctrl+V": { weight: 10, handler: "paste" }
  },
  copyRecordText: "L{copyRecord}",
  cutRecordText: "L{cutRecord}",
  pasteRecordText: "L{pasteRecord}",
  rowSpecifierText: "L{row}",
  rowSpecifierTextPlural: "L{rows}",
  localizableProperties: [
    "copyRecordText",
    "cutRecordText",
    "pasteRecordText",
    "rowSpecifierText",
    "rowSpecifierTextPlural"
  ],
  /**
   * Adds `Cut (row)`, `Copy (row)` and `Paste (row)` options when opening a context menu on a selected cell when
   * {@link Grid.view.mixin.GridSelection#config-selectionMode cellSelection} and
   * {@link Grid.feature.CellCopyPaste} is active. Default behaviour will only provide row copy/paste actions on a
   * selected row.
   * @config {Boolean}
   * @default
   */
  rowOptionsOnCellContextMenu: false
});
RowCopyPaste.featureClass = "b-row-copypaste";
RowCopyPaste._$name = "RowCopyPaste";
GridFeatureManager.registerFeature(RowCopyPaste, true, "Grid");
GridFeatureManager.registerFeature(RowCopyPaste, false, "Gantt");
GridFeatureManager.registerFeature(RowCopyPaste, false, "SchedulerPro");
GridFeatureManager.registerFeature(RowCopyPaste, false, "ResourceHistogram");

// lib/Grid/feature/RowExpander.js
var actions4 = {
  onTab: 1,
  onShiftTab: 1
};
var storeRemoveActions = { remove: 1, filter: 1, dataset: 1, replace: 1 };
var RowExpander = class extends InstancePlugin.mixin(Delayable_default) {
  // Cannot use `static properties = {}`, new Map/Set would pollute the prototype
  static get properties() {
    return {
      // CSS classes
      expanderBodyClass: "b-rowexpander-body",
      expandedRowClass: "b-rowexpander-row-expanded",
      shadowRootContainerClass: "b-rowexpander-shadowroot-container",
      // Map where the keys are the expanded records and values are an object
      // {rowHeight, cellHeight, expandedBodyElements}
      recordStateMap: /* @__PURE__ */ new Map(),
      collapsingStateMap: /* @__PURE__ */ new Map()
    };
  }
  // Plugin configuration. This plugin chains/overrides some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ["afterColumnsChange", "beforeRenderRow", "processRowHeight", "bindStore", "navigateUp"],
      override: ["onGridBodyFocusIn", "navigateDown", "catchFocus", "keyMapOnKeyDown"]
    };
  }
  //endregion
  //region Init
  afterConstruct() {
    const me = this, { client } = me;
    if (!me.renderer && !me.widget) {
      me.disabled = true;
      console.warn("RowExpander requires either a widget config or implementing the renderer function.");
      return;
    }
    if (client.isGanttBase && client.fixedRowHeight !== false) {
      console.warn("When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.");
    }
    if (me.widget) {
      GlobalEvents_default.ion({
        theme: me.onThemeChange,
        thisObj: me
      });
    }
    me.bindStore(client.store);
    if (me.triggerEvent) {
      client.ion({ [me.triggerEvent]: "onTriggerEvent", thisObj: me });
    }
    me.addColumn();
  }
  bindStore(store) {
    const me = this;
    me.recordStateMap.clear();
    me.collapsingStateMap.clear();
    me.detachListeners("clientStoreChange");
    store.ion({
      name: "clientStoreChange",
      change: me.onStoreChange,
      thisObj: me
    });
  }
  doDisable(disable) {
    const { client } = this;
    if (disable) {
      this.recordStateMap.clear();
      this.collapsingStateMap.clear();
    }
    if (!client.isConfiguring) {
      client.rowManager.renderFromRow();
    }
    super.doDisable(disable);
  }
  changeLoadingIndicatorText(text) {
    return text ? this.L(text) : text;
  }
  // Overrides onGridBodyFocusIn to ignore events on row expander body.
  onGridBodyFocusIn(event) {
    var _a4, _b;
    const me = this;
    if (me.hasWidget ? !event.target.matches(`.${me.expanderBodyClass}, .${me.shadowRootContainerClass}`) : !((_b = (_a4 = me.client.lastMousedownEvent) == null ? void 0 : _a4.target) == null ? void 0 : _b.closest("." + me.expanderBodyClass))) {
      me.overridden.onGridBodyFocusIn(event);
    }
  }
  // Override keyMap key down so to not acting on keydown inside nested grid
  keyMapOnKeyDown({ target }) {
    var _a4;
    if (!this.hasWidget || !((_a4 = target.classList) == null ? void 0 : _a4.contains(this.shadowRootContainerClass))) {
      this.overridden.keyMapOnKeyDown(...arguments);
    }
  }
  get isAnimating() {
    return this.client.isAnimating;
  }
  set isAnimating(value) {
    const { client } = this, wasAnimating = client.isAnimating;
    client.isAnimating = value;
    if (client.isAnimating !== wasAnimating) {
      client.element.classList.toggle("b-rowexpander-animating");
    }
  }
  changeWidget(widget) {
    if (widget && this.isWidgetConfig(widget)) {
      return { [this.client.regions[0]]: widget };
    }
    return widget;
  }
  //endregion
  //region Events
  /**
   * This event fires before row expand is started.
   *
   * Returning `false` from a listener prevents the RowExpander to expand the row.
   *
   * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is
   * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by
   * scrolling, it can happen much later.
   *
   * @event beforeExpand
   * @preventable
   * @async
   * @param {Core.data.Model} record Record
   */
  /**
   * This event fires before row collapse is started.
   *
   * Returning `false` from a listener prevents the RowExpander to collapse the row.
   *
   * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is
   * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by
   * scrolling, it can happen much later.
   *
   * @event beforeCollapse
   * @preventable
   * @async
   * @param {Core.data.Model} record Record
   */
  /**
   * This event fires when a row expand has finished expanding.
   *
   * Note that this event fires when actual row expander body is rendered, and not necessarily in immediate succession
   * of an expand action. In the case of expanding a row that is not yet rendered into view by scrolling, it can happen
   * much later.
   *
   * @event expand
   * @param {Core.data.Model} record Record
   * @param {Object} expandedElements An object with the Grid region name as property and the expanded body
   * element as value
   * @param {Core.widget.Widget} widget In case of expanding a Widget, this will be a reference to the instance
   * created by the actual expansion. If there is multiple Grid regions, use the `widgets` param instead.
   * @param {Object} widgets In case of expanding a Widget, this will be an object with the Grid region name as
   * property and the reference to the widget instance created by the actual expansion
   */
  /**
   * This event fires when a row has finished collapsing.
   *
   * @event collapse
   * @param {Core.data.Model} record Record
   */
  //endregion
  //region ExpanderColumn
  afterColumnsChange() {
    this.addColumn();
  }
  changeColumn(config) {
    if (config == null) {
      return config;
    }
    return {
      type: "action",
      actions: [{
        cls: "b-icon b-icon-collapse-down",
        tooltip: ({ record }) => this.L(this.recordStateMap.has(record) ? "L{RowExpander.collapse}" : "L{RowExpander.expand}"),
        onClick: ({ record }) => this.toggleExpand(record)
      }],
      width: 40,
      hideable: false,
      align: "center",
      region: this.client.regions[0],
      ...config,
      field: "expanderActionColumn"
    };
  }
  // Called in construct and if grid columns change
  addColumn() {
    const me = this, { column } = me, { columns } = me.client;
    if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {
      me._isAddingExpanderColumn = true;
      if (me.columnPosition === "last") {
        [me._expander] = columns.add(column);
      } else {
        [me._expander] = columns.insert(0, column);
      }
      me._isAddingExpanderColumn = false;
    }
  }
  //endregion
  //region UI events
  onTriggerEvent({ target }) {
    if (this.disabled || (target == null ? void 0 : target.closest(".b-action-cell")) || !target.closest(".b-grid-cell")) {
      return;
    }
    this.toggleExpand(this.client.getRecordFromElement(target));
  }
  /**
   * Toggles expanded state.
   * @private
   * @param {Core.data.Model} record The record that should be toggled
   * @category Internal
   */
  toggleExpand(record) {
    if (record) {
      if (this.recordStateMap.has(record)) {
        this.collapse(record);
      } else {
        this.expand(record);
      }
    }
  }
  onExpanderBodyResize(entries) {
    var _a4;
    for (const entry of entries) {
      const record = this.client.store.getById((_a4 = entry.target.dataset) == null ? void 0 : _a4.id), recordState = record && this.recordStateMap.get(record);
      if (recordState && !recordState.ignoreResize && !recordState.isAnimating) {
        const oldHeight = recordState.expanderBodyHeight;
        recordState.expanderBodyHeight = null;
        if (this.processRowHeight(record, 0) !== oldHeight) {
          this.renderRowsWithAnimation(record);
        }
      }
    }
  }
  //endregion
  //region Rendering
  get shouldSpanRegions() {
    return this.spanRegions && this.client.regions.length > 1;
  }
  /**
   * Listens to changes in the Grid Store. Will remove expand State data on Store removal.
   * If the refreshOnRecordChange config is `true`, it will trigger a re-render of the expander.
   * @private
   * @param {String} action
   * @param {Core.data.Store} source
   * @param {Core.data.Model[]} records
   * @category Internal
   */
  onStoreChange({ action, source, records, changes }) {
    var _a4;
    const me = this, { recordStateMap, collapsingStateMap } = me, changedKeys = changes && Object.keys(changes);
    if ((changedKeys == null ? void 0 : changedKeys.length) === 1 && ((_a4 = source.modelClass.fieldMap[changedKeys[0]]) == null ? void 0 : _a4.type) === "store") {
      return;
    }
    if (me.disabled) {
      return;
    }
    if (action === "removeAll") {
      recordStateMap.clear();
      collapsingStateMap.clear();
    } else if (storeRemoveActions[action]) {
      for (const [record, state] of recordStateMap) {
        if (!source.includes(record)) {
          me.destroyWidgets(state);
          recordStateMap.delete(record);
          collapsingStateMap.delete(record);
        }
      }
    } else if (me.refreshOnRecordChange && (records == null ? void 0 : records.length)) {
      if (action === "update") {
        const recordState = recordStateMap.get(records[0]);
        if (recordState == null ? void 0 : recordState.isCreated) {
          recordState.isCreated = false;
          me.client.rowManager.renderFromRecord(records[0]);
        }
      } else if (action === "updatemultiple") {
        let topRecordIndex, topRecord;
        for (const rec of records) {
          const recordState = recordStateMap.get(rec);
          if (recordState == null ? void 0 : recordState.isCreated) {
            const index = source.records.indexOf(rec);
            recordState.isCreated = false;
            if (!topRecord || topRecordIndex > index) {
              topRecordIndex = index;
              topRecord = rec;
            }
          }
        }
        if (topRecord) {
          me.client.rowManager.renderFromRecord(topRecord);
        }
      }
    }
  }
  // Implements grid.processRowHeight hook
  processRowHeight(record, height) {
    var _a4, _b;
    const me = this, { shouldSpanRegions } = me;
    let recordState = me.recordStateMap.get(record), heightChanged = false;
    if (recordState && !recordState.expanderBodyHeight) {
      for (const region of me.client.regions) {
        const height2 = (_a4 = recordState.expandedBodyElements[region]) == null ? void 0 : _a4.offsetHeight;
        if (height2 > recordState.expanderBodyHeight) {
          recordState.expanderBodyHeight = height2;
          heightChanged = true;
        }
      }
    } else if (!recordState && (recordState = me.collapsingStateMap.get(record)) && recordState.expanderBodyHeight) {
      recordState.expanderBodyHeight = 0;
      heightChanged = true;
    }
    if (heightChanged && me.enableAnimations && shouldSpanRegions) {
      me.animateSpannedExpander(recordState);
    }
    return ((_b = recordState == null ? void 0 : recordState.expanderBodyHeight) != null ? _b : 0) + height;
  }
  // If we're using spanRegions, we need to force a CSS transition on the body elements height
  animateSpannedExpander(state) {
    const me = this, bodyElement = state.expandedBodyElements[me.client.regions[0]], rowElement = me.client.rowManager.getRowById(state.record).element;
    state.isAnimating = me.isAnimating = true;
    state.ignoreResize = true;
    bodyElement.style.height = rowElement.offsetHeight - state.cellHeight + "px";
    bodyElement.offsetHeight;
    bodyElement.style.height = state.expanderBodyHeight + "px";
    me.waitForTransition(bodyElement, () => {
      bodyElement.style.height = "";
      if (!state.expanderBodyHeight) {
        bodyElement.remove();
      }
      state.isAnimating = me.isAnimating = false;
    });
  }
  /**
   * Hooks on before row render to render or remove row expander content depending on record state.
   * @private
   * @category Internal
   */
  beforeRenderRow({ row, record }) {
    const me = this, { regions } = me.client, {
      expandedRowClass,
      collapsingStateMap,
      shouldSpanRegions
    } = me, recordState = me.recordStateMap.get(record);
    row.cls.toggle("b-rowexpander-disabled", me.disabled);
    if (row.cls[expandedRowClass]) {
      let collapsingState = collapsingStateMap.get(record);
      if (collapsingState) {
        const clearCollapse = () => {
          collapsingState = collapsingStateMap.get(record);
          if (collapsingState) {
            collapsingStateMap.delete(record);
            me.removeExpander(row);
            me.destroyWidgets(collapsingState);
          }
        };
        if (me.enableAnimations && me.isAnimating) {
          me.waitForTransition(row, clearCollapse);
        } else {
          clearCollapse();
        }
      } else if (!recordState) {
        me.removeExpander(row);
      }
    } else {
      collapsingStateMap.delete(record);
    }
    if (!me.disabled && recordState) {
      if (!recordState.isCreated) {
        recordState.ignoreResize = true;
        me.renderExpander(record, row, recordState);
      }
      row.cls.add(expandedRowClass);
      regions.forEach((region, i) => {
        const rowElement = row.getElement(region);
        if (recordState.isCreated && (!shouldSpanRegions || i === 0)) {
          const bodyElement = recordState.expandedBodyElements[region], target = shouldSpanRegions ? me.client.verticalScroller : rowElement;
          if (bodyElement.parentElement !== target) {
            if (!shouldSpanRegions) {
              DomHelper.removeEachSelector(rowElement, "." + me.expanderBodyClass);
            }
            target.appendChild(bodyElement);
            me.observeResize(bodyElement);
          }
          if (shouldSpanRegions) {
            bodyElement.style.top = row.top + recordState.cellHeight + "px";
          }
          recordState.ignoreResize = false;
          if (recordState.renderPromiseResolver && !recordState.isRenderingAsync) {
            me.delay(recordState.renderPromiseResolver);
            recordState.renderPromiseResolver = null;
          }
        }
        me.lockCellHeight(rowElement, recordState.cellHeight, false);
      });
      if (me._shouldScrollIntoView && me.autoScroll) {
        me._shouldScrollIntoView = false;
        if (!DomHelper.isInView(recordState.expandedBodyElements[regions[0]], true)) {
          me.client.rowManager.ion({
            once: true,
            thisObj: me,
            renderDone: () => me.scrollRowIntoView(row, record)
          });
        }
      }
    }
  }
  /**
   * Scrolls expanded row into view. This function is called after rowManager has finished rendering.
   * @private
   * @category Internal
   */
  scrollRowIntoView(row, record) {
    if (this.isAnimating) {
      this.waitForTransition(row, () => this.client.scrollRowIntoView(record));
    } else {
      this.client.scrollRowIntoView(record);
    }
  }
  /**
   * Waits for height transition on the provided rows element. Then calls provided function.
   * @private
   * @category Internal
   */
  waitForTransition(row, fn) {
    var _a4;
    const element = DomHelper.isElement(row) ? row : row.element;
    EventHelper.onTransitionEnd({
      element,
      property: "height",
      handler: fn,
      thisObj: this,
      duration: (_a4 = DomHelper.getPropertyTransitionDuration(element, "height")) != null ? _a4 : 1
    });
  }
  removeExpander(row) {
    var _a4, _b;
    const me = this;
    row.cls.remove(me.expandedRowClass);
    for (const region of me.client.regions) {
      const rowElement = row.getElement(region);
      for (const child of rowElement.querySelectorAll("." + me.expanderBodyClass)) {
        me.unobserveResize(child);
        child.remove();
      }
      rowElement.classList.remove(me.expandedRowClass);
      me.lockCellHeight(rowElement, null, false);
      if (me.shouldSpanRegions) {
        (_b = (_a4 = row._spannedExpandedBodyElement) == null ? void 0 : _a4.remove) == null ? void 0 : _b.call(_a4);
        row._spannedExpandedBodyElement = null;
      }
    }
  }
  destroyWidgets(state) {
    var _a4, _b, _c;
    for (const region of this.client.regions) {
      (_c = (_b = (_a4 = state.widgets) == null ? void 0 : _a4[region]) == null ? void 0 : _b.destroy) == null ? void 0 : _c.call(_b);
    }
  }
  // Checks if a configuration object is a widget configuration object
  isWidgetConfig(content) {
    return content.type && !content.tag;
  }
  /**
   * Creates expander element for each grid region and calls the renderer, also for each grid region.
   * @private
   * @param {Core.data.Model} record
   * @param {Grid.row.Row} row
   * @param {Object} recordState
   * @category Internal
   */
  renderExpander(record, row, recordState) {
    var _a4, _b;
    const me = this, { client: grid, widget, shouldSpanRegions } = me, cellHeight = (_a4 = row.cells[0]) == null ? void 0 : _a4.offsetHeight, { expandedBodyElements = {} } = recordState, renderPromises = [], continueRendering = (content, expanderElement, region) => {
      if (content != null) {
        if (typeof content === "string") {
          const currentChildren = [...expanderElement.childNodes].map((n) => expanderElement.removeChild(n));
          expanderElement.innerHTML = content;
          currentChildren.reverse().forEach((n) => expanderElement.insertBefore(n, expanderElement.firstChild));
        } else if (me.isWidgetConfig(content)) {
          createWidget(content, expanderElement, region);
        } else {
          content = DomHelper.createElement(content);
          expanderElement.appendChild(content);
        }
      }
    }, createWidget = (widgetConfig, expanderElement, region) => {
      var _a5;
      const themeName = (_a5 = DomHelper.getThemeInfo()) == null ? void 0 : _a5.name, shadowRootContainer = DomHelper.createElement({
        parent: expanderElement,
        className: me.shadowRootContainerClass,
        style: "flex : 1"
      }), shadowRoot = shadowRootContainer._shadowRoot = shadowRootContainer.attachShadow({ mode: "closed" });
      renderPromises.push(DomHelper.cloneStylesIntoShadowRoot(shadowRoot).then(() => {
        var _a6;
        if (grid.isDestroyed) {
          return;
        }
        const widgetDataField = (_a6 = widgetConfig.dataField) != null ? _a6 : me.dataField;
        if (widgetDataField) {
          const fieldData = record.getValue(widgetDataField);
          if (fieldData == null ? void 0 : fieldData.isStore) {
            widgetConfig.store = fieldData;
          } else if (grid.store[`${widgetDataField}Store`]) {
            const relatedStore = grid.store[`${widgetDataField}Store`];
            widgetConfig.store = relatedStore.chain((r) => record.getValue(widgetDataField).includes(r));
          } else {
            widgetConfig.store = {
              data: fieldData,
              // Refresh expanded row on created store changes
              internalListeners: {
                change: () => !row.isDestroyed && row.render(),
                thisObj: me
              }
            };
          }
        }
        if (themeName) {
          const { cls } = widgetConfig, themeCls = `b-theme-${themeName.toLowerCase()}`;
          widgetConfig.cls = cls ? cls + " " + themeCls : themeCls;
        }
        if (!recordState.widgets) {
          recordState.widgets = {};
        }
        recordState.widgets[region] = expanderElement.widget = Widget.create(ObjectHelper.assign({
          appendTo: shadowRoot,
          owner: grid,
          flex: 1,
          minHeight: "5em",
          isNested: true,
          expandedRecord: record
        }, widgetConfig));
      }).catch((href) => {
        throw new Error("Could not load stylesheet " + href);
      }));
    };
    if (recordState.isRenderingAsync) {
      return;
    }
    row.addCls(me.expandedRowClass);
    Object.assign(recordState, { cellHeight, expandedBodyElements, expanderBodyHeight: 0, loadingIndicators: [] });
    for (const [i, region] of grid.regions.entries()) {
      if (shouldSpanRegions && i > 0) {
        break;
      }
      const rowElement = row.getElement(region);
      let expanderBodyElement = expandedBodyElements[region], renderResponse;
      if (expanderBodyElement) {
        me.unobserveResize(expanderBodyElement);
        expanderBodyElement.innerHTML = "";
      } else {
        expanderBodyElement = DomHelper.createElement({
          parent: shouldSpanRegions ? grid.verticalScroller : rowElement,
          tabIndex: -1,
          className: me.expanderBodyClass,
          style: {
            top: shouldSpanRegions ? row.top + cellHeight : cellHeight + "px"
          },
          dataset: {
            id: record.id
          }
        });
      }
      if (shouldSpanRegions) {
        row._spannedExpandedBodyElement = expanderBodyElement;
      }
      me.observeResize(expanderBodyElement);
      if (widget == null ? void 0 : widget[region]) {
        createWidget(widget[region], expanderBodyElement, region);
      } else {
        renderResponse = (_b = me.renderer) == null ? void 0 : _b.call(me, {
          record,
          expanderElement: expanderBodyElement,
          rowElement,
          region,
          grid
        });
      }
      if (Objects.isPromise(renderResponse)) {
        renderPromises.push(renderResponse.then((content) => continueRendering(content, expanderBodyElement, region)));
      } else {
        continueRendering(renderResponse, expanderBodyElement, region);
      }
      expandedBodyElements[region] = expanderBodyElement;
    }
    if (renderPromises.length) {
      recordState.isRenderingAsync = true;
      me.showLoadingIndicators(recordState);
      Promise.all(renderPromises).then(() => {
        Promise.all(renderPromises).then(() => {
          var _a5, _b2;
          if (grid.isDestroyed) {
            return;
          }
          (_a5 = recordState.loadingIndicators) == null ? void 0 : _a5.forEach((li) => li.remove());
          recordState.loadingIndicators.length = 0;
          recordState.ignoreResize = false;
          recordState.isRenderingAsync = false;
          for (const [, state] of me.recordStateMap) {
            if (state.isRenderingAsync) {
              return;
            }
          }
          (_b2 = me.renderRowsWithAnimation) == null ? void 0 : _b2.call(me, record, true);
        });
      });
    }
    recordState.isCreated = true;
  }
  showLoadingIndicators(recordState) {
    for (const region in recordState.expandedBodyElements) {
      recordState.loadingIndicators.push(DomHelper.createElement({
        parent: recordState.expandedBodyElements[region],
        className: "b-rowexpander-loading",
        style: {
          height: this.loadingIndicatorHeight + "px"
        },
        children: [
          {
            tag: "i",
            className: "b-icon b-icon-spinner"
          },
          this.loadingIndicatorText
        ]
      }));
    }
  }
  /**
   * Called when grid rows needs to re-render, for example on expand or collapse.
   * Activates animations on grid, and deactivates them when they are completed.
   * @private
   * @param {Core.data.Model} record Record whose row was toggled
   * @category Internal
   */
  renderRowsWithAnimation(record) {
    const me = this;
    if (me.enableAnimations) {
      const row = me.client.rowManager.getRowById(record);
      if (row) {
        me.isAnimating = true;
        if (me.collapsingStateMap.has(record)) {
          row.addCls("b-row-is-collapsing");
        }
        me.waitForTransition(row, () => {
          var _a4;
          me.isAnimating = false;
          if (!row.isDestroyed) {
            (_a4 = row.removeCls) == null ? void 0 : _a4.call(row, "b-row-is-collapsing");
          }
        });
      }
    }
    return me.bufferedRenderer(record);
  }
  /**
   * Collects a rendering call for each record, saves them in array and calls the delayed (RAF) rafRenderer function
   * @private
   * @param {Core.data.Model} record Record whose row was toggled
   * @category Internal
   */
  bufferedRenderer(record) {
    var _a4;
    ((_a4 = this._bufferedRecords) != null ? _a4 : this._bufferedRecords = []).push(record);
    if (!this._rafPromise) {
      this._rafPromise = new Promise((resolve) => {
        requestAnimationFrame(() => {
          var _a5;
          (_a5 = this.internalRender) == null ? void 0 : _a5.call(this, resolve);
          this._rafPromise = null;
        });
      });
    }
    return this._rafPromise;
  }
  /**
   * Re-renders the grid from the topmost record of those saved in bufferedRenderer
   * @private
   * @category Internal
   */
  internalRender(resolvePromise) {
    const me = this, { _bufferedRecords } = me, { store } = me.client;
    me.recordStateMap.forEach((state, record) => {
      if (state.renderPromiseResolver && state.isCreated && !_bufferedRecords.includes(record)) {
        _bufferedRecords.push(record);
      }
    });
    const [top] = _bufferedRecords.sort((a, b) => store.indexOf(a) - store.indexOf(b));
    me.client.rowManager.renderFromRecord(top);
    _bufferedRecords.length = 0;
    me.delay(resolvePromise);
  }
  /**
   * Called when row is expanded. This function locks all cell's height to current height (before expanding).
   * @private
   * @param {HTMLElement} rowElement
   * @param {Number} cellHeight The height to lock
   * @param {Boolean} unlock To remove locked cell height when the row is collapsed
   * @category Internal
   */
  lockCellHeight(rowElement, cellHeight, unlock) {
    for (let a = 0; a < rowElement.children.length; a++) {
      const child = rowElement.children[a];
      if (!child.classList.contains(this.expanderBodyClass)) {
        child.style.height = unlock ? "" : cellHeight + "px";
      }
    }
  }
  //endregion
  //region Public
  /**
   * Tells the RowExpander that the provided record should be expanded. If or when the record is rendered into view,
   * the record will be expanded.
   *
   * Promise will resolve when the row gets expanded. Note that this can be much later than the actual expand call,
   * depending on response times and if current record is in view or not.
   *
   * @param {Core.data.Model} record Record whose row should be expanded
   * @category Common
   */
  async expand(record, fromSplit = false) {
    const me = this;
    if (me.disabled || me.recordStateMap.has(record) || await me.trigger("beforeExpand", { record }) === false) {
      return;
    }
    let recordState;
    return new Promise((resolve) => {
      var _a4, _b;
      recordState = {
        isCreated: false,
        renderPromiseResolver: resolve,
        record
      };
      me.recordStateMap.set(record, recordState);
      me.collapsingStateMap.delete(record);
      me._shouldScrollIntoView = true;
      me.renderRowsWithAnimation(record);
      if (!fromSplit) {
        (_b = (_a4 = me.client).syncSplits) == null ? void 0 : _b.call(_a4, (other) => other.features.rowExpander.expand(record, true));
      }
    }).then(() => {
      var _a4, _b;
      (_b = me.trigger) == null ? void 0 : _b.call(me, "expand", {
        record,
        expandedElements: recordState.expandedBodyElements,
        widget: (_a4 = recordState.widgets) == null ? void 0 : _a4[me.client.regions[0]],
        widgets: recordState.widgets
      });
    });
  }
  /**
   * Tells the RowExpander that the provided record should be collapsed. If the record is in view, it will be
   * collapsed. If the record is not in view, it will simply not be expanded when rendered into view.
   *
   * @param {Core.data.Model} record Record whose row should be collapsed
   * @category Common
   */
  async collapse(record, fromSplit = false) {
    var _a4, _b;
    const me = this, recordState = me.recordStateMap.get(record);
    if (me.disabled || await me.trigger("beforeCollapse", { record }) === false) {
      return;
    }
    if (recordState == null ? void 0 : recordState.expandedBodyElements) {
      for (const region in recordState.expandedBodyElements) {
        me.unobserveResize(recordState.expandedBodyElements[region]);
      }
    }
    me.recordStateMap.delete(record);
    me.collapsingStateMap.set(record, recordState);
    await me.renderRowsWithAnimation(record);
    me.trigger("collapse", { record });
    if (!fromSplit) {
      (_b = (_a4 = me.client).syncSplits) == null ? void 0 : _b.call(_a4, (other) => other.features.rowExpander.collapse(record, true));
    }
  }
  //endregion
  // region Nested navigation
  get hasWidget() {
    return Boolean(this.widget) || [...this.recordStateMap.values()].some((state) => state.widgets);
  }
  // Overrides the original, hence the if statement
  navigateDown() {
    if (!this.onKeyboardIn()) {
      return this.overridden.navigateDown(...arguments);
    }
  }
  // Chains the original
  navigateUp() {
    this.onKeyboardIn(true);
  }
  // Detects if focus is being reverted here by a nested grid, and focuses either the expanded row or the row below
  catchFocus({ navigationDirection, source, editing }) {
    var _a4;
    const { client } = this, { focusedCell, regions } = client;
    for (let [record, state] of this.recordStateMap.entries()) {
      for (const region in state.expandedBodyElements) {
        if (state.expandedBodyElements[region].widget === source) {
          if (editing) {
            const nextRegion = regions[regions.indexOf(region) + (navigationDirection === "down" ? 1 : -1)];
            if (nextRegion) {
              return this.startEditInWidget((_a4 = state.widgets) == null ? void 0 : _a4[nextRegion], navigationDirection === "down");
            }
          }
          if (navigationDirection === "down") {
            record = client.store.getNext(record, void 0, true);
          }
          let column;
          if (!editing && focusedCell && !focusedCell._isDefaultFocus) {
            column = focusedCell.column;
          } else {
            column = this.getNavigateableColumn(client, true, editing && navigationDirection === "up");
          }
          client._focusedCell = null;
          const cellContext = client.normalizeCellContext({ record, column });
          client.focusCell(cellContext);
          if (editing) {
            client.startEditing(cellContext);
          }
          return true;
        }
      }
    }
  }
  // Detects if the user keyboard navigates either from the expanded row and down, or the row below the expanded row
  // and up. If so, and there is a Grid in the expanded body, it starts to keyboard navigate there
  onKeyboardIn(up) {
    var _a4, _b, _c;
    const { focusedCell } = this.client, state = focusedCell && this.recordStateMap.get(focusedCell.record), widget = (_c = (_b = state == null ? void 0 : state.expandedBodyElements) == null ? void 0 : _b[(_a4 = focusedCell == null ? void 0 : focusedCell.column) == null ? void 0 : _a4.region]) == null ? void 0 : _c.widget;
    if (widget == null ? void 0 : widget.isGrid) {
      let column;
      if (widget.focusedCell && !widget.focusedCell._isDefaultFocus) {
        column = widget.focusedCell.column;
      } else {
        column = this.getNavigateableColumn(widget);
      }
      widget._focusedCell = null;
      widget.focusCell(widget.normalizeCellContext({ record: widget[`${up ? "last" : "first"}VisibleRow`], column }));
      return true;
    }
    return false;
  }
  /**
   * Get the first column that is not the `checkboxSelectionColumn` and not the expander column.
   * @param grid
   * @param editable Also checks that the column has an `editor`
   * @param reverse If `true`, this functions returns the last column which meets the requirements
   * @private
   */
  getNavigateableColumn(grid, editable = true, reverse = false) {
    var _a4;
    const columns = reverse ? [...grid.columns.visibleColumns].reverse() : grid.columns.visibleColumns;
    return (_a4 = columns.find(
      (c) => {
        var _a5;
        return c !== grid.checkboxSelectionColumn && c !== ((_a5 = grid.features.rowExpander) == null ? void 0 : _a5._expander) && (!editable || c.editor);
      }
    )) != null ? _a4 : columns[0];
  }
  isActionAvailable({ actionName }) {
    var _a4;
    if (actions4[actionName]) {
      return !this.isDisabled && ((_a4 = this.client.features.cellEdit) == null ? void 0 : _a4.isEditing);
    }
  }
  onTab(previous) {
    var _a4;
    const { client } = this, { cellEdit } = client.features;
    if (cellEdit == null ? void 0 : cellEdit.enabled) {
      const { columns, regions } = client, { activeRecord } = cellEdit, next = previous !== true, nextCell = cellEdit.getAdjacentEditableCell(client.focusedCell, next), expandedRecord = next ? activeRecord : nextCell ? client.store.getById(nextCell.id) : null, widgets = expandedRecord && ((_a4 = this.recordStateMap.get(expandedRecord)) == null ? void 0 : _a4.widgets);
      if (widgets && (activeRecord == null ? void 0 : activeRecord.id) !== (nextCell == null ? void 0 : nextCell.id)) {
        let nextRegion = (nextCell ? columns.getById(nextCell.columnId) : columns.visibleColumns[0]).region;
        while (nextRegion) {
          const widget = widgets[nextRegion];
          if (this.startEditInWidget(widget, next)) {
            return true;
          }
          nextRegion = regions[regions.indexOf(nextRegion) + (next ? 1 : -1)];
        }
      }
    }
    return false;
  }
  startEditInWidget(widget, next = true) {
    var _a4, _b;
    const { cellEdit } = this.client.features;
    if ((cellEdit == null ? void 0 : cellEdit.enabled) && ((_b = (_a4 = widget == null ? void 0 : widget.features) == null ? void 0 : _a4.cellEdit) == null ? void 0 : _b.enabled)) {
      cellEdit.finishEditing().then(() => {
        const record = widget[`${next ? "first" : "last"}VisibleRow`], column = this.getNavigateableColumn(widget, true, !next);
        widget.startEditing(widget.normalizeCellContext({ record, column }));
      });
      return true;
    }
  }
  onShiftTab() {
    return this.onTab(true);
  }
  // endregion
  // Resize observe in own function for overridability
  observeResize(element) {
    const me = this;
    if (!me.resizeObserver) {
      me.resizeObserver = new ResizeObserver((entries) => me.onExpanderBodyResize(entries));
    }
    me.resizeObserver.observe(element);
  }
  // Unobserves an observed element
  unobserveResize(element) {
    var _a4;
    (_a4 = this.resizeObserver) == null ? void 0 : _a4.unobserve(element);
  }
  doDestroy() {
    var _a4;
    (_a4 = this.resizeObserver) == null ? void 0 : _a4.disconnect();
    delete this.resizeObserver;
    for (const [, state] of this.recordStateMap) {
      this.destroyWidgets(state);
    }
    super.doDestroy();
  }
  onThemeChange({ prev, theme }) {
    for (const [, entry] of this.recordStateMap) {
      Object.values(entry.expandedBodyElements).forEach((bodyElement) => {
        var _a4, _b, _c, _d;
        const shadowRootContainer = bodyElement.querySelector("." + this.shadowRootContainerClass);
        if (shadowRootContainer == null ? void 0 : shadowRootContainer._shadowRoot) {
          DomHelper.cloneStylesIntoShadowRoot(shadowRootContainer == null ? void 0 : shadowRootContainer._shadowRoot, true);
          (_b = (_a4 = bodyElement.widget) == null ? void 0 : _a4.element) == null ? void 0 : _b.classList.remove(`b-theme-${prev}`);
          (_d = (_c = bodyElement.widget) == null ? void 0 : _c.element) == null ? void 0 : _d.classList.add(`b-theme-${theme}`);
        }
      });
    }
  }
  /**
   * Gets the corresponding expanded record from either a nested widget or an element in the expanded body.
   * @param {HTMLElement|Core.widget.Widget} elementOrWidget
   * @returns {Core.data.Model}
   */
  getExpandedRecord(elementOrWidget) {
    var _a4;
    for (const [rec, { widgets, expandedBodyElements }] of this.recordStateMap.entries()) {
      if (widgets && elementOrWidget.isWidget) {
        for (const region in widgets) {
          if (widgets[region] === elementOrWidget) {
            return rec;
          }
        }
        if ((_a4 = elementOrWidget.expandedRecord) == null ? void 0 : _a4.isModel) {
          return elementOrWidget.expandedRecord;
        }
      } else {
        for (const region in expandedBodyElements) {
          const curEl = expandedBodyElements[region];
          if (curEl === elementOrWidget || curEl.contains(elementOrWidget)) {
            return rec;
          }
        }
      }
    }
    return null;
  }
  /**
   * Gets the expanded widget(s) for a specified record. The widget(s) will be returned as an object with region
   * names as properties and the widgets as values.
   * @param {Core.data.Model} record
   * @returns {Core.widget.Widget}
   */
  getExpandedWidgets(record) {
    var _a4;
    return (_a4 = this.recordStateMap.get(record)) == null ? void 0 : _a4.widgets;
  }
};
//region Config
__publicField(RowExpander, "$name", "RowExpander");
__publicField(RowExpander, "configurable", {
  /**
   * The implementation of this function is called each time the body of an expanded row is rendered. Either
   * return an HTML string, a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup or any
   * Widget configuration object, like a Grid configuration object for example.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            renderer({record, region, expanderElement}){
   *                return htmlToBeExpanded;
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * Or return a {@link Core.helper.DomHelper#typedef-DomConfig} object.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            renderer({record, region, expanderElement}){
   *                return {
   *                   tag       : 'form',
   *                   className : 'expanded-row-form',
   *                   children  : [
   *                       {
   *                           tag        : 'textarea',
   *                           name       : 'description',
   *                           className  : 'expanded-textarea'
   *                       },
   *                       {
   *                           tag        : 'button',
   *                           text       : 'Save',
   *                           className  : 'expanded-save-button',
   *                       }
   *                   ]
   *                };
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * Or return a Widget configuration object. What differs a Widget configuration object from a DomConfig object
   * is the presence of the `type` property and the absence of a `tag` property.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            async renderer({record, region, expanderElement}){
   *                const myData = await fetch('myURL');
   *                return {
   *                   type : 'grid',
   *                   autoHeight : true,
   *                   columns : [
   *                       ...
   *                   ],
   *                   data : myData
   *                };
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * It is also possible to add markup directly to the expanderElement.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            renderer({record, region, expanderElement}){
   *                new UIComponent({
   *                    appendTo: expanderElement,
   *                    ...
   *                });
   *            }
   *        }
   *    }
   * });
   * ```
   * The renderer function can also be asynchronous.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            async renderer({record, region, expanderElement}){
   *                return await awaitAsynchronousOperation();
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @config {Function}
   * @param {Object} renderData Object containing renderer parameters
   * @param {Core.data.Model} renderData.record Record for the row
   * @param {HTMLElement} renderData.expanderElement Expander body element
   * @param {HTMLElement} renderData.rowElement Row element
   * @param {String} renderData.region Grid region name
   * @param {Grid.view.Grid} renderData.grid Grid instance
   * @returns {String|DomConfig|null} Row expander body content
   * @async
   *
   * @category Rendering
   */
  renderer: null,
  /**
   * The name of the Grid event that will toggle expander. Defaults to `null` but can be set to any event such
   * as {@link Grid.view.mixin.GridElementEvents#event-cellDblClick} or
   * {@link Grid.view.mixin.GridElementEvents#event-cellClick}.
   *
   * ```javascript
   * features : {
   *     rowExpander : {
   *         triggerEvent : 'cellclick'
   *     }
   * }
   * ```
   *
   * @config {String}
   */
  triggerEvent: null,
  /**
   * Provide a column config object to display a button with expand/collapse functionality.
   * Shown by default, set to `null` to not include.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            column: {
   *                // Use column config options here
   *                region: 'last'
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @config {ActionColumnConfig|Grid.column.ActionColumn}
   */
  column: {},
  /**
   * Makes the expand/collapse button column appear either as the first column (default or `first`) or as the
   * last (set to `last`). Note that the column by default will be added to the first region, if the Grid
   * has multiple regions. Use the {@link #config-column} config to change region.
   * @config {String}
   * @default
   */
  columnPosition: "first",
  /**
   * If set to `true`, the RowExpander will, on record update, re-render an expanded row by calling the
   * {@link #config-renderer} function or recreate the configured {@link #config-widget}.
   * @config {Boolean}
   * @default
   */
  refreshOnRecordChange: false,
  /**
   * Use this for customizing async {@link #config-renderer} loading indicator height.
   * @config {Number}
   * @defalt
   */
  loadingIndicatorHeight: 100,
  /**
   * Use this for customizing async {@link #config-renderer} loading indicator text.
   * @config {String}
   * @default Loading
   */
  loadingIndicatorText: "L{loading}",
  /**
   * Use this to disable expand and collapse animations.
   * @config {Boolean}
   * @default
   */
  enableAnimations: true,
  /**
   * A widget configuration object that will be used to create a widget to render into the row expander body. Can
   * be used instead of providing a {@link #config-renderer}.
   *
   * If the widget needs a store, it can be populated by use of the {@link #config-dataField} config. This will
   * create a store from the expanded record's corresponding `dataField` value, which needs to be an array of
   * objects or a store itself.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            widget : {
   *                type : 'detailGrid',
   *            },
   *            dataField : 'orderDetails'
   *        }
   *    }
   * });
   * ```
   *
   * If there is multiple regions, you can configure each region like so:
   *
   * ```javascript
   * new Grid({
   *     features : {
   *         rowExpander : {
   *             widget : {
   *                 // The region name is the property, and its widget config the value
   *                 left : {
   *                    type : 'detailGrid',
   *                    // If your widgets uses different data sources, put the dataField
   *                    //  property in the widget configuration object
   *                    dataField : 'orderDetails'
   *                },
   *                middle : {
   *                    type : 'summaryGrid',
   *                    dataField : 'sumDetails
   *                },
   *                // No expander here
   *                right : null
   *             }
   *         }
   *     }
   * })
   * ```
   *
   * @config {ContainerItemConfig}
   * @typings {ContainerItemConfig}
   */
  widget: null,
  /**
   * Used together with {@link #config-widget} to populate the widget's Store from the expanded record's
   * corresponding `dataField` value, which needs to be an array of objects or a store itself.
   * @config {String}
   */
  dataField: null,
  keyMap: {
    // Private
    Tab: { handler: "onTab", weight: 50 },
    "Shift+Tab": { handler: "onShiftTab", weight: 50 }
  },
  /**
   * When expanding a row and the expanded body element is not completely in view, setting this to `true` will
   * automatically scroll the expanded row into view.
   * @config {Boolean}
   * @default
   */
  autoScroll: false,
  /**
   * When the Grid has multiple regions, setting this config to `true` changes how the expanded content is created
   * and rendered. Instead of calling {@link #config-renderer} once per region (or one {@link #config-widget}
   * per region) it will only create one expanded element which will span the full grid width regardless of Grid
   * regions.
   * @config {Boolean}
   * @default
   */
  spanRegions: false
});
RowExpander._$name = "RowExpander";
GridFeatureManager.registerFeature(RowExpander);

// lib/Grid/feature/RowReorder.js
var RowReorder = class extends Delayable_default(InstancePlugin) {
  static get deprecatedEvents() {
    return {
      gridRowBeforeDragStart: {
        product: "Grid",
        invalidAsOfVersion: "6.0.0",
        message: "`gridRowBeforeDragStart` event is deprecated, listen on this event on the Grid instead."
      },
      gridRowDragStart: {
        product: "Grid",
        invalidAsOfVersion: "6.0.0",
        message: "`gridRowDragStart` event is deprecated, listen on this event on the Grid instead."
      },
      gridRowDrag: {
        product: "Grid",
        invalidAsOfVersion: "6.0.0",
        message: "`gridRowDrag` event is deprecated, listen on this event on the Grid instead."
      },
      gridRowBeforeDropFinalize: {
        product: "Grid",
        invalidAsOfVersion: "6.0.0",
        message: "`gridRowBeforeDropFinalize` event is deprecated, listen on this event on the Grid instead."
      },
      gridRowDrop: {
        product: "Grid",
        invalidAsOfVersion: "6.0.0",
        message: "`gridRowDrop` event is deprecated, listen on this event on the Grid instead."
      },
      gridRowAbort: {
        product: "Grid",
        invalidAsOfVersion: "6.0.0",
        message: "`gridRowAbort` event is deprecated, listen on this event on the Grid instead."
      }
    };
  }
  construct(grid, config) {
    this.grid = grid;
    super.construct(...arguments);
  }
  doDestroy() {
    var _a4;
    (_a4 = this.dragHelper) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  /**
   * Initialize drag & drop (called on first paint)
   * @private
   */
  init() {
    const me = this, { grid } = me;
    me.dragHelper = DragHelper.new({
      name: "rowReorder",
      cloneTarget: true,
      dragThreshold: 10,
      proxyTopOffset: 10,
      targetSelector: ".b-grid-row",
      lockX: true,
      dragWithin: grid.bodyContainer,
      allowDropOutside: true,
      scrollManager: grid.scrollManager,
      outerElement: me.targetSubGridElement,
      touchStartDelay: me.touchStartDelay,
      isElementDraggable: me.isElementDraggable.bind(me),
      monitoringConfig: {
        scrollables: [
          {
            element: grid.scrollable.element,
            direction: "vertical"
          }
        ]
      },
      setXY(element, x, y) {
        const { context } = this;
        if (!context.started) {
          const elementRect = Rectangle.from(context.element, this.dragWithin), pointerDownOffset = context.startPageY - globalThis.pageYOffset - context.element.getBoundingClientRect().top;
          y = elementRect.top + pointerDownOffset + this.proxyTopOffset;
        }
        DomHelper.setTranslateXY(element, x, y);
      },
      // Since parent nodes can expand after hovering, meaning original drag start position now refers to a different point in the tree
      ignoreSamePositionDrop: false,
      createProxy(element) {
        const clone = element.cloneNode(true), container = document.createElement("div");
        container.classList.add("b-row-reorder-proxy");
        clone.removeAttribute("id");
        clone.style.transform = "";
        clone.style.width = "";
        container.appendChild(clone);
        if (grid.selectedRecords.length > 1) {
          const clone2 = clone.cloneNode(true);
          clone2.classList.add("b-row-dragging-multiple");
          container.appendChild(clone2);
        }
        DomHelper.removeClsGlobally(container, "b-selected", "b-hover", "b-focused");
        return container;
      },
      internalListeners: {
        beforedragstart: "onBeforeDragStart",
        dragstart: "onDragStart",
        drag: "onDrag",
        drop: "onDrop",
        abort: "onAbort",
        reset: "onReset",
        prio: 1e4,
        // To ensure our listener is run before the relayed listeners (for the outside world)
        thisObj: me
      }
    }, me.dragHelperConfig);
    me.relayEvents(me.dragHelper, ["beforeDragStart", "dragStart", "drag", "abort"], "gridRow");
    grid.relayEvents(me.dragHelper, ["beforeDragStart", "dragStart", "drag", "abort"], "gridRow");
    me.dropIndicator = DomHelper.createElement({
      className: "b-row-drop-indicator"
    });
    me.dropOverTargetCls = ["b-row-reordering-target", "b-hover"];
  }
  get targetSubGridElement() {
    const targetSubGrid = this.grid.regions[0];
    return this.grid.subGrids[targetSubGrid].element;
  }
  //endregion
  //region Events (drop)
  isElementDraggable(el, event) {
    if (!el.closest(".b-grid-cell .b-widget")) {
      if (this.gripOnly) {
        const firstCell = el.closest(".b-grid-cell:first-child");
        if (firstCell) {
          const gripperStyle = getComputedStyle(firstCell, ":before"), offsetX = this.grid.rtl ? firstCell.getBoundingClientRect().width - event.borderOffsetX : event.borderOffsetX, onGrip = offsetX <= parseFloat(gripperStyle.width);
          if (onGrip) {
            this.client.preventDragSelect = true;
          }
          return onGrip;
        }
      } else {
        return true;
      }
    }
  }
  onBeforeDragStart({ event, source, context }) {
    const me = this, { grid } = me, { group } = grid.features, subGridEl = me.targetSubGridElement;
    if (event.target.classList.contains("b-rowexpander-shadowroot-container") || me.disabled || grid.readOnly || grid.isTreeGrouped || !subGridEl.contains(context.element)) {
      return false;
    }
    const startRecord = context.startRecord = grid.getRecordFromElement(context.element);
    if ((group == null ? void 0 : group.enabled) && Array.isArray(startRecord[grid.features.group.field])) {
      return false;
    }
    if (startRecord.readOnly || startRecord.isSpecialRow) {
      return false;
    }
    context.originalRowTop = grid.rowManager.getRowFor(startRecord).top;
    if (!grid.selectionMode.checkboxOnly) {
      if (source.startEvent.pointerType === "touch") {
        if (!grid.isSelected(startRecord)) {
          grid.selectRow({
            record: startRecord,
            addToSelection: false
          });
        }
      } else if (!grid.isSelected(startRecord) && !event.shiftKey && !event.ctrlKey) {
        grid.selectRow({
          record: startRecord
        });
      }
    }
    const selectedRecords = grid.selectedRecords.filter((r) => !r.readOnly);
    context.records = [startRecord];
    if (selectedRecords.includes(startRecord)) {
      context.records.push(...selectedRecords.filter((r) => r !== startRecord));
      context.records.sort((r1, r2) => grid.store.indexOf(r1) - grid.store.indexOf(r2));
    }
    return true;
  }
  onDragStart({ context }) {
    var _a4, _b;
    const me = this, { grid } = me, { cellEdit, cellMenu, headerMenu } = grid.features;
    if (cellEdit) {
      me.cellEditDisabledState = cellEdit.disabled;
      cellEdit.disabled = true;
    }
    (_a4 = cellMenu == null ? void 0 : cellMenu.hideContextMenu) == null ? void 0 : _a4.call(cellMenu, false);
    (_b = headerMenu == null ? void 0 : headerMenu.hideContextMenu) == null ? void 0 : _b.call(headerMenu, false);
    grid.element.classList.add("b-row-reordering");
    const focusedCell = context.element.querySelector(".b-focused");
    focusedCell == null ? void 0 : focusedCell.classList.remove("b-focused");
    context.element.firstElementChild.classList.remove("b-selected", "b-hover");
    grid.bodyContainer.appendChild(me.dropIndicator);
  }
  onDrag({ context, event }) {
    var _a4;
    const me = this, { grid } = me, { store, rowManager } = grid, { clientY } = event;
    let valid = true, row = rowManager.getRowAt(clientY), overRecord, dataIndex, after, over, insertBefore;
    if (row) {
      const rowTop = row.top + grid.scrollable.element.getBoundingClientRect().top - grid.scrollable.y, quarter = row.height / 4, topQuarter = rowTop + quarter, middleY = rowTop + row.height / 2, bottomQuarter = rowTop + quarter * 3;
      dataIndex = row.dataIndex;
      overRecord = store.getAt(dataIndex);
      if (store.tree) {
        over = (overRecord.isParent || me.dropOnLeaf) && clientY > topQuarter && clientY < bottomQuarter;
      } else if (store.isGrouped) {
        over = overRecord.isGroupHeader && overRecord.meta.collapsed;
      }
      after = !over && event.clientY >= middleY;
    } else {
      if (event.pageY < grid._bodyRectangle.y) {
        dataIndex = 0;
        overRecord = store.first;
        after = false;
      } else {
        dataIndex = store.count - 1;
        overRecord = store.last;
        after = true;
      }
      row = grid.rowManager.getRow(dataIndex);
    }
    if (overRecord === me.overRecord && me.after === after && me.over === over) {
      context.valid = me.reorderValid;
      return;
    }
    if (me.overRecord !== overRecord) {
      (_a4 = rowManager.getRowById(me.overRecord)) == null ? void 0 : _a4.removeCls(me.dropOverTargetCls);
    }
    me.overRecord = overRecord;
    me.after = after;
    me.over = over;
    if (
      // Hovering the dragged record. This is a no-op.
      // But still gather the contextual data.
      overRecord === context.startRecord || // Not allowed to drop above topmost group header or below a collapsed header
      !after && !over && dataIndex === 0 && store.isGrouped || // Not allowed to drop after last collapsed group
      after && overRecord.isGroupHeader && overRecord.meta.collapsed && store.indexOf(overRecord) === store.count - 1
    ) {
      valid = false;
    }
    if (store.tree) {
      insertBefore = after ? overRecord.nextSibling : overRecord;
      if (context.records.some((rec) => rec.contains(overRecord))) {
        valid = false;
      }
      context.parent = valid && over ? overRecord : overRecord.parent;
      me.clearTimeout(me.hoverTimer);
      if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {
        me.hoverTimer = me.setTimeout(() => grid.expand(overRecord), me.hoverExpandTimeout);
      }
    } else {
      insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;
    }
    row.toggleCls(me.dropOverTargetCls, valid && over);
    if (!over && dataIndex === store.indexOf(context.startRecord) + (after ? -1 : 1) && context.parent && context.startRecord.parent === context.parent) {
      valid = false;
    }
    row && DomHelper.setTranslateY(me.dropIndicator, Math.max(row.top + (after ? row.element.getBoundingClientRect().height : 0), 1));
    me.dropIndicator.style.visibility = over ? "hidden" : "visible";
    me.dropIndicator.classList.toggle("b-drag-invalid", !valid);
    context.insertBefore = insertBefore;
    context.valid = me.reorderValid = valid;
  }
  /**
   * Handle drop
   * @private
   */
  async onDrop(event) {
    const me = this, { client } = me, { context } = event;
    context.valid = context.valid && me.reorderValid;
    if (context.valid) {
      context.async = true;
      if (client.store.tree) {
        context.oldPositionContext = context.records.map((record) => {
          var _a4;
          return {
            record,
            parentId: (_a4 = record.parent) == null ? void 0 : _a4.id,
            parentIndex: record.parentIndex
          };
        });
      }
      let result = await me.trigger("gridRowBeforeDropFinalize", event);
      if (result === false) {
        context.valid = false;
      }
      result = await client.trigger("gridRowBeforeDropFinalize", event);
      if (result === false) {
        context.valid = false;
      }
      me.animateDrop && await me.dragHelper.animateProxyTo(me.dropIndicator, { align: "l0-l0" });
      await me.finalizeReorder(context);
    }
    me.clearTimeout(me.hoverTimer);
    me.overRecord = me.after = me.over = null;
    me.trigger("gridRowDrop", event);
    client.trigger("gridRowDrop", event);
  }
  onAbort(event) {
    this.client.trigger("gridRowDragAbort", event);
  }
  async finalizeReorder(context) {
    var _a4, _b;
    const me = this, { grid } = me, { store, focusedCell } = grid, sorterFn = me.preserveSorters && store.isSorted && store.sorterFn;
    let { records } = context;
    context.valid = context.valid && !records.some((rec) => !store.includes(rec));
    if (context.valid) {
      let result;
      if (sorterFn) {
        records.sort(sorterFn);
      }
      if (store.tree) {
        records = records.filter((record) => !record.parent || record.bubbleWhile((parent) => !records.includes(parent), true));
        result = await context.parent.tryInsertChild(records, me.over ? (_a4 = context.parent.children) == null ? void 0 : _a4[0] : context.insertBefore);
        grid.rowManager.forEach((r) => r.removeCls(me.dropOverTargetCls));
        if (!context.parent.isExpanded() && ((_b = context.parent.children) == null ? void 0 : _b.length)) {
          grid.expand(context.parent);
        }
        context.valid = result !== false;
      } else if (store.isGrouped && me.over) {
        store.move(records, store.getAt(store.indexOf(context.insertBefore) + 1));
      } else {
        if (records.length > 1) {
          while (context.insertBefore && records.includes(context.insertBefore)) {
            context.insertBefore = store.getNext(context.insertBefore, false, true);
          }
        }
        store.move(records, context.insertBefore);
      }
      if ((focusedCell == null ? void 0 : focusedCell._rowIndex) >= 0) {
        grid._focusedCell = null;
        grid.focusCell({
          grid,
          record: focusedCell.record,
          columnId: focusedCell.columnId
        });
      }
      let clearSorters = true;
      if (context.valid && sorterFn) {
        const firstRecord = records[0], lastRecord = records[records.length - 1], beforeFirst = firstRecord.previousSibling, afterLast = lastRecord.nextSibling;
        if ((!beforeFirst || sorterFn(beforeFirst, firstRecord) <= 0) && (!afterLast || sorterFn(lastRecord, afterLast) <= 0)) {
          clearSorters = false;
        }
      }
      if (context.valid && clearSorters) {
        store.clearSorters();
      }
    }
    context.finalize(context.valid);
    grid.element.classList.remove("b-row-reordering");
  }
  /**
   * Clean up on reset
   * @private
   */
  onReset() {
    const me = this, { grid } = me, cellEdit = grid.features.cellEdit;
    grid.element.classList.remove("b-row-reordering");
    if (cellEdit) {
      cellEdit.disabled = me.cellEditDisabledState;
    }
    me.dropIndicator.remove();
    DomHelper.removeClsGlobally(
      grid.element,
      ...me.dropOverTargetCls
    );
  }
  //endregion
  //region Render
  onInternalPaint({ firstPaint }) {
    if (firstPaint) {
      this.init();
    }
  }
  //endregion
  updateShowGrip(show) {
    this.grid.element.classList.toggle("b-row-reorder-with-grip", show);
  }
  get isDragging() {
    return this.dragHelper.isDragging;
  }
};
//region Events
/**
 * Fired before dragging starts, return false to prevent the drag operation.
 * @preventable
 * @event gridRowBeforeDragStart
 * @param {Core.helper.DragHelper} source
 * @param {Object} context
 * @param {Core.data.Model[]} context.records The dragged row records
 * @param {MouseEvent|TouchEvent} event
 * @on-owner
 */
/**
 * Fired when dragging starts.
 * @event gridRowDragStart
 * @param {Core.helper.DragHelper} source
 * @param {Object} context
 * @param {Core.data.Model[]} context.records The dragged row records
 * @param {MouseEvent|TouchEvent} event
 * @on-owner
 */
/**
 * Fired while the row is being dragged, in the listener function you have access to `context.insertBefore` a grid /
 * tree record, and additionally `context.parent` (a TreeNode) for trees. You can signal that the drop position is
 * valid or invalid by setting `context.valid = false;`
 * @event gridRowDrag
 * @param {Core.helper.DragHelper} source
 * @param {Object} context
 * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
 * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)
 * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)
 * @param {Core.data.Model[]} context.records The dragged row records
 * @param {MouseEvent} event
 * @on-owner
 */
/**
 * Fired before the row drop operation is finalized. You can return false to abort the drop operation, or a
 * Promise yielding `true` / `false` which allows for asynchronous abort (e.g. first show user a confirmation dialog).
 * @event gridRowBeforeDropFinalize
 * @preventable
 * @async
 * @param {Core.helper.DragHelper} source
 * @param {Object} context
 * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid
 * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)
 * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)
 * @param {Core.data.Model[]} context.records The dragged row records
 * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.
 * Objects contain the `record`, and its original `parentIndex` and `parentId` values
 * @param {MouseEvent} event
 * @on-owner
 */
/**
 * Fired after the row drop operation has completed, regardless of validity
 * @event gridRowDrop
 * @param {Core.helper.DragHelper} source
 * @param {Object} context
 * @param {Boolean} context.valid true or false depending on whether the drop position was valid
 * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)
 * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)
 * @param {Core.data.Model} context.record [DEPRECATED] The dragged row record
 * @param {Core.data.Model[]} context.records The dragged row records
 * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.
 * Objects contain the record, and its original `parentIndex` and `parentId` values
 * @param {MouseEvent} event
 * @on-owner
 */
/**
 * Fired when a row drag operation is aborted
 * @event gridRowAbort
 * @param {Core.helper.DragHelper} source
 * @param {Object} context
 * @param {MouseEvent} event
 * @on-owner
 */
//endregion
//region Init
__publicField(RowReorder, "$name", "RowReorder");
__publicField(RowReorder, "configurable", {
  /**
   * Set to `true` to show a grip icon on the left side of each row.
   * @config {Boolean}
   */
  showGrip: null,
  /**
   * Set to `true` to only allow reordering by the {@link #config-showGrip} config
   * @config {Boolean}
   */
  gripOnly: null,
  /**
   * If hovering over a parent node for this period of a time in a tree, the node will expand
   * @config {Number}
   */
  hoverExpandTimeout: 1e3,
  /**
   * The amount of milliseconds to wait after a touchstart, before a drag gesture will be allowed to start.
   * @config {Number}
   * @default
   */
  touchStartDelay: 300,
  /**
   * Enables creation of parents by dragging a row and dropping it onto a leaf row. Only works in a Grid with
   * a tree store.
   * @config {Boolean}
   */
  dropOnLeaf: false,
  /**
   * An object used to configure the internal {@link Core.helper.DragHelper} class
   * @config {DragHelperConfig}
   */
  dragHelperConfig: null,
  /**
   * Set to `true` to preserve sorters after a drop operation, if that operation leads to the store still being
   * sorted.
   * @config {Boolean}
   * @default false
   */
  preserveSorters: null,
  // Can be used in tests to disable drop animation to speed them up
  animateDrop: true
});
//endregion
//region Plugin config
__publicField(RowReorder, "pluginConfig", {
  after: ["onInternalPaint"]
});
RowReorder.featureClass = "";
RowReorder._$name = "RowReorder";
GridFeatureManager.registerFeature(RowReorder, false);

// lib/Grid/feature/RowResize.js
var RowResize = class extends InstancePlugin {
  //region Init
  construct(grid, config) {
    const me = this;
    super.construct(...arguments);
    me.resizer = new ResizeHelper({
      name: "rowResize",
      targetSelector: ".b-grid-row:not(.b-group-header)",
      handleContainerSelector: ".b-grid-row",
      outerElement: grid.element,
      direction: "vertical",
      dragThreshold: 1,
      handleSize: Math.min(5, grid.rowHeight * 0.1),
      internalListeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onResize,
        cancel: me.onCancel,
        thisObj: me
      },
      allowResize(target, event) {
        var _a4;
        return (_a4 = grid.hoveredCell) == null ? void 0 : _a4.matches(me.cellSelector);
      },
      overTopHandle(event, target) {
        if (this.canResize(target, event) && target.dataset.index !== "0") {
          const topHandle = Rectangle.from(target);
          topHandle.height = this.handleSize;
          return topHandle.height > 0 && Math.abs(topHandle.top - EventHelper.getPagePoint(event).top) < this.handleSize;
        }
        return false;
      },
      internalBeforeStart(context) {
        const { edge, element } = context;
        if (edge === "top") {
          return {
            edge: "bottom",
            element: element.previousElementSibling
          };
        }
      },
      // Prevent selection as a result of mousedown on virtual handle
      onResizeHandlePointerDown(event) {
        grid.selectionDisabled = true;
        if (grid.features.rowReorder) {
          me._oldReorderDisabled = grid.features.rowReorder.disabled;
          grid.features.rowReorder.disabled = true;
        }
        grid.setTimeout(() => {
          grid.selectionDisabled = false;
        }, 10);
      }
    });
  }
  doDestroy() {
    var _a4;
    (_a4 = this.resizer) == null ? void 0 : _a4.destroy();
    super.doDestroy();
  }
  //endregion
  //region Events
  onBeforeResizeStart() {
    return !this.disabled;
  }
  onResizeStart({ source, context }) {
    const { client } = this, applyGlobally = this.applyToAllRows || client.fixedRowHeight;
    context.record = client.store.getById(context.element.dataset.id);
    context.oldHeight = context.record.rowHeight;
    client.store.suspendAutoCommit();
    Object.assign(source, {
      minHeight: this.minHeight,
      maxHeight: this.maxHeight,
      // Only update live element if applying to all rows
      skipUpdatingElement: !applyGlobally
    });
    client.element.classList.add("b-row-resizing");
  }
  onResizing({ context }) {
    if (!this.applyToAllRows && !this.client.fixedRowHeight && context.valid) {
      context.record.rowHeight = context.newHeight;
    }
  }
  onResize({ context }) {
    const { client } = this;
    if (this.applyToAllRows || client.fixedRowHeight) {
      client.rowHeight = context.newHeight;
    } else if (client.selectionMode.multiSelect && client.selectedRecords.includes(context.record)) {
      client.selectedRecords.forEach((record) => record.rowHeight = context.newHeight);
    }
    this.cleanup();
  }
  /**
   * Restore row size on cancel (ESC)
   * @private
   */
  onCancel({ context }) {
    if (!this.applyToAllRows && !this.client.fixedRowHeight) {
      context.record.rowHeight = context.oldHeight;
    }
    this.cleanup();
  }
  //endregion
  cleanup() {
    const { client } = this;
    client.element.classList.remove("b-row-resizing");
    client.store.resumeAutoCommit();
    if (typeof this._oldReorderDisabled === "boolean") {
      client.features.rowReorder.disabled = this._oldReorderDisabled;
    }
  }
};
__publicField(RowResize, "$name", "RowResize");
__publicField(RowResize, "configurable", {
  /**
   * Set this to true to modify the global {@link Grid/view/Grid#config-rowHeight} which affects all grid rows.
   * @prp {Boolean}
   * @default false
   */
  applyToAllRows: null,
  /**
   * Set this to a CSS selector to only trigger row resizing in cells for a specific column.
   * @config {String}
   * @default
   */
  cellSelector: ".b-grid-cell",
  /**
   * Minimum height when resizing
   * @prp {Number}
   * @default
   */
  minHeight: 20,
  /**
   * Max height when resizing
   * @prp {Number}
   */
  maxHeight: 0
});
RowResize._$name = "RowResize";
GridFeatureManager.registerFeature(RowResize, false);

// lib/Grid/feature/Search.js
var actions5 = {
  goToNextHit: 1,
  goToPrevHit: 1
};
var Search = class extends Delayable_default(InstancePlugin) {
  static get properties() {
    return {
      hitCls: "b-search-hit",
      hitCellCls: "b-search-hit-cell",
      hitCellBadgeCls: "b-search-hit-cell-badge",
      hitTextCls: "b-search-hit-text"
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    Object.assign(this, {
      grid,
      text: "",
      hitEls: [],
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
    grid.ion({
      expandNode: "onTreeNodeExpand",
      thisObj: this
    });
  }
  isActionAvailable({ actionName }) {
    if (actions5[actionName]) {
      return Boolean(this.text);
    }
  }
  onTreeNodeExpand() {
    if (this.text) {
      this.requestAnimationFrame(this.search, [this.text, false, true, void 0, void 0, false]);
    }
  }
  doDestroy() {
    this.clear(true);
    super.doDestroy();
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  //endregion
  //region Plugin config
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ["populateCellMenu"]
    };
  }
  //endregion
  //region Search
  /**
   * Performs a search and highlights hits.
   * @param {String} text Text to search for
   * @param {Boolean} [gotoHit] Go to first hit after search
   * @param {Boolean} [reapply] Pass true to force search
   * @param {String[]} [fields] An array of the fields to search for the value in
   */
  async search(text, gotoHit = true, reapply = false, fields, fromSplit = false, expandToHits = this.client.store.isTree) {
    var _a4;
    const me = this;
    if (!text) {
      return me.clear();
    }
    if (!reapply && text === me.text || me.disabled) {
      return;
    }
    const { grid, store } = me, columns = grid.columns.visibleColumns.filter((col) => col.searchable !== false), formatters = [];
    fields = fields || columns.map((col) => {
      var _a5;
      formatters.push((_a5 = col.formatValue) == null ? void 0 : _a5.bind(col));
      return col.field;
    });
    const found = store.search(text, fields, formatters);
    if (expandToHits && found.length) {
      await grid.expandTo(found.map((hit) => hit.id));
    }
    for (const column of columns) {
      if (column.mergeCells && column.isSorted) {
        let prevValue = null, belongsTo = null;
        for (const hit of found) {
          if (hit.field === column.field) {
            const value = hit.data[hit.field];
            if (value === prevValue) {
              hit.belongsTo = belongsTo;
            }
            prevValue = value;
            belongsTo = `${hit.field}-${hit.id}`;
          }
        }
      }
    }
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      text,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\s+)?`, "ig")
    });
    me.clearHits();
    if (!found) {
      return;
    }
    for (const hit of found) {
      me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;
      if (i > me.limit) {
        break;
      }
    }
    if (!me.listenersInitialized) {
      grid.rowManager.ion({
        name: "renderCell",
        renderCell: "renderCell",
        thisObj: me
      });
      store.ion({
        name: "storeRefresh",
        [`refresh${grid.asyncEventSuffix}`]: "onStoreRefresh",
        thisObj: me
      });
      me.listenersInitialized = true;
    }
    grid.refreshRows();
    grid.trigger("search", { grid, find: text, found });
    if (gotoHit && !me.isHitFocused && !fromSplit) {
      me.gotoNextHit(true);
    }
    (_a4 = grid.syncSplits) == null ? void 0 : _a4.call(grid, (other) => other.features.search.search(text, gotoHit, reapply, fields, true));
    return found;
  }
  clearHits() {
    for (const cellElement of DomHelper.children(this.grid.element, "." + this.hitCls)) {
      cellElement.classList.remove(this.hitCls, this.hitCellCls);
      const row = DomDataStore.get(cellElement).row;
      if (row) {
        row.forceInnerHTML = true;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
  }
  /**
   * Clears search results.
   */
  clear(silent = false) {
    var _a4;
    const me = this, { grid } = me;
    if (me.foundMap) {
      delete me.foundMap;
    }
    me.text = null;
    me.clearHits();
    if (me.listenersInitialized) {
      me.detachListeners("renderCell");
      me.detachListeners("storeRefresh");
      me.listenersInitialized = false;
    }
    if (!silent) {
      grid.trigger("clearSearch", { grid });
      (_a4 = grid.syncSplits) == null ? void 0 : _a4.call(grid, (other) => other.features.search.clear());
    }
  }
  /**
   * Number of results found
   * @readonly
   * @property {Number}
   */
  get foundCount() {
    var _a4, _b;
    return (_b = (_a4 = this.found) == null ? void 0 : _a4.length) != null ? _b : 0;
  }
  //endregion
  //region Navigation
  /**
   * Returns true if focused row is a hit
   * @property {Boolean}
   * @readonly
   */
  get isHitFocused() {
    var _a4;
    const me = this, { grid } = me, { focusedCell } = grid;
    if ((_a4 = focusedCell == null ? void 0 : focusedCell.cell) == null ? void 0 : _a4.contains(DomHelper.getActiveElement(grid.element))) {
      const { rowIndex, column } = focusedCell;
      return rowIndex !== -1 && me.found.some(
        (hit) => hit.index === rowIndex && column && hit.field === column.field
      );
    }
  }
  /**
   * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
   */
  gotoNextHit(fromStart = false) {
    var _a4;
    const me = this;
    if (!((_a4 = me.found) == null ? void 0 : _a4.length)) {
      return;
    }
    const { grid, store } = me, fromCell = grid.focusedCell || grid.lastFocusedCell, currentIndex = fromCell && fromStart !== true ? store.indexOf(fromCell.record, void 0, true) : -1, nextHit = me.found.findIndex((hit) => hit.index > currentIndex);
    if (nextHit !== -1) {
      me.gotoHit(nextHit);
    }
  }
  /**
   * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
   */
  gotoPrevHit() {
    var _a4;
    const me = this, { store } = me;
    if (!((_a4 = me.found) == null ? void 0 : _a4.length)) {
      return;
    }
    const { grid, found } = me, fromCell = grid.focusedCell || grid.lastFocusedCell, currentIndex = fromCell ? store.indexOf(fromCell.record, void 0, true) : 0;
    for (let i = found.length - 1; i--; i >= 0) {
      const hit = found[i];
      if (hit.index < currentIndex) {
        me.gotoHit(i);
        break;
      }
    }
  }
  /**
   * Go to specified hit.
   * @param {Number} index
   */
  gotoHit(index) {
    const { grid } = this, nextHit = this.found[index];
    if (nextHit) {
      grid.focusCell({
        field: nextHit.field,
        id: nextHit.id
      });
    }
    return Boolean(nextHit);
  }
  /**
   * Go to the first hit.
   */
  gotoFirstHit() {
    this.gotoHit(0);
  }
  /**
   * Go to the last hit.
   */
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  //endregion
  //region Render
  /**
   * Called from SubGrid when a cell is rendered. Highlights search hits.
   * @private
   */
  renderCell({ cellElement, column, record, value }) {
    var _a4, _b;
    const me = this, {
      treeWalker,
      findRe,
      hitTextCls,
      showHitIndex
    } = me, hitIndex = (_a4 = me.foundMap) == null ? void 0 : _a4[column.field + "-" + record.id];
    if (hitIndex) {
      cellElement.classList.add(me.hitCls);
      showHitIndex && ((_b = cellElement.querySelector(`.${me.hitCellBadgeCls}`)) == null ? void 0 : _b.remove());
      const inner = DomHelper.down(cellElement, ".b-grid-cell-value,.b-tree-cell-value") || cellElement;
      if (String(value).toLowerCase() === String(me.text).toLowerCase()) {
        inner.innerHTML = `<span class="${me.hitTextCls}">${inner.innerHTML}</span>${showHitIndex ? `<div class="${me.hitCellBadgeCls}">${hitIndex}</div>` : ""}`;
      } else {
        treeWalker.currentNode = inner;
        for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode); ) {
          const nodeToReplace = textNode, textContent = textNode.nodeValue, newText = ["<span>"];
          textNode = treeWalker.nextNode();
          let offset = findRe.lastIndex;
          for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
            const preamble = textContent.substring(offset, match.index), spaceBefore = match[1] ? "\xA0" : "", v = match[2], spaceAfter = match[3] ? "\xA0" : "";
            newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${StringHelper.encodeHtml(v)}</span>${spaceAfter}`);
            offset = findRe.lastIndex;
          }
          newText.push(StringHelper.encodeHtml(textContent.substring(offset)), "<span>");
          nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(""), {
            fragment: true
          }), nodeToReplace);
          nodeToReplace.remove();
        }
        if (showHitIndex) {
          DomHelper.createElement({
            parent: cellElement,
            className: me.hitCellBadgeCls,
            text: hitIndex
          });
        }
      }
      me.hitEls.push(cellElement);
    }
  }
  //endregion
  //region Context menu
  /**
   * Add search menu item to cell context menu.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Core.data.Model} options.record Record for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateCellMenu({ column, record, items: items2, cellElement }) {
    const me = this;
    if (column.searchable) {
      items2.search = {
        text: "L{searchForValue}",
        localeClass: me,
        icon: "b-fw-icon b-icon-search",
        cls: "b-separator",
        weight: 200,
        disabled: me.disabled,
        onItem: () => {
          let sel = globalThis.getSelection().toString();
          if (!sel) {
            sel = cellElement.innerText;
          }
          me.search(sel);
        }
      };
    }
  }
  //endregion
  //region Events
  onStoreRefresh() {
    this.search(this.text, false, true);
  }
  //endregion
};
//region Init
__publicField(Search, "$name", "Search");
__publicField(Search, "configurable", {
  /**
   * The maximum amount of search hits
   * @config {Number}
   * @default
   */
  limit: 1e3,
  /**
   * Set to `false` to not show the search hit index numbers
   * @config {Boolean}
   * @default
   */
  showHitIndex: true,
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    F3: "gotoNextHit",
    "Ctrl+g": "gotoNextHit",
    "Shift+F3": "gotoPrevHit",
    "Ctrl+Shift+g": "gotoPrevHit"
  }
});
Search.featureClass = "b-search";
Search._$name = "Search";
GridFeatureManager.registerFeature(Search);

// lib/Grid/feature/Sort.js
var emptyArray11 = Object.freeze([]);
var Sort = class extends InstancePlugin {
  static get properties() {
    return {
      ignoreRe: new RegExp([
        // Stop this feature from having to know the internals of two other optional features.
        "b-grid-header-resize-handle",
        "b-filter-icon"
      ].join("|")),
      sortableCls: "b-sortable",
      sortedCls: "b-sort",
      sortedAscCls: "b-asc",
      sortedDescCls: "b-desc"
    };
  }
  //endregion
  //region Init
  construct(grid, config) {
    config = this.processConfig(config);
    this.grid = grid;
    this.bindStore(this.store);
    super.construct(grid, config);
  }
  // Sort feature handles special config cases, where user can supply a string or an array of sorters
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === "string" || Array.isArray(config)) {
      return {
        field: config,
        ascending: null
      };
    }
    return config;
  }
  // override setConfig to process config before applying it
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  bindStore(store) {
    var _a4;
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeSort: "onStoreBeforeSort",
      sort: "syncHeaderSortState",
      thisObj: this
    });
    if ((_a4 = this.client) == null ? void 0 : _a4.isPainted) {
      this.syncHeaderSortState();
    }
  }
  set field(field) {
    var _a4;
    const column = this.grid.columns.get(field);
    if (column && typeof column.sortable === "object") {
      column.sortable.field = column.sortable.property || field;
      field = column.sortable;
    }
    if (!((_a4 = this.store.sorters) == null ? void 0 : _a4.some((g) => g.field === field))) {
      this.store.sort(field, this.ascending);
    }
  }
  // Avoid caching store, it might change
  get store() {
    return this.grid[this.grid.sortFeatureStore];
  }
  //endregion
  //region Plugin config
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ["onElementClick", "populateHeaderMenu", "getColumnDragToolbarItems", "renderHeader", "onInternalPaint", "bindStore"]
    };
  }
  //endregion
  //region Headers
  /**
   * Update headers to match stores sorters (displays sort icon in correct direction on them)
   * @private
   */
  syncHeaderSortState() {
    var _a4;
    const me = this, { grid } = me;
    if (!grid.hideHeaders && grid.isPainted) {
      const storeSorters = me.store.sorters.concat(me.store.groupers || emptyArray11), sorterCount = storeSorters.length, classList = new DomClassList();
      let sorter;
      for (const leafColumn of grid.columns.visibleColumns) {
        if (!leafColumn.sortable) {
          continue;
        }
        const leafHeader = leafColumn.element, textEl = leafColumn.textWrapper, dataset = textEl == null ? void 0 : textEl.dataset;
        let sortDirection = "none";
        (dataset == null ? void 0 : dataset.sortIndex) && delete dataset.sortIndex;
        classList.value = leafHeader.classList;
        if (leafColumn.sortable === false) {
          classList.remove(me.sortableCls);
          (_a4 = textEl == null ? void 0 : textEl.querySelector(".b-sort-icon")) == null ? void 0 : _a4.remove();
        } else {
          if (!(textEl == null ? void 0 : textEl.querySelector(".b-sort-icon"))) {
            DomHelper.createElement({
              parent: textEl,
              className: "b-sort-icon"
            });
          }
          classList.add(me.sortableCls);
          sorter = storeSorters.find(
            (sort) => sort.field === leafColumn.field || sort.sortFn && sort.sortFn === leafColumn.sortable.sortFn
          );
          if (sorter) {
            if (sorterCount > 1 && dataset) {
              dataset.sortIndex = storeSorters.indexOf(sorter) + 1;
            }
            classList.add(me.sortedCls);
            if (sorter.ascending) {
              classList.add(me.sortedAscCls);
              classList.remove(me.sortedDescCls);
              sortDirection = "ascending";
            } else {
              classList.add(me.sortedDescCls);
              classList.remove(me.sortedAscCls);
              sortDirection = "descending";
            }
          } else {
            classList.remove(me.sortedCls);
            if (!classList["b-group"]) {
              classList.remove(me.sortedAscCls);
              classList.remove(me.sortedDescCls);
            }
          }
        }
        DomHelper.syncClassList(leafHeader, classList);
        DomHelper.setAttributes(leafHeader, {
          "aria-sort": sortDirection
        });
      }
    }
  }
  //endregion
  //region Context menu
  /**
   * Adds sort menu items to header context menu.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateHeaderMenu({ column, items: items2 }) {
    const me = this, { store } = me, sortBy = { ...column.sortable, field: column.field, columnOwned: true };
    if (column.sortable !== false) {
      items2.sortAsc = {
        text: "L{sortAscending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-sort-asc",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => store.sort(sortBy, true)
      };
      items2.sortDesc = {
        text: "L{sortDescending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-sort-desc",
        weight: 310,
        disabled: me.disabled,
        onItem: () => store.sort(sortBy, false)
      };
      if (me.multiSort && me.grid.columns.records.some((col) => col.sortable)) {
        const sorter = store.sorters.find((s) => s.field === column.field || column.sortable.sortFn && column.sortable.sortFn === s.sortFn);
        items2.multiSort = {
          text: "L{multiSort}",
          localeClass: me,
          icon: "b-fw-icon b-icon-sort",
          weight: 320,
          disabled: me.disabled,
          menu: {
            addSortAsc: {
              text: sorter ? "L{toggleSortAscending}" : "L{addSortAscending}",
              localeClass: me,
              icon: "b-fw-icon b-icon-sort-asc",
              disabled: sorter && (sorter == null ? void 0 : sorter.ascending),
              weight: 330,
              onItem: () => store.addSorter(sortBy, true)
            },
            addSortDesc: {
              text: sorter ? "L{toggleSortDescending}" : "L{addSortDescending}",
              localeClass: me,
              icon: "b-fw-icon b-icon-sort-desc",
              disabled: sorter && !sorter.ascending,
              weight: 340,
              onItem: () => store.addSorter(sortBy, false)
            },
            removeSorter: {
              text: "L{removeSorter}",
              localeClass: me,
              icon: "b-fw-icon b-icon-remove",
              weight: 350,
              disabled: !sorter,
              onItem: () => {
                store.removeSorter(sortBy.field);
              }
            }
          }
        };
      }
    }
  }
  /**
   * Supply items to ColumnDragToolbar
   * @private
   */
  getColumnDragToolbarItems(column, items2) {
    const me = this, { store, disabled } = me;
    if (column.sortable !== false) {
      const sorter = store.sorters.find((s) => s.field === column.field);
      items2.push(
        {
          text: "L{sortAscendingShort}",
          group: "L{sort}",
          localeClass: me,
          icon: "b-icon b-icon-sort-asc",
          ref: "sortAsc",
          cls: "b-separator",
          weight: 105,
          disabled,
          onDrop: ({ column: column2 }) => store.sort(column2.field, true)
        },
        {
          text: "L{sortDescendingShort}",
          group: "L{sort}",
          localeClass: me,
          icon: "b-icon b-icon-sort-desc",
          ref: "sortDesc",
          weight: 105,
          disabled,
          onDrop: ({ column: column2 }) => store.sort(column2.field, false)
        },
        {
          text: "L{addSortAscendingShort}",
          group: "L{multiSort}",
          localeClass: me,
          icon: "b-icon b-icon-sort-asc",
          ref: "multisortAddAsc",
          disabled: disabled || sorter && sorter.ascending,
          weight: 105,
          onDrop: ({ column: column2 }) => store.addSorter(column2.field, true)
        },
        {
          text: "L{addSortDescendingShort}",
          group: "L{multiSort}",
          localeClass: me,
          icon: "b-icon b-icon-sort-desc",
          ref: "multisortAddDesc",
          disabled: disabled || sorter && !sorter.ascending,
          weight: 105,
          onDrop: ({ column: column2 }) => store.addSorter(column2.field, false)
        },
        {
          text: "L{removeSorterShort}",
          group: "L{multiSort}",
          localeClass: me,
          icon: "b-icon b-icon-remove",
          ref: "multisortRemove",
          weight: 105,
          disabled: disabled || !sorter,
          onDrop: ({ column: column2 }) => store.removeSorter(column2.field)
        }
      );
    }
    return items2;
  }
  //endregion
  //region Events
  // Intercept sorting by a column that has a custom sorting fn, and inject that fn
  onStoreBeforeSort({ sorters }) {
    var _a4;
    const { columns } = this.client;
    for (let i = 0; i < sorters.length; i++) {
      const sorter = sorters[i], column = (sorter.columnOwned || this.prioritizeColumns) && columns.get(sorter.field);
      if ((_a4 = column == null ? void 0 : column.sortable) == null ? void 0 : _a4.sortFn) {
        sorters[i] = { ...sorter, ...column.sortable, columnOwned: true };
      }
    }
  }
  /**
   * Clicked on header, sort Store.
   * @private
   */
  onElementClick(event) {
    const me = this, { store } = me, { target } = event, header = target.closest(".b-grid-header.b-sortable"), field = header == null ? void 0 : header.dataset.column;
    if (me.ignoreRe.test(target.className) || me.disabled || event.handled) {
      return;
    }
    if (header && field && (me.toggleOnHeaderClick || target.closest(".b-sort-icon"))) {
      const column = me.grid.columns.getById(header.dataset.columnId), columnGrouper = store.isGrouped && store.groupers.find((g) => g.field === field);
      if (columnGrouper && !event.shiftKey) {
        return;
      }
      if (column.sortable && !event.shiftKey) {
        if (event.ctrlKey && event.altKey) {
          store.removeSorter(column.field);
        } else {
          const sortBy = {
            columnOwned: true,
            field: column.field
          };
          if (typeof column.sortable === "object") {
            ObjectHelper.assign(sortBy, column.sortable);
          }
          store.sort(sortBy, null, event.ctrlKey && me.multiSort);
        }
      }
    }
  }
  /**
   * Called when grid headers are rendered, make headers match current sorters.
   * @private
   */
  renderHeader() {
    this.syncHeaderSortState();
  }
  onInternalPaint() {
    this.syncHeaderSortState();
  }
  //endregion
};
//region Config
__publicField(Sort, "$name", "Sort");
__publicField(Sort, "configurable", {
  /**
   * Enable multi sort
   * @config {Boolean}
   * @default
   */
  multiSort: true,
  /**
   * Use custom sorting functions defined on columns also when programmatically sorting by the columns field.
   *
   * ```javascript
   * const grid = new Grid({
   *     columns : [
   *         {
   *             field : 'age',
   *             text : 'Age',
   *             sortable(lhs, rhs) {
   *               // Custom sorting, see Array#sort
   *             }
   *         }
   *     ],
   *
   *     features : {
   *         sort : {
   *             prioritizeColumns : true
   *         }
   *     }
   * });
   *
   * grid.store.sort('age');
   * ```
   *
   * @config {Boolean}
   * @default
   */
  prioritizeColumns: false,
  /**
   * By default, clicking anywhere on the header text toggles the sorting state of a column.
   *
   * Configure this as `false` to only toggle the sorting state of a column on click of the
   * "arrow" icon within the grid header.
   * @config {Boolean}
   * @default false
   */
  toggleOnHeaderClick: true
});
Sort.featureClass = "b-sort";
Sort._$name = "Sort";
GridFeatureManager.registerFeature(Sort, true);

// lib/Grid/feature/StickyCells.js
var StickyCells = class extends InstancePlugin {
  //region Config
  static get $name() {
    return "StickyCells";
  }
  static get defaultConfig() {
    return {
      /**
       * A CSS selector which must identify the content within your grid row which you
       * require to be pinned to the grid while the row if the topmost row, and remains visible.
       * @config {String}
       */
      contentSelector: null,
      currentTopRowCls: "b-sticky-cells-current-top-row"
    };
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      before: ["renderRows"]
    };
  }
  //endregion
  //region Init
  construct(grid, config) {
    super.construct(grid, config);
    grid.ion({
      scroll: "onGridScroll",
      thisObj: this
    });
    Object.assign(this, DomHelper.createElement({
      reference: "element",
      parent: grid.element,
      className: "b-grid-sticky-row",
      children: [{
        reference: "contentElement",
        className: "b-grid-cell"
      }]
    }));
    this.removeClasses = {
      "b-focused": false,
      "b-hover": false,
      "b-selected": false,
      [this.currentTopRowCls]: false
    };
  }
  renderRows() {
    this.element.classList.add("b-hide-visibility");
  }
  onGridScroll() {
    const me = this, {
      client: grid,
      element,
      contentElement
    } = me, gridViewport = Rectangle.client(grid.bodyContainer).roundPx(), currentTopRow = grid.rowManager.getRowAt(gridViewport.y), topRowChanged = currentTopRow !== me.currentTopRow;
    if (currentTopRow) {
      if (topRowChanged) {
        if (me.currentTopRow) {
          me.currentTopRow.removeCls(me.currentTopRowCls);
          me.currentTopRow.removeCls("b-not-enough-height");
        }
        me.currentTopRow = currentTopRow;
        currentTopRow.addCls(me.currentTopRowCls);
        contentElement.innerHTML = "";
        contentElement.appendChild(me.updateStickyContent());
      }
      const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;
      me.element.classList[notEnoughHeight ? "add" : "remove"]("b-hide-visibility");
      me.currentTopRow[notEnoughHeight ? "addCls" : "removeCls"]("b-not-enough-height");
      gridViewport.y += me.stickyContentTop;
      DomHelper.alignTo(element, me.stickyEls[0], { align: "t0-t0", constrainTo: gridViewport }, true);
    }
    me.lastProcessedTopRow = currentTopRow;
  }
  updateStickyContent() {
    const me = this, {
      currentTopRow,
      removeClasses
    } = me, rowClasses = {
      "b-grid-sticky-row": 1
    }, cellClasses = {}, stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()), stickyEls = me.stickyEls || (me.stickyEls = []);
    stickyEls.forEach((e) => {
      e.classList.remove("b-sticky-content-el");
    });
    stickyEls.length = 0;
    currentTopRow.eachElement((rowEl) => {
      stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));
    });
    while (stickyContent.firstChild) {
      stickyContent.remove(stickyContent.firstChild);
    }
    me.stickyContentHeight = 0;
    me.stickyContentTop = 0;
    stickyEls.map((e) => {
      e.closest(".b-grid-cell").classList.forEach((cls) => cellClasses[cls] = 1);
      e.closest(".b-grid-row").classList.forEach((cls) => rowClasses[cls] = 1);
      Object.assign(cellClasses, removeClasses);
      Object.assign(rowClasses, removeClasses);
      const eTop = e.offsetTop;
      me.stickyContentTop = Math.max(me.stickyContentTop, eTop);
      e.style.alignSelf = "flex-end";
      me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);
      e.style.alignSelf = "";
      const result = e.cloneNode(true);
      e.classList.add("b-sticky-content-el");
      stickyContent.appendChild(result);
      return result;
    });
    cellClasses["b-focused"] = false;
    DomHelper.syncClassList(me.contentElement, cellClasses);
    DomHelper.syncClassList(me.element, rowClasses);
    return stickyContent;
  }
};
StickyCells._$name = "StickyCells";
GridFeatureManager.registerFeature(StickyCells, false);

// lib/Grid/feature/Stripe.js
var Stripe = class extends InstancePlugin {
  static get $name() {
    return "Stripe";
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.ion({
      renderrow: "onRenderRow",
      thisObj: this
    });
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this.client.refreshRows();
    }
    super.doDisable(disable);
  }
  /**
   * Applies even/odd CSS when row is rendered
   * @param {Grid.row.Row} rowModel
   * @private
   */
  onRenderRow({ row, record }) {
    var _a4, _b;
    const { disabled } = this, { isGroupHeader } = record, groupParent = (_a4 = record.groupParent) == null ? void 0 : _a4.get(this.client.store.id), even = ((_b = groupParent == null ? void 0 : groupParent.groupChildren.indexOf(record)) != null ? _b : row.dataIndex) % 2 === 0;
    row.assignCls({
      "b-even": !disabled && !isGroupHeader && even,
      "b-odd": !disabled && !isGroupHeader && !even
    });
  }
};
Stripe._$name = "Stripe";
GridFeatureManager.registerFeature(Stripe);

// lib/Grid/feature/Split.js
var startScrollOptions = Object.freeze({
  animate: false,
  block: "start"
});
var endScrollOptions = Object.freeze({
  animate: false,
  block: "end"
});
var splitterWidth = 7;
var ignoreListeners = {
  split: 1,
  unsplit: 1
};
var _ignoreColumnChanges;
var Split = class extends InstancePlugin {
  constructor() {
    super(...arguments);
    // Flag used to ignore column changes that arise from syncing columns
    __privateAdd(this, _ignoreColumnChanges, false);
    __publicField(this, "restorers", []);
  }
  doDestroy() {
    this.unsplit(true);
    super.doDestroy();
  }
  doDisable(disable) {
    const me = this;
    if (!me.isConfiguring) {
      if (disable) {
        me._disabledSplitOptions = me._splitOptions;
        me.unsplit();
      } else if (me._disabledSplitOptions) {
        me.split(me._disabledSplitOptions);
        me._disabledSplitOptions = null;
      }
    }
  }
  //region Split / unsplit
  get isSplit() {
    var _a4;
    return Boolean((_a4 = this.widgets) == null ? void 0 : _a4.length);
  }
  getClientConfig(appendTo, order, options, config = {}) {
    const { client } = this, { subGrids, regions } = client, columns = client.columns.records.slice(), subGridConfigs = ObjectHelper.assign({}, client.subGridConfigs);
    client.eachSubGrid((subGrid) => {
      const config2 = subGridConfigs[subGrid.region];
      if (subGrid.flex) {
        config2.flex = subGrid.flex;
      } else {
        config2.width = subGrid.element.style.width;
      }
    });
    if (options.atColumn && regions.length > 1 && order > 0) {
      const subGridIndex = regions.indexOf(options.atColumn.region);
      for (let i = 0; i < subGridIndex; i++) {
        const subGrid = subGrids[regions[i]];
        ArrayHelper.remove(columns, ...subGrid.columns.records);
        delete subGridConfigs[regions[i]];
      }
    }
    const clientConfig = ObjectHelper.assign({}, client.initialConfig, {
      appendTo,
      insertFirst: null,
      insertBefore: null,
      splitFrom: client,
      owner: client.owner,
      // Use no toolbar or fake empty toolbar for things to line up nicely
      tbar: client.initialConfig.tbar && order === 1 ? {
        height: client.tbar.height,
        items: [" "]
      } : null,
      // Share store & selection
      store: client.store,
      selectedRecordCollection: client.selectedRecordCollection,
      subGridConfigs,
      // Cannot directly share columns, since there is a 1-1 mapping between column and it's header
      columns: this.cloneColumns(columns),
      minHeight: 0,
      minWidth: 0
    }, config);
    for (const prop of ObjectHelper.keys(this.relayProperties)) {
      clientConfig[prop] = client[prop];
    }
    const appListeners = {};
    for (const name in client.listeners) {
      if (!ignoreListeners[name]) {
        const listeners = client.listeners[name].filter((l) => !l.$internal);
        if (listeners.length) {
          appListeners[name] = listeners;
        }
      }
    }
    clientConfig.listeners = appListeners;
    if (options.direction === "horizontal") {
      clientConfig.hideHeaders = true;
    } else if (options.direction === "both" && order !== 1) {
      clientConfig.hideHeaders = true;
    }
    delete clientConfig.data;
    delete clientConfig.adopt;
    return clientConfig;
  }
  cloneColumns(source) {
    return source.flatMap((col) => {
      if (col.meta.isSelectionColumn || col.field === "expanderActionColumn") {
        return [];
      }
      const data = { ...col.data };
      if (col.children) {
        data.children = col.children.map((child) => ({ ...child.data }));
      }
      delete data.headerRenderer;
      delete data.parentId;
      return data;
    });
  }
  cloneClient(appendTo, order, options, config) {
    const clientConfig = this.getClientConfig(appendTo, order, options, config), clone = new this.client.constructor(clientConfig);
    clone.element.classList.add("b-split-clone");
    return clone;
  }
  // Process options, deducing direction, atRecord, etc.
  processOptions(options) {
    var _a4;
    const { client } = this, { atRecord, atColumn, direction } = options;
    if (!direction) {
      if (atRecord && atColumn) {
        options.direction = "both";
      } else if (atColumn) {
        options.direction = "vertical";
      } else {
        options.direction = "horizontal";
      }
    } else {
      if (direction !== "vertical" && !atRecord && client.store.count) {
        const centerY = client._bodyRectangle.height / 2 + client.scrollable.y, centerRow = (_a4 = client.rowManager.getRowAt(centerY, true)) != null ? _a4 : client.rowManager.rows[Math.ceil(client.rowManager.rows.length / 2)];
        options.atRecord = client.store.getById(centerRow.id);
      }
      if (direction !== "horizontal" && !atColumn) {
        const bounds = Rectangle.from(client.element);
        let centerX = bounds.center.x - bounds.x, subGrid = client.subGrids[client.regions[0]], i = 0, column = null;
        while (centerX > subGrid.width) {
          centerX -= subGrid.width;
          subGrid = client.subGrids[client.regions[++i]];
        }
        centerX += subGrid.scrollable.x;
        const { visibleColumns } = subGrid.columns;
        let x = 0, j = 0;
        while (x < centerX && j < visibleColumns.length) {
          column = visibleColumns[j++];
          x += column.element.offsetWidth;
        }
        options.atColumn = column;
      }
    }
    return options;
  }
  // Create element to contain the splits, it "both" mode it will hold a top container and a bottom container.
  // In single mode, it will hold the splits + splitters directly.
  createSplitContainer({ direction }) {
    const { client } = this, { element } = client;
    return this.splitContainer = DomHelper.createElement({
      parent: element.parentElement,
      className: {
        "b-split-container": 1,
        [`b-split-${direction}`]: 1,
        "b-rtl": client.rtl
      },
      style: {
        width: element.style.width,
        height: element.style.height
      },
      children: [
        // Split in one dir, use original as first child
        direction !== "both" && element,
        // Split in both directions, make two sub-containers and put original in first
        direction === "both" && {
          className: "b-split-top",
          children: [
            element
          ]
        },
        direction === "both" && {
          className: "b-split-bottom"
        }
      ]
    });
  }
  // Make the headers of all splits same height. Since headers shrinkwrap, they might differ depending on which
  // subgrids was cloned to each split
  syncHeaderHeights() {
    let maxHeaderHeight = 0;
    for (const split of this.subViews) {
      split.eachSubGrid((subGrid) => {
        if (subGrid.header.height > maxHeaderHeight) {
          maxHeaderHeight = subGrid.header.height;
        }
      });
    }
    for (const split of this.subViews) {
      split.eachSubGrid((subGrid) => {
        subGrid.header.height = maxHeaderHeight;
      });
    }
  }
  // Clones can be created with correct subgrids, in the original we might instead need to hide some when splitting
  // in a region that is not the last one (locked for example)
  toggleOriginalSubGrids(options) {
    const me = this, { client } = me, { regions } = client;
    if (options.atColumn && regions.length > 1) {
      const subGridIndex = regions.indexOf(options.atColumn.region), splits = [client];
      if (options.direction === "both") {
        splits.push(me.subViews[2]);
      }
      for (const split of splits) {
        if (subGridIndex + 1 < regions.length) {
          const isOriginal = split === client;
          const subGrid = split.subGrids[regions[subGridIndex]];
          subGrid.hideSplitter();
          isOriginal && me.restorers.push(() => subGrid.showSplitter());
          if (!subGrid.flex) {
            client.inForEachOther = true;
            subGrid.flex = 1;
            client.inForEachOther = false;
            isOriginal && me.restorers.push(() => {
              subGrid.flex = null;
              subGrid.width = subGrid._initialWidth;
            });
          }
          for (let i = subGridIndex + 1; i < regions.length; i++) {
            const subGrid2 = split.subGrids[regions[i]];
            subGrid2.hide();
            isOriginal && me.restorers.push(() => {
              subGrid2.show();
            });
          }
          if (regions.length === 2) {
            split._initialWidth = split.element.style.width;
            split._initialFlex = split.flex;
            split.width = subGrid._initialWidth;
            isOriginal && me.restorers.push(() => {
              if (split._initialFlex !== null) {
                split.flex = split._initialFlex;
              } else if (split._initialWidth !== null) {
                split.width = split._initialWidth;
              }
            });
          }
        }
      }
    }
  }
  /**
   * Split the grid into two or four parts.
   *
   * - Splits into two when passed `direction : 'vertical'`, `direction : 'horizontal'` or `atColumn` or `atRecord`.
   * - Splits into four when passed `direction : 'both'` or `atColumn` and `atRecord`.
   *
   * ```javascript
   * // Split horizontally (at the row in the center of the grid)
   * await grid.split({ direction : 'horizontal' });
   *
   * // Split both ways by a specific column and record
   * await grid.split({
   *    atRecord : grid.store.getById(10),
   *    atColumn : grid.columns.get('city')
   * });
   * ```
   *
   * To return to a single grid, call {@link #function-unsplit}.
   *
   * Note that this function is callable directly on the grid instance.
   *
   * @param {Object} [options] Split options
   * @param {'vertical'|'horizontal'|'both'} [options.direction] Split direction, 'vertical', 'horizontal' or 'both'.
   * Not needed when passing `atColumn` or `atRecord`.
   * @param {Grid.column.Column} [options.atColumn] Column to split at
   * @param {Core.data.Model} [options.atRecord] Record to split at
   * @returns {Promise} Resolves when split is complete, and subviews are scrolled to the correct position.
   * @async
   * @on-owner
   * @category Common
   */
  async split(options = {}) {
    const me = this, { client } = me;
    if (client.splitFrom) {
      return;
    }
    if (me.isSplit) {
      await me.unsplit(true);
    }
    const { rtl } = client, { atRecord, atColumn, direction } = me.processOptions(options);
    let { splitX, remainingWidth } = options, splitY = null, remainingHeight = null;
    if (atRecord) {
      await client.scrollRowIntoView(atRecord);
      const row = client.getRowFor(atRecord);
      if (!row) {
        throw new Error(`Could not find row for record ${atRecord.id}`);
      }
      splitY = Rectangle.from(row.cells[0], client.element).bottom;
      remainingHeight = Rectangle.from(client.element).height - splitY;
    }
    if (atColumn && !splitX) {
      splitX = Rectangle.from(atColumn.element, client.element).getEnd(rtl);
      remainingWidth = Rectangle.from(client.element).width - splitX - DomHelper.scrollBarWidth;
      if (rtl) {
        const x = splitX;
        splitX = remainingWidth + DomHelper.scrollBarWidth;
        remainingWidth = x - DomHelper.scrollBarWidth;
      }
    }
    const scrollPromises = [], splitContainer = me.createSplitContainer(options), { visibleColumns } = client.columns, nextColumn = atColumn ? visibleColumns[visibleColumns.indexOf(atColumn) + 1] : null, nextRecord = atRecord ? client.store.getNext(atRecord) : null;
    client.eachSubGrid((subGrid) => subGrid._initialWidth = subGrid.width);
    client.columns.commit();
    if (direction !== "both") {
      const cloneConfig = {
        flex: `0 0 ${(splitY != null ? remainingHeight : remainingWidth) - splitterWidth}px`,
        height: null
      };
      const [, clone] = me.widgets = [
        new Splitter({ appendTo: splitContainer }),
        me.cloneClient(splitContainer, direction === "vertical" ? 1 : 0, options, cloneConfig)
      ];
      if (splitX != null) {
        client.renderRows();
        if (!options.atDate) {
          scrollPromises.push(client.scrollColumnIntoView(atColumn, endScrollOptions));
          nextColumn && scrollPromises.push(clone.scrollColumnIntoView(nextColumn, startScrollOptions));
        }
      }
      if (splitY != null) {
        scrollPromises.push(clone.scrollRowIntoView(nextRecord, startScrollOptions));
      }
      client.element.classList.add("b-split-start");
      clone.element.classList.add("b-split-end");
      client.scrollable.addPartner(clone.scrollable, {
        x: direction === "horizontal",
        y: direction !== "horizontal"
      });
    } else {
      const rightConfig = {
        flex: `0 0 ${remainingWidth - splitterWidth}px`
      };
      splitContainer.lastElementChild.style.flex = `0 0 ${remainingHeight - splitterWidth}px`;
      me.widgets = [
        new Splitter({ insertBefore: splitContainer.lastElementChild }),
        // Full horizontal
        me.topSplitter = new Splitter({ appendTo: splitContainer.firstElementChild }),
        // Top vertical
        me.cloneClient(splitContainer.firstElementChild, 1, options, rightConfig),
        // Top right
        me.cloneClient(splitContainer.lastElementChild, 0, options),
        // Bottom left
        me.bottomSplitter = new Splitter({ appendTo: splitContainer.lastElementChild }),
        // Bottom vertical
        me.cloneClient(splitContainer.lastElementChild, 2, options, rightConfig)
        // Bottom right
      ];
      const topLeft = client, topRight = me.widgets[2], bottomLeft = me.widgets[3], bottomRight = me.widgets[5];
      topLeft.element.classList.add("b-split-top-start");
      topRight.element.classList.add("b-split-top-end");
      bottomLeft.element.classList.add("b-split-bottom-start");
      bottomRight.element.classList.add("b-split-bottom-end");
      if (splitX != null) {
        topLeft.renderRows();
        bottomLeft.renderRows();
        if (atColumn && !options.atDate) {
          scrollPromises.push(client.scrollColumnIntoView(atColumn, endScrollOptions));
          nextColumn && scrollPromises.push(topRight.scrollColumnIntoView(nextColumn, startScrollOptions));
        }
      }
      if (splitY != null) {
        scrollPromises.push(
          bottomLeft.scrollRowIntoView(nextRecord, startScrollOptions),
          bottomRight.scrollRowIntoView(nextRecord, startScrollOptions)
        );
      }
      topLeft.scrollable.addPartner(topRight.scrollable, "y");
      topLeft.scrollable.addPartner(bottomLeft.scrollable, "x");
      topRight.scrollable.addPartner(bottomRight.scrollable, "x");
      bottomLeft.scrollable.addPartner(bottomRight.scrollable, "y");
      me.topSplitter.ion({
        splitterMouseDown: "onSplitterMouseDown",
        splitterMouseEnter: "onSplitterMouseEnter",
        splitterMouseLeave: "onSplitterMouseLeave",
        drag: "onSplitterDrag",
        drop: "onSplitterDrop",
        thisObj: me
      });
      me.bottomSplitter.ion({
        splitterMouseDown: "onSplitterMouseDown",
        splitterMouseEnter: "onSplitterMouseEnter",
        splitterMouseLeave: "onSplitterMouseLeave",
        drag: "onSplitterDrag",
        drop: "onSplitterDrop",
        thisObj: me
      });
    }
    me.subViews = [client, ...me.widgets.filter((w) => w.isGridBase)];
    me.toggleOriginalSubGrids(options);
    me.syncHeaderHeights();
    me._splitOptions = options;
    await Promise.all(scrollPromises);
    const bounds = Rectangle.from(client.element);
    client.onInternalResize(client.element, bounds.width, bounds.height);
    client.eachSubGrid((subGrid) => {
      const subGridBounds = Rectangle.from(subGrid.element);
      subGrid.onInternalResize(subGrid.element, subGridBounds.width, subGridBounds.height);
    });
    client.scrollable.x += 0.5;
    client.scrollable.y += 0.5;
    me.startSyncingColumns();
    client.trigger("split", { subViews: me.subViews, options });
    return me.subViews;
  }
  /**
   * Remove splits, returning to a single grid.
   *
   * Note that this function is callable directly on the grid instance.
   *
   * @on-owner
   * @async
   * @category Common
   */
  async unsplit(silent = false) {
    var _a4;
    const me = this, { client } = me, { element } = client;
    if (me.isSplit) {
      me.stopSyncingColumns();
      (_a4 = me.widgets) == null ? void 0 : _a4.forEach((split) => split.destroy());
      me.widgets = null;
      client.eachSubGrid((subGrid) => subGrid.scrollable.x);
      client.scrollable.y;
      me.splitContainer.parentElement.appendChild(element);
      me.splitContainer.remove();
      me.splitContainer = null;
      element.style.flexBasis = element.style.flexGrow = "";
      element.classList.remove("b-split-top-start", "b-split-start");
      me.subViews.length = 0;
      if (!me.isDestroying) {
        client.renderRows();
        me.unsplitCleanup();
        for (const restorer of me.restorers) {
          restorer();
        }
        me.restorers.length = 0;
        await AsyncHelper.animationFrame();
        await AsyncHelper.animationFrame();
        if (me.isDestroyed) {
          return;
        }
        !silent && client.trigger("unsplit");
        me._splitOptions = null;
      }
    }
  }
  unsplitCleanup() {
  }
  //endregion
  //region Context menu
  populateCellMenu({ record, column, items: items2 }) {
    const me = this, { isSplit } = me, { splitFrom } = me.client;
    if (!me.disabled) {
      items2.splitGrid = {
        text: "L{split}",
        localeClass: me,
        icon: "b-icon b-icon-split-vertical",
        weight: 500,
        separator: true,
        hidden: isSplit || splitFrom,
        menu: {
          splitHorizontally: {
            text: "L{horizontally}",
            icon: "b-icon b-icon-split-horizontal",
            localeClass: me,
            weight: 100,
            onItem() {
              me.split({ atRecord: record });
            }
          },
          splitVertically: {
            text: "L{vertically}",
            icon: "b-icon b-icon-split-vertical",
            localeClass: me,
            weight: 200,
            onItem() {
              me.split({ atColumn: column });
            }
          },
          splitBoth: {
            text: "L{both}",
            icon: "b-icon b-icon-split-both",
            localeClass: me,
            weight: 300,
            onItem() {
              me.split({ atColumn: column, atRecord: record });
            }
          }
        }
      };
      items2.unsplitGrid = {
        text: "L{unsplit}",
        localeClass: me,
        icon: "b-icon b-icon-clear",
        hidden: !(isSplit || splitFrom),
        weight: 400,
        separator: true,
        onItem() {
          (splitFrom || me).unsplit();
        }
      };
    }
  }
  //endregion
  //region Syncing columns
  startSyncingColumns() {
    for (const subView of this.subViews) {
      subView.columns.ion({
        name: "columns",
        change: "onColumnsChange",
        thisObj: this
      });
    }
  }
  stopSyncingColumns() {
    this.detachListeners("columns");
  }
  onColumnsChange({
    source,
    isMove,
    action,
    /*index, */
    parent,
    records,
    changes
  }) {
    var _a4, _b;
    const me = this;
    if (!__privateGet(me, _ignoreColumnChanges)) {
      __privateSet(me, _ignoreColumnChanges, true);
      for (const clone of me.subViews) {
        const { columns } = clone;
        if (source !== columns) {
          if (action === "update" && changes.region && Object.keys(changes).length === 1) {
            if (!columns.getById(records[0].id)) {
              const [column] = records, targetParent = (_a4 = columns.getById(me.$before.parent.id)) != null ? _a4 : columns.rootNode, targetBefore = me.$before.id !== null && columns.getById(me.$before.id);
              targetParent.insertChild(column.data, targetBefore);
            } else {
              columns.remove(records[0].id);
            }
            me.$before = null;
          } else if (!(isMove == null ? void 0 : isMove[records[0].id]) && isMove !== true) {
            if (action === "add") {
              const relevantColumns = records.filter((column) => clone.getSubGridFromColumn(column));
              columns.add(me.cloneColumns(relevantColumns));
            } else {
              columns.applyChangesFromStore(source);
            }
          } else if (action === "add") {
            const sourceColumn = records[0], sourceBefore = sourceColumn.nextSibling, targetColumn = columns.getById(sourceColumn.id);
            if (!targetColumn) {
              me.$before = {
                id: sourceBefore == null ? void 0 : sourceBefore.id,
                parent
              };
              __privateSet(me, _ignoreColumnChanges, false);
              continue;
            }
            if (sourceColumn.meta.isSelectionColumn) {
              __privateSet(me, _ignoreColumnChanges, false);
              continue;
            }
            const targetParent = (_b = columns.getById(parent.id)) != null ? _b : columns.rootNode, targetBefore = sourceBefore && columns.getById(sourceBefore.id);
            targetParent.insertChild(targetColumn, targetBefore);
          }
          columns.commit();
        }
      }
      source.commit();
      __privateSet(me, _ignoreColumnChanges, false);
    }
  }
  //endregion
  //region Syncing splitters
  getOtherSplitter(splitter) {
    return splitter === this.topSplitter ? this.bottomSplitter : this.topSplitter;
  }
  onSplitterMouseDown({ source, event }) {
    if (!event.handled) {
      event.handled = true;
      this.getOtherSplitter(source).onMouseDown(event);
    }
  }
  onSplitterMouseEnter({ source, event }) {
    this.getOtherSplitter(source).element.classList.add("b-hover");
  }
  onSplitterMouseLeave({ source, event }) {
    this.getOtherSplitter(source).element.classList.remove("b-hover");
  }
  onSplitterDrag({ source, event }) {
    if (!event.handled) {
      event.handled = true;
      this.getOtherSplitter(source).onMouseMove(event);
    }
  }
  onSplitterDrop({ source, event }) {
    if (!event.handled) {
      event.handled = true;
      this.getOtherSplitter(source).onMouseUp(event);
    }
  }
  //endregion
  //region Relaying property changes & events
  // Relay relevant config changes to other splits
  afterConfigChange({ name, value }) {
    if (this.isSplit && this.relayProperties[name]) {
      this.syncSplits((split) => {
        split[name] = value;
      });
    }
  }
  // Sync listeners added at runtime to other splits
  afterAddListener(eventName, listener) {
    if (this.isSplit && !listener.$internal && !ignoreListeners[eventName]) {
      this.syncSplits((split) => split.on(eventName, listener));
    }
  }
  afterRemoveListener(eventName, listener) {
    if (!listener.$internal) {
      this.syncSplits((split) => split.un(eventName, listener));
    }
  }
  //endregion
  //region Util
  // Call a fn for all splits except the on this fn is called on
  forEachOther(fn) {
    const original = this.client.splitFrom || this.client;
    if (original.features.split.enabled && !original.inForEachOther) {
      original.inForEachOther = true;
      for (const view of original.subViews) {
        if (view !== this.client) {
          fn(view);
        }
      }
      original.inForEachOther = false;
    }
  }
  syncSplits(fn) {
    this.forEachOther(fn);
  }
  //endregion
};
_ignoreColumnChanges = new WeakMap();
__publicField(Split, "$name", "Split");
__publicField(Split, "featureClass", "");
__publicField(Split, "configurable", {
  /**
   * An array of sub-views. The first sub-view is the original grid, and the others are clones of the original.
   * See the "Accessing a sub-view" section above for more information.
   *
   * ```javascript
   * await grid.split('vertical');
   * const bottom = grid.subViews[1];
   * await bottom.scrollRowIntoView(100);
   * ```
   *
   * Note that this property is accessible directly on the grid instance.
   *
   * @member {Grid.view.Grid[]} subViews
   * @on-owner
   * @readonly
   * @category Common
   */
  subViews: [],
  // Not a config, but still defined in configurable to allow assigning it in pluginConfig,
  /**
   * Properties whose changes should be relayed to sub-views at runtime.
   *
   * Supply an object with property names as keys, and a truthy value to relay the change, or a falsy value to not
   * relay it. The object will be merged with the default values.
   *
   * By default, these properties are relayed:
   * * {@link Grid/view/Grid#property-readOnly}
   * * {@link Grid/view/Grid#property-rowHeight}
   *
   * Example of supplying a custom set of properties to relay:
   * ```javascript
   * const grid = new Grid({
   *     features : {
   *         split : {
   *             relayProperties : {
   *                 readOnly : false, // Do not relay readOnly changes
   *                 myConfig : true   // Relay changes to the myConfig property
   *             }
   *         }
   *     }
   * }
   * ```
   * @config {Object<String,Boolean>}
   */
  relayProperties: {
    value: {
      readOnly: 1,
      rowHeight: 1
    },
    $config: {
      merge: "merge"
    }
  }
});
__publicField(Split, "pluginConfig", {
  chain: ["populateCellMenu", "afterConfigChange", "afterAddListener", "afterRemoveListener"],
  assign: ["split", "unsplit", "subViews", "syncSplits"]
});
Split._$name = "Split";
GridFeatureManager.registerFeature(Split, false);

// lib/Grid/feature/Summary.js
var Summary = class extends SummaryFormatter_default(InstancePlugin) {
  //region Config
  static get configurable() {
    return {
      /**
       * Set to `true` to sum values of selected row records
       * @prp {Boolean}
       */
      selectedOnly: null,
      hideFooters: false
    };
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ["renderRows", "bindStore"]
    };
  }
  //endregion
  //region Init
  static get $name() {
    return "Summary";
  }
  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
    this.bindStore(grid.store);
    grid.hideFooters = this.hideFooters;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      change: "onStoreChange",
      thisObj: this
    });
  }
  get store() {
    return this.grid.store;
  }
  doDestroy() {
    super.doDestroy();
  }
  doDisable(disable) {
    super.doDisable(disable);
    const { client } = this;
    if (disable) {
      client.element.classList.add("b-summary-disabled");
    } else {
      this.updateSummaries();
      client.element.classList.remove("b-summary-disabled");
      client.eachSubGrid((subGrid) => subGrid.scrollable.syncPartners());
    }
  }
  //endregion
  //region Render
  renderRows() {
    this.updateSummaries();
  }
  /**
   * Updates summaries. Summaries are displayed as tables in footer (styling left out to keep brief):
   * ```
   * <table>
   *     <tr><td colspan="2">0</td></tr> // { sum : 'min' } Only a calculation, span entire table
   *     <tr><td>Max</td><td>10</td></tr> // { sum : 'max', label: 'Max' } Label + calculation
   *     <tr><td>Max</td><td>10</td></tr> // { sum : 'sum', label: 'Max' } Label + calculation
   * </table>
   * ```
   * @private
   */
  updateSummaries() {
    const me = this, { grid, store } = me, cells = DomHelper.children(grid.element, ".b-grid-footer"), selectedOnly = me.selectedOnly && grid.selectedRecords.length > 0, records = (store.isFiltered ? store.storage.values : store.allRecords).filter((r) => !r.isSpecialRow && (!selectedOnly || grid.isSelected(r)));
    grid.columns.forEach((column) => {
      var _a4;
      (_a4 = column.summaries) == null ? void 0 : _a4.forEach((config) => {
        if ("seed" in config) {
          if (!("initialSeed" in config)) {
            config.initialSeed = config.seed;
          }
          if (["number", "string", "date"].includes(typeof config.initialSeed)) {
            config.seed = config.initialSeed;
          } else {
            config.seed = Object.assign({}, config.initialSeed);
          }
        }
      });
    });
    cells.forEach((cellElement) => {
      if (!cellElement.dataset.column) {
        return;
      }
      const column = grid.columns.get(cellElement.dataset.column), html = me.generateHtml(column, records, "b-grid-footer-summary");
      if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {
        if (!cellElement.children.length) {
          cellElement.innerHTML = html;
        } else {
          DomHelper.sync(html, cellElement.firstElementChild);
        }
      }
    });
  }
  //endregion
  //region Events
  /**
   * Updates summaries on store changes (except record update, handled below)
   * @private
   */
  onStoreChange({ action, changes }) {
    let shouldUpdate = true;
    if (this.disabled) {
      return;
    }
    if (action === "update") {
      shouldUpdate = Object.keys(changes).some((field) => {
        const colField = this.grid.columns.get(field);
        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
    }
    if (shouldUpdate) {
      this.updateSummaries();
    }
  }
  //endregion
  updateSelectedOnly(value) {
    const me = this;
    me.detachListeners("selectionChange");
    if (value) {
      me.grid.ion({
        name: "selectionChange",
        selectionChange: me.refresh,
        thisObj: me
      });
    }
    me.refresh();
  }
  /**
   * Refreshes the summaries
   */
  refresh() {
    this.updateSummaries();
  }
};
Summary.featureClass = "b-summary";
Summary._$name = "Summary";
GridFeatureManager.registerFeature(Summary);

// lib/Grid/feature/Tree.js
var immediatePromise5 = Promise.resolve();
var Tree = class extends InstancePlugin.mixin(Delayable_default) {
  // Plugin configuration. This plugin chains some functions in Grid.
  static get pluginConfig() {
    return {
      assign: ["collapseAll", "expandAll", "collapse", "expand", "expandTo", "toggleCollapse"],
      chain: ["onElementClick", "bindStore", "beforeRenderRow"]
    };
  }
  //endregion
  //region Init
  construct(client, config) {
    var _a4;
    super.construct(client, config);
    if (!this.treeColumn && ((_a4 = client.initialConfig.columns) == null ? void 0 : _a4.length) > 0) {
      console.info("To use the tree feature, one column should be configured with `type: 'tree'`");
    }
    client.store && this.bindStore(client.store);
  }
  doDisable(disable) {
    if (disable) {
      throw new Error("Tree feature cannot be disabled");
    }
  }
  get store() {
    return this.client.store;
  }
  get treeColumn() {
    const me = this, { columns } = me.client;
    if (!me._treeColumn || !columns.includes(me._treeColumn)) {
      me._treeColumn = columns.find((column) => column.isTreeColumn);
    }
    return me._treeColumn;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeLoadChildren: "onBeforeLoadChildren",
      loadChildren: "onLoadChildren",
      loadChildrenException: "onLoadChildrenException",
      beforeToggleNode: "onBeforeToggleNode",
      thisObj: this
    });
  }
  //endregion
  //region Expand & collapse
  /**
   * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
   * This function is exposed on Grid and can thus be called as `grid.toggleCollapse()`
   * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @on-owner
   * @category Tree
   */
  async toggleCollapse(idOrRecord, collapse) {
    if (idOrRecord == null) {
      throw new Error("Tree#toggleCollapse must be passed a record");
    }
    const me = this, { store, client } = me, { rowManager } = client, record = store.getById(idOrRecord), meta = record.instanceMeta(store);
    record.generation++;
    if (await store.toggleCollapse(record, collapse)) {
      const row = rowManager.getRowFor(record);
      if (row && record.ancestorsExpanded()) {
        row.render(null, null, false);
      }
      if (!me.isTogglingNode) {
        client.element.classList.add("b-toggling-node");
        me.isTogglingNode = true;
        me.requestAnimationFrame(() => {
          client.element.classList.remove("b-toggling-node");
          me.isTogglingNode = false;
        });
      }
      client.trigger(meta.collapsed ? "collapseNode" : "expandNode", { record });
      client.trigger("toggleNode", { record, collapse: meta.collapsed });
    }
  }
  /**
   * Collapse a single node.
   * This function is exposed on Grid and can thus be called as `grid.collapse()`
   * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
   * @on-owner
   * @category Tree
   */
  async collapse(idOrRecord) {
    return this.toggleCollapse(idOrRecord, true);
  }
  /**
   * Expand a single node.
   * This function is exposed on Grid and can thus be called as `grid.expand()`
   * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to expand
   * @on-owner
   * @category Tree
   */
  async expand(idOrRecord) {
    return this.toggleCollapse(idOrRecord, false);
  }
  onBeforeToggleNode({ record, collapse }) {
    this.client.trigger("beforeToggleNode", { record, collapse });
  }
  onBeforeLoadChildren({ source: store, params }) {
    const parent = store.getById(params[store.modelClass.idField]), row = this.client.rowManager.getRowFor(parent);
    row == null ? void 0 : row.addCls("b-loading-children");
  }
  onLoadChildren({ source: store, params }) {
    const parent = store.getById(params[store.modelClass.idField]), row = this.client.rowManager.getRowFor(parent);
    row == null ? void 0 : row.removeCls("b-loading-children");
  }
  onLoadChildrenException({ record }) {
    const row = this.client.rowManager.getRowFor(record);
    row == null ? void 0 : row.removeCls("b-loading-children");
  }
  /**
   * Expand or collapse all nodes, as specified by param, starting at the passed node (which defaults to the root node)
   * @param {Boolean} [collapse] Set to true to collapse, false to expand (defaults to true)
   * @param {Core.data.Model} [topNode] The topmost node from which to cascade a collapse.
   * Defaults to the {@link Core.data.Store#property-rootNode}. Not included in the cascade if
   * the root node is being used.
   * @category Tree
   */
  async expandOrCollapseAll(collapse = true, topNode = this.store.rootNode) {
    const { client, store } = this, { animateTreeNodeToggle } = client, promises = [], childRecords = [];
    client.trigger("beforeToggleAllNodes", { collapse });
    client.animateTreeNodeToggle = false;
    store.suspendEvents();
    store.traverse((record) => {
      const gridMeta = record.instanceMeta(store);
      if (!record.isLeaf) {
        if (collapse && !gridMeta.collapsed) {
          this.toggleCollapse(record, true);
          childRecords.push(...record.children);
        } else if (!collapse && gridMeta.collapsed) {
          if (Array.isArray(record.children)) {
            childRecords.push(...record.children);
          }
          promises.push(this.toggleCollapse(record, false));
        }
      }
    }, topNode, topNode === store.rootNode);
    store.resumeEvents();
    return (collapse ? immediatePromise5 : Promise.all(promises)).then(() => {
      client.refreshRows(collapse);
      if (childRecords.length) {
        if (collapse) {
          store.trigger("remove", { records: childRecords, isCollapse: true, isCollapseAll: true });
        } else {
          store.trigger("add", { records: childRecords, isExpand: true, isExpandAll: true });
        }
      }
      client.trigger("toggleAllNodes", { collapse });
      client.animateTreeNodeToggle = animateTreeNodeToggle;
    });
  }
  /**
   * Collapse all nodes.
   * This function is exposed on Grid and can thus be called as `grid.collapseAll()`
   * @on-owner
   * @category Tree
   */
  async collapseAll() {
    return this.expandOrCollapseAll(true);
  }
  /**
   * Expand all nodes.
   * This function is exposed on Grid and can thus be called as `grid.expandAll()`
   * @on-owner
   * @category Tree
   */
  async expandAll() {
    return this.expandOrCollapseAll(false);
  }
  /**
   * Expands parent nodes to make this node "visible".
   * This function is exposed on Grid and can thus be called as `grid.expandTo()`
   * @param {String|Number|Core.data.Model|String[]|Number[]|Core.data.Model[]} idOrRecord Record (the node itself),
   * or id of a node. Also accepts arrays of the same types.
   * @param {Boolean} [scrollIntoView=true] A flag letting you control whether to scroll the record into view
   * @on-owner
   * @async
   * @category Tree
   */
  async expandTo(idOrRecord, scrollIntoView = true) {
    var _a4, _b, _c, _d;
    const me = this, { store, client } = me, { animateTreeNodeToggle } = client;
    if (Array.isArray(idOrRecord)) {
      if (idOrRecord.length > 0) {
        client.suspendRefresh();
        for (let i = idOrRecord.length - 1; i >= 0; i--) {
          const record2 = store.getById(idOrRecord[i]);
          if (i === 0) {
            (_a4 = client.resumeRefresh) == null ? void 0 : _a4.call(client, false);
            client.rowManager.refresh();
          }
          await ((_b = me.expandTo) == null ? void 0 : _b.call(me, record2, i === 0));
        }
      }
      return;
    }
    const record = store.getById(idOrRecord);
    if (record.instanceMeta(me.store).hiddenByCollapse === false) {
      return;
    }
    client.animateTreeNodeToggle = false;
    if (!record.ancestorsExpanded()) {
      const parents = [];
      for (let parent = record.parent; parent && !parent.isRoot; parent = parent.parent) {
        if (!parent.isExpanded(store)) {
          parents.unshift(parent);
        }
      }
      client.suspendRefresh();
      for (const parent of parents) {
        if (!me.isDestroyed) {
          await me.toggleCollapse(parent, false);
        }
      }
      (_c = client.resumeRefresh) == null ? void 0 : _c.call(client, false);
      (_d = client.refreshRows) == null ? void 0 : _d.call(client);
    }
    client.animateTreeNodeToggle = animateTreeNodeToggle;
    if (!me.isDestroyed && scrollIntoView) {
      await client.scrollRowIntoView(record);
    }
  }
  /**
   * Expands the parent nodes in the tree to the provided depth.
   * @param {Number} level The depth to expand to. Passing level `0` means the top level root parents will be expanded.
   * @param {Boolean} [collapseAll=false] Pass `true` to collapse all nodes before expanding
   * @category Tree
   */
  async expandToLevel(level, collapseAll = false) {
    const { store, client } = this, { animateTreeNodeToggle } = client, expandChildren = (parent) => {
      parent.children.forEach((record) => {
        if (!record.isLeaf) {
          if (record.instanceMeta(store).collapsed) {
            this.toggleCollapse(record, false);
          }
          if (record.childLevel < level) {
            expandChildren(record);
          }
        }
      });
    };
    store.suspendEvents();
    client.suspendRefresh();
    if (collapseAll) {
      await this.collapseAll();
    }
    if (!client.isDestroyed) {
      client.animateTreeNodeToggle = false;
      expandChildren(store.rootNode);
      store.resumeEvents();
      client.resumeRefresh(true);
      client.animateTreeNodeToggle = animateTreeNodeToggle;
    }
  }
  //endregion
  //region Events
  /**
   * Called when user clicks somewhere in the grid. Expand/collapse node on icon click.
   * @private
   */
  onElementClick(event) {
    const me = this, target = event.target, cellData = me.client.getCellDataFromEvent(event), clickedExpander = target.closest(".b-tree-expander");
    if (clickedExpander) {
      event.preventDefault();
    }
    if (clickedExpander || me.expandOnCellClick && (cellData == null ? void 0 : cellData.record.isParent)) {
      me.toggleCollapse(cellData.record);
    }
  }
  /**
   * Called on key down in grid. Expand/collapse node on [space]
   * @private
   */
  toggleCollapseByKey() {
    var _a4;
    const { focusedCell } = this.client;
    if ((focusedCell == null ? void 0 : focusedCell.rowIndex) > -1 && !((_a4 = this.client.features.cellEdit) == null ? void 0 : _a4.isEditing) && focusedCell.record.isParent && document.activeElement.closest(".b-grid-cell")) {
      this.toggleCollapse(focusedCell.id);
      return true;
    }
    return false;
  }
  //endregion
  //region Rendering
  beforeRenderRow({ record, cls }) {
    if (!record.isLeaf) {
      const isCollapsed = !record.isExpanded(this.client.store);
      cls["b-tree-parent-row"] = 1;
      cls["b-tree-collapsed"] = isCollapsed;
      cls["b-tree-expanded"] = !isCollapsed;
      cls["b-loading-children"] = record.instanceMeta(this.client).isLoadingChildren;
    } else {
      cls["b-tree-parent-row"] = 0;
      cls["b-tree-collapsed"] = 0;
      cls["b-tree-expanded"] = 0;
      cls["b-loading-children"] = 0;
    }
  }
  //endregion
  // Expands tree if single column.
  // Called by default on ArrowRight
  expandIfSingleColumn() {
    if (this.client.columns.count === 1) {
      return this.expandByKey();
    }
    return false;
  }
  // Expands tree on Shift+ArrowRight by default.
  expandByKey() {
    const me = this, { client } = me, { focusedCell } = client, record = focusedCell == null ? void 0 : focusedCell.record;
    if (record && (focusedCell == null ? void 0 : focusedCell.column.tree) && record.isParent && record.instanceMeta(client.store).collapsed) {
      me.expand(record);
      return true;
    }
    return false;
  }
  collapseIfSingleColumn() {
    if (this.client.columns.count === 1) {
      return this.collapseByKey();
    }
    return false;
  }
  collapseByKey() {
    const me = this, { client } = me, { focusedCell } = client, record = focusedCell == null ? void 0 : focusedCell.record;
    if ((focusedCell == null ? void 0 : focusedCell.column.tree) && record) {
      if (record.isParent && !record.instanceMeta(client.store).collapsed) {
        me.collapse(record);
        return true;
      }
      if (record.parent && !record.parent.isRoot) {
        client.deselectAll();
        client.focusCell({
          record: record.parent,
          column: focusedCell.column
        });
        return true;
      }
    }
    return false;
  }
};
//region Config
__publicField(Tree, "$name", "Tree");
__publicField(Tree, "configurable", {
  /**
   * Expand parent nodes when clicking on their cell
   * @prp {Boolean}
   * @default
   */
  expandOnCellClick: false,
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    " ": "toggleCollapseByKey",
    ArrowRight: "expandIfSingleColumn",
    "Shift+ArrowRight": "expandByKey",
    ArrowLeft: "collapseIfSingleColumn",
    "Shift+ArrowLeft": "collapseByKey"
  }
});
Tree.featureClass = "b-tree";
Tree._$name = "Tree";
GridFeatureManager.registerFeature(Tree, false, "Grid");
GridFeatureManager.registerFeature(Tree, true, "TreeGrid");

// lib/Grid/feature/TreeGroup.js
var TreeGroup = class extends InstancePlugin {
  construct(grid, config) {
    this.treeColumn = grid.columns.find((col) => col.isTreeColumn);
    super.construct(grid, config);
    this._levels = this._levels || [];
    if (!grid.hasFeature("tree")) {
      throw new Error("The TreeGroup feature requires the Tree feature to be enabled");
    }
  }
  applyPluginConfig() {
    this.scheduleRefreshGroups = FunctionHelper.createBuffered(this.refreshGroups, this.refreshGroupsTimeout, this);
    return super.applyPluginConfig(...arguments);
  }
  processParentData(parentData) {
    const me = this;
    if (me.parentCls) {
      parentData.cls = me.parentCls;
    }
  }
  processTransformedData(transformedData) {
  }
  async waitForReadiness() {
    var _a4;
    const me = this;
    if (me.originalStore.isLoading) {
      await me.originalStore.await("load", false);
      if (me.isDestroyed) {
        return;
      }
    }
    const { crudManager } = this.client;
    if (crudManager) {
      if (crudManager.isLoadingOrSyncing || crudManager._autoLoadPromise) {
        await crudManager.await("requestDone");
      }
      if (me.isDestroyed) {
        return;
      }
      await ((_a4 = me.client.project) == null ? void 0 : _a4.commitAsync());
    }
  }
  async applyLevels(levels) {
    var _a4;
    const me = this, { client, treeColumn } = me;
    let { store } = client, result = null, treeColumnField;
    const { modelClass } = store;
    if ((treeColumn == null ? void 0 : treeColumn.field) && modelClass.getFieldDefinition(treeColumn.field)) {
      treeColumnField = modelClass.getFieldDataSource(treeColumn.field);
    }
    levels = levels || [];
    if (levels.length === 0 && me.isConfiguring) {
      return;
    }
    me._levels = levels;
    me.isApplying++;
    client.suspendRefresh();
    if (!me.originalStore) {
      me.originalStore = store;
      store = new store.constructor({
        reapplyFilterOnAdd: true,
        reapplyFilterOnUpdate: true,
        tree: true,
        modelClass: store.modelClass,
        load: (_a4 = store.load) == null ? void 0 : _a4.bind(store),
        commit: store.commit.bind(store),
        remove: (records, silent) => me.originalStore.remove(records.map((rec) => rec.$original), silent),
        removeAll: store.removeAll.bind(store)
      });
      client.store = store;
      me.originalStore.ion({
        name: "originalStore",
        refresh: me.onOriginalStoreRefresh,
        add: me.onOriginalStoreChanged,
        update: me.onOriginalStoreUpdate,
        remove: me.onOriginalStoreChanged,
        removeAll: me.onOriginalStoreChanged,
        thisObj: me
      });
    }
    await me.waitForReadiness();
    if (me.isDestroyed) {
      return;
    }
    if (levels.length > 0) {
      const leafLinks = me.originalStore.getAllDataRecords(false).flatMap((record) => record.isLeaf ? record.link() : []);
      leafLinks.forEach((record) => record.setInstanceMeta(store.id, { collapsed: false }));
      store.data = leafLinks;
      result = store.treeify(levels, (parentData) => {
        if (treeColumnField) {
          ObjectHelper.setPath(parentData, treeColumnField, parentData.key);
        }
        me.processParentData(parentData);
      });
      me.processTransformedData(result);
      await me.trigger("beforeDataLoad", { store, data: result.children });
      store.data = result.children;
    } else {
      client.store = me.originalStore;
      me.detachListeners("originalStore");
      me.originalStore = null;
    }
    me.isApplying--;
    client.resumeRefresh(false);
    if (client.isPainted) {
      client.renderRows(false);
    }
    client.trigger("treeGroupChange", { levels });
  }
  doDisable(disable) {
    if (disable) {
      this.clearGroups();
    }
    super.doDisable(disable);
  }
  onOriginalStoreUpdate({ records, changes }) {
    if (this.levels.some((level) => (level.fieldName || level) in changes)) {
      this.scheduleRefreshGroups();
    }
  }
  onOriginalStoreChanged() {
    this.scheduleRefreshGroups();
  }
  onOriginalStoreRefresh({ action }) {
    if (action === "dataset" || action === "filter") {
      this.scheduleRefreshGroups();
    }
  }
  updateLevels(levels, old) {
    const me = this, { client } = me;
    if (me.hideGroupedColumns) {
      old == null ? void 0 : old.forEach((field) => {
        field = field.fieldName || field;
        if (!levels.some((level) => (level.fieldName || level) === field)) {
          client.columns.get(field).show();
        }
      });
      levels == null ? void 0 : levels.forEach((field) => {
        field = field.fieldName || field;
        if (!old || !old.some((fn) => fn.fieldName === field)) {
          client._suspendRenderContentsOnColumnsChanged = true;
          client.columns.get(field).hide();
          client._suspendRenderContentsOnColumnsChanged = false;
        }
      });
    }
    if (levels || !me.isConfiguring) {
      me.updatePromise = me.applyLevels(levels);
      client.renderContents();
    }
  }
  /**
   * Transforms the data according to the supplied levels.
   *
   * Yields the same result as assigning to {@link #property-levels}.
   *
   * ```javascript
   * // Transform into a tree with two parent levels
   * grid.group('status', record => (record.percentDone % 10) * 10);
   * ```
   *
   * @param {Array<String|Grid.column.Column|Function(Core.data.Model) : any>} levels Field names or functions use to generate parents in resulting tree.
   * @on-owner
   * @category Common
   */
  async group(levels) {
    ObjectHelper.assertArray(levels, "group()");
    await this.applyLevels(levels);
  }
  /**
   * Clears the previously applied transformation, restoring data to its initial state.
   *
   * Yields the same result as assigning `null` to {@link #property-levels}.
   *
   * ```javascript
   * // Restore original data
   * grid.clearGroups();
   * ```
   * @on-owner
   * @category Common
   */
  async clearGroups() {
    if (this.isGrouped) {
      this.levels = [];
      await this.updatePromise;
    }
  }
  /**
   * Refreshes the store tree grouping by re-applying the current transformation.
   *
   * ```javascript
   * // Refresh groups
   * grid.refreshGroups();
   * ```
   * @on-owner
   * @category Common
   * @private
   */
  refreshGroups() {
    var _a4;
    return (_a4 = this.applyLevels) == null ? void 0 : _a4.call(this, this._levels);
  }
  /**
   * Indicates if the feature has applied grouping and the component uses
   * a transformed version of the store.
   * @property {Boolean}
   */
  get isGrouped() {
    return this._levels.length > 0;
  }
  /**
   * Supply items for headers context menu.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateHeaderMenu({ column, items: items2 }) {
    const me = this, groupable = column.groupable !== false && !column.isTreeColumn;
    let separator = false;
    if (groupable && !me.isGroupedByField(column.field)) {
      items2.groupAsc = {
        text: "L{group}",
        localeClass: me,
        icon: "b-fw-icon b-icon-group-asc",
        separator: true,
        weight: 400,
        disabled: me.disabled,
        onItem: () => me.addGrouper(column)
      };
      separator = true;
    }
    if (me.isGrouped) {
      if (me.isGroupedByField(column.field)) {
        items2.groupRemove = {
          text: "L{stopGroupingThisColumn}",
          localeClass: me,
          icon: "b-fw-icon b-icon-clear",
          separator: !separator,
          weight: 420,
          disabled: me.disabled,
          onItem: () => me.removeGrouper(column)
        };
        separator = true;
      }
      items2.groupRemoveAll = {
        text: "L{stopGrouping}",
        localeClass: me,
        icon: "b-fw-icon b-icon-clear",
        separator: !separator,
        weight: 420,
        disabled: me.disabled,
        onItem: () => me.clearGroups()
      };
    }
  }
  addGrouper(column) {
    this.levels = this.levels.concat(column.field);
  }
  isGroupedByField(field) {
    return this.levels.find((groupFn) => groupFn.fieldName === field);
  }
  removeGrouper(column) {
    this.levels.splice(this.levels.findIndex((groupFn) => groupFn.fieldName === column.field), 1);
    this.levels = this.levels.slice();
  }
};
__publicField(TreeGroup, "$name", "TreeGroup");
__publicField(TreeGroup, "configurable", {
  /**
   * An array of model field names or functions used to determine the levels in the resulting tree.
   *
   * When supplying a function, it will be called for each leaf in the original data, and it is expected to return
   * an atomic value used to determine which parent the leaf will be added to at that level.
   *
   * ```javascript
   * const grid = new TreeGrid({
   *     features : {
   *         treeGroup : {
   *             levels : [
   *                 // First level is determined by the value of the status field
   *                 'status',
   *                 // Second level by the result of this function
   *                 // (which puts percentdone 0-9 in one group, 10-19 into another and so on)
   *                 record => (record.percentDone % 10) * 10
   *             ]
   *         }
   *     }
   * });
   * ```
   *
   * The function form can also be used as a formatter/renderer of sorts, simply by returning a string:
   *
   * ```javascript
   * const grid = new TreeGrid({
   *     features : {
   *         treeGroup : {
   *             levels : [
   *                 record => `Status: ${record.status}`
   *             ]
   *         }
   *     }
   * });
   * ```
   *
   * Assigning `null` restores the tree structure to its original state.
   *
   * @prp {Array<String|Function(Core.data.Model) : any>} levels
   */
  levels: [],
  /**
   * CSS class to apply to the generated parents.
   *
   * @config {String}
   * @default
   */
  parentCls: "b-generated-parent",
  /**
   * A function letting you format the text shown in the generated parent group levels. This method will be provided
   * with the value produced by the column representing the grouped level. Each column's renderer method will be
   * provided an extra `isTreeGroup` param to indicate that the value will be used for a generated parent. `cellElement`
   * and other DOM specific args will be in the context of the tree column.
   *
   * ```javascript
   * const grid = new Grid({
   *     features : {
   *         treeGroup : {
   *             hideGroupedColumns : true,
   *             levels             : [
   *                 'priority'
   *             ],
   *             parentRenderer({ field, value, column, record }) {
   *                 // For generated group parent, prefix with the grouped column text
   *                 return column.text + ': ' + value;
   *             }
   *         }
   *     }
   * })
   * ```
   *
   * @config {Function}
   * @param {Object} data The rendering data representing the generated tree parent record
   * @param {String} data.field The field representing this group level (e.g. 'priority')
   * @param {*} data.value The value representing this group level (e.g. 'high')
   * @param {Grid.column.Column} data.column The value representing this group level (e.g. 'high')
   * @param {Core.data.Model} data.record The first record for this parent
   * @returns {String}
   */
  parentRenderer: null,
  /**
   * True to hide grouped columns. Only supported when using String to define levels.
   *
   * @config {Boolean}
   */
  hideGroupedColumns: null,
  /**
   * The number of milliseconds to wait after {@link #function-scheduleRefreshGroups} call
   * before actually refreshing groups.
   * Each further {@link #function-scheduleRefreshGroups} call during that timeout will restart the timer.
   * @config {Number}
   * @default
   * @private
   */
  refreshGroupsTimeout: 100
});
__publicField(TreeGroup, "pluginConfig", {
  chain: ["populateHeaderMenu"],
  assign: ["group", "clearGroups", "refreshGroups"]
});
__publicField(TreeGroup, "properties", {
  isApplying: 0,
  /**
   * The original store used by the component before applying grouping. Use this to modify / load data
   * while tree grouping is active.
   * @property {Core.data.Store}
   * @readonly
   */
  originalStore: null
});
TreeGroup._$name = "TreeGroup";
GridFeatureManager.registerFeature(TreeGroup);

// lib/Grid/feature/export/Utils.js
var RowsRange = {
  all: "all",
  visible: "visible"
};
var PaperFormat = {
  A6: {
    width: 4.11,
    height: 5.81
  },
  A5: {
    width: 5.81,
    height: 8.25
  },
  A4: {
    width: 8.25,
    height: 11.69,
    portraitWidth: 8.3,
    portraitHeight: 11.7,
    landscapeWidth: 11.7,
    landscapeHeight: 8.26
  },
  A3: {
    width: 11.69,
    height: 16.49,
    portraitWidth: 11.7,
    // 16.54 works perfect in print, but in export (puppeteer) it results in extra empty page
    portraitHeight: 16.49,
    landscapeWidth: 16.54,
    landscapeHeight: 11.68
  },
  Legal: {
    width: 8.5,
    height: 14,
    portraitWidth: 8.5,
    portraitHeight: 14,
    landscapeWidth: 14,
    landscapeHeight: 8.15
  },
  Letter: {
    width: 8.5,
    height: 11,
    portraitWidth: 8.5,
    portraitHeight: 10.95,
    landscapeWidth: 11,
    landscapeHeight: 8.3
  }
};
function getPrintPaperSizeAdjustments() {
  if (BrowserHelper.isFirefox) {
    return {
      portraitWidth: 0,
      portraitHeight: 0,
      landscapeWidth: 0,
      landscapeHeight: 0.26
    };
  }
  if (BrowserHelper.isSafari) {
    return {
      portraitWidth: 0,
      portraitHeight: 0.1,
      landscapeWidth: 0,
      landscapeHeight: 0.5
    };
  }
  return {
    portraitWidth: 0,
    portraitHeight: 0,
    landscapeWidth: 0,
    landscapeHeight: 0.25
  };
}
var Orientation = {
  portrait: "portrait",
  landscape: "landscape"
};
var FileFormat = {
  pdf: "pdf",
  png: "png"
};
var FileMIMEType = {
  pdf: "application/pdf",
  png: "image/png"
};

// lib/Grid/view/export/field/ExportRowsCombo.js
var ExportRowsCombo = class extends Combo {
  //region Config
  static get $name() {
    return "ExportRowsCombo";
  }
  // Factoryable type name
  static get type() {
    return "exportrowscombo";
  }
  static get defaultConfig() {
    return {
      editable: false
    };
  }
  //endregion
  buildItems() {
    const me = this;
    return [
      { id: RowsRange.all, text: me.L("L{all}") },
      { id: RowsRange.visible, text: me.L("L{visible}") }
    ];
  }
};
ExportRowsCombo.initClass();
ExportRowsCombo._$name = "ExportRowsCombo";

// lib/Grid/view/export/field/ExportOrientationCombo.js
var ExportOrientationCombo = class extends Combo {
  //region Config
  static get $name() {
    return "ExportOrientationCombo";
  }
  // Factoryable type name
  static get type() {
    return "exportorientationcombo";
  }
  static get defaultConfig() {
    return {
      editable: false
    };
  }
  //endregion
  buildItems() {
    const me = this;
    return [
      { id: Orientation.portrait, text: me.L("L{portrait}") },
      { id: Orientation.landscape, text: me.L("L{landscape}") }
    ];
  }
};
ExportOrientationCombo.initClass();
ExportOrientationCombo._$name = "ExportOrientationCombo";

// lib/Grid/view/export/ExportDialog.js
function buildComboItems(obj, fn = (x) => x) {
  return Object.keys(obj).map((key) => ({ id: key, text: fn(key) }));
}
var ExportDialog = class extends Popup {
  //region Config
  static get $name() {
    return "ExportDialog";
  }
  static get type() {
    return "exportdialog";
  }
  static get configurable() {
    return {
      autoShow: false,
      autoClose: false,
      closable: true,
      centered: true,
      /**
       * Returns map of values of dialog fields.
       * @member {Object<String,Object>} values
       * @readonly
       */
      /**
       * Grid instance to build export dialog for
       * @config {Grid.view.Grid}
       */
      client: null,
      /**
       * Set to `false` to not preselect all visible columns when the dialog is shown
       * @config {Boolean}
       */
      autoSelectVisibleColumns: true,
      /**
       * Set to `false` to allow using PNG + Multipage config in export dialog
       * @config {Boolean}
       */
      hidePNGMultipageOption: true,
      /**
       * When set to `true` labels in the dialog will say `Print` instead of `Export`
       * @prp {Boolean}
       */
      useBrowserPrint: false,
      title: "L{exportSettings}",
      maxHeight: "80%",
      scrollable: {
        overflowY: true
      },
      defaults: {
        localeClass: this
      },
      items: {
        columnsField: {
          type: "combo",
          label: "L{ExportDialog.columns}",
          name: "columns",
          store: {},
          valueField: "id",
          displayField: "text",
          multiSelect: true,
          weight: 100,
          maxHeight: 100
        },
        rowsRangeField: {
          type: "exportrowscombo",
          label: "L{ExportDialog.rows}",
          name: "rowsRange",
          value: "all",
          weight: 200
        },
        exporterTypeField: {
          type: "combo",
          label: "L{ExportDialog.exporterType}",
          name: "exporterType",
          editable: false,
          value: "singlepage",
          displayField: "text",
          buildItems() {
            const dialog = this.parent;
            return dialog.exporters.map((exporter) => ({
              id: exporter.type,
              text: dialog.optionalL(exporter.title, this)
            }));
          },
          onChange({ value }) {
            this.owner.widgetMap.alignRowsField.hidden = value === "singlepage";
            this.owner.widgetMap.repeatHeaderField.hidden = value !== "multipagevertical";
          },
          weight: 300
        },
        alignRowsField: {
          type: "checkbox",
          label: "L{ExportDialog.alignRows}",
          name: "alignRows",
          checked: false,
          hidden: true,
          weight: 400
        },
        repeatHeaderField: {
          type: "checkbox",
          label: "L{ExportDialog.repeatHeader}",
          name: "repeatHeader",
          localeClass: this,
          hidden: true,
          weight: 500
        },
        fileFormatField: {
          type: "combo",
          label: "L{ExportDialog.fileFormat}",
          name: "fileFormat",
          localeClass: this,
          editable: false,
          value: "pdf",
          items: [],
          onChange({ value, oldValue }) {
            const dialog = this.parent;
            if (dialog.hidePNGMultipageOption) {
              const exporterField = dialog.widgetMap.exporterTypeField, exporter = exporterField.store.find((r) => r.id === "singlepage");
              if (value === FileFormat.png && exporter) {
                this._previousDisabled = exporterField.disabled;
                exporterField.disabled = true;
                this._previousValue = exporterField.value;
                exporterField.value = "singlepage";
              } else if (oldValue === FileFormat.png && this._previousValue) {
                exporterField.disabled = this._previousDisabled;
                exporterField.value = this._previousValue;
              }
            }
          },
          weight: 600
        },
        paperFormatField: {
          type: "combo",
          label: "L{ExportDialog.paperFormat}",
          name: "paperFormat",
          editable: false,
          value: "A4",
          items: [],
          weight: 700
        },
        orientationField: {
          type: "exportorientationcombo",
          label: "L{ExportDialog.orientation}",
          name: "orientation",
          value: "portrait",
          weight: 800
        }
      },
      bbar: {
        defaults: {
          localeClass: this
        },
        items: {
          exportButton: {
            color: "b-green",
            text: "L{ExportDialog.export}",
            weight: 100,
            onClick: "up.onExportClick"
          },
          cancelButton: {
            color: "b-gray",
            text: "L{ExportDialog.cancel}",
            weight: 200,
            onClick: "up.onCancelClick"
          }
        }
      },
      internalListeners: {
        beforeShow: "onInternalBeforeShow"
      }
    };
  }
  //endregion
  construct(config = {}) {
    const me = this, { client } = config;
    if (!client) {
      throw new Error("`client` config is required");
    }
    me.columnsStore = client.columns.chain((column) => column.isLeaf && column.exportable, null, { excludeCollapsedRecords: false });
    me.applyInitialValues(config);
    super.construct(config);
    LocaleManager_default.ion({
      locale: "onLocaleChange",
      prio: -1,
      thisObj: me
    });
  }
  updateUseBrowserPrint(value) {
    const me = this;
    me.whenVisible(() => {
      const { exportButton, fileFormatField } = me.widgetMap, defaultText = exportButton.initialConfig.text, isDefaultTitle = !("title" in me.initialConfig);
      if (!defaultText || defaultText === "L{ExportDialog.export}" && value) {
        exportButton.text = value ? me.L("L{ExportDialog.print}") : me.L("L{ExportDialog.export}");
      }
      if (isDefaultTitle) {
        me.title = value ? me.L("L{printSettings}") : me.L("L{exportSettings}");
      }
      fileFormatField.hidden = value || Boolean(fileFormatField.initialConfig.hidden);
    });
  }
  applyInitialValues(config) {
    const me = this, items2 = config.items = config.items || {};
    config.width = config.width || me.L("L{width}");
    config.defaults = config.defaults || {};
    config.defaults.labelWidth = config.defaults.labelWidth || me.L("L{ExportDialog.labelWidth}");
    items2.columnsField = items2.columnsField || {};
    items2.fileFormatField = items2.fileFormatField || {};
    items2.paperFormatField = items2.paperFormatField || {};
    items2.fileFormatField.items = buildComboItems(FileFormat, (value) => value.toUpperCase());
    items2.paperFormatField.items = buildComboItems(PaperFormat);
    items2.columnsField.store = me.columnsStore;
  }
  onInternalBeforeShow() {
    const { columnsField, alignRowsField, exporterTypeField, repeatHeaderField } = this.widgetMap;
    if (this.autoSelectVisibleColumns) {
      columnsField.value = this.columnsStore.query((c) => !c.hidden);
    }
    alignRowsField.hidden = exporterTypeField.value === "singlepage";
    repeatHeaderField.hidden = exporterTypeField.value !== "multipagevertical";
  }
  onLocaleChange() {
    const labelWidth = this.L("L{labelWidth}");
    this.width = this.L("L{width}");
    this.eachWidget((widget) => {
      if (widget instanceof Field) {
        widget.labelWidth = labelWidth;
      }
    });
  }
  onExportClick() {
    const values = this.values;
    this.trigger("export", { values });
  }
  onCancelClick() {
    this.trigger("cancel");
    this.hide();
  }
};
ExportDialog.initClass();
ExportDialog._$name = "ExportDialog";

// lib/Grid/feature/export/exporter/Exporter.js
var Exporter = class extends Delayable_default(Events_default(Localizable_default(Base))) {
  static get defaultConfig() {
    return {
      /**
       * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.
       * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.
       *
       * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css
       * @config {Boolean|String}
       * @default
       */
      translateURLsToAbsolute: true,
      /**
       * When true links are converted to absolute by combining current window location (with replaced origin) with
       * resource link.
       * When false links are converted by combining new origin with resource link (for angular)
       * @config {Boolean}
       * @default
       */
      keepPathName: true,
      /**
       * This method accepts all stylesheets (link and style tags) which are supposed to be put on the page. Use this
       * hook method to filter or modify them.
       *
       * ```javascript
       * new Grid({
       *     features: {
       *         pdfExport: {
       *             // filter out inline styles and bootstrap.css
       *             filterStyles: styles => styles.filter(item => !/(link|bootstrap.css)/.test(item))
       *         }
       *     }
       * });
       * ```
       * @param {String[]} styles
       * @returns {String[]} List of stylesheets to put on the exported page
       */
      filterStyles: (styles) => styles
    };
  }
  static inchToPx(value) {
    return value * 96;
  }
  /**
   * Template of an extracted page.
   * @param {Object} data Data for the page template
   * @returns {String}
   */
  pageTpl(data) {
    const {
      title,
      header,
      footer,
      styles,
      htmlClasses,
      bodyClasses = [],
      paperHeight,
      paperWidth,
      html,
      currentPage,
      isPrint
    } = data;
    let { htmlStyle = "", bodyStyle = "" } = data;
    bodyClasses.push(`b-${this.constructor.type}`);
    if (DomHelper.scrollBarWidth) {
      bodyClasses.push("b-visible-scrollbar");
    } else {
      bodyClasses.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      bodyClasses.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      bodyClasses.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      bodyClasses.push("b-firefox");
    }
    htmlStyle = isPrint ? htmlStyle : `${htmlStyle}; width: ${paperWidth}in; height: ${paperHeight}in;`;
    bodyStyle = isPrint ? `${bodyStyle}; width: ${paperWidth}in;` : `${bodyStyle}; width: ${paperWidth}in; height: ${paperHeight}in;`;
    return TemplateHelper.tpl`
            <!DOCTYPE html>
            <html class="${htmlClasses} b-print-root" style="${htmlStyle}">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${title}</title>
                    ${styles.join("")}
                </head>
                <body class="b-export ${bodyClasses.join(" ")}" style="${bodyStyle}">
                    <div class="b-export-content b-page-${currentPage}">
                        ${header && `<div class="b-export-header" style="width: 100%">${header}</div>`}
                        <div class="b-export-body"><div class="b-export-viewport">${html}</div></div>
                        ${footer && `<div class="b-export-footer" style="width: 100%">${footer}</div>`}
                    </div>
                </body>
            </html>`;
  }
  /**
   * Returns all style-related tags: `<style>` and `<link rel="stylesheet">`
   * @property {String[]}
   * @readonly
   */
  get stylesheets() {
    const me = this;
    if (me._stylesheets) {
      return me._stylesheets;
    }
    const translate = me.translateURLsToAbsolute, origin = globalThis.origin, styleSheetNodes = Array.from(document.querySelectorAll('link[rel="stylesheet"], style')), styles = [];
    styleSheetNodes.forEach((node) => {
      node = node.cloneNode(true);
      if (translate && node.href) {
        let result;
        if (translate === true) {
          result = node.href;
        } else if (this.keepPathName) {
          result = node.href.replace(origin, translate);
        } else {
          result = new URL(node.getAttribute("href"), translate);
        }
        node.setAttribute("href", result);
      }
      let styleText = node.outerHTML;
      if (translate && /style/i.test(node.tagName)) {
        const converter = me.getStyleTagURLConverter(translate);
        styleText = styleText.replace(/url\(['"]?(.+?)['"]?\)/g, converter);
      }
      styles.push(styleText);
    });
    return me._stylesheets = me.filterStyles(styles);
  }
  set stylesheets(value) {
    this._stylesheets = value ? this.filterStyles(value) : value;
  }
  getStyleTagURLConverter(translate) {
    return function(match, url) {
      let result;
      try {
        let base;
        if (/^#/.test(url)) {
          result = match;
        } else {
          if (translate === true) {
            base = globalThis.location.href;
          } else if (this.keepPathName) {
            base = globalThis.location.href.replace(globalThis.location.origin, translate);
          } else {
            base = translate;
          }
          result = `url('${new URL(url, base).href}')`;
        }
      } catch (e) {
        result = match;
      }
      return result;
    }.bind(this);
  }
  saveState({ client }) {
    const { disableGridColumnIdWarning } = client;
    client.disableGridColumnIdWarning = true;
    this.state = client.state;
    client.disableGridColumnIdWarning = disableGridColumnIdWarning;
  }
  async restoreState({ client }) {
    const promises = [], detachers = /* @__PURE__ */ new Set();
    detachers.add(
      client.scrollable.ion({
        scroll() {
          promises.push(client.scrollable.await("scrollEnd"));
        }
      })
    );
    client.eachSubGrid(({ header, scrollable }) => {
      detachers.add(
        scrollable.ion({
          scroll() {
            promises.push(scrollable.await("scrollEnd"));
          }
        })
      );
      detachers.add(
        header.scrollable.ion({
          scroll() {
            promises.push(header.scrollable.await("scrollEnd"));
          }
        })
      );
    });
    client.state = this.state;
    await Promise.all(promises);
    detachers.forEach((fn) => fn());
  }
  beforeExport() {
    this.element = document.createElement("div");
  }
  //region DOM helpers
  cloneElement(element, target = this.element, clear = true) {
    if (clear) {
      target.innerHTML = "";
    }
    target.appendChild(element.cloneNode(true));
    DomHelper.removeEachSelector(target, ".b-grid-row,.b-grid-merged-cells-container");
    const maskEl = target.querySelector(".b-gridbase > .b-mask");
    if (maskEl) {
      maskEl.remove();
    }
  }
  createPlaceholder(el, clear = true, config = {}) {
    if (clear) {
      el.innerHTML = "";
    }
    return DomHelper.createElement(Object.assign({
      parent: el,
      id: IdHelper.generateId("export")
    }, config));
  }
  prepareElement({ client }) {
    const { tbar, bbar } = client;
    if (tbar) {
      this.element.querySelector(`#${tbar.id}`).remove();
    }
    if (bbar) {
      this.element.querySelector(`#${bbar.id}`).remove();
    }
  }
  /**
   * Appends generated header/footer element to the document body to measure their height
   * @param html
   * @returns {Number}
   * @private
   */
  measureElement(html = "") {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }
    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: "hidden",
        position: "absolute"
      },
      // Add html to measure to a div between two other divs to take margin into account
      html: `<div style="height: 1px"></div>${html}<div style="height: 1px"></div>`
    });
    const result = target.offsetHeight - 2;
    target.remove();
    return result;
  }
  // Converts local urls to absolute
  prepareHTML(html) {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }
    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: "hidden",
        position: "absolute"
      },
      html
    });
    const elements = target.querySelectorAll("img");
    for (let i = 0, l = elements.length; i < l; i++) {
      elements[i].setAttribute("src", elements[i].src);
    }
    const result = target.innerHTML;
    target.remove();
    return result;
  }
  getVirtualScrollerHeight(client) {
    let result = 0;
    client.eachSubGrid((subGrid) => {
      if (subGrid.overflowingHorizontally) {
        result = DomHelper.scrollBarWidth;
      }
    });
    return result === 0 ? result : result + 1;
  }
  //endregion
  // Use carefully picked values for portrait/landscape mode and fallback to legacy width/height in case use
  // has them overridden
  getPaperWidth(paperFormat, isPortrait) {
    if ("portraitWidth" in paperFormat) {
      const prop = isPortrait ? "portraitWidth" : "landscapeWidth";
      return paperFormat[prop] - (this.exportMeta.isPrinting ? getPrintPaperSizeAdjustments()[prop] : 0);
    } else {
      return isPortrait ? paperFormat.width : paperFormat.height;
    }
  }
  getPaperHeight(paperFormat, isPortrait) {
    if ("portraitHeight" in paperFormat) {
      const prop = isPortrait ? "portraitHeight" : "landscapeHeight";
      return paperFormat[prop] - (this.exportMeta.isPrinting ? getPrintPaperSizeAdjustments()[prop] : 0);
    } else {
      return isPortrait ? paperFormat.height : paperFormat.width;
    }
  }
  inchToPx(value) {
    return value * 96;
  }
  getScaleValue(base, value) {
    return Math.floor(base * 1e4 / value) / 1e4;
  }
  getVisibleRowsCount(client) {
    const rowManager = client.rowManager, firstVisibleIndex = rowManager.rows.indexOf(rowManager.firstVisibleRow), lastVisibleIndex = rowManager.rows.indexOf(rowManager.lastVisibleRow);
    let result;
    if (firstVisibleIndex !== -1) {
      if (lastVisibleIndex === -1) {
        result = client.store.count - firstVisibleIndex;
      } else {
        result = lastVisibleIndex - firstVisibleIndex + 1;
      }
    } else {
      result = client.store.count;
    }
    return result;
  }
  async export(config) {
    const me = this;
    let pages;
    me.beforeExport();
    me.saveState(config);
    await me.prepareComponent(config);
    try {
      pages = await me.getPages(config);
    } finally {
      await me.restoreComponent(config);
      me.stylesheets = null;
      await new Promise((resolve) => me.requestAnimationFrame(resolve));
      await me.restoreState(config);
    }
    return pages;
  }
  async getPages(config) {
    const generator = this.pagesExtractor(config), pages = [];
    let step;
    while ((step = await generator.next()) && !step.done) {
      pages.push(step.value);
    }
    return pages;
  }
  // Row buffer has to be adjusted to render complete row set per exported page. See virtual scrolling section in README
  // for more details
  adjustRowBuffer(client) {
    const { contentHeight } = this.exportMeta, { rowManager } = client;
    this.oldRowManagerConfig = {
      prependRowBuffer: rowManager.prependRowBuffer,
      appendRowBuffer: rowManager.appendRowBuffer
    };
    const adjustedRowBuffer = Math.ceil(contentHeight / rowManager.rowOffsetHeight);
    rowManager.prependRowBuffer = adjustedRowBuffer;
    rowManager.appendRowBuffer = adjustedRowBuffer;
    client.renderRows();
    client.rowManager.jumpToPosition(client.scrollable.y);
  }
  restoreRowBuffer(client) {
    client.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer;
    client.rowManager.appendRowBuffer = this.oldRowManagerConfig.appendRowBuffer;
  }
  async prepareComponent(config) {
    const me = this, {
      client,
      columns,
      rowsRange,
      keepRegionSizes,
      enableDirectRendering,
      useRenderedColumnWidth
    } = config, { rowManager } = client, exportMeta = me.exportMeta = {
      enableDirectRendering,
      totalWidth: 0,
      totalHeight: 0 - (enableDirectRendering ? 0 : me.getVirtualScrollerHeight(client)),
      subGrids: {},
      isPrinting: config.useBrowserPrint
    };
    client.columns.forEach((column) => {
      if (columns.includes(column.id)) {
        column.show();
      } else {
        column.hide();
      }
    });
    await new Promise((resolve) => client.requestAnimationFrame(resolve));
    if (rowManager.rowCount > 0) {
      if (rowsRange === RowsRange.all) {
        exportMeta.firstVisibleDataIndex = rowManager.rows[0].dataIndex;
      } else {
        exportMeta.firstVisibleDataIndex = rowManager.firstVisibleRow.dataIndex;
        config.alignRows = true;
      }
      if (!enableDirectRendering) {
        await client.scrollRowIntoView(client.store.getAt(exportMeta.firstVisibleDataIndex), { block: "start" });
      }
    }
    const { element } = me;
    me.cloneElement(client.element);
    me.prepareElement(config);
    let fakeRow;
    if (enableDirectRendering) {
      exportMeta.fakeRow = fakeRow = rowManager.rowClass.new({
        cls: client.rowCls,
        rowManager,
        grid: client,
        // use fake indices, they aren't really required
        index: -10,
        dataIndex: -10
      });
    }
    client.eachSubGrid((subGrid) => {
      var _a4, _b, _c;
      if (fakeRow) {
        subGrid.onAddRow({ rows: [fakeRow], isExport: true });
        fakeRow.element.dataset.ownerCmp = client.id;
      }
      const placeHolder = me.createPlaceholder(element.querySelector(`[id="${subGrid.id}"]`), false);
      let width;
      if (keepRegionSizes == null ? void 0 : keepRegionSizes[subGrid.region]) {
        width = subGrid.element.offsetWidth;
      } else {
        const { visibleColumns } = subGrid.columns;
        if (
          // If there is only one visible column...
          visibleColumns.length === 1 && // ...and it is not a timeaxis column, which should always take as much space as possible
          !visibleColumns[0].isTimeAxisColumn && // ...and originally in grid there was only one visible column and it is the same one
          me.state.columns.filter((c) => c.region === subGrid.region && !c.hidden && c.id !== visibleColumns[0].id).length === 0
        ) {
          width = subGrid.element.offsetWidth;
        } else {
          width = subGrid.columns.visibleColumns.reduce((result, column) => {
            if (!useRenderedColumnWidth && typeof column.width === "number") {
              result += column.width;
            } else {
              result += (client.hideHeaders ? rowManager.rows[0].getCell(column.id) : column.element).offsetWidth;
            }
            return result;
          }, 0);
        }
      }
      exportMeta.totalWidth += width;
      const splitterWidth2 = ((_a4 = subGrid.splitterElement) == null ? void 0 : _a4.offsetWidth) || 0;
      exportMeta.totalWidth += splitterWidth2;
      exportMeta.subGrids[subGrid.region] = {
        id: subGrid.id,
        headerId: ((_b = subGrid.header) == null ? void 0 : _b.id) || null,
        footerId: ((_c = subGrid.footer) == null ? void 0 : _c.id) || null,
        rows: [],
        splitterWidth: splitterWidth2,
        placeHolder,
        width
      };
    });
  }
  prepareExportElement() {
    const me = this, { element, exportMeta } = me;
    Object.values(exportMeta.subGrids).forEach(({ width, id, headerId, footerId }) => {
      [id, headerId, footerId].forEach((id2) => {
        if (id2) {
          const childElement = element.querySelector(`[id="${id2}"]`);
          if (childElement) {
            childElement.style.width = `${width}px`;
            childElement.style.flex = "";
          }
        }
      });
    });
    return element.innerHTML;
  }
  async restoreComponent(config) {
    if (this.exportMeta.fakeRow) {
      this.exportMeta.fakeRow.destroy();
      delete this.exportMeta.fakeRow;
    }
  }
  async scrollRowIntoView(client, index) {
    await client.scrollRowIntoView(client.store.getAt(index), { block: "start" });
    await new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  collectRow(row) {
    const subGrids = this.exportMeta.subGrids, re = /data-owner-cmp=".+?"/;
    Object.entries(row.elements).forEach(([key, value]) => {
      subGrids[key].rows.push([
        value.outerHTML.replace(re, ""),
        row.top,
        row.offsetHeight,
        /* @__PURE__ */ new Map()
        // This one is used to collect events (or in general additional row content)
      ]);
    });
  }
  renderMergedCells(config, fromIndex, toIndex, rows) {
    const me = this, { client } = config, { subGrids } = me.exportMeta, domConfigMap = client.features.mergeCells.buildMergedCellsConfig(fromIndex, toIndex, rows);
    for (const subGridName in subGrids) {
      const subGrid = subGrids[subGridName], target = document.createElement("div");
      DomSync.sync({
        targetElement: target,
        domConfig: {
          children: domConfigMap[subGridName].children
        }
      });
      if (target.childNodes.length) {
        target.childNodes.forEach((child) => {
          const { syncId } = child.dataset, range = client.features.mergeCells.mergedRanges.find((range2) => {
            var _a4;
            return ((_a4 = range2.cellElement) == null ? void 0 : _a4.parentNode.dataset.syncId) === syncId;
          });
          if (range) {
            child.innerHTML = range.cellElement.outerHTML;
          }
        });
        subGrid.mergedCellsHtml = [target.innerHTML];
      }
    }
  }
};
Exporter.prototype.pagesExtractor = async function* pagesExtractor() {
  throw new Error("Implement this method in a subclass");
};
Exporter._$name = "Exporter";

// lib/Grid/feature/export/exporter/MultiPageExporter.js
var MultiPageExporter = class extends Exporter {
  static get $name() {
    return "MultiPageExporter";
  }
  static get type() {
    return "multipage";
  }
  static get title() {
    return this.L("L{multipage}");
  }
  static get exportingPageText() {
    return "L{exportingPage}";
  }
  //region State management
  async stateNextPage({ client, rowsRange, enableDirectRendering }) {
    const { exportMeta } = this;
    ++exportMeta.currentPage;
    ++exportMeta.verticalPosition;
    delete exportMeta.lastExportedRowBottom;
    if (exportMeta.verticalPosition >= exportMeta.verticalPages) {
      Object.assign(exportMeta, {
        verticalPosition: 0,
        horizontalPosition: exportMeta.horizontalPosition + 1,
        currentPageTopMargin: 0,
        lastTop: 0,
        lastRowIndex: rowsRange === RowsRange.visible ? client.rowManager.firstVisibleRow.dataIndex : 0
      });
      delete exportMeta.lastRowDataIndex;
      if (!enableDirectRendering) {
        await this.scrollRowIntoView(client, exportMeta.firstVisibleDataIndex, { block: "start" });
      }
    }
  }
  //endregion
  //region Preparation
  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this, { exportMeta } = me, {
      client,
      headerTpl,
      footerTpl,
      alignRows,
      rowsRange,
      enableDirectRendering
    } = config, paperFormat = PaperFormat[config.paperFormat], isPortrait = config.orientation === Orientation.portrait, paperWidth = me.getPaperWidth(paperFormat, isPortrait), paperHeight = me.getPaperHeight(paperFormat, isPortrait), pageWidth = me.inchToPx(paperWidth), pageHeight = me.inchToPx(paperHeight), onlyVisibleRows = rowsRange === RowsRange.visible, horizontalPages = Math.ceil(exportMeta.totalWidth / pageWidth);
    let contentHeight = pageHeight;
    if (headerTpl) {
      contentHeight -= me.measureElement(headerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (footerTpl) {
      contentHeight -= me.measureElement(footerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    let totalHeight, verticalPages, totalRows = client.store.count;
    if (onlyVisibleRows) {
      totalRows = me.getVisibleRowsCount(client);
      totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.bodyHeight;
    } else {
      totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;
    }
    if (alignRows && !onlyVisibleRows) {
      const rowHeight = client.rowManager.rowOffsetHeight, rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight), rowsPerPage = Math.floor(contentHeight / rowHeight), remainingRows = totalRows - rowsOnFirstPage;
      verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
    } else {
      verticalPages = Math.ceil(totalHeight / contentHeight);
    }
    Object.assign(exportMeta, {
      paperWidth,
      paperHeight,
      pageWidth,
      pageHeight,
      horizontalPages,
      verticalPages,
      totalHeight,
      contentHeight,
      totalRows,
      totalPages: horizontalPages * verticalPages,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0,
      currentPageTopMargin: 0,
      lastTop: 0,
      lastRowIndex: onlyVisibleRows ? client.rowManager.firstVisibleRow.dataIndex : 0
    });
    if (!enableDirectRendering) {
      this.adjustRowBuffer(client);
    }
  }
  async restoreComponent(config) {
    await super.restoreComponent(config);
    if (!config.enableDirectRendering) {
      this.restoreRowBuffer(config.client);
    }
  }
  //endregion
  async collectRows(config) {
    const me = this, { exportMeta } = me, {
      client,
      alignRows,
      rowsRange
    } = config, {
      subGrids,
      currentPageTopMargin,
      verticalPosition,
      contentHeight,
      totalRows,
      lastRowDataIndex
    } = exportMeta, { rowManager } = client, { rows } = rowManager, onlyVisible = rowsRange === RowsRange.visible, hasMergeCells = client.hasActiveFeature("mergeCells");
    let remainingHeight, index;
    if (onlyVisible && lastRowDataIndex != null) {
      if (lastRowDataIndex === rows[rows.length - 1].dataIndex) {
        index = rows.length - 1;
      } else {
        index = rows.findIndex((r) => r.dataIndex === lastRowDataIndex);
      }
    } else {
      index = onlyVisible ? rows.findIndex((r) => r.bottom > Math.ceil(client.scrollable.y)) : rows.findIndex((r) => r.bottom + currentPageTopMargin + client.headerHeight > 0);
    }
    const firstRowIndex = index, overflowingHeight = onlyVisible || verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + client.headerHeight;
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= client.headerHeight;
    }
    let lastDataIndex, offset = 0;
    while (remainingHeight > 0) {
      const row = rows[index];
      if (alignRows && remainingHeight < row.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
        me.exportMeta.lastExportedRowBottom = rows[index - 1].bottom;
      } else {
        me.collectRow(row);
        remainingHeight -= row.offsetHeight;
        lastDataIndex = row.dataIndex;
        if (++index === rows.length && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisible && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      for (const subGridName in subGrids) {
        const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
        subGrid.mergedCellsHtml = [];
        for (const mergedCell of mergedCells) {
          subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
        }
      }
    }
    const lastRow = rows[index - 1];
    if (lastRow) {
      exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
      exportMeta.lastRowDataIndex = lastRow.dataIndex + 1;
    }
    await me.onRowsCollected(rows.slice(firstRowIndex, index), config);
    if (onlyVisible) {
      exportMeta.exactGridHeight -= exportMeta.scrollableTopMargin = client.scrollable.y;
    } else {
      const detacher2 = rowManager.ion({ offsetRows: ({ offset: value }) => offset += value });
      await me.scrollRowIntoView(client, lastDataIndex + 1);
      detacher2();
    }
    return offset;
  }
  async renderRows(config) {
    const me = this, { exportMeta } = me, {
      client,
      alignRows,
      rowsRange
    } = config, {
      currentPageTopMargin,
      verticalPosition,
      contentHeight,
      totalRows,
      lastRowIndex,
      fakeRow
    } = exportMeta, { store } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = rowsRange === RowsRange.visible;
    let index = lastRowIndex, { lastTop } = exportMeta, remainingHeight;
    const firstRowIndex = index, overflowingHeight = onlyVisibleRows || verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + client.headerHeight, rows = [];
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= client.headerHeight;
    }
    let lastDataIndex, previousTop, offset = 0;
    while (remainingHeight > 0) {
      fakeRow.render(index, store.getAt(index), true, false, true);
      if (alignRows && remainingHeight < fakeRow.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
        me.exportMeta.lastExportedRowBottom = lastTop;
      } else {
        previousTop = lastTop;
        lastDataIndex = index;
        lastTop = fakeRow.translate(lastTop);
        remainingHeight -= fakeRow.offsetHeight;
        me.collectRow(fakeRow);
        rows.push({
          top: fakeRow.top,
          bottom: fakeRow.bottom,
          offsetHeight: fakeRow.offsetHeight,
          dataIndex: fakeRow.dataIndex
        });
        if (++index === store.count && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisibleRows && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      me.renderMergedCells(config, firstRowIndex, index, rows);
    }
    exportMeta.lastRowIndex = alignRows ? index : lastDataIndex;
    exportMeta.lastTop = alignRows ? lastTop : previousTop;
    if (fakeRow) {
      exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows, config);
    return offset;
  }
  async buildPage(config) {
    const me = this, { exportMeta } = me, {
      client,
      headerTpl,
      footerTpl,
      enableDirectRendering
    } = config, {
      totalWidth,
      totalPages,
      currentPage,
      subGrids
    } = exportMeta;
    Object.values(subGrids).forEach((subGrid) => subGrid.rows = []);
    if (config.rowsRange === RowsRange.all) {
      exportMeta.totalHeight = client.height - client.bodyHeight + client.scrollable.scrollHeight - me.getVirtualScrollerHeight(client);
    }
    let header, footer;
    if (headerTpl) {
      header = me.prepareHTML(headerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (footerTpl) {
      footer = me.prepareHTML(footerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    let offset;
    if (enableDirectRendering) {
      offset = await me.renderRows(config);
    } else {
      offset = await me.collectRows(config);
    }
    const html = me.buildPageHtml(config);
    return { html, header, footer, offset };
  }
  async onRowsCollected() {
  }
  buildPageHtml() {
    const me = this, { subGrids } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = rows.reduce((result, row) => {
        result += row[0];
        return result;
      }, "");
      if (mergedCellsHtml == null ? void 0 : mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
  prepareExportElement() {
    const me = this, { element, exportMeta } = me;
    if (exportMeta.scrollableTopMargin) {
      element.querySelector(".b-grid-vertical-scroller").style.marginTop = `-${exportMeta.scrollableTopMargin}px`;
    }
    return super.prepareExportElement();
  }
};
MultiPageExporter.prototype.pagesExtractor = async function* pagesExtractor2(config) {
  const me = this, {
    exportMeta,
    stylesheets
  } = me, {
    totalWidth,
    totalPages,
    paperWidth,
    paperHeight,
    realPaperWidth,
    realPaperHeight,
    contentHeight
  } = exportMeta, isPrint = config.useBrowserPrint;
  let currentPage;
  while ((currentPage = exportMeta.currentPage) < totalPages) {
    me.trigger("exportStep", { text: me.L(MultiPageExporter.exportingPageText, { currentPage, totalPages }), progress: Math.round((currentPage + 1) / totalPages * 90) });
    const { html, header, footer, offset } = await me.buildPage(config);
    const styles = [
      ...stylesheets,
      `
                <style>
                    .b-page-wrap {
                        width: ${paperWidth}in;
                        height: ${paperHeight}in;
                    }
                    .b-page-${currentPage} #${config.client.id} {
                        height: ${exportMeta.exactGridHeight}px !important;
                        width: ${totalWidth}px !important;
                    }
                    .b-page-${currentPage} .b-export-body .b-export-viewport {
                        transform: translate(${-paperWidth * exportMeta.horizontalPosition}in, ${exportMeta.currentPageTopMargin}px);
                    }
                </style>
            `
    ];
    exportMeta.currentPageTopMargin -= contentHeight + offset;
    await me.stateNextPage(config);
    yield {
      html: me.pageTpl({
        html,
        header,
        footer,
        styles,
        paperWidth,
        paperHeight,
        realPaperWidth,
        realPaperHeight,
        currentPage,
        isPrint
      })
    };
  }
};
MultiPageExporter._$name = "MultiPageExporter";

// lib/Grid/feature/export/exporter/MultiPageVerticalExporter.js
var MultiPageVerticalExporter = class extends Exporter {
  static get $name() {
    return "MultiPageVerticalExporter";
  }
  static get type() {
    return "multipagevertical";
  }
  static get title() {
    return this.L("L{multipagevertical}");
  }
  static get exportingPageText() {
    return "L{exportingPage}";
  }
  //region State management
  async stateNextPage({ client }) {
    const { exportMeta } = this, {
      totalRows,
      processedRows,
      totalPages
    } = exportMeta;
    ++exportMeta.currentPage;
    ++exportMeta.verticalPosition;
    if (exportMeta.currentPage === totalPages && processedRows.size !== totalRows) {
      ++exportMeta.totalPages;
      ++exportMeta.verticalPages;
    }
  }
  //endregion
  estimateTotalPages(config) {
    const me = this, { exportMeta } = me, {
      client,
      headerTpl,
      footerTpl,
      alignRows,
      rowsRange,
      repeatHeader,
      enableDirectRendering
    } = config, {
      pageWidth,
      pageHeight,
      totalWidth
    } = exportMeta, scale = me.getScaleValue(pageWidth, totalWidth);
    let totalHeight = 0 - me.getVirtualScrollerHeight(client) + client.height - client.bodyElement.offsetHeight + client.scrollable.scrollHeight, contentHeight = pageHeight / scale, totalRows = client.store.count, initialScroll = 0, rowsHeight = totalHeight, verticalPages;
    if (headerTpl) {
      contentHeight -= me.measureElement(headerTpl({
        totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (footerTpl) {
      contentHeight -= me.measureElement(footerTpl({
        totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (repeatHeader) {
      contentHeight -= client.headerHeight + client.footerHeight;
      totalHeight -= client.headerHeight + client.footerHeight;
    }
    if (rowsRange === RowsRange.visible) {
      const rowManager = client.rowManager, firstRow = rowManager.firstVisibleRow, lastRow = rowManager.lastVisibleRow;
      if (!enableDirectRendering) {
        initialScroll = firstRow.top;
      }
      totalRows = me.getVisibleRowsCount(client);
      if (enableDirectRendering) {
        totalHeight = client.headerHeight + client.footerHeight + lastRow.bottom - firstRow.top;
        rowsHeight = lastRow.bottom - firstRow.top;
      } else {
        rowsHeight = totalHeight = totalHeight - client.scrollable.scrollHeight + lastRow.bottom - firstRow.top;
      }
      exportMeta.lastRowIndex = firstRow.dataIndex;
      exportMeta.finishRowIndex = lastRow.dataIndex;
    } else {
      exportMeta.finishRowIndex = client.store.count - 1;
    }
    if (alignRows && !repeatHeader && rowsRange !== RowsRange.visible) {
      const rowHeight = client.rowManager.rowOffsetHeight, rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight), rowsPerPage = Math.floor(contentHeight / rowHeight), remainingRows = totalRows - rowsOnFirstPage;
      verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
    } else {
      verticalPages = Math.ceil(rowsHeight / contentHeight);
    }
    Object.assign(exportMeta, {
      scale,
      contentHeight,
      totalRows,
      totalHeight,
      verticalPages,
      initialScroll,
      horizontalPages: 1,
      totalPages: verticalPages
    });
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this, { exportMeta } = me, { client } = config, paperFormat = PaperFormat[config.paperFormat], isPortrait = config.orientation === Orientation.portrait, paperWidth = me.getPaperWidth(paperFormat, isPortrait), paperHeight = me.getPaperHeight(paperFormat, isPortrait), pageWidth = me.inchToPx(paperWidth), pageHeight = me.inchToPx(paperHeight), horizontalPages = 1;
    Object.assign(exportMeta, {
      paperWidth,
      paperHeight,
      realPaperWidth: me.getPaperWidth(paperFormat, isPortrait),
      realPaperHeight: me.getPaperHeight(paperFormat, isPortrait),
      pageWidth,
      pageHeight,
      horizontalPages,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0,
      currentPageTopMargin: 0,
      lastTop: 0,
      lastRowIndex: 0,
      processedRows: /* @__PURE__ */ new Set()
    });
    me.estimateTotalPages(config);
    if (!config.enableDirectRendering) {
      me.adjustRowBuffer(client);
    }
  }
  async restoreComponent(config) {
    await super.restoreComponent(config);
    if (!config.enableDirectRendering) {
      this.restoreRowBuffer(config.client);
    }
  }
  async collectRows(config) {
    const me = this, { exportMeta } = me, {
      client,
      alignRows,
      repeatHeader
    } = config, {
      subGrids,
      currentPageTopMargin,
      verticalPosition,
      totalRows,
      contentHeight
    } = exportMeta, clientHeaderHeight = repeatHeader ? 0 : client.headerHeight, { rowManager } = client, { rows } = rowManager, onlyVisibleRows = config.rowsRange === RowsRange.visible, hasMergeCells = client.hasActiveFeature("mergeCells");
    let index = onlyVisibleRows ? rows.findIndex((r) => r.bottom > client.scrollable.y) : rows.findIndex((r) => r.bottom + currentPageTopMargin + clientHeaderHeight > 0), remainingHeight;
    const firstRowIndex = index, overflowingHeight = verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + clientHeaderHeight;
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= clientHeaderHeight;
    }
    let lastDataIndex, offset = 0;
    while (remainingHeight > 0) {
      const row = rows[index];
      if (alignRows && remainingHeight < row.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
      } else {
        me.collectRow(row);
        remainingHeight -= row.offsetHeight;
        if (remainingHeight > 0) {
          exportMeta.processedRows.add(row.dataIndex);
        }
        lastDataIndex = row.dataIndex;
        if (++index === rows.length && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisibleRows && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      for (const subGridName in subGrids) {
        const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
        subGrid.mergedCellsHtml = [];
        for (const mergedCell of mergedCells) {
          subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
        }
      }
    }
    const lastRow = rows[index - 1];
    if (lastRow) {
      exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows.slice(firstRowIndex, index), config);
    if (onlyVisibleRows) {
      exportMeta.scrollableTopMargin = client.scrollable.y;
    } else {
      const detacher2 = rowManager.ion({ offsetRows: ({ offset: value }) => offset += value });
      await me.scrollRowIntoView(client, lastDataIndex + 1);
      detacher2();
    }
    return offset;
  }
  async renderRows(config) {
    const me = this, { exportMeta } = me, {
      client,
      alignRows,
      repeatHeader
    } = config, {
      currentPageTopMargin,
      verticalPosition,
      totalRows,
      contentHeight,
      lastRowIndex,
      finishRowIndex,
      fakeRow
    } = exportMeta, clientHeaderHeight = repeatHeader ? 0 : client.headerHeight, { store } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = config.rowsRange === RowsRange.visible;
    let index = lastRowIndex, { lastTop } = exportMeta, remainingHeight;
    const firstRowIndex = index, overflowingHeight = verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + clientHeaderHeight, rows = [];
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= clientHeaderHeight;
    }
    let lastDataIndex, nextPageTop, offset = 0;
    while (remainingHeight > 0) {
      fakeRow.render(index, store.getAt(index), true, false, true);
      if (alignRows && remainingHeight < fakeRow.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
      } else {
        nextPageTop = lastTop;
        lastDataIndex = index;
        lastTop = fakeRow.translate(lastTop);
        remainingHeight -= fakeRow.offsetHeight;
        me.collectRow(fakeRow);
        rows.push({
          top: fakeRow.top,
          bottom: fakeRow.bottom,
          offsetHeight: fakeRow.offsetHeight,
          dataIndex: fakeRow.dataIndex
        });
        if (remainingHeight > 0) {
          exportMeta.processedRows.add(index);
        }
        if (index === finishRowIndex) {
          remainingHeight = 0;
        } else if (++index - firstRowIndex === totalRows && onlyVisibleRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      me.renderMergedCells(config, firstRowIndex, index, rows);
    }
    exportMeta.lastRowIndex = lastDataIndex;
    exportMeta.lastTop = nextPageTop;
    if (fakeRow) {
      exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows, config);
    return offset;
  }
  async buildPage(config) {
    const me = this, { exportMeta } = me, {
      client,
      headerTpl,
      footerTpl,
      enableDirectRendering
    } = config, {
      totalWidth,
      totalPages,
      currentPage,
      subGrids
    } = exportMeta;
    Object.values(subGrids).forEach((subGrid) => subGrid.rows = []);
    if (config.rowsRange === RowsRange.all) {
      exportMeta.totalHeight = client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;
      if (!enableDirectRendering) {
        exportMeta.totalHeight -= me.getVirtualScrollerHeight(client);
      }
    }
    let header, footer, offset;
    if (headerTpl) {
      header = me.prepareHTML(headerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (footerTpl) {
      footer = me.prepareHTML(footerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (enableDirectRendering) {
      offset = await me.renderRows(config);
    } else {
      offset = await me.collectRows(config);
    }
    const html = me.buildPageHtml(config);
    return { html, header, footer, offset };
  }
  async onRowsCollected() {
  }
  buildPageHtml() {
    const me = this, { subGrids } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = rows.reduce((result, row) => {
        result += row[0];
        return result;
      }, "");
      if (mergedCellsHtml == null ? void 0 : mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
};
MultiPageVerticalExporter.prototype.pagesExtractor = async function* pagesExtractor3(config) {
  const me = this, {
    exportMeta,
    stylesheets
  } = me, {
    totalWidth,
    paperWidth,
    paperHeight,
    realPaperWidth,
    realPaperHeight,
    contentHeight,
    scale,
    initialScroll
  } = exportMeta, isPrint = config.useBrowserPrint;
  let { totalPages } = exportMeta, currentPage, style;
  while ((currentPage = exportMeta.currentPage) < totalPages) {
    me.trigger("exportStep", {
      text: me.L(MultiPageVerticalExporter.exportingPageText, { currentPage, totalPages }),
      progress: Math.round((currentPage + 1) / totalPages * 90)
    });
    const { html, header, footer, offset } = await me.buildPage(config);
    style = `
            ${isPrint ? `
                        .b-page-wrap {
                            width: ${realPaperWidth}in;
                            height: ${realPaperHeight}in;
                        }
                        .b-print:not(.b-firefox) .b-export-content {
                            zoom: ${scale};
                            height: 100%;
                        }
                        .b-print.b-firefox .b-export-content {
                            transform: scale(${scale});
                            transform-origin: top left;
                            height: ${100 / scale}%;
                            width: ${100 / scale}%;
                        }
                    ` : `
                        .b-export .b-page-${currentPage}.b-export-content {
                            transform: scale(${scale});
                            transform-origin: top left;
                            height: ${100 / scale}%;
                            width: ${100 / scale}%;
                        }
                    `}
        `;
    if (config.repeatHeader) {
      const gridHeight = exportMeta.exactGridHeight ? `${exportMeta.exactGridHeight + exportMeta.currentPageTopMargin}px` : "100%";
      style = `
                ${style}
                .b-page-${currentPage} #${config.client.id} {
                    height: ${gridHeight} !important;
                    width: ${totalWidth}px !important;
                }
                .b-export-body {
                    height: 100%;
                    display: flex;
                }
                .b-export-viewport {
                    height: 100%;
                }
                .b-page-${currentPage} .b-grid-vertical-scroller {
                    margin-top: ${exportMeta.currentPageTopMargin - initialScroll}px;
                }
            `;
    } else {
      const gridHeight = exportMeta.exactGridHeight || contentHeight - exportMeta.currentPageTopMargin;
      style = `
                ${style}
                .b-page-${currentPage} #${config.client.id} {
                    height: ${gridHeight}px !important;
                    width: ${totalWidth}px !important;
                }
                .b-export-body {
                    overflow: hidden;
                }
                .b-page-${currentPage} .b-export-body .b-export-viewport {
                    margin-top: ${exportMeta.currentPageTopMargin}px;
                }
                .b-page-${currentPage} .b-grid-vertical-scroller {
                    margin-top: -${initialScroll}px;
                }
            `;
    }
    const styles = [
      ...stylesheets,
      `<style>${style}</style>`
    ];
    exportMeta.currentPageTopMargin -= contentHeight + offset;
    await me.stateNextPage(config);
    ({ totalPages } = exportMeta);
    yield {
      html: me.pageTpl({
        html,
        header,
        footer,
        styles,
        paperWidth,
        paperHeight,
        realPaperWidth,
        realPaperHeight,
        currentPage,
        isPrint
      })
    };
  }
};
MultiPageVerticalExporter._$name = "MultiPageVerticalExporter";

// lib/Grid/feature/export/exporter/SinglePageExporter.js
var SinglePageExporter = class extends Exporter {
  static get $name() {
    return "SinglePageExporter";
  }
  static get type() {
    return "singlepage";
  }
  static get title() {
    return this.localize("L{singlepage}");
  }
  static get defaultConfig() {
    return {
      /**
       * Set to true to center content horizontally on the page
       * @config {Boolean}
       */
      centerContentHorizontally: false
    };
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    Object.assign(this.exportMeta, {
      verticalPages: 1,
      horizontalPages: 1,
      totalPages: 1,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0
    });
  }
  async onRowsCollected() {
  }
  positionRows(rows, config) {
    if (config.enableDirectRendering) {
      return rows.map((r) => r[0]);
    } else {
      let currentTop = 0;
      return rows.map(([html, , height]) => {
        const result = html.replace(/translate\(\d+px, \d+px\)/, `translate(0px, ${currentTop}px)`);
        currentTop += height;
        return result;
      });
    }
  }
  async collectRows(config) {
    const me = this, { client } = config, { rowManager, store } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), { subGrids } = me.exportMeta, totalRows = config.rowsRange === RowsRange.visible && store.count ? me.getVisibleRowsCount(client) : store.count;
    let { totalHeight } = me.exportMeta, processedRows = 0, lastDataIndex = -1;
    if (rowManager.rows.length > 0) {
      if (config.rowsRange === RowsRange.visible) {
        lastDataIndex = rowManager.firstVisibleRow.dataIndex - 1;
      }
      if (hasMergeCells) {
        for (const subGrid of Object.values(subGrids)) {
          subGrid.mergedCellsHtml = [];
        }
      }
      while (processedRows < totalRows) {
        const rows = rowManager.rows, lastRow = rows[rows.length - 1], lastProcessedRowIndex = processedRows;
        rows.forEach((row) => {
          if (row.dataIndex > lastDataIndex && processedRows < totalRows) {
            ++processedRows;
            totalHeight += row.offsetHeight;
            me.collectRow(row);
          }
        });
        if (hasMergeCells) {
          for (const subGridName in subGrids) {
            const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
            for (const mergedCell of mergedCells) {
              subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
            }
          }
        }
        const firstNewRowIndex = rows.findIndex((r) => r.dataIndex === lastDataIndex + 1), lastNewRowIndex = firstNewRowIndex + (processedRows - lastProcessedRowIndex);
        await me.onRowsCollected(rows.slice(firstNewRowIndex, lastNewRowIndex), config);
        if (processedRows < totalRows) {
          lastDataIndex = lastRow.dataIndex;
          await me.scrollRowIntoView(client, lastDataIndex + 1);
        }
      }
    }
    return totalHeight;
  }
  async renderRows(config) {
    const me = this, { client, rowsRange } = config, { rowManager, store } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = rowsRange === RowsRange.visible;
    let { totalHeight } = me.exportMeta;
    if (store.count) {
      const { fakeRow } = me.exportMeta, { firstVisibleRow } = rowManager, fromIndex = onlyVisibleRows ? firstVisibleRow.dataIndex : 0, toIndex = onlyVisibleRows ? rowManager.lastVisibleRow.dataIndex : store.count - 1, rows = [];
      let top = 0;
      if (fakeRow.cells.length) {
        for (let i = fromIndex; i <= toIndex; i++) {
          fakeRow.render(i, store.getAt(i), true, false, true);
          top = fakeRow.translate(top);
          me.collectRow(fakeRow);
          rows.push({
            top: fakeRow.top,
            bottom: fakeRow.bottom,
            offsetHeight: fakeRow.offsetHeight,
            dataIndex: fakeRow.dataIndex
          });
        }
        await me.onRowsCollected(rows, config);
      }
      totalHeight += top;
      if (hasMergeCells) {
        me.renderMergedCells(config, fromIndex, toIndex, rows);
      }
    }
    return totalHeight;
  }
  buildPageHtml(config) {
    const me = this, { subGrids } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = me.positionRows(rows, config).join("");
      if (mergedCellsHtml == null ? void 0 : mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
};
SinglePageExporter.prototype.pagesExtractor = async function* pagesExtractor4(config) {
  const me = this, { client } = config, { totalWidth } = me.exportMeta, styles = me.stylesheets, portrait = config.orientation === Orientation.portrait, paperFormat = PaperFormat[config.paperFormat], isPrint = config.useBrowserPrint, paperWidth = me.getPaperWidth(paperFormat, portrait), paperHeight = me.getPaperHeight(paperFormat, portrait), realPaperWidth = me.getPaperWidth(paperFormat, portrait), realPaperHeight = me.getPaperHeight(paperFormat, portrait);
  let totalHeight, header, footer;
  if (config.enableDirectRendering) {
    totalHeight = await me.renderRows(config);
    totalHeight += client.headerHeight + client.footerHeight;
  } else {
    totalHeight = await me.collectRows(config);
    totalHeight += client.height - client.bodyHeight;
  }
  const html = me.buildPageHtml(config);
  const totalClientHeight = totalHeight;
  if (config.headerTpl) {
    header = me.prepareHTML(config.headerTpl({ totalWidth }));
    const height = me.measureElement(header);
    totalHeight += height;
  }
  if (config.footerTpl) {
    footer = me.prepareHTML(config.footerTpl({ totalWidth }));
    const height = me.measureElement(footer);
    totalHeight += height;
  }
  const widthScale = Math.min(1, me.getScaleValue(me.inchToPx(paperWidth), totalWidth)), heightScale = Math.min(1, me.getScaleValue(me.inchToPx(paperHeight), totalHeight)), scale = Math.min(widthScale, heightScale);
  styles.push(
    `<style>
                #${client.id} {
                    height: ${totalClientHeight}px !important;
                    width: ${totalWidth}px !important;
                }
                ${isPrint ? `
                            html, body {
                                overflow: hidden;
                            }
                            .b-page-wrap {
                                width: ${realPaperWidth}in;
                                height: ${realPaperHeight}in;
                            }
                            .b-print:not(.b-firefox) .b-export-content {
                                zoom: ${scale};
                                height: 100%;
                            }
                            .b-print.b-firefox .b-export-content {
                                transform: scale(${scale}) ${me.centerContentHorizontally ? "translateX(-50%)" : ""};
                                transform-origin: top left;
                                height: ${scale === 1 ? "inherit" : "auto !important"};
                            }
                            .b-export-content {
                                ${me.centerContentHorizontally ? "left: 50%;" : ""}
                            }
                        ` : `
                            .b-export-content {
                                ${me.centerContentHorizontally ? "left: 50%;" : ""}
                                transform: scale(${scale}) ${me.centerContentHorizontally ? "translateX(-50%)" : ""};
                                transform-origin: top left;
                                height: ${scale === 1 ? "inherit" : "auto !important"};
                            }
                        `}
            </style>`
  );
  yield {
    html: me.pageTpl({
      html,
      header,
      footer,
      styles,
      paperWidth,
      paperHeight,
      realPaperHeight,
      realPaperWidth,
      currentPage: 0,
      isPrint: config.useBrowserPrint
    })
  };
};
SinglePageExporter._$name = "SinglePageExporter";

// lib/Grid/feature/export/PdfExport.js
var PdfExport = class extends InstancePlugin {
  static get $name() {
    return "PdfExport";
  }
  static get configurable() {
    return {
      dialogClass: ExportDialog,
      /**
       * URL of the print server.
       * @config {String}
       */
      exportServer: void 0,
      /**
       * Returns the instantiated export dialog widget as configured by {@link #config-exportDialog}
       * @member {Grid.view.export.ExportDialog} exportDialog
       */
      /**
       * A config object to apply to the {@link Grid.view.export.ExportDialog} widget.
       * @config {ExportDialogConfig}
       */
      exportDialog: {
        value: true,
        $config: ["lazy"]
      },
      /**
       * Name of the exported file.
       * @config {String}
       * @category Export file config
       */
      fileName: null,
      /**
       * Format of the exported file, either `pdf` or `png`.
       * @config {'pdf'|'png'}
       * @default
       * @category Export file config
       */
      fileFormat: "pdf",
      /**
       * Export server will navigate to this url first and then will change page content to whatever client sent.
       * This option is useful with react dev server, which uses a strict CORS policy.
       * @config {String}
       */
      clientURL: null,
      /**
       * Export paper format. Available options are A1...A5, Legal, Letter.
       * @config {'A1'|'A2'|'A3'|'A4'|'A5'|'Legal'|'Letter'}
       * @default
       * @category Export file config
       */
      paperFormat: "A4",
      /**
       * Orientation. Options are `portrait` and `landscape`.
       * @config {'portrait'|'landscape'}
       * @default
       * @category Export file config
       */
      orientation: "portrait",
      /**
       * Specifies which rows to export. `all` for complete set of rows, `visible` for only rows currently visible.
       * @config {'all'|'visible'}
       * @category Export file config
       * @default
       */
      rowsRange: "all",
      /**
       * Set to true to align row top to the page top on every exported page. Only applied to multipage export.
       * @config {Boolean}
       * @default
       */
      alignRows: false,
      /**
       * Set to true to show column headers on every page. This will also set {@link #config-alignRows} to true.
       * Only applies to MultiPageVertical exporter.
       * @config {Boolean}
       * @default
       */
      repeatHeader: false,
      /**
       * By default, subGrid width is changed to fit all exported columns. To keep certain subGrid size specify it
       * in the following form:
       * ```javascript
       * keepRegionSizes : {
       *     locked : true
       * }
       * ```
       * @config {Object<String,Boolean>}
       * @default
       */
      keepRegionSizes: null,
      /**
       * When exporting large views (hundreds of pages) stringified HTML may exceed browser or server request
       * length limit. This config allows to specify how many pages to send to server in one request.
       * @config {Number}
       * @default
       * @private
       */
      pagesPerRequest: 0,
      /**
       * Config for exporter.
       * @config {Object}
       * @private
       */
      exporterConfig: null,
      /**
       * Type of the exporter to use. Should be one of the configured {@link #config-exporters}
       * @config {'singlepage'|'multipage'|'multipagevertical'|String}
       * @default
       */
      exporterType: "singlepage",
      /**
       * List of exporter classes to use in export feature
       * @config {Grid.feature.export.exporter.Exporter[]}
       * @default
       */
      exporters: [SinglePageExporter, MultiPageExporter, MultiPageVerticalExporter],
      /**
       * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.
       * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.
       *
       * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css
       * @config {Boolean|String}
       * @default
       */
      translateURLsToAbsolute: true,
      /**
       * When true links are converted to absolute by combining current window location (with replaced origin) with
       * resource link.
       * When false links are converted by combining new origin with resource link (for angular)
       * @config {Boolean}
       * @default
       */
      keepPathName: true,
      /**
       * When true, page will attempt to download generated file.
       * @config {Boolean}
       * @default
       */
      openAfterExport: true,
      /**
       * Set to true to receive binary file from the server instead of download link.
       * @config {Boolean}
       * @default
       */
      sendAsBinary: false,
      /**
       * False to open in the current tab, true - in a new tab
       * @config {Boolean}
       * @default
       */
      openInNewTab: false,
      /**
       * A template function used to generate a page header. It is passed an object with ´currentPage´ and `totalPages´ properties.
       *
       * ```javascript
       * let grid = new Grid({
       *     appendTo   : 'container',
       *     features : {
       *         pdfExport : {
       *             exportServer : 'http://localhost:8080/',
       *             headerTpl : ({ currentPage, totalPages }) => `
       *                 <div class="demo-export-header">
       *                     <img src="coolcorp-logo.png"/>
       *                     <dl>
       *                         <dt>Date: ${DateHelper.format(new Date(), 'll LT')}</dt>
       *                         <dd>${totalPages ? `Page: ${currentPage + 1}/${totalPages}` : ''}</dd>
       *                     </dl>
       *                 </div>`
       *          }
       *     }
       * });
       * ```
       * @config {Function}
       * @param {Object} data Data object
       * @param {Number} data.currentPage Current page number
       * @param {Number} data.totalPages Tolal pages count
       * @returns {String}
       */
      headerTpl: null,
      /**
       * A template function used to generate a page footer. It is passed an object with ´currentPage´ and `totalPages´ properties.
       *
       * ```javascript
       * let grid = new Grid({
       *      appendTo   : 'container',
       *      features : {
       *          pdfExport : {
       *              exportServer : 'http://localhost:8080/',
       *              footerTpl    : () => '<div class="demo-export-footer"><h3>© 2020 CoolCorp Inc</h3></div>'
       *          }
       *      }
       * });
       * ```
       *
       * @config {Function}
       * @param {Object} data Data object
       * @param {Number} data.currentPage Current page number
       * @param {Number} data.totalPages Tolal pages count
       * @returns {String}
       */
      footerTpl: null,
      /**
       * An object containing the Fetch options to pass to the export server request. Use this to control if
       * credentials are sent and other options, read more at
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
       * @config {FetchOptions}
       */
      fetchOptions: null,
      /**
       * A message to be shown when Export feature is performing export.
       * @config {String}
       * @default "Generating pages..."
       */
      exportMask: "L{Generating pages}",
      /**
       * A message to be shown when export is almost done.
       * @config {String}
       * @default "Waiting for response from server..."
       */
      exportProgressMask: "L{Waiting for response from server}",
      /**
       * Set to `false` to not show Toast message on export error.
       * @config {Boolean}
       * @default
       */
      showErrorToast: true,
      localizableProperties: ["exportMask", "exportProgressMask"],
      /**
       * This method accepts all stylesheets (link and style tags) which are supposed to be put on the page. Use
       * this hook method to filter or modify them.
       *
       * ```javascript
       * new Grid({
       *     features: {
       *         pdfExport: {
       *             // filter out inline styles and bootstrap.css
       *             filterStyles: styles => styles.filter(item => !/(link|bootstrap.css)/.test(item))
       *         }
       *     }
       * });
       * ```
       * @param {String[]} styles
       * @returns {String[]} List of stylesheets to put on the exported page
       */
      filterStyles: (styles) => styles,
      /**
       * Enables direct rendering of the component content which significantly improves performance. To enable
       * old export mode set this flag to false.
       * @config {Boolean}
       * @default
       */
      enableDirectRendering: true,
      /**
       * This config forces exporter to always use rendered column width. Used by Agenda view in Calendar
       * @private
       */
      useRenderedColumnWidth: false,
      /**
       * When true, export feature will use an iframe and browser's default print dialog, which allows to save
       * as PDF. Content is optimized for chrome/edge to exact page size in the specified orientation and no
       * margins. If you only see grid header or blank pages, try using different scale value in the print dialog
       * **NOTE**: Not supported in Safari. Print works, but Safari cannot seem to fit content to one page
       * correctly.
       * @config {Boolean}
       * @default
       * @private
       */
      useBrowserPrint: false,
      testConfig: {
        // Cant open export in tests
        openAfterExport: false
      }
    };
  }
  updateEnableDirectRendering(value) {
    if (!value) {
      VersionHelper.deprecate("Grid", "6.0.0", "Indirect rendering is deprecated");
    }
  }
  doDestroy() {
    var _a4;
    (_a4 = this.exportDialog) == null ? void 0 : _a4.destroy();
    this.exportersMap.forEach((exporter) => exporter.destroy());
    super.doDestroy();
  }
  /**
   * When export is started from GUI ({@link Grid.view.export.ExportDialog}), export promise can be accessed via
   * this property.
   * @property {Promise|null}
   */
  get currentExportPromise() {
    return this._currentExportPromise;
  }
  set currentExportPromise(value) {
    this._currentExportPromise = value;
  }
  get exportersMap() {
    return this._exportersMap || (this._exportersMap = /* @__PURE__ */ new Map());
  }
  getExporter(config = {}) {
    const me = this, { exportersMap } = me, { type } = config;
    let exporter;
    if (exportersMap.has(type)) {
      exporter = exportersMap.get(type);
      Object.assign(exporter, config);
    } else {
      const exporterClass = this.exporters.find((cls) => cls.type === type);
      if (!exporterClass) {
        throw new Error(`Exporter type ${type} is not found. Make sure you've configured it`);
      }
      config = ObjectHelper.clone(config);
      delete config.type;
      exporter = new exporterClass(config);
      exporter.relayAll(me);
      exportersMap.set(type, exporter);
    }
    return exporter;
  }
  buildExportConfig(config = {}) {
    const me = this, {
      client,
      exportServer,
      clientURL,
      fileFormat,
      fileName,
      paperFormat,
      rowsRange,
      alignRows,
      repeatHeader,
      keepRegionSizes,
      orientation,
      translateURLsToAbsolute,
      keepPathName,
      sendAsBinary,
      headerTpl,
      footerTpl,
      filterStyles,
      enableDirectRendering,
      useRenderedColumnWidth,
      useBrowserPrint
    } = me;
    if (!config.columns) {
      config.columns = client.columns.visibleColumns.filter((column) => column.exportable).map((column) => column.id);
    }
    const result = ObjectHelper.assign({
      client,
      exportServer,
      clientURL,
      fileFormat,
      paperFormat,
      rowsRange,
      alignRows,
      repeatHeader,
      keepRegionSizes,
      orientation,
      translateURLsToAbsolute,
      keepPathName,
      sendAsBinary,
      headerTpl,
      footerTpl,
      enableDirectRendering,
      useRenderedColumnWidth,
      useBrowserPrint,
      exporterType: me.exporterType,
      fileName: fileName || client.$$name
    }, config);
    result.columns = config.columns.slice();
    if (result.exporterType !== "multipagevertical") {
      result.repeatHeader = false;
    }
    if (!("alignRows" in config) && config.repeatHeader) {
      result.alignRows = true;
    }
    result.exporterConfig = ObjectHelper.assign({
      type: result.exporterType,
      translateURLsToAbsolute: result.translateURLsToAbsolute,
      keepPathName: result.keepPathName,
      filterStyles
    }, result.exporterConfig || {});
    delete result.exporterType;
    delete result.translateURLsToAbsolute;
    delete result.keepPathName;
    return result;
  }
  /**
   * Starts the export process. Accepts a config object which overrides any default configs.
   * **NOTE**. Component should not be interacted with when export is in progress
   *
   * @param {Object} config
   * @returns {Promise} Object of the following structure
   * ```
   * {
   *     response // Response instance
   * }
   * ```
   */
  async export(config = {}) {
    var _a4, _b;
    const me = this, {
      client,
      pagesPerRequest
    } = me;
    config = me.buildExportConfig(config);
    let result;
    if (client.trigger("beforePdfExport", { config }) !== false) {
      client.isExporting = true;
      client.mask(me.exportMask);
      try {
        const exporter = me.getExporter(config.exporterConfig);
        if (pagesPerRequest === 0) {
          const pages = await exporter.export(config);
          if (me.isDestroying) {
            return;
          }
          (_a4 = me.exportDialog) == null ? void 0 : _a4.close();
          client.unmask();
          me.trigger("exportStep", { progress: 90, text: me.exportProgressMask, contentGenerated: true });
          if (config.useBrowserPrint) {
            await me.doPrint(pages, config);
            result = {};
          } else {
            const responsePromise = me.receiveExportContent(pages, config);
            me.toast = me.showLoadingToast(responsePromise);
            const response = await responsePromise;
            result = { response };
            await me.processExportContent(response, config);
          }
        }
      } catch (error) {
        if (error instanceof Response) {
          result = { response: error };
        } else {
          result = { error };
        }
        throw error;
      } finally {
        if (me.toast && !me.toast.isDestroying) {
          me.toast.hide();
        }
        if (!me.isDestroying) {
          (_b = me.exportDialog) == null ? void 0 : _b.close();
          client.unmask();
          if (me.showErrorToast) {
            if (result.error) {
              if (result.error.name !== "AbortError") {
                Toast.show({
                  html: me.L("L{Export failed}"),
                  rootElement: me.rootElement
                });
              }
            } else if (result.response && !result.response.ok) {
              Toast.show({
                html: me.L("L{Server error}"),
                rootElement: me.rootElement
              });
            }
          }
          client.trigger("pdfExport", result);
          client.isExporting = false;
        }
      }
    }
    return result;
  }
  /**
   * Sends request to the export server and returns Response instance. This promise can be cancelled by the user
   * by clicking on the toast message. When the user clicks on the toast, `abort` method is called on the promise
   * returned by this method. If you override this method you can implement `abort` method like in the snippet
   * below to cancel the request.
   *
   * ```javascript
   * class MyPdfExport extends PdfExport {
   *     receiveExportContent(pages, config) {
   *         let controller;
   *
   *         const promise = new Promise(resolve => {
   *             controller = new AbortController();
   *             const signal = controller.signal;
   *
   *             fetch(url, { signal })
   *                 .then(response => resolve(response));
   *         });
   *
   *         // This method will be called when user clicks on the toast message to cancel the request
   *         promise.abort = () => controller.abort();
   *
   *         return promise;
   *     }
   * }
   *
   * const grid = new Grid({ features: { myPdfExport : {...} } });
   *
   * grid.features.myPdfExport.export().catch(e => {
   *     // In case of aborted request do nothing
   *     if (e.name !== 'AbortError') {
   *         // handle other exceptions
   *     }
   * });
   * ```
   * @param {Object[]} pages Array of exported pages.
   * @param {String} pages[].html pages HTML of the exported page.
   * @param {Object} config Export config
   * @param {String} config.exportServer URL of the export server.
   * @param {String} config.orientation Page orientation. portrait/landscape.
   * @param {String} config.paperFormat Paper format as supported by puppeteer. A4/A3/...
   * @param {String} config.fileFormat File format. PDF/PNG.
   * @param {String} config.fileName Name to use for the saved file.
   * @param {String} config.clientURL URL to navigate before export. See {@link #config-clientURL}.
   * @param {String} config.sendAsBinary Tells server whether to return binary file instead of download link.
   * @returns {Promise} Returns Response instance
   */
  receiveExportContent(pages, config) {
    return AjaxHelper.fetch(
      config.exportServer,
      Object.assign({
        method: "POST",
        credentials: "omit",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          html: pages,
          orientation: config.orientation,
          format: config.paperFormat,
          fileFormat: config.fileFormat,
          fileName: config.fileName,
          clientURL: config.clientURL,
          sendAsBinary: config.sendAsBinary
        })
      }, this.fetchOptions)
    );
  }
  /**
   * Handles output of the {@link #function-receiveExportContent}. Server response can be of two different types depending
   * on {@link #config-sendAsBinary} config:
   * - `application/json` In this case JSON response contains url of the file to download
   * - `application/octet-stream` In this case response contains stream of file binary data
   *
   * If {@link #config-openAfterExport} is true, this method will try to download content.
   * @param {Response} response
   * @param {Object} config Export config
   * @param {String} config.exportServer URL of the export server.
   * @param {String} config.orientation Page orientation. portrait/landscape.
   * @param {String} config.paperFormat Paper format as supported by puppeteer. A4/A3/...
   * @param {String} config.fileFormat File format. PDF/PNG.
   * @param {String} config.fileName Name to use for the saved file.
   * @param {String} config.clientURL URL to navigate before export. See {@link #config-clientURL}.
   * @param {String} config.sendAsBinary Tells server whether to return binary file instead of download link. See {@link #config-sendAsBinary}
   */
  async processExportContent(response, config) {
    const me = this;
    if (response.ok && me.openAfterExport) {
      response = response.clone();
      const contentType = response.headers.get("content-type");
      if (contentType.match(/application\/octet-stream/)) {
        const MIMEType = FileMIMEType[config.fileFormat], objectURL = await me.responseBlobToObjectURL(response, MIMEType), link = me.getDownloadLink(config.fileName, objectURL);
        link.click();
      } else if (contentType.match(/application\/json/)) {
        const responseJSON = await response.json();
        if (responseJSON.success) {
          const link = me.getDownloadLink(config.fileName, responseJSON.url);
          link.click();
        } else {
          Toast.show({
            html: responseJSON.msg,
            rootElement: this.rootElement
          });
        }
      }
    }
  }
  doPrint(pages) {
  }
  /**
   * Creates object URL from response content with given mimeType
   * @param {Response} response Response instance
   * @param {String} mimeType
   * @returns {Promise} Returns string object URL
   * @private
   */
  async responseBlobToObjectURL(response, mimeType) {
    const blob = await response.blob();
    return URL.createObjectURL(blob.slice(0, blob.size, mimeType));
  }
  /**
   * Creates link to download the file.
   * @param {String} name File name
   * @param {String} href URL of the resource
   * @returns {HTMLElement} HTMLAnchorElement
   * @private
   */
  getDownloadLink(name, href) {
    const link = document.createElement("a");
    link.download = name;
    link.href = href;
    if (this.openInNewTab) {
      link.target = "_blank";
    }
    return link;
  }
  get defaultExportDialogConfig() {
    return ObjectHelper.copyProperties({}, this, [
      "client",
      "exporters",
      "exporterType",
      "orientation",
      "fileFormat",
      "paperFormat",
      "alignRows",
      "rowsRange",
      "repeatHeader",
      "useBrowserPrint"
    ]);
  }
  changeExportDialog(exportDialog, oldExportDialog) {
    const me = this;
    oldExportDialog == null ? void 0 : oldExportDialog.destroy();
    if (exportDialog) {
      const config = me.dialogClass.mergeConfigs({
        rootElement: me.rootElement,
        client: me.client,
        modal: {
          transparent: true
        },
        items: {
          rowsRangeField: {
            value: me.rowsRange
          },
          exporterTypeField: {
            value: me.exporterType
          },
          orientationField: {
            value: me.orientation
          },
          paperFormatField: {
            value: me.paperFormat
          },
          repeatHeaderField: {
            value: me.repeatHeader
          },
          fileFormatField: {
            value: me.fileFormat
          },
          alignRowsField: {
            checked: me.alignRows
          }
        }
      }, me.defaultExportDialogConfig, exportDialog);
      exportDialog = me.dialogClass.new(config);
      exportDialog.ion({
        export: me.onExportButtonClick,
        thisObj: me
      });
    }
    return exportDialog;
  }
  /**
   * Shows {@link Grid.view.export.ExportDialog export dialog}
   */
  async showExportDialog() {
    return this.exportDialog.show();
  }
  onExportButtonClick({ values }) {
    const me = this, dialogMask = me.exportDialog.mask({
      progress: 0,
      maxProgress: 100,
      text: me.exportMask
    });
    const detacher2 = me.ion({
      exportstep({ progress, text, contentGenerated }) {
        if (contentGenerated) {
          me.exportDialog.unmask();
          detacher2();
        } else {
          dialogMask.progress = progress;
          if (text != null) {
            dialogMask.text = text;
          }
        }
      }
    });
    me.currentExportPromise = me.export(values);
    me.currentExportPromise.catch(() => {
    }).finally(() => {
      var _a4;
      detacher2();
      (_a4 = me.exportDialog) == null ? void 0 : _a4.unmask();
      me.currentExportPromise = null;
    });
  }
  showLoadingToast(exportPromise) {
    const toast = Toast.show({
      timeout: 0,
      showProgress: false,
      rootElement: this.rootElement,
      html: `
    <span class="b-mask-icon b-icon b-icon-spinner"></span>
    <span>${this.exportProgressMask}</span>
    <button class="b-button">${this.L("L{Click to abort}")}</button>`
    });
    EventHelper.on({
      element: toast.element,
      click() {
        var _a4;
        (_a4 = exportPromise.abort) == null ? void 0 : _a4.call(exportPromise);
      }
    });
    return toast;
  }
};
PdfExport._$name = "PdfExport";
GridFeatureManager.registerFeature(PdfExport, false, "Grid");

// lib/Grid/feature/export/mixin/PrintMixin.js
var PrintMixin_default = (Target) => class PrintMixin extends Target {
  static get $name() {
    return "PrintMixin";
  }
  static get configurable() {
    return {
      useBrowserPrint: true,
      exporterType: "multipagevertical"
    };
  }
  static get pluginConfig() {
    return {
      assign: ["print", "showPrintDialog"]
    };
  }
  /**
   * Shows the {@link Grid.view.export.ExportDialog print dialog}
   * @returns {Promise}
   * @on-owner
   * @catagory Print
   */
  showPrintDialog(config) {
    return this.showExportDialog(config);
  }
  /**
   * Starts the print process. Accepts a config object which overrides any default configs.
   * **NOTE** Component should not be interacted with when print is in progress
   *
   * @param {Object} config
   * @returns {Promise} Promise which resolves when printing is done. Optionally it might return an object with an
   * `error` key in it.
   * @on-owner
   * @catagory Print
   */
  print(config) {
    return this.export(config);
  }
  /**
   * This method is called when IFrame is loaded with all the HTML/CSS and is about to be printed. Use it to take
   * control over the page contents.
   * @param {HTMLIFrameElement} iframe
   */
  async onPrintIFrameLoad(iframe) {
  }
  async showBrowserPrintDialog(iframe, resolve) {
    await this.onPrintIFrameLoad(iframe);
    if (await this.client.trigger("beforeShowPrintDialog", { iframe }) !== false) {
      const { contentWindow } = iframe;
      contentWindow.onafterprint = () => {
        iframe.remove();
        resolve();
      };
      contentWindow.print();
    } else {
      iframe.remove();
      resolve();
    }
  }
  doPrint(pages) {
    const me = this;
    return new Promise((resolve, reject) => {
      const iframe = document.createElement("iframe");
      iframe.className = "b-print-wrapper";
      iframe.style.visibility = "hidden";
      iframe.style.height = "0";
      iframe.onload = () => {
        var _a4;
        const handle = iframe.contentWindow, doc2 = handle.document, { body } = doc2, parser = new DOMParser();
        let paperHeight;
        pages.forEach(({ html: html2 }) => {
          const fragment = parser.parseFromString(html2, "text/html"), node = doc2.adoptNode(fragment.body.firstChild), pageWrap = doc2.createElement("div");
          fragment.head.querySelectorAll('style,link[rel="stylesheet"],link[as="style"]').forEach((styleEl) => {
            const el = doc2.adoptNode(styleEl);
            doc2.head.appendChild(el);
          });
          pageWrap.classList.add("b-page-wrap");
          pageWrap.style.height = fragment.body.parentElement.style.height;
          pageWrap.style.width = fragment.body.parentElement.style.width;
          paperHeight = parseFloat(fragment.body.parentElement.style.height);
          body.appendChild(pageWrap);
          pageWrap.appendChild(node);
        });
        const { html } = pages[0];
        body.className = ((_a4 = html.match(/<body class="(.+?)"/)) == null ? void 0 : _a4[1]) || "";
        body.classList.add("b-print");
        body.parentElement.classList.add("b-print-root");
        body.parentElement.style.height = `${paperHeight * pages.length}in`;
        Promise.all(Array.from(doc2.head.querySelectorAll('link[rel="stylesheet"]')).map((link) => {
          return new Promise((resolve2, reject2) => {
            link.onload = resolve2;
            link.onerror = reject2;
          });
        })).then(() => doc2.fonts.ready).then(() => me.showBrowserPrintDialog(iframe, resolve)).catch((e) => {
          console.warn(`Failed to load stylesheets ${e.message ? `: ${e.message}` : ""}`);
          reject(me.L("L{PdfExport.Export failed}"));
        });
      };
      me.client.element.parentElement.appendChild(iframe);
    });
  }
};

// lib/Grid/feature/export/Print.js
var Print = class extends PrintMixin_default(PdfExport) {
};
/**
 * @hideConfigs clientURL, exportServer, fetchOptions, fileFormat, fileName, openAfterExport, openInNewTab, sendAsBinary
 */
/**
 * @hideFunctions processExportContent, receiveExportContent, showExportDialog
 */
__publicField(Print, "$name", "Print");
Print._$name = "Print";
GridFeatureManager.registerFeature(Print, false, "Grid");

// lib/Grid/util/TableExporter.js
var TableExporter = class extends Base {
  static get defaultConfig() {
    return {
      /**
       * Target grid instance to export data from
       * @config {Grid.view.Grid} target
       */
      target: null,
      /**
       * Specifies a default column width if no width specified
       * @config {Number} defaultColumnWidth
       * @default
       */
      defaultColumnWidth: 100,
      /**
       * Set to `false` to export dates as they are displayed by Date column formatter
       * @config {Boolean}
       * @default
       */
      exportDateAsInstance: true,
      /**
       * If true and the grid is grouped, shows the grouped value in the first column. True by default.
       * @config {Boolean} showGroupHeader
       * @default
       */
      showGroupHeader: true,
      /**
       * An array of column configuration objects used to specify column widths, header text, and data fields to get the data from.
       * 'field' config is required. If 'text' is missing, it will read it from the grid column or the 'field' config.
       * If 'width' is missing, it will try to get it retrieved from the grid column or {@link #config-defaultColumnWidth} config.
       * If no columns provided the config will be generated from the grid columns.
       *
       * For example:
       * ```javascript
       * columns : [
       *     'firstName', // field
       *     'age', // field
       *     { text : 'Starts', field : 'start', width : 140 },
       *     { text : 'Ends', field : 'finish', width : 140 }
       * ]
       * ```
       *
       * @config {String[]|Object[]} columns
       * @default
       */
      columns: null,
      /**
       * When true and tree is being exported, node names are indented with {@link #config-indentationSymbol}
       * @config {Boolean}
       * @default
       */
      indent: true,
      /**
       * This symbol (four spaces by default) is used to indent node names when {@link #config-indent} is true
       * @config {String}
       * @default
       */
      indentationSymbol: "\xA0\xA0\xA0\xA0"
    };
  }
  /**
   * Exports grid data according to provided config
   * @param {Object} config
   * @returns {{ rows : Object[][], columns : Object[] }}
   */
  export(config = {}) {
    const me = this;
    config = ObjectHelper.assign({}, me.config, config);
    me.normalizeColumns(config);
    return me.generateExportData(config);
  }
  generateExportData(config) {
    const me = this, columns = me.generateColumns(config), rows = me.generateRows(config);
    return { rows, columns };
  }
  normalizeColumns(config) {
    const columns = config.columns || this.target.columns.visibleColumns.filter((rec) => rec.exportable !== false);
    config.columns = columns.map((col) => {
      if (typeof col === "string") {
        return this.target.columns.find((column) => column.field === col) || { field: col };
      } else {
        return col;
      }
    });
  }
  generateColumns(config) {
    return config.columns.map((col) => this.processColumn(col, config));
  }
  generateRows(config) {
    const { columns, rows } = config;
    if (columns.length === 0 || (rows == null ? void 0 : rows.length) === 0) {
      return [];
    }
    const me = this, { target } = me;
    return (rows || target.store).map((record) => me.processRecord(record, columns, config)).filter((cells) => cells == null ? void 0 : cells.length);
  }
  getColumnType(column, store = this.target.store) {
    let result = column.exportedType || "object";
    if (column.exportedType === void 0) {
      if (column.field) {
        const fieldDefinition = store.modelClass.getFieldDefinition(column.field);
        if (fieldDefinition && fieldDefinition.type !== "auto") {
          result = fieldDefinition.type;
        }
      }
    }
    return result;
  }
  /**
   * Extracts export data from the column instance
   * @param {Grid.column.Column} column
   * @param {Object} config
   * @private
   * @returns {Object}
   */
  processColumn(column, config) {
    const me = this, { target } = me, { defaultColumnWidth } = config;
    let { field, text: value, width, minWidth } = column;
    if (!(field in target.store.modelClass.fieldMap)) {
      field = "";
    }
    if (!value || !width) {
      const gridColumn = target.columns.find((col) => col.field === field);
      if (!value) {
        value = gridColumn && (gridColumn.text || gridColumn.headerRenderer && gridColumn.textElement.innerText) || field;
      }
      if (width == null) {
        width = gridColumn && gridColumn.width || defaultColumnWidth;
      }
    }
    width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);
    return { field, value, width, type: me.getColumnType(column) };
  }
  /**
   * Extracts export data from the record instance reading supplied column configs
   * @param {Core.data.Model|null} record If null is passed, all columns will be filled with empty strings
   * @param {Grid.column.Column[]} columns
   * @param {Object} config
   * @private
   * @returns {Object[]}
   */
  processRecord(record, columns, config) {
    const { target } = this, {
      showGroupHeader,
      indent,
      indentationSymbol
    } = config;
    let cells;
    if (!record) {
      cells = columns.map(() => "");
    } else if (record.isSpecialRow) {
      if (showGroupHeader && record.meta.groupRowFor) {
        cells = columns.map((column) => {
          return target.features.group.buildGroupHeader({
            // Create dummy element to get html from
            cellElement: DomHelper.createElement(),
            grid: target,
            record,
            column
          });
        });
      }
    } else {
      cells = columns.map((column) => {
        let value = record.getValue(column.field);
        const useRenderer = column.externalRenderer || column.renderer;
        if (useRenderer && !(value && column.isDateColumn && config.exportDateAsInstance)) {
          value = useRenderer.call(column, {
            value,
            record,
            column,
            grid: target,
            isExport: true
          });
        }
        if (indent && column.tree) {
          value = `${indentationSymbol.repeat(record.childLevel)}${value}`;
        }
        return value;
      });
    }
    return cells;
  }
};
TableExporter._$name = "TableExporter";

// lib/Grid/util/BooleanUnicodeSymbol.js
var BooleanUnicodeSymbol = class {
  constructor(value) {
    this._value = value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return Boolean(this.value) ? "\u2713" : "";
  }
};
BooleanUnicodeSymbol._$name = "BooleanUnicodeSymbol";

// lib/Grid/feature/experimental/ExcelExporter.js
var ExcelExporter = class extends InstancePlugin {
  static get $name() {
    return "ExcelExporter";
  }
  static get defaultConfig() {
    return {
      /**
       * Name of the exported file
       * @config {String} filename
       * @default
       */
      filename: null,
      /**
       * Defines how dates in a cell will be formatted
       * @config {String} dateFormat
       * @default
       */
      dateFormat: "YYYY-MM-DD",
      /**
       * Exporter class to use as a data provider. {@link Grid.util.TableExporter} by default.
       * @config {Grid.util.TableExporter}
       * @typings {typeof TableExporter}
       * @default
       */
      exporterClass: TableExporter,
      /**
       * Configuration object for {@link #config-exporterClass exporter class}.
       * @config {Object}
       */
      exporterConfig: null,
      /**
       * Reference to zipcelx library. If not provided, exporter will look in the global scope.
       * @config {Object}
       */
      zipcelx: null,
      /**
       * If this config is true, exporter will convert all empty values to ''. Empty values are:
       * * undefined, null, NaN
       * * Objects/class instances that do not have toString method defined and are stringified to [object Object]
       * * functions
       * @config {Boolean}
       */
      convertEmptyValueToEmptyString: true
    };
  }
  processValue(value) {
    if (value === void 0 || value === null || Number.isNaN(value) || typeof value === "function" || typeof value === "object" && String(value) === "[object Object]") {
      return "";
    } else {
      return value;
    }
  }
  generateExportData(config) {
    const me = this, { rows, columns } = me.exporter.export(config.exporterConfig);
    return {
      rows: rows.map((row) => {
        return row.map((value, index) => {
          var _a4;
          if (value instanceof Date) {
            value = DateHelper.format(value, config.dateFormat);
          } else if (typeof value === "boolean") {
            value = new BooleanUnicodeSymbol(value);
          }
          if (me.convertEmptyValueToEmptyString) {
            value = me.processValue(value);
          }
          const type = ((_a4 = columns[index]) == null ? void 0 : _a4.type) === "number" ? "number" : "string";
          return { value, type };
        });
      }),
      columns: columns.map((col) => {
        let { field, value, width, type } = col;
        type = "string";
        return { field, value, width, type };
      })
    };
  }
  /**
   * Generate and download an Excel (.xlsx), or CSV file (.csv).
   * @param {Object} config Optional configuration object, which overrides initial settings of the feature/exporter.
   * @param {String} [config.filename] Name of the exported file
   * @param {String} [config.dateFormat] Defines how dates in a cell will be formatted
   * @param {Boolean|Object} [config.csv] Set to true to output as a CSV file, or as an object where you can specify
   * delimiters.
   * @param {String} [config.csv.columnDelimiter] The CSV delimiter to separate values on one line, defaults to `,`.
   * @param {String} [config.csv.lineDelimiter] The CSV delimiter to separate lines, defaults to `\n`.
   * @param {String[]|Object[]} [config.columns] An array of column configuration objects
   * @param {Core.data.Model[]} [config.rows] An array of records to export
   * @returns {Promise} Promise that resolves when the export is completed
   */
  export(config = {}) {
    const me = this, zipcelx2 = me.zipcelx || globalThis.zipcelx;
    if (!zipcelx2) {
      throw new Error('ExcelExporter: "zipcelx" library is required');
    }
    if (me.disabled) {
      return;
    }
    config = ObjectHelper.assign({}, me.config, config);
    if (!config.filename) {
      config.filename = me.client.$$name;
    }
    const { filename } = config, { rows, columns } = me.generateExportData(config);
    if (config.csv) {
      const columnDelimiter = config.csv.columnDelimiter || ",", lineDelimiter = config.csv.lineDelimiter || "\n", headers = columns.map((col) => this.processCsvValue(col.value)).join(columnDelimiter) + lineDelimiter, text = rows.map((rowValues) => rowValues.map((obj) => this.processCsvValue(obj.value)).join(`${columnDelimiter}`)).join(lineDelimiter), bom = new Uint8Array([239, 187, 191]), blob = new Blob([bom, headers + text], { type: "text/csv" });
      BrowserHelper.downloadBlob(blob, filename);
      return Promise.resolve();
    }
    return zipcelx2({
      filename,
      sheet: {
        data: [columns].concat(rows),
        cols: columns
      }
    });
  }
  processCsvValue(text = "") {
    return `"${String(text).replace(/"/g, '""')}"`;
  }
  construct(grid, config) {
    super.construct(grid, config);
    if (!this.zipcelx) {
      if (typeof zipcelx !== "undefined") {
        this.zipcelx = globalThis.zipcelx;
      }
    }
  }
  get exporter() {
    const me = this;
    return me._exporter || (me._exporter = me.exporterClass.new({ target: me.client }, me.exporterConfig));
  }
};
ExcelExporter._$name = "ExcelExporter";
GridFeatureManager.registerFeature(ExcelExporter, false, "Grid");

// lib/Grid/feature/experimental/FileDrop.js
var FileDrop = class extends InstancePlugin {
  construct(client, config) {
    const me = this;
    super.construct(client, config);
    EventHelper.on({
      element: client.element,
      thisObj: me,
      drop: me.onFileDrop,
      dragover: me.onFileDragOver,
      dragenter: me.onFileDragEnter,
      dragleave: me.onFileDragLeave
    });
  }
  onFileLoad(domEvent) {
    this.client.trigger("fileDrop", {
      file: this.file,
      domEvent
    });
  }
  onFileDragEnter() {
    this.client.element.classList.add("b-dragging-file");
  }
  onFileDragOver(event) {
    event.preventDefault();
  }
  onFileDragLeave(event) {
    const { element } = this.client;
    if (event.relatedTarget && !element.contains(event.relatedTarget)) {
      this.client.element.classList.remove("b-dragging-file");
    }
  }
  onFileDrop(domEvent) {
    domEvent.preventDefault();
    const file = domEvent.dataTransfer.items[0].getAsFile();
    this.client.trigger("fileDrop", { file, domEvent });
    this.onFileDragLeave(domEvent);
  }
};
__publicField(FileDrop, "$name", "FileDrop");
FileDrop._$name = "FileDrop";
GridFeatureManager.registerFeature(FileDrop, false, "Grid");

// lib/Grid/row/Row.js
var cellContentRange = document.createRange();
var Row = class extends Base {
  static get configurable() {
    return {
      /**
       * When __read__, this a {@link Core.helper.util.DomClassList} of class names to be
       * applied to this Row's elements.
       *
       * It can be __set__ using Object notation where each property name with a truthy value is added as
       * a class, or as a regular space-separated string.
       *
       * @member {Core.helper.util.DomClassList} cls
       * @accepts {Core.helper.util.DomClassList|Object<String,Boolean|Number>}
       */
      /**
       * The class name to initially add to all row elements
       * @config {String|Core.helper.util.DomClassList|Object<String,Boolean|Number>}
       */
      cls: {
        $config: {
          equal: (c1, c2) => (c1 == null ? void 0 : c1.isDomClassList) && (c2 == null ? void 0 : c2.isDomClassList) && c1.isEqual(c2)
        }
      }
    };
  }
  //region Init
  /**
   * Constructs a Row setting its index.
   * @param {Object} config A configuration object which must contain the following two properties:
   * @param {Grid.view.Grid} config.grid The owning Grid.
   * @param {Grid.row.RowManager} config.rowManager The owning RowManager.
   * @param {Number} config.index The index of the row within the RowManager's cache.
   * @function constructor
   * @internal
   */
  construct(config) {
    Object.assign(this, {
      _elements: {},
      _elementsArray: [],
      _cells: {},
      _allCells: [],
      _regions: [],
      lastHeight: 0,
      lastTop: -1,
      _dataIndex: 0,
      _top: 0,
      _height: 0,
      _id: null,
      forceInnerHTML: false,
      isGroupFooter: false,
      // Create our cell rendering context
      cellContext: new Location({
        grid: config.grid,
        id: null,
        columnIndex: 0
      })
    });
    super.construct(config);
    if (this.grid.positionMode === "position") {
      this.translateElements = this.positionElements;
    }
  }
  doDestroy() {
    const me = this;
    if (!me.rowManager.isDestroying) {
      me.removeElements();
      if (me.rowManager.idMap[me.id] === me) {
        delete me.rowManager.idMap[me.id];
      }
    }
    super.doDestroy();
  }
  //endregion
  //region Data getters/setters
  /**
   * Get index in RowManagers rows array
   * @property {Number}
   * @readonly
   */
  get index() {
    return this._index;
  }
  set index(index) {
    this._index = index;
  }
  /**
   * Get/set this rows current index in grids store
   * @property {Number}
   */
  get dataIndex() {
    return this._dataIndex;
  }
  set dataIndex(dataIndex) {
    if (this._dataIndex !== dataIndex) {
      this._dataIndex = dataIndex;
      this.eachElement((element) => {
        element.dataset.index = dataIndex;
        element.ariaRowIndex = this.grid.hideHeaders ? dataIndex + 1 : dataIndex + 2;
      });
    }
  }
  /**
   * Get/set id for currently rendered record
   * @property {String|Number}
   */
  get id() {
    return this._id;
  }
  set id(id) {
    const me = this, idObj = { id }, idMap = me.rowManager.idMap;
    if (me._id !== id || idMap[id] !== me) {
      if (idMap[me._id] === me)
        delete idMap[me._id];
      idMap[id] = me;
      me._id = id;
      me.eachElement((element) => {
        DomDataStore.assign(element, idObj);
        element.dataset.id = id;
      });
      me.eachCell((cell) => DomDataStore.assign(cell, idObj));
    }
  }
  //endregion
  //region Row elements
  /**
   * Add a row element for specified region.
   * @param {String} region Region to add element for
   * @param {HTMLElement} element Element
   * @private
   */
  addElement(region, element) {
    const me = this, { dataIndex } = me;
    let cellElement = element.firstElementChild;
    me._elements[region] = element;
    me._elementsArray.push(element);
    me._regions.push(region);
    DomDataStore.assign(element, { index: me.index });
    me._cells[region] = [];
    while (cellElement) {
      me._cells[region].push(cellElement);
      me._allCells.push(cellElement);
      DomDataStore.set(cellElement, {
        column: cellElement.dataset.column,
        columnId: cellElement.dataset.columnId,
        rowElement: cellElement.parentNode,
        row: me
      });
      cellElement = cellElement.nextElementSibling;
    }
    element.dataset.index = dataIndex;
    element.ariaRowIndex = me.grid.hideHeaders ? dataIndex + 1 : dataIndex + 2;
    if (me.top !== null) {
      me.translateElements(true);
    }
  }
  /**
   * Get the element for the specified region.
   * @param {String} region
   * @returns {HTMLElement}
   */
  getElement(region) {
    return this._elements[region];
  }
  /**
   * Get the {@link Core.helper.util.Rectangle element bounds} for the specified region of this Row.
   * @param {String} region
   * @returns {Core.helper.util.Rectangle}
   */
  getRectangle(region) {
    return Rectangle.from(this.getElement(region));
  }
  /**
   * Execute supplied function for each regions element.
   * @param {Function} fn
   */
  eachElement(fn) {
    this._elementsArray.forEach(fn);
  }
  /**
   * Execute supplied function for each cell.
   * @param {Function} fn
   */
  eachCell(fn) {
    this._allCells.forEach(fn);
  }
  /**
   * An object, keyed by region name (for example `locked` and `normal`) containing the elements which comprise the full row.
   * @type {Object<String,HTMLElement>}
   * @readonly
   */
  get elements() {
    return this._elements;
  }
  /**
   * The row element, only applicable when not using multiple grid sections (see {@link #property-elements})
   * @type {HTMLElement}
   * @readonly
   */
  get element() {
    const region = Object.keys(this._elements)[0];
    return this._elements[region];
  }
  //endregion
  //region Cell elements
  /**
   * Row cell elements
   * @property {HTMLElement[]}
   * @readonly
   */
  get cells() {
    return this._allCells;
  }
  /**
   * Get cell elements for specified region.
   * @param {String} region Region to get elements for
   * @returns {HTMLElement[]} Array of cell elements
   */
  getCells(region) {
    return this._cells[region];
  }
  /**
   * Get the cell element for the specified column.
   * @param {String|Number} columnId Column id
   * @returns {HTMLElement} Cell element
   */
  getCell(columnId, strict = false) {
    return this._allCells.find((cell) => {
      const cellData = DomDataStore.get(cell);
      return cellData.columnId == columnId || !strict && cellData.column == columnId;
    });
  }
  removeElements(onlyRelease = false) {
    const me = this;
    me.rowManager.trigger("removeRow", { row: me });
    if (!onlyRelease) {
      me.eachElement((element) => element.remove());
    }
    me._elements = {};
    me._cells = {};
    me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;
    me.lastTop = -1;
  }
  //endregion
  //region Height
  /**
   * Get/set row height
   * @property {Number}
   */
  get height() {
    return this._height;
  }
  set height(height) {
    this._height = height;
  }
  /**
   * Get row height including border
   * @property {Number}
   */
  get offsetHeight() {
    return this.height + this.grid._rowBorderHeight;
  }
  /**
   * Sync elements height to rows height
   * @private
   */
  updateElementsHeight(isExport) {
    const me = this;
    if (!isExport) {
      me.rowManager.storeKnownHeight(me.id, me.height);
    }
    if (me.lastHeight !== me.height) {
      this.eachElement((element) => element.style.height = `${me.offsetHeight}px`);
      me.lastHeight = me.height;
    }
  }
  //endregion
  //region CSS
  /**
   * Add CSS classes to each element.
   * @param {...String|Object<String,Boolean|Number>|Core.helper.util.DomClassList} classes
   */
  addCls(classes) {
    this.updateCls(this.cls.add(classes));
  }
  /**
   * Remove CSS classes from each element.
   * @param {...String|Object<String,Boolean|Number>|Core.helper.util.DomClassList} classes
   */
  removeCls(classes) {
    this.updateCls(this.cls.remove(classes));
  }
  /**
   * Toggle CSS classes for each element.
   * @param {Object<String,Boolean|Number>|Core.helper.util.DomClassList|...String} classes
   * @param {Boolean} add
   */
  toggleCls(classes, add) {
    this.updateCls(this.cls[add ? "add" : "remove"](classes));
  }
  /**
   * Adds/removes class names according to the passed object's properties.
   *
   * Properties with truthy values are added.
   * Properties with false values are removed.
   * @param {Object<String,Boolean|Number>} classes Object containing properties to set/clear
   */
  assignCls(classes) {
    this.updateCls(this.cls.assign(classes));
  }
  changeCls(cls) {
    return new DomClassList(cls);
  }
  updateCls(cls) {
    this.eachElement((element) => DomHelper.syncClassList(element, cls));
  }
  setAttribute(attribute, value) {
    this.eachElement((element) => element.setAttribute(attribute, value));
  }
  removeAttribute(attribute) {
    this.eachElement((element) => element.removeAttribute(attribute));
  }
  //endregion
  //region Position
  /**
   * Is this the very first row?
   * @property {Boolean}
   * @readonly
   */
  get isFirst() {
    return this.dataIndex === 0;
  }
  /**
   * Row top coordinate
   * @property {Number}
   * @readonly
   */
  get top() {
    return this._top;
  }
  /**
   * Row bottom coordinate
   * @property {Number}
   * @readonly
   */
  get bottom() {
    return this._top + this._height + this.grid._rowBorderHeight;
  }
  /**
   * Sets top coordinate, translating elements position.
   * @param {Number} top Top coordinate
   * @param {Boolean} [silent] Specify `true` to not trigger translation event
   * @internal
   */
  setTop(top, silent) {
    if (this._top !== top) {
      this._top = top;
      this.translateElements(silent);
    }
  }
  /**
   * Sets bottom coordinate, translating elements position.
   * @param {Number} bottom Bottom coordinate
   * @param {Boolean} [silent] Specify `true` to not trigger translation event
   * @private
   */
  setBottom(bottom, silent) {
    this.setTop(bottom - this.offsetHeight, silent);
  }
  // Used by export feature to position individual row
  translate(top, silent = false) {
    this.setTop(top, silent);
    return top + this.offsetHeight;
  }
  /**
   * Sets css transform to position elements at correct top position (translateY)
   * @private
   */
  translateElements(silent) {
    const me = this, { top, _elementsArray } = me;
    if (me.lastTop !== top) {
      for (let i = 0, { length } = _elementsArray; i < length; i++) {
        _elementsArray[i].style.transform = `translate(0,${top}px)`;
      }
      !silent && me.rowManager.trigger("translateRow", { row: me });
      me.lastTop = top;
    }
  }
  /**
   * Sets css top to position elements at correct top position
   * @private
   */
  positionElements(silent) {
    const me = this, { top, _elementsArray } = me;
    if (me.lastTop !== top) {
      for (let i = 0, { length } = _elementsArray; i < length; i++) {
        _elementsArray[i].style.top = `${top}px`;
      }
      !silent && me.rowManager.trigger("translateRow", { row: me });
      me.lastTop = top;
    }
  }
  /**
   * Moves all row elements up or down and updates model.
   * @param {Number} offsetTop Pixels to offset the elements
   * @private
   */
  offset(offsetTop) {
    let newTop = this._top + offsetTop;
    if (newTop < 0) {
      offsetTop -= newTop;
      newTop = 0;
    }
    this.setTop(newTop);
    return offsetTop;
  }
  //endregion
  //region Render
  /**
   * Renders a record into this row´s elements (trigger event that subgrids catch to do the actual rendering).
   * @param {Number} recordIndex
   * @param {Core.data.Model} record
   * @param {Boolean} [updatingSingleRow]
   * @param {Boolean} [batch]
   * @private
   */
  render(recordIndex, record, updatingSingleRow = true, batch = false, isExport = false) {
    var _a4, _b, _c;
    const me = this, {
      cellContext,
      cls,
      elements,
      grid,
      rowManager,
      height: oldHeight,
      _id: oldId
    } = me, rowElData = DomDataStore.get(me._elementsArray[0]), rowHeight = rowManager._rowHeight, { store } = grid, { isTree } = store;
    let i = 0, size;
    if (!record && record !== false) {
      record = grid.store.getById(rowElData.id);
      recordIndex = grid.store.indexOf(record);
    }
    if (!record) {
      return;
    }
    const rCls = record == null ? void 0 : record.cls, recordCls = rCls ? rCls.isDomClassList ? rCls : new DomClassList(rCls) : null;
    cls.assign({
      // do not put updating class if we're exporting the row
      "b-grid-row-updating": updatingSingleRow && grid.transitionDuration && !isExport,
      "b-selected": grid.isSelected(record == null ? void 0 : record.id),
      "b-readonly": record.readOnly,
      "b-linked": record.isLinked,
      "b-original": record.hasLinks
    });
    if (me.lastRecordCls) {
      cls.remove(me.lastRecordCls);
    }
    if (recordCls) {
      cls.add(recordCls);
      me.lastRecordCls = Object.assign({}, recordCls);
    } else {
      me.lastRecordCls = null;
    }
    rowManager.trigger("beforeRenderRow", { row: me, record, recordIndex, oldId });
    grid.beforeRenderRow({ row: me, record, recordIndex, oldId, cls });
    me.updateCls(cls);
    if (updatingSingleRow && grid.transitionDuration && !isExport) {
      grid.setTimeout(() => {
        if (!me.isDestroyed) {
          cls.remove("b-grid-row-updating");
          me.updateCls(cls);
        }
      }, grid.transitionDuration + 50);
    }
    me.id = record.id;
    me.dataIndex = recordIndex;
    const height = !grid.fixedRowHeight && grid.getRowHeight(record) || rowHeight;
    let maxRequestedHeight = me.maxRequestedHeight = null;
    if (isTree) {
      for (const region in elements) {
        const el = elements[region];
        el.id = `${grid.id}-${region}-${me.id}`;
        DomHelper.setAttributes(el, {
          "aria-level": record.childLevel + 1,
          "aria-setsize": record.parent.children.length,
          "aria-posinset": record.parentIndex + 1
        });
        if (record.isExpanded(store)) {
          DomHelper.setAttributes(el, {
            "aria-expanded": true,
            // A branch node may be configured expanded, but yet have no children.
            // They may be added dynamically.
            "aria-owns": ((_a4 = record.children) == null ? void 0 : _a4.length) ? (_b = record.children) == null ? void 0 : _b.map((r) => `${grid.id}-${region}-${r.id}`).join(" ") : null
          });
        } else {
          if (record.isLeaf) {
            el.removeAttribute("aria-expanded");
          } else {
            el.setAttribute("aria-expanded", false);
          }
          el.removeAttribute("aria-owns");
        }
      }
    }
    cellContext._record = record;
    cellContext._id = record.id;
    cellContext._rowIndex = recordIndex;
    for (i = 0; i < grid.columns.visibleColumns.length; i++) {
      const column = grid.columns.visibleColumns[i];
      cellContext._columnId = column.id;
      cellContext._column = column;
      cellContext._columnIndex = i;
      cellContext._cell = me.getCell(column.id, true);
      cellContext.height = height;
      cellContext.maxRequestedHeight = maxRequestedHeight;
      cellContext.updatingSingleRow = updatingSingleRow;
      size = me.renderCell(cellContext);
      if (!rowManager.fixedRowHeight) {
        if (size.height != null) {
          maxRequestedHeight = Math.max(maxRequestedHeight, size.height);
          if (!size.transient) {
            me.maxRequestedHeight = maxRequestedHeight;
          }
        }
      }
    }
    const useHeight = maxRequestedHeight != null ? maxRequestedHeight : height;
    me.height = (_c = grid.processRowHeight(record, useHeight)) != null ? _c : useHeight;
    me.updateElementsHeight(isExport);
    if (updatingSingleRow && !isExport) {
      if (oldHeight !== me.height) {
        rowManager.translateFromRow(me, batch);
      }
      rowManager.trigger("updateRow", { row: me, record, recordIndex, oldId });
      rowManager.trigger("renderDone");
    }
    grid.afterRenderRow({ row: me, record, recordIndex, oldId, oldHeight, isExport });
    rowManager.trigger("renderRow", { row: me, record, recordIndex, oldId, isExport });
    if (oldHeight && me.height !== oldHeight) {
      rowManager.trigger("rowRowHeight", { row: me, record, height: me.height, oldHeight });
    }
    me.forceInnerHTML = false;
  }
  /**
   * Renders a single cell, calling features to allow them to hook
   * @param {Grid.util.Location|HTMLElement} cellContext A {@link Grid.util.Location} which contains rendering
   * options, or a cell element which can be used to initialize a {@link Grid.util.Location}
   * @param {Number} [cellContext.height] Configured row height
   * @param {Number} [cellContext.maxRequestedHeight] Maximum proposed row height from renderers
   * @param {Boolean} [cellContext.updatingSingleRow] Rendered as part of updating a single row
   * @param {Boolean} [cellContext.isMeasuring] Rendered as part of a measuring operation
   * @internal
   */
  renderCell(cellContext) {
    var _a4, _b, _c, _d;
    if (!cellContext.isLocation) {
      cellContext = new Location(cellContext);
    }
    let {
      cell: cellElement,
      record
    } = cellContext;
    const me = this, {
      grid,
      column,
      height,
      maxRequestedHeight,
      updatingSingleRow = true,
      isMeasuring = false
    } = cellContext, cellEdit = (_a4 = grid.features) == null ? void 0 : _a4.cellEdit, cellElementData = DomDataStore.get(cellElement), rowElement = cellElementData.rowElement, rowElementData = DomDataStore.get(rowElement);
    if (!record) {
      record = cellContext._record = grid.store.getById(rowElementData.id);
      if (!record) {
        return;
      }
    }
    let cellContent = column.getRawValue(record);
    const dataField = record.fieldMap[column.field], size = { configuredHeight: height, height: null, maxRequestedHeight }, cellCls = column.getCellClass(cellContext), rendererData = {
      cellElement,
      dataField,
      rowElement,
      value: cellContent,
      record,
      column,
      size,
      grid,
      row: cellElementData.row,
      updatingSingleRow,
      isMeasuring
    }, useRenderer = column.renderer;
    grid.beforeRenderCell(rendererData);
    if (rendererData.cellElement !== cellElement) {
      cellElement = rendererData.cellElement;
    }
    DomHelper.syncClassList(cellElement, cellCls);
    let shouldSetContent = true;
    if (useRenderer) {
      cellContent = column.callback(useRenderer, column, [rendererData]);
      if (column.externalRenderer) {
        const externalRendererResult = column.callback(column.externalRenderer, column, [rendererData]);
        if (externalRendererResult != null) {
          cellContent = externalRendererResult;
        }
      }
      if (cellContent === void 0) {
        if (record.generatedParent && column.rendererReturningContent) {
          cellContent = "";
        } else if (column.alwaysClearCell === false) {
          shouldSetContent = false;
        }
      }
    } else if (dataField) {
      cellContent = dataField.print(cellContent);
    }
    const hasFrameworkRenderer = (_b = grid.hasFrameworkRenderer) == null ? void 0 : _b.call(grid, { cellContent, column });
    if (hasFrameworkRenderer && record.isSpecialRow) {
      cellContent = "";
    }
    const frameworkPerformsFullRendering = hasFrameworkRenderer && !column.data.tree && !record.isSpecialRow;
    if (shouldSetContent && !frameworkPerformsFullRendering) {
      let renderTarget = cellElement;
      if (((_c = cellEdit == null ? void 0 : cellEdit.editorContext) == null ? void 0 : _c.equals(cellContext)) && !cellEdit.editor.isFinishing) {
        renderTarget = me.moveContentFromCell(cellElement, cellEdit.editor.element);
      }
      const hasObjectContent = cellContent != null && typeof cellContent === "object", hasStringContent = typeof cellContent === "string", text = hasObjectContent || cellContent == null ? "" : String(cellContent);
      if (me.forceInnerHTML) {
        renderTarget.innerHTML = "";
        delete renderTarget._content;
        cellElement.lastDomConfig = null;
      }
      if (!hasObjectContent && column.htmlEncode && !column.disableHtmlEncode) {
        if (cellElement._hasHtml) {
          renderTarget.innerText = text;
          cellElement._hasHtml = false;
        } else {
          DomHelper.setInnerText(renderTarget, text);
        }
      } else {
        if (column.autoSyncHtml && (!hasStringContent || DomHelper.getChildElementCount(renderTarget))) {
          if (hasStringContent) {
            DomHelper.sync(text, renderTarget.firstElementChild);
          } else if (hasObjectContent) {
            DomSync.sync({
              domConfig: cellContent,
              targetElement: renderTarget
            });
          }
        } else if (hasObjectContent) {
          DomSync.sync({
            targetElement: renderTarget,
            domConfig: {
              onlyChildren: true,
              children: ArrayHelper.asArray(cellContent)
            }
          });
        } else if (renderTarget._content !== text) {
          renderTarget.innerHTML = renderTarget._content = text;
        }
      }
      if (renderTarget !== cellElement) {
        const { firstChild } = cellElement;
        for (const node of [...renderTarget.childNodes]) {
          cellElement.insertBefore(node, firstChild);
        }
      }
    }
    if (!record.isSpecialRow) {
      (_d = grid.processCellContent) == null ? void 0 : _d.call(grid, {
        cellElementData,
        rendererData,
        // In case of TreeColumn we should prerender inner cell content like expand controls, bullets, etc
        // Then the framework renders the content into the nested "b-tree-cell-value" element.
        // rendererHtml is set in TreeColumn.treeRenderer
        rendererHtml: rendererData.rendererHtml || cellContent
      });
    }
    if (column.autoHeight && size.height == null) {
      cellElement.classList.add("b-measuring-auto-height");
      size.height = Math.max(cellElement.offsetHeight, grid.rowHeight);
      cellElement.classList.remove("b-measuring-auto-height");
    }
    if (!isMeasuring) {
      me.rowManager.trigger("renderCell", rendererData);
    }
    return size;
  }
  //#region Hooks for salesforce
  moveContentFromCell(cellElement, editorElement) {
    cellContentRange.setStart(cellElement, 0);
    cellContentRange.setEndBefore(editorElement);
    const renderTarget = document.createElement("div");
    renderTarget.appendChild(cellContentRange.extractContents());
    return renderTarget;
  }
  //#endregion
  //endregion
};
__publicField(Row, "$name", "Row");
Row.initClass();
Row._$name = "Row";

// lib/Grid/view/Bar.js
var Bar = class extends Widget {
  static get $name() {
    return "Bar";
  }
  // Factoryable type name
  static get type() {
    return "gridbar";
  }
  static get defaultConfig() {
    return {
      htmlCls: "",
      scrollable: {
        overflowX: "hidden-scroll"
      }
    };
  }
  //region Init
  get columns() {
    return this._columns || this.subGrid.columns;
  }
  // Only needed for tests which create standalone Headers with no owning SubGrid.
  set columns(columns) {
    this._columns = columns;
  }
  //endregion
  /**
   * Fix cell widths (flex or fixed width) after rendering.
   * Not a part of template any longer because of CSP
   * @private
   */
  fixCellWidths() {
    const me = this, { hasFlex: hasFlex2 } = me.columns;
    let flexBasis;
    me.columns.traverse((column) => {
      const cellEl = me.getBarCellElement(column.id), domWidth = DomHelper.setLength(column.width), domMinWidth = DomHelper.setLength(column.minWidth), domMaxWidth = DomHelper.setLength(column.maxWidth);
      if (cellEl) {
        flexBasis = domWidth;
        cellEl.style.maxWidth = domMaxWidth;
        if (column.isParent && column.width == null && column.flex == null) {
          const flex = column.children.reduce((result, child) => result += !child.hidden && child.flex || 0, 0);
          cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : "";
          cellEl.style.minWidth = null;
          if (flex > 0) {
            column.traverse((col) => col.data.minWidth = null);
          }
        } else {
          if (parseInt(column.minWidth) >= 0) {
            cellEl.style.minWidth = domMinWidth;
          }
          cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = "";
          if (column.flex) {
            if (!isNaN(parseInt(column.flex)) && column.children) {
              cellEl.style.flex = `${column.flex} 0 auto`;
            } else {
              cellEl.style.flex = column.flex;
            }
          } else if (parseInt(column.width) >= 0) {
            const parent = column.parent;
            if (me.isHeader && !parent.isRoot && !parent.width) {
              cellEl.style.width = domWidth;
            } else {
              cellEl.style.flexBasis = flexBasis;
            }
          }
        }
        if (column.height >= 0) {
          cellEl.style.height = DomHelper.setLength(column.height);
        }
      }
    });
    me.scrollable.element.classList.toggle("b-has-flex", hasFlex2);
  }
  getLrPadding(cellEl) {
    if (!this.cellLrPadding) {
      const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);
      this.cellLrPadding = parseInt(s.getPropertyValue("padding-left")) + parseInt(s.getPropertyValue("padding-right")) + parseInt(s.getPropertyValue("border-left-width")) + parseInt(s.getPropertyValue("border-right-width"));
    }
    return this.cellLrPadding;
  }
  /**
   * Get the header or footer cell element for the specified column.
   * @param {String} columnId Column id
   * @returns {HTMLElement} Header or footer element, depending on which subclass is in use.
   * @private
   */
  getBarCellElement(columnId) {
    return this.element.querySelector(`[data-column-id="${columnId}"]`);
  }
};
Bar.initClass();
Bar._$name = "Bar";

// lib/Grid/view/Footer.js
var Footer = class extends Bar {
  static get $name() {
    return "Footer";
  }
  // Factoryable type name
  static get type() {
    return "gridfooter";
  }
  get subGrid() {
    return this._subGrid;
  }
  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }
  refreshContent() {
    this.element.firstElementChild.innerHTML = this.contentTemplate();
    this.fixFooterWidths();
  }
  onInternalPaint({ firstPaint }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }
  template() {
    const region = this.subGrid.region;
    return TemplateHelper.tpl`
            <div class="b-grid-footer-scroller b-grid-footer-scroller-${region}" role="presentation">
                <div data-reference="footersElement" class="b-grid-footers b-grid-footers-${region}" data-region="${region}" role="presentation"></div>
            </div>
        `;
  }
  get overflowElement() {
    return this.footersElement;
  }
  //region Getters
  /**
   * Get the footer cell element for the specified column.
   * @param {String} columnId Column id
   * @returns {HTMLElement} Footer cell element
   */
  getFooter(columnId) {
    return this.getBarCellElement(columnId);
  }
  //endregion
  /**
   * Footer template. Iterates leaf columns to create content.
   * Style not included because of CSP. Widths are fixed up in
   * {@link #function-fixFooterWidths}
   * @private
   */
  contentTemplate() {
    const me = this;
    return me.columns.visibleColumns.map((column) => {
      return TemplateHelper.tpl`
                <div
                    class="b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ""} ${column.cls || ""}"
                    data-column="${column.field || ""}" data-column-id="${column.id}" data-all-index="${column.allIndex}"
                    role="presentation">
                    ${column.footerText || ""}
                </div>`;
    }).join("");
  }
  /**
   * Fix footer widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP
   * @private
   */
  fixFooterWidths() {
    this.fixCellWidths();
  }
};
Footer.initClass();
Footer._$name = "Footer";

// lib/Grid/row/RowManager.js
var cloneRowEl = (el) => {
  const p = el.parentElement, result = el.cloneNode(true);
  result.classList.add("b-removing");
  p.insertBefore(result, el);
  return result;
};
var nodeAnimationCleanup;
var nodeAnimationCleanupListener;
var RowManager = class extends InstancePlugin {
  //region Config
  // Plugin configuration.
  static get pluginConfig() {
    return {
      chain: [
        "destroy"
      ],
      assign: [
        "topRow",
        "bottomRow",
        "firstVisibleRow",
        "lastVisibleRow",
        "firstFullyVisibleRow",
        "lastFullyVisibleRow",
        "getRowById",
        "getRecordCoords",
        "getRow",
        "getRowFor",
        "getRowFromElement"
      ]
    };
  }
  static get defaultConfig() {
    return {
      rowClass: Row,
      /**
       * Number of rows to render above current viewport
       * @config {Number}
       * @default
       */
      prependRowBuffer: 5,
      /**
       * Number of rows to render below current viewport
       * @config {Number}
       * @default
       */
      appendRowBuffer: 5,
      /**
       * Default row height, assigned from Grid at construction (either from config
       * {@link Grid.view.Grid#config-rowHeight} or CSS). Can be set from renderers
       * @config {Number}
       * @default
       */
      rowHeight: null,
      /**
       * Set to `true` to get a small performance boost in applications that uses fixed row height
       * @config {Boolean}
       */
      fixedRowHeight: null,
      autoHeight: false
    };
  }
  static get properties() {
    return {
      idMap: {},
      topIndex: 0,
      lastScrollTop: 0,
      _rows: [],
      // Record id -> row height mapping
      heightMap: /* @__PURE__ */ new Map(),
      // Sum of entries in heightMap
      totalKnownHeight: 0,
      // Will be calculated in `estimateTotalHeight()`, as totalKnownHeight + an estimate for unknown rows
      _totalHeight: 0,
      // Average of the known heights, kept up to date when entries in the heightMap are updated
      averageRowHeight: 0,
      scrollTargetRecordId: null,
      refreshDetails: {
        topRowIndex: 0,
        topRowTop: 0
      }
    };
  }
  //endregion
  //region Init
  construct(config) {
    config.grid._rowManager = this;
    super.construct(config.grid, config);
  }
  // Chained to client grid's doDestroy
  doDestroy() {
    this.removeAllRows();
    super.doDestroy();
  }
  /**
   * Initializes the RowManager with Rows to fit specified height.
   * @param {Number} height
   * @param {Boolean} [isRendering]
   * @private
   * @category Init
   */
  initWithHeight(height, isRendering = false) {
    const me = this;
    if (me.autoHeight) {
      height = me.store.allCount * me.preciseRowOffsetHeight;
    }
    me.viewHeight = height;
    me.calculateRowCount(isRendering);
    return height;
  }
  /**
   * Releases all elements (not from dom), calculates how many are needed, creates those and renders
   */
  reinitialize(returnToTop = false) {
    const me = this;
    me.calculateRowCount(false, true, true);
    if (me.topIndex + me.rowCount - 1 > me.store.count) {
      returnToTop = true;
    }
    if (returnToTop) {
      me.topIndex = me.lastScrollTop = 0;
    }
    me.scrollTargetRecordId = null;
    const { topRow } = me;
    if (topRow) {
      topRow.dataIndex = me.topIndex;
      topRow.setTop(me.calculateTop(me.topIndex), true);
    }
    me.estimateTotalHeight();
    me.renderFromRow(topRow);
  }
  //endregion
  //region Rows
  /**
   * Add or remove rows to fit row count
   * @private
   * @category Rows
   */
  matchRowCount(skipRender = false) {
    var _a4;
    const me = this, { rows, grid, rowClass } = me, numRows = rows.length, delta = numRows - me.rowCount;
    if (delta) {
      if (delta < 0) {
        const newRows = [];
        for (let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0; index < me.rowCount; index++, dataIndex++) {
          newRows.push(rowClass.new({
            cls: grid.rowCls,
            rowManager: me,
            grid,
            index,
            dataIndex
          }));
        }
        rows.push.apply(rows, newRows);
        me.trigger("addRows", { rows: newRows });
        if (!skipRender) {
          me.renderFromRow(rows[Math.max(0, numRows - 1)]);
        }
      } else {
        const activeCell = (_a4 = DomHelper.getActiveElement(grid)) == null ? void 0 : _a4.closest(".b-grid-cell"), removedRows = rows.splice(numRows - delta, delta);
        if (numRows !== delta && removedRows.some((row) => row.cells.includes(activeCell))) {
          rows[rows.length - 1].cells[grid.focusedCell.columnIndex].focus();
        }
        me.trigger("removeRows", { rows: removedRows });
        removedRows.forEach((row) => row.destroy());
        !skipRender && rows.length && me.fillBelow(me.lastScrollTop);
      }
    }
  }
  /**
   * Calculates how many rows fit in the available height (view height)
   * @private
   * @category Rows
   */
  calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {
    var _a4, _b;
    const me = this, { store } = me, visibleRowCount = Math.ceil(me.viewHeight / me.minRowOffsetHeight), maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;
    if (!((_a4 = me.grid.columns) == null ? void 0 : _a4.count) || isNaN(visibleRowCount)) {
      me.rowCount = 0;
      return 0;
    }
    if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) {
      return me.rowCount;
    }
    me.visibleRowCount = visibleRowCount;
    me.rowCount = Math.min(store.count, maxRenderRowCount);
    if (!skipMatchRowCount) {
      if (me.rows && me.rowCount !== me.rows.length) {
        me.matchRowCount(skipRender);
        if (((_b = me.bottomRow) == null ? void 0 : _b.dataIndex) >= store.count && me.topRow.dataIndex !== 0) {
          const indexDelta = me.bottomRow.dataIndex - store.count + 1;
          for (const row of me.rows) {
            row.dataIndex -= indexDelta;
          }
          me.topIndex -= indexDelta;
        }
      } else if (!me.rowCount) {
        me.trigger("changeTotalHeight", { totalHeight: me.totalHeight });
      }
      me.grid.toggleEmptyText();
    }
    return me.rowCount;
  }
  /**
   * Animate adding or removing rows to/from the rows array.
   * @internal
   * @param {Number} index The index at which to insert or remove
   * @param {Number} count The number of rows to add. May be negative to remove.
   */
  insert(index, count) {
    var _a4, _b, _c, _d, _e;
    nodeAnimationCleanup == null ? void 0 : nodeAnimationCleanup();
    const me = this, {
      rows,
      rowCount,
      rowClass,
      grid
    } = me, { element } = grid, { rowCls } = grid, newRowDataIndex = ((_a4 = rows[index - 1]) == null ? void 0 : _a4.dataIndex) + 1 || 0, addedRows = [], durationMS = DateHelper.as("ms", DomHelper.getStyleValue(grid.element, "--row-splice-duration")), visibleRowsBelow = me.lastVisibleRow.index + 1 - index;
    let needsPrune;
    if (count < 0) {
      count = Math.abs(count);
      const visualRemoveCount = newRowDataIndex >= grid.store.count ? count : Math.min(count, visibleRowsBelow), visuallyRemovedRows = rows.slice(index, index + visualRemoveCount), visuallyRemovedHeight = visualRemoveCount ? visuallyRemovedRows[visuallyRemovedRows.length - 1].bottom - visuallyRemovedRows[0].top : 0, outgoingElements = [], outgoingRows = [], repositioningRows = [];
      for (let i = 0, { length } = visuallyRemovedRows; i < length; i++) {
        const outgoingEls = visuallyRemovedRows[i]._elementsArray.map(cloneRowEl);
        outgoingRows.push(rowClass.new({
          rowManager: me,
          _elementsArray: outgoingEls,
          grid
        }));
        outgoingElements.push(...outgoingEls);
      }
      for (let i = index; i < rowCount; i++) {
        repositioningRows.push(rows[i]);
        rows[i].addCls("b-repositioning");
        rows[i].setTop(rows[i].top + visuallyRemovedHeight);
      }
      needsPrune = rows.length > grid.store.count;
      (_b = outgoingElements[0]) == null ? void 0 : _b.getBoundingClientRect();
      element.classList.add("b-splicing-rows");
      for (let i = 0, { length } = visuallyRemovedRows; i < length; i++) {
        outgoingRows[i].setTop(((_c = rows[index - 1]) == null ? void 0 : _c.bottom) || 0, true);
      }
      nodeAnimationCleanup = () => {
        if (nodeAnimationCleanupListener && !me.isDestroyed) {
          nodeAnimationCleanupListener = nodeAnimationCleanupListener();
          nodeAnimationCleanup = null;
          element.classList.remove("b-splicing-rows");
          outgoingElements.forEach((e) => e.remove());
          repositioningRows.forEach((e) => {
            var _a5;
            return (_a5 = e.removeCls) == null ? void 0 : _a5.call(e, "b-repositioning");
          });
        }
      };
    } else if (count > 0) {
      const repositioningRows = [];
      count = me.grid.hasVerticalOverflow ? Math.min(count, me.lastVisibleRow.index + 1 - index) : Math.min(count, Math.ceil((me.grid.scrollable.clientHeight - (((_d = rows[index - 1]) == null ? void 0 : _d.bottom) || 0)) / me.rowHeight));
      let newIndex = index, dataIndex = newRowDataIndex;
      for (let i = 0; i < count; i++, newIndex++, dataIndex++) {
        addedRows.push(rowClass.new({
          cls: `${rowCls} b-adding`,
          rowManager: me,
          _top: ((_e = rows[index - 1]) == null ? void 0 : _e.bottom) || 0,
          grid,
          index: newIndex,
          dataIndex
        }));
      }
      for (let i = index; i < me.rowCount; i++, newIndex++, dataIndex++) {
        repositioningRows.push(rows[i]);
        rows[i].addCls("b-repositioning");
        rows[i].index = newIndex;
        rows[i].dataIndex = dataIndex;
      }
      needsPrune = addedRows.length;
      nodeAnimationCleanup = () => {
        if (nodeAnimationCleanupListener && !me.isDestroyed) {
          nodeAnimationCleanupListener = nodeAnimationCleanupListener();
          nodeAnimationCleanup = null;
          element.classList.remove("b-splicing-rows");
          addedRows.forEach((r) => !r.isDestroyed && r.removeCls("b-adding"));
          repositioningRows.forEach((e) => {
            var _a5;
            return (_a5 = e.removeCls) == null ? void 0 : _a5.call(e, "b-repositioning");
          });
        }
      };
      rows.splice(index, 0, ...addedRows);
      if (count > 0) {
        me.rowCount += count;
        me.trigger("addRows", { rows: addedRows });
      }
      element.classList.add("b-splicing-rows");
    }
    nodeAnimationCleanupListener = EventHelper.on({
      element: grid.element,
      animationcancel: nodeAnimationCleanup,
      transitioncancel: nodeAnimationCleanup,
      once: true,
      expires: {
        delay: durationMS,
        alt: nodeAnimationCleanup
      }
    });
    me.renderFromRow(rows[index], true);
    if (needsPrune) {
      me.calculateRowCount(false, true, true);
    }
    me.estimateTotalHeight();
    return addedRows;
  }
  removeAllRows() {
    const me = this, { topRow } = me, result = topRow ? me.refreshDetails = {
      topRowIndex: topRow.dataIndex,
      topRowTop: topRow.top
    } : me.refreshDetails, removedRows = me.rows.slice();
    me.trigger("removeRows", { rows: removedRows });
    me.rows.forEach((row) => row.destroy());
    me.rows.length = 0;
    me.idMap = {};
    return result;
  }
  setPosition(refreshDetails) {
    const { topRow } = this, { topRowIndex, topRowTop } = refreshDetails;
    if (topRow) {
      topRow.setTop(topRowTop);
      topRow.dataIndex = topRowIndex;
    }
  }
  //endregion
  //region Rows - Getters
  get store() {
    return this.client.store;
  }
  /**
   * Get all Rows
   * @property {Grid.row.Row[]}
   * @readonly
   * @category Rows
   */
  get rows() {
    return this._rows;
  }
  /**
   * Get the Row at a specified store index. Returns `undefined` if the row index is not rendered.
   * @param {Number} index
   * @returns {Grid.row.Row|undefined}
   * @category Rows
   */
  getRow(index) {
    if (this.rowCount) {
      return this.rows[index - this.topIndex];
    }
  }
  /**
   * Get Row for specified record id
   * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)
   * @returns {Grid.row.Row|null} Found Row or null if record not rendered
   * @category Rows
   */
  getRowById(recordOrId) {
    if (recordOrId && recordOrId.isModel) {
      recordOrId = recordOrId.id;
    }
    return this.idMap[recordOrId];
  }
  /**
   * Get a Row from an HTMLElement
   * @param {HTMLElement} element
   * @returns {Grid.row.Row|null} Found Row or null if record not rendered
   * @category Rows
   */
  getRowFromElement(element) {
    element = element.closest(".b-grid-row");
    return element && this.getRow(element.dataset.index);
  }
  /**
   * Get the row at the specified Y coordinate, which is by default viewport-based.
   * @param {Number} y The `Y` coordinate to find the Row for.
   * @param {Boolean} [local=false] Pass `true` if the `Y` coordinate is local to the SubGrid's element.
   * @returns {Grid.row.Row} Found Row or null if no row is rendered at that point.
   */
  getRowAt(y, local = false) {
    if (!local) {
      y -= Rectangle.from(this.grid.bodyContainer, null, true).roundPx(1).top;
      y += this.grid.scrollable.y;
    }
    y = DomHelper.roundPx(y);
    return this.rows.find((r) => y >= r.top && y < r.bottom);
  }
  /**
   * Get a Row for either a record, a record id or an HTMLElement
   * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   */
  getRowFor(recordOrId) {
    if (recordOrId instanceof HTMLElement) {
      return this.getRowFromElement(recordOrId);
    }
    return this.getRowById(recordOrId);
  }
  /**
   * Gets the Row following the specified Row (by index or object). Wraps around the end.
   * @param {Number|Grid.row.Row} indexOrRow index or Row
   * @returns {Grid.row.Row}
   * @category Rows
   */
  getNextRow(indexOrRow) {
    const index = typeof indexOrRow === "number" ? indexOrRow : indexOrRow.index;
    return this.getRow((index + 1) % this.rowCount);
  }
  /**
   * Get the Row that is currently displayed at top.
   * @property {Grid.row.Row}
   * @readonly
   * @category Rows
   */
  get topRow() {
    return this.rows[0];
  }
  /**
   * Get the Row currently displayed furthest down.
   * @property {Grid.row.Row}
   * @readonly
   * @category Rows
   */
  get bottomRow() {
    const rowCount = Math.min(this.rowCount, this.store.count);
    return this.rows[rowCount - 1];
  }
  /**
   * Get the topmost visible Row
   * @property {Grid.row.Row}
   * @readonly
   * @category Rows
   */
  get firstVisibleRow() {
    return this.rows.find((r) => r.bottom > Math.ceil(this.grid.scrollable.y));
  }
  get firstFullyVisibleRow() {
    return this.rows.find((r) => r.top >= Math.ceil(this.grid.scrollable.y));
  }
  /**
   * Get the last visible Row
   * @property {Grid.row.Row}
   * @readonly
   * @category Rows
   */
  get lastVisibleRow() {
    const { grid } = this;
    return ArrayHelper.findLast(this.rows, (r) => r.top < grid.scrollable.y + grid.bodyHeight);
  }
  get lastFullyVisibleRow() {
    const { grid } = this;
    return ArrayHelper.findLast(this.rows, (r) => r.bottom < grid.scrollable.y + grid.bodyHeight);
  }
  /**
   * Calls offset() for each Row passing along offset parameter
   * @param {Number} offset Pixels to translate Row elements.
   * @private
   * @category Rows
   */
  offsetRows(offset) {
    if (offset !== 0) {
      const { rows } = this, { length } = rows;
      for (let i = 0; i < length; i++) {
        rows[i].offset(offset);
      }
    }
    this.trigger("offsetRows", { offset });
  }
  //endregion
  //region Row height
  get prependBufferHeight() {
    return this.prependRowBuffer * this.rowOffsetHeight;
  }
  get appendBufferHeight() {
    return this.appendRowBuffer * this.rowOffsetHeight;
  }
  /**
   * Set a fixed row height (can still be overridden by renderers) or get configured row height. Setting refreshes all rows
   * @type {Number}
   * @on-owner
   * @category Rows
   */
  get rowHeight() {
    return this._rowHeight;
  }
  set rowHeight(height) {
    const me = this, { grid, fixedRowHeight } = me, oldHeight = me.rowHeight;
    if (oldHeight === height) {
      return;
    }
    ObjectHelper.assertNumber(height, "rowHeight");
    if (height < 10) {
      height = 10;
    }
    me.trigger("beforeRowHeight", { height });
    me.minRowHeight = me._rowHeight = height;
    if (fixedRowHeight) {
      me.averageRowHeight = height;
    }
    if (me.rows.length) {
      const oldY = grid.scrollable.y, topRow = me.getRowAt(oldY, true), edgeOffset = topRow ? topRow.top - oldY : 0;
      let average, oldAverage;
      if (fixedRowHeight) {
        average = height;
        oldAverage = oldHeight;
      } else {
        oldAverage = average = me.averageRowHeight;
        me.clearKnownHeights();
        average *= height / oldHeight;
      }
      me.calculateRowCount(false, true, true);
      me.topRow.setTop(me.topRow.dataIndex * (average + grid._rowBorderHeight), true);
      me.refresh();
      const newY = oldY * (average / oldAverage);
      if (newY !== oldY) {
        grid.scrollRowIntoView(topRow.id, {
          block: "start",
          edgeOffset
        });
      }
    }
    me.trigger("rowHeight", { height, oldHeight });
  }
  /**
   * Get actually used row height, which includes any border and might be an average if using variable row height.
   * @property {Number}
   */
  get rowOffsetHeight() {
    return Math.floor(this.preciseRowOffsetHeight);
  }
  get preciseRowOffsetHeight() {
    return (this.averageRowHeight || this._rowHeight) + this.grid._rowBorderHeight;
  }
  get minRowOffsetHeight() {
    return (this.minRowHeight || this._rowHeight) + this.grid._rowBorderHeight;
  }
  /*
  * How store CRUD affects the height map:
  *
  * | Operation | Result                            |
  * |-----------|-----------------------------------|
  * | add       | No. Appears on render             |
  * | insert    | No. Appears on render             |
  * | remove    | Remove entry                      |
  * | removeAll | Clear                             |
  * | update    | No                                |
  * | replace   | Height might differ, remove entry |
  * | move      | No                                |
  * | filter    | No                                |
  * | sort      | No                                |
  * | group     | No                                |
  * | dataset   | Clear                             |
  *
  * The above is handled in GridBase
  */
  /**
   * Returns `true` if all rows have a known height. They do if all rows are visited, or if RowManager is configured
   * with `fixedRowHeight`. If so, all tops can be calculated exactly, no guessing needed
   * @property {Boolean}
   * @private
   */
  get allHeightsKnown() {
    return this.fixedRowHeight || this.heightMap.size >= this.store.count;
  }
  /**
   * Store supplied `height` using `id` as key in the height map. Called by `Row` when it gets its height.
   * Keeps `averageRowHeight` and `totalKnownHeight` up to date. Ignored when configured with `fixedRowHeight`
   * @param {String|Number} id
   * @param {Number} height
   * @internal
   */
  storeKnownHeight(id, height) {
    const me = this, { heightMap } = me;
    if (!me.fixedRowHeight) {
      if (heightMap.has(id)) {
        me.totalKnownHeight -= heightMap.get(id);
      }
      heightMap.set(id, height);
      me.totalKnownHeight += height;
      if (height < me.minRowHeight) {
        me.minRowHeight = height;
      }
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }
  /**
   * Get the known or estimated offset height for the specified record id
   * @param {Core.data.Model} record
   * @returns {Number}
   * @private
   */
  getOffsetHeight(record) {
    const me = this;
    return (record && me.heightMap.get(record.id) || record && me.grid.getRowHeight(record) || me.averageRowHeight || me.rowHeight) + me.grid._rowBorderHeight;
  }
  /**
   * Invalidate cached height for a record. Removing it from `totalKnownHeight` and factoring it out of
   * `averageRowHeight`.
   * @param {Core.data.Model|Core.data.Model[]} records
   */
  invalidateKnownHeight(records) {
    const me = this;
    if (!me.fixedRowHeight) {
      const { heightMap } = me;
      records = ArrayHelper.asArray(records);
      records.forEach((record) => {
        if (record) {
          if (heightMap.has(record.id)) {
            me.totalKnownHeight -= heightMap.get(record.id);
            heightMap.delete(record.id);
          }
        }
      });
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }
  /**
   * Invalidates all cached height and resets `averageRowHeight` and `totalKnownHeight`
   */
  clearKnownHeights() {
    this.heightMap.clear();
    this.averageRowHeight = this.totalKnownHeight = 0;
  }
  /**
   * Calculates a row top from its data index. Uses known values from the height map, unknown are substituted with
   * the average row height. When configured with `fixedRowHeight`, it will always calculate a correct value
   * @param {Number} index Index in store
   * @private
   */
  calculateTop(index) {
    if (this.fixedRowHeight) {
      return index * this.rowOffsetHeight;
    }
    const { store } = this;
    let top = 0;
    for (let i = 0; i < index; i++) {
      const record = store.getAt(i);
      top += this.getOffsetHeight(record);
    }
    return Math.floor(top);
  }
  //endregion
  //region Calculations
  /**
   * Returns top and bottom for rendered row or estimated coordinates for unrendered.
   * @param {Core.data.Model|String|Number} recordOrId Record or record id
   * @param {Boolean} [local] Pass true to get relative record coordinates
   * @param {Boolean} [roughly] Pass true to allow a less exact but cheaper estimate
   * @returns {Core.helper.util.Rectangle} Record bounds with format { x, y, width, height, bottom, right }
   * @category Calculations
   */
  getRecordCoords(recordOrId, local = false, roughly = false) {
    const me = this, row = me.getRowById(recordOrId);
    let scrollingViewport = me.client._bodyRectangle;
    if (!local) {
      scrollingViewport = me.client.refreshBodyRectangle();
    }
    if (row) {
      return new Rectangle(
        scrollingViewport.x,
        local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y),
        scrollingViewport.width,
        row.offsetHeight
      );
    }
    return me.getRecordCoordsByIndex(me.store.indexOf(recordOrId), local, roughly);
  }
  /**
   * Returns top and bottom coordinates for specified row. If all heights are known, by for example using fixed row
   * height, the top is calculated exactly. If not, the top is estimated based on the closest known row.
   *
   * @param {Number} recordIndex Record index
   * @param {Boolean} [local]
   * @returns {Core.helper.util.Rectangle} Estimated record bounds
   * @category Calculations
   */
  getRecordCoordsByIndex(recordIndex, local = false, roughly = false) {
    var _a4;
    const me = this, { topRow, bottomRow } = me, scrollingViewport = me.client._bodyRectangle, { id } = me.store.getAt(recordIndex), height = me.preciseRowOffsetHeight, currentTopIndex = topRow.dataIndex, currentBottomIndex = bottomRow.dataIndex, maybeKnownHeight = Math.floor((_a4 = me.heightMap.get(id)) != null ? _a4 : height);
    let recordY;
    if (me.allHeightsKnown && !roughly) {
      const top = me.calculateTop(recordIndex);
      recordY = local ? top : top + scrollingViewport.y - me.client.scrollable.y;
    } else {
      const calculateFrom = (
        // bottomRow is closest, calculate from it
        recordIndex > currentBottomIndex ? { index: recordIndex - currentBottomIndex - 1, y: bottomRow.bottom, from: "bottomRow" } : recordIndex > currentTopIndex / 2 ? { index: recordIndex - currentTopIndex, y: topRow.top, from: "topRow" } : { index: recordIndex, y: 0, from: "top" }
      ), top = Math.floor(calculateFrom.y + calculateFrom.index * height);
      recordY = local ? calculateFrom.from === "topRow" ? top + height - maybeKnownHeight : top : top + scrollingViewport.y - me.client.scrollable.y;
    }
    const result = new Rectangle(scrollingViewport.x, recordY, scrollingViewport.width, maybeKnownHeight);
    result.virtual = true;
    result.block = result.bottom < scrollingViewport.y ? "start" : result.y > scrollingViewport.bottom ? "end" : "nearest";
    return result;
  }
  /**
   * Total estimated grid height (used for scroller)
   * @property {Number}
   * @readonly
   * @category Calculations
   */
  get totalHeight() {
    return this._totalHeight;
  }
  //endregion
  //region Iteration etc.
  /**
   * Calls a function for each Row
   * @param {Function} fn Function that will be called with Row as first parameter
   * @category Iteration
   */
  forEach(fn) {
    this.rows.forEach(fn);
  }
  /**
   * Iterator that allows you to do for (let row of rowManager)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.rows[Symbol.iterator]();
  }
  //endregion
  //region Scrolling & rendering
  /**
   * Refresh a single cell.
   * @param {Core.data.Model} record Record for row holding the cell that should be updated
   * @param {String|Number} columnId Column id to identify the cell within the row
   * @returns {Boolean} Returns `true` if cell was found and refreshed, `false` if not
   */
  refreshCell(record, columnId) {
    const cellContext = new Location({ grid: this.grid, record, columnId });
    return Boolean(cellContext.cell && cellContext.row.renderCell(cellContext));
  }
  /**
   * Renders from the top of the grid, also resetting scroll to top. Used for example when collapsing all groups.
   * @category Scrolling & rendering
   */
  returnToTop() {
    const me = this;
    me.topIndex = 0;
    me.lastScrollTop = 0;
    if (me.topRow) {
      me.topRow.dataIndex = 0;
      me.topRow.setTop(0, true);
    }
    me.refresh();
    me.grid.scrollable.y = 0;
  }
  /**
   * Renders from specified records row and down (used for example when collapsing a group, does not affect rows above).
   * @param {Core.data.Model} record Record of first row to render
   * @category Scrolling & rendering
   */
  renderFromRecord(record) {
    const row = this.getRowById(record.id);
    if (row) {
      this.renderFromRow(row);
    }
  }
  /**
   * Renders from specified row and down (used for example when collapsing a group, does not affect rows above).
   * @param {Grid.row.Row} fromRow First row to render
   * @category Scrolling & rendering
   */
  renderFromRow(fromRow = null, animatingRowPosition) {
    const me = this, {
      rows,
      store,
      topIndex,
      topRow
    } = me, storeCount = store.count;
    let fromRowIndex = fromRow ? rows.indexOf(fromRow) : 0;
    if (me.calculateRowCount(false, storeCount < rows.length && !animatingRowPosition, true) === 0 || fromRowIndex >= rows.length) {
      me.estimateTotalHeight(true);
      return;
    }
    if (me.topIndex < topIndex) {
      me.topRow.setTop(me.calculateTop(me.topIndex), true);
      fromRowIndex = 0;
      fromRow = me.topRow;
    } else if (fromRow && rows.indexOf(fromRow) < 0) {
      fromRow = rows[fromRowIndex] || topRow;
    }
    let dataIndex = fromRow ? fromRow.dataIndex : rows[0].dataIndex;
    const recordsAfter = storeCount - dataIndex - 1, toRowIndex = Math.min(rows.length - 1, fromRowIndex + recordsAfter);
    let leftOverCount = rows.length - toRowIndex - 1, top = fromRowIndex > 0 ? rows[fromRowIndex - 1].bottom : rows[fromRowIndex].top, row;
    const newTops = [];
    for (let i = fromRowIndex; i <= toRowIndex; i++) {
      row = rows[i];
      row.dataIndex = dataIndex;
      if (animatingRowPosition) {
        newTops[i] = top;
      } else {
        row.setTop(top, true);
      }
      row.render(dataIndex, store.getAt(dataIndex++), false);
      top += row.offsetHeight;
    }
    if (animatingRowPosition) {
      rows[fromRowIndex].element.getBoundingClientRect();
      for (let i = fromRowIndex; i <= toRowIndex; i++) {
        rows[i].setTop(newTops[i], true);
      }
    }
    while (leftOverCount-- > 0) {
      me.displayRecordAtTop();
    }
    if (me.bottomRow.bottom < me.viewHeight) {
      me.calculateRowCount();
    }
    me.estimateTotalHeight(true);
    me.trigger("renderDone");
  }
  /**
   * Renders the passed array (or [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)) of {@link Grid.row.Row rows}
   * @param {Grid.row.Row[]|Set} rows The rows to render
   * @category Scrolling & rendering
   */
  renderRows(rows) {
    let oldHeight, heightChanged = false;
    rows = Array.from(rows);
    rows.sort((a, b) => a.dataIndex - b.dataIndex);
    for (const row of rows) {
      oldHeight = row.height;
      row.render(null, null, false);
      heightChanged |= row.height !== oldHeight;
    }
    if (heightChanged) {
      this.translateFromRow(rows[0]);
    }
    this.trigger("renderDone");
  }
  /**
   * Translates all rows after the specified row. Used when a single rows height is changed and the others should
   * rearrange. (Called from Row#render)
   * @param {Grid.row.Row} fromRow
   * @private
   * @category Scrolling & rendering
   */
  translateFromRow(fromRow, batch = false) {
    const me = this;
    let top = fromRow.bottom, row, index;
    for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {
      top = row.translate(top);
    }
    if (!batch) {
      me.estimateTotalHeight(true);
    }
  }
  /**
   * Rerender all rows
   * @category Scrolling & rendering
   * @privateparam {Boolean} force Force re-rendering even if there are no rows currently
   */
  refresh(force = false) {
    const me = this, { topRow } = me;
    if (!topRow && !force || me.grid.refreshSuspended) {
      return;
    }
    me.idMap = {};
    me.renderFromRow(topRow);
    me.trigger("refresh");
  }
  /**
   * Makes sure that specified record is displayed in view
   * @param newScrollTop Top of visible section
   * @param [forceRecordIndex] Index of record to display at center
   * @private
   * @category Scrolling & rendering
   */
  jumpToPosition(newScrollTop, forceRecordIndex) {
    const me = this, { store, heightMap } = me, storeCount = store.count;
    if (me.allHeightsKnown && !me.fixedRowHeight) {
      const top = newScrollTop - me.prependBufferHeight, border = me.grid._rowBorderHeight;
      let accumulated = 0, targetIndex = 0;
      while (accumulated < top) {
        const record = store.getAt(targetIndex);
        accumulated += heightMap.get(record.id) + border;
        targetIndex++;
      }
      const startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(me.calculateTop(startIndex), false);
      me.refresh();
    } else {
      const rowHeight = me.preciseRowOffsetHeight, targetIndex = forceRecordIndex == null ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer : forceRecordIndex - Math.floor(me.rowCount / 2), startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0), viewportTop = me.client.scrollable.y, viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(Math.floor(startIndex * rowHeight), false);
      me.refresh();
      if (me.bottomRow.bottom < viewportBottom) {
        me.calculateRowCount(false, false, false);
        while (me.bottomRow.bottom < viewportBottom && me._rows[me.prependRowBuffer].top < viewportTop && me.bottomRow.dataIndex < storeCount - 1) {
          me.displayRecordAtBottom();
        }
      }
      me.estimateTotalHeight();
    }
    if (forceRecordIndex != null) {
      const { scrollable } = me.grid, targetRow = me.getRow(forceRecordIndex), rowCenter = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y, viewportCenter = scrollable.viewport.center.y;
      if (targetRow) {
        scrollable.y = newScrollTop = Math.floor(scrollable.y + (rowCenter - viewportCenter));
      }
    }
    return newScrollTop;
  }
  /**
   * Jumps to a position if it is far enough from current position. Otherwise does nothing.
   * @private
   * @category Scrolling & rendering
   */
  warpIfNeeded(newScrollTop) {
    const me = this, result = { newScrollTop, deltaTop: newScrollTop - me.lastScrollTop };
    if (Math.abs(result.deltaTop) > me.rowCount * me.rowOffsetHeight * 3) {
      let index;
      if (me.scrollTargetRecordId) {
        index = me.store.indexOf(me.scrollTargetRecordId);
      }
      me.grid.onFocusedRowDerender();
      result.newScrollTop = me.jumpToPosition(newScrollTop, index);
      result.deltaTop = 0;
    }
    return result;
  }
  /**
   * Handles virtual rendering (only visible rows + buffer are in dom) for rows
   * @param {Number} newScrollTop The `Y` scroll position for which to render rows.
   * @param {Boolean} [force=false] Pass `true` to update the rendered row block even if the scroll position has not changed.
   * @returns {Number} Adjusted height required to fit rows
   * @private
   * @category Scrolling & rendering
   */
  updateRenderedRows(newScrollTop, force, ignoreError = false) {
    const me = this;
    if (me.rowCount === 0) {
      return 0;
    }
    let result = me.totalHeight;
    if (force || // Only react if we have scrolled by one row or more
    Math.abs(newScrollTop - me.lastScrollTop) >= me.rowOffsetHeight || // or if we have a gap at top/bottom (#9375)
    me.topRow.top > newScrollTop || me.bottomRow.bottom < newScrollTop + me.viewHeight) {
      const posInfo = me.warpIfNeeded(newScrollTop);
      me.scrollTargetRecordId = null;
      me.lastScrollTop = posInfo.newScrollTop;
      if (posInfo.deltaTop > 0) {
        me.fillBelow(posInfo.newScrollTop);
      } else if (posInfo.deltaTop < 0) {
        me.fillAbove(posInfo.newScrollTop);
      }
      if (!me.fixedRowHeight && !ignoreError) {
        me.correctError(posInfo, newScrollTop);
      }
      result = me.estimateTotalHeight();
    }
    return result;
  }
  correctError(posInfo, newScrollTop) {
    const me = this;
    let error = 0;
    if (me.allHeightsKnown) {
      error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
    } else {
      if (
        // Scrolling up within top zone
        posInfo.deltaTop < 0 && newScrollTop < me.viewHeight * 2 || // Scrolling down within bottom zone
        posInfo.deltaTop > 0 && newScrollTop > me.totalHeight - me.viewHeight * 2 - 3
      ) {
        error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
      }
    }
    if (error) {
      me.offsetRows(-error);
      me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;
    }
  }
  /**
   * Moves as many rows from the bottom to the top that are needed to fill to current scroll pos.
   * @param newTop Scroll position
   * @private
   * @category Scrolling & rendering
   */
  fillAbove(newTop) {
    const me = this, { rows } = me, prependIndex = Math.min(me.prependRowBuffer, rows.length - 1);
    while (
      // Prepend buffer should be above viewport
      rows[prependIndex].top > newTop && // unless we have reached the top
      me.topIndex > 0
    ) {
      me.displayRecordAtTop();
    }
    me.trigger("renderDone");
  }
  /**
   * Moves as many rows from the top to the bottom that are needed to fill to current scroll pos.
   * @param newTop Scroll position
   * @private
   * @category Scrolling & rendering
   */
  fillBelow(newTop) {
    const me = this, { rows } = me, { length } = rows, appendIndex = Math.min(length - Math.min(me.appendRowBuffer, length - 1), length - 1), { count } = me.store, newBottom = newTop + me.viewHeight;
    while (
      // Append buffer should be below viewport
      rows[appendIndex].top < newBottom && // unless we have reached the bottom
      me.bottomRow.dataIndex < count - 1
    ) {
      me.displayRecordAtBottom();
    }
    me.trigger("renderDone");
  }
  /**
   * Estimates height needed to fit all rows, based on average row height. Also offsets rows if needed to not be above
   * the reachable area of the view.
   * @param {Boolean} [immediate] Specify true to pass the `immediate` flag on to any listeners (probably only Grid
   * cares. Used to bypass buffered element resize)
   * @returns {Number}
   * @private
   * @category Scrolling & rendering
   */
  estimateTotalHeight(immediate = false) {
    const me = this;
    if (me.grid.renderingRows) {
      return;
    }
    const recordCount = me.store.count, unknownCount = recordCount - me.heightMap.size, { bottomRow } = me;
    let estimate;
    if (me.fixedRowHeight) {
      estimate = recordCount * me.rowOffsetHeight;
    } else {
      estimate = // Known height, from entries in heightMap
      me.totalKnownHeight + // Those heights are "clientHeights", estimate needs to include borders
      me.heightMap.size * me.grid._rowBorderHeight + // Add estimate for rows with unknown height
      unknownCount * me.preciseRowOffsetHeight;
      if (bottomRow && unknownCount) {
        const bottom = bottomRow.bottom;
        if (bottom > estimate || me.topIndex + me.rowCount >= recordCount && estimate > bottom && bottom > 0) {
          estimate = bottom;
          if (bottomRow.dataIndex < recordCount - 1) {
            estimate += (recordCount - 1 - bottomRow.dataIndex) * me.preciseRowOffsetHeight;
          }
        }
      }
      estimate = Math.floor(estimate);
    }
    if (estimate !== me.totalHeight) {
      if (me.trigger("changeTotalHeight", { totalHeight: estimate, immediate }) !== false) {
        me._totalHeight = estimate;
      }
    }
    return estimate;
  }
  /**
   * Moves a row from bottom to top and renders the corresponding record to it.
   * @returns {Number} New row height
   * @private
   * @category Scrolling & rendering
   */
  displayRecordAtTop() {
    var _a4;
    const me = this, { grid } = me, recordIndex = me.topIndex - 1, record = me.store.getAt(recordIndex), bottomRow = me.bottomRow, bottomRowTop = bottomRow.top;
    me.trigger("beforeTranslateRow", {
      row: bottomRow,
      newRecord: record
    });
    if (bottomRow.dataIndex === ((_a4 = grid.focusedCell) == null ? void 0 : _a4.rowIndex)) {
      grid.onFocusedRowDerender();
    }
    bottomRow._top = me.topRow.top - me.getOffsetHeight(record);
    bottomRow.estimatedTop = !me.fixedRowHeight;
    bottomRow.render(recordIndex, record, false);
    bottomRow._top = bottomRowTop;
    bottomRow.setBottom(me.topRow.top);
    bottomRow.estimatedTop = false;
    me.topIndex--;
    me._rows.unshift(me._rows.pop());
    me.fixIndices();
    return bottomRow.offsetHeight;
  }
  /**
   * Moves a row from top to bottom and renders the corresponding record to it.
   * @returns {Number} New row height
   * @private
   * @category Scrolling & rendering
   */
  displayRecordAtBottom() {
    var _a4;
    const me = this, { grid } = me, recordIndex = me.topIndex + me.rowCount, record = me.store.getAt(recordIndex), topRow = me.topRow;
    me.trigger("beforeTranslateRow", {
      row: topRow,
      newRecord: record
    });
    if (topRow.dataIndex === ((_a4 = grid.focusedCell) == null ? void 0 : _a4.rowIndex)) {
      grid.onFocusedRowDerender();
    }
    topRow.dataIndex = recordIndex;
    topRow.setTop(me.bottomRow.bottom);
    topRow.render(recordIndex, record, false);
    me.topIndex++;
    me._rows.push(me._rows.shift());
    me.fixIndices();
    return topRow.offsetHeight;
  }
  fixIndices() {
    for (let i = 0, { rows } = this, { length } = rows; i < length; i++) {
      rows[i].index = i;
    }
  }
  //endregion
};
RowManager.featureClass = "";
RowManager._$name = "RowManager";

// lib/Grid/util/GridScroller.js
var xAxis2 = {
  x: 1
};
var subGridFilter = (w) => w.isSubGrid;
var GridScroller = class extends Scroller {
  addScroller(scroller) {
    (this.xScrollers || (this.xScrollers = [])).push(scroller);
  }
  addPartner(otherScroller, axes = xAxis2) {
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (axes.x) {
      otherScroller.owner.initScroll();
      const subGrids = this.widget.items.filter(subGridFilter), otherSubGrids = otherScroller.widget.items.filter(subGridFilter);
      for (let i = 0, { length } = subGrids; i < length; i++) {
        subGrids[i].scrollable.addPartner(otherSubGrids[i].scrollable, "x");
      }
    }
    if (axes.y) {
      super.addPartner(otherScroller, "y");
    }
  }
  removePartner(otherScroller) {
    this.xScrollers.forEach((scroller, i) => {
      if (!scroller.isDestroyed) {
        scroller.removePartner(otherScroller.xScrollers[i]);
      }
    });
    super.removePartner(otherScroller);
  }
  updateOverflowX(overflowX) {
    var _a4;
    const hideScroll = overflowX === false;
    (_a4 = this.xScrollers) == null ? void 0 : _a4.forEach((s) => s.overflowX = hideScroll ? "hidden" : "hidden-scroll");
    this.widget.virtualScrollers.classList.toggle("b-hide-display", hideScroll);
  }
  scrollIntoView(element, options) {
    if (element.nodeType === Element.ELEMENT_NODE && this.element.contains(element)) {
      for (const subGridScroller of this.xScrollers) {
        if (subGridScroller.element.contains(element)) {
          return subGridScroller.scrollIntoView(element, options);
        }
      }
    } else {
      return super.scrollIntoView(element, options);
    }
  }
  hasOverflow(axis = "y") {
    return axis === "y" ? this.scrollHeight > this.clientHeight : false;
  }
  set x(x) {
    if (this.xScrollers) {
      this.xScrollers[0].x = x;
    }
  }
  get x() {
    return this.xScrollers ? this.xScrollers[0].x : 0;
  }
};
GridScroller._$name = "GridScroller";

// lib/Grid/view/Header.js
var Header = class extends Bar {
  get subGrid() {
    return this._subGrid;
  }
  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }
  get region() {
    var _a4;
    return (_a4 = this.subGrid) == null ? void 0 : _a4.region;
  }
  changeElement(element, was) {
    const { region } = this;
    this.getConfig("columns");
    return super.changeElement({
      className: {
        "b-grid-header-scroller": 1,
        [`b-grid-header-scroller-${region}`]: region
      },
      children: [{
        reference: "headersElement",
        className: {
          "b-grid-headers": 1,
          [`b-grid-headers-${region}`]: region
        },
        dataset: {
          region,
          reference: "headersElement",
          maxDepth: this.maxDepth
        }
      }]
    }, was);
  }
  get overflowElement() {
    return this.headersElement;
  }
  /**
   * Recursive column header config creator.
   * Style not included because of CSP. Widths are fixed up in
   * {@link #function-fixHeaderWidths}
   * @private
   */
  getColumnConfig(column) {
    const {
      id,
      align,
      resizable,
      isLeaf,
      isParent,
      isLastInSubGrid,
      cls,
      childLevel,
      field,
      tooltip,
      children,
      isFocusable,
      grid
    } = column, focusedCell = grid == null ? void 0 : grid.focusedCell, isFocused = (focusedCell == null ? void 0 : focusedCell.rowIndex) === -1 && (focusedCell == null ? void 0 : focusedCell.column) === column, style = {};
    if (column.isVisible) {
      if (column.flex) {
        style.flex = column.flex;
      } else if (column.width) {
        style.width = DomHelper.setLength(column.width);
      }
      return {
        style,
        className: {
          "b-grid-header": 1,
          "b-grid-header-parent": isParent,
          [`b-level-${childLevel}`]: 1,
          [`b-depth-${column.meta.depth}`]: 1,
          [`b-grid-header-align-${align}`]: align,
          "b-grid-header-resizable": resizable && isLeaf,
          [cls]: cls,
          "b-collapsible": column.collapsible,
          "b-last-parent": isParent && isLastInSubGrid,
          "b-last-leaf": isLeaf && isLastInSubGrid
        },
        role: isFocusable ? "columnheader" : "presentation",
        "aria-sort": "none",
        "aria-label": column.ariaLabel,
        [isFocusable ? "tabIndex" : ""]: isFocused ? 0 : -1,
        dataset: {
          ...Tooltip.encodeConfig(tooltip),
          columnId: id,
          [field ? "column" : ""]: field
        },
        children: [
          {
            className: "b-grid-header-text",
            children: [{
              [grid && isFocusable ? "id" : ""]: `${grid == null ? void 0 : grid.id}-column-${column.id}`,
              className: "b-grid-header-text-content"
            }]
          },
          children ? {
            className: "b-grid-header-children",
            children: children.map((child) => this.getColumnConfig(child)),
            syncOptions: {
              syncIdField: "columnId"
            }
          } : null,
          {
            className: "b-grid-header-resize-handle"
          }
        ]
      };
    }
  }
  // used by safari to fix flex when rows width shrink below this value
  calculateMinWidthForSafari() {
    let minWidth = 0;
    this.columns.visibleColumns.forEach((column) => {
      minWidth += column.calculateMinWidth();
    });
    return minWidth;
  }
  /**
   * Fix header widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP
   * @private
   */
  fixHeaderWidths() {
    this.fixCellWidths();
  }
  refreshHeaders() {
    const me = this;
    me.columns.traverse((column) => me.refreshColumn(column));
    me.fixHeaderWidths();
  }
  refreshColumn(column) {
    const me = this, headerElement = me.getBarCellElement(column.id);
    if (headerElement) {
      let html = column.headerText;
      if (column.headerRenderer) {
        html = column.headerRenderer.call(column.thisObj || me, { column, headerElement });
      }
      if (column.headerWidgetMap) {
        Object.values(column.headerWidgetMap).forEach((widget) => {
          widget.render(column.textWrapper);
        });
      }
      if (column.icon) {
        html = `<i class="${StringHelper.encodeHtml(column.icon)}"></i>` + (html || "");
      }
      const innerEl = headerElement.querySelector(".b-grid-header-text-content");
      if (innerEl) {
        innerEl.innerHTML = html || "";
      }
    }
  }
  get columns() {
    const me = this, result = super.columns;
    if (!me.columnsDetacher) {
      me.columnsDetacher = result.ion({
        change() {
          me.initDepths();
        },
        thisObj: me
      });
      me.initDepths();
    }
    return result;
  }
  set columns(columns) {
    super.columns = columns;
  }
  /**
   * Depths are used for styling of grouped headers. Sets them on meta.
   * @private
   */
  initDepths(columns = this.columns.topColumns, parent = null) {
    const me = this;
    let maxDepth = 0;
    if (parent == null ? void 0 : parent.meta) {
      parent.meta.depth++;
    }
    for (const column of columns) {
      const { meta } = column;
      meta.depth = 0;
      if (column.children) {
        me.initDepths(column.children.filter(me.columns.chainedFilterFn), column);
        if (meta.depth && parent) {
          parent.meta.depth += meta.depth;
        }
      }
      if (meta.depth > maxDepth) {
        maxDepth = meta.depth;
      }
    }
    if (!parent) {
      me.maxDepth = maxDepth;
    }
    return maxDepth;
  }
  //endregion
  //region Getters
  /**
   * Get the header cell element for the specified column.
   * @param {String} columnId Column id
   * @returns {HTMLElement} Header cell element
   */
  getHeader(columnId) {
    return this.getBarCellElement(columnId);
  }
  //endregion
  get contentElement() {
    return this.element.firstElementChild;
  }
  refreshContent() {
    const me = this;
    DomSync.sync({
      domConfig: {
        children: me.columns.topColumns.map((col) => me.getColumnConfig(col)),
        onlyChildren: true
      },
      targetElement: me.contentElement,
      strict: true,
      syncIdField: "columnId",
      releaseThreshold: 0
    });
    me.refreshHeaders();
  }
  onInternalPaint({ firstPaint }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }
};
__publicField(Header, "$name", "Header");
__publicField(Header, "type", "gridheader");
Header.initClass();
Header._$name = "Header";

// lib/Grid/view/mixin/GridElementEvents.js
var gridBodyElementEventHandlers = {
  touchstart: "onElementTouchStart",
  touchmove: "onElementTouchMove",
  touchend: "onElementTouchEnd",
  pointerover: "onElementMouseOver",
  mouseout: "onElementMouseOut",
  mousedown: "onElementMouseDown",
  mousemove: "onElementMouseMove",
  mouseup: "onElementMouseUp",
  click: "onHandleElementClick",
  dblclick: "onElementDblClick",
  keyup: "onElementKeyUp",
  keypress: "onElementKeyPress",
  contextmenu: "onElementContextMenu",
  pointerdown: "onElementPointerDown",
  pointerup: "onElementPointerUp"
};
var eventProps2 = [
  "pageX",
  "pageY",
  "clientX",
  "clientY",
  "screenX",
  "screenY"
];
var textInputs = 'input:is(:not([type]),[type="text"],[type="number"],[type="date"],[type="datetime-local"],[type="email"],[type="month"],[type="password"],[type="range"],[type="search"],[type="tel"],[type="time"],[type="url"],[type="week"])';
var textKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowLeft: 1,
  ArrowRight: 1,
  Backspace: 1,
  Delete: 1
};
function toggleHover(element, add = true) {
  element == null ? void 0 : element.classList.toggle("b-hover", add);
}
function setCellHover(columnId, row, add = true) {
  row && columnId && toggleHover(row.getCell(columnId), add);
}
var GridElementEvents_default = (Target) => class GridElementEvents extends (Target || Base) {
  static get $name() {
    return "GridElementEvents";
  }
  //region Config
  static get configurable() {
    return {
      /**
       * The currently hovered grid cell
       * @member {HTMLElement}
       * @readonly
       * @category Misc
       */
      hoveredCell: null,
      /**
       * Time in ms until a longpress is triggered
       * @prp {Number}
       * @default
       * @category Misc
       */
      longPressTime: 400,
      /**
       * Set to true to listen for CTRL-Z (CMD-Z on Mac OS) keyboard event and trigger undo (redo when SHIFT is
       * pressed). Only applicable when using a {@link Core.data.stm.StateTrackingManager}.
       * @prp {Boolean}
       * @default
       * @category Misc
       */
      enableUndoRedoKeys: true,
      keyMap: {
        "Ctrl+z": "undoRedoKeyPress",
        "Ctrl+Shift+z": "undoRedoKeyPress",
        " ": { handler: "clickCellByKey", weight: 1e3 }
      }
    };
  }
  //endregion
  //region Events
  /**
   * Fired when user clicks in a grid cell
   * @event cellClick
   * @param {Grid.view.Grid} grid The grid instance
   * @param {Core.data.Model} record The record representing the row
   * @param {Grid.column.Column} column The column to which the cell belongs
   * @param {HTMLElement} cellElement The cell HTML element
   * @param {HTMLElement} target The target element
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when user double clicks a grid cell
   * @event cellDblClick
   * @param {Grid.view.Grid} grid The grid instance
   * @param {Core.data.Model} record The record representing the row
   * @param {Grid.column.Column} column The column to which the cell belongs
   * @param {HTMLElement} cellElement The cell HTML element
   * @param {HTMLElement} target The target element
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when user activates contextmenu in a grid cell
   * @event cellContextMenu
   * @param {Grid.view.Grid} grid The grid instance
   * @param {Core.data.Model} record The record representing the row
   * @param {Grid.column.Column} column The column to which the cell belongs
   * @param {HTMLElement} cellElement The cell HTML element
   * @param {HTMLElement} target The target element
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when user moves the mouse over a grid cell
   * @event cellMouseOver
   * @param {Grid.view.Grid} grid The grid instance
   * @param {Core.data.Model} record The record representing the row
   * @param {Grid.column.Column} column The column to which the cell belongs
   * @param {HTMLElement} cellElement The cell HTML element
   * @param {HTMLElement} target The target element
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when a user moves the mouse out of a grid cell
   * @event cellMouseOut
   * @param {Grid.view.Grid} grid The grid instance
   * @param {Core.data.Model} record The record representing the row
   * @param {Grid.column.Column} column The column to which the cell belongs
   * @param {HTMLElement} cellElement The cell HTML element
   * @param {HTMLElement} target The target element
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when the mouse enters a row
   * @event rowMouseEnter
   * @param {Grid.view.Grid} source The grid instance
   * @param {Core.data.Model} record The record representing the hovered row
   * @param {Grid.column.Column} column The column currently hovered
   * @param {HTMLElement} cellElement The cell HTML element
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when the mouse leaves a row
   * @event rowMouseLeave
   * @param {Grid.view.Grid} source The grid instance
   * @param {Core.data.Model} record The record representing the row that the mouse left
   * @param {HTMLElement} cellElement The cell HTML element that the mouse left
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when the mouse enters a cell
   * @event cellMouseEnter
   * @param {Grid.view.Grid} source The grid instance
   * @param {Core.data.Model} record The record representing the hovered cell
   * @param {Grid.column.Column} column The column currently hovered
   * @param {HTMLElement} cellElement The cell HTML element
   * @param {MouseEvent} event The native DOM event
   */
  /**
   * Fired when the mouse leaves a cell
   * @event cellMouseLeave
   * @param {Grid.view.Grid} source The grid instance
   * @param {Core.data.Model} record The record representing the cell that the mouse left
   * @param {Grid.column.Column} column The column representing the cell that the mouse left
   * @param {HTMLElement} cellElement The cell HTML element that the mouse left
   * @param {MouseEvent} event The native DOM event
   */
  //endregion
  //region Event handling
  /**
   * Init listeners for a bunch of dom events. All events are handled by handleEvent().
   * @private
   * @category Events
   */
  initInternalEvents() {
    const handledEvents = Object.keys(gridBodyElementEventHandlers), len = handledEvents.length, listeners = {
      element: this.bodyElement,
      thisObj: this
    };
    for (let i = 0; i < len; i++) {
      const eventName = handledEvents[i];
      listeners[eventName] = {
        handler: "handleEvent"
      };
      if (eventName.startsWith("touch")) {
        listeners[eventName].passive = false;
      }
    }
    EventHelper.on(listeners);
    EventHelper.on({
      mouseenter: "onGridBodyMouseEnterOrLeave",
      mouseleave: "onGridBodyMouseEnterOrLeave",
      focusin: "onGridBodyFocusIn",
      element: this.bodyElement,
      thisObj: this,
      capture: true
    });
  }
  /**
   * This method finds the cell location of the passed event. It returns an object describing the cell.
   * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.
   * @param {Boolean} [includeSingleAxisMatch] Set to `true` to return a cell from xy either above or below the Grid's
   * body or to the left or right.
   * @returns {Object} An object containing the following properties:
   * - `cellElement` - The cell element clicked on.
   * - `column` - The {@link Grid.column.Column column} clicked under.
   * - `columnId` - The `id` of the {@link Grid.column.Column column} clicked under.
   * - `record` - The {@link Core.data.Model record} clicked on.
   * - `id` - The `id` of the {@link Core.data.Model record} clicked on.
   * @internal
   * @category Events
   */
  getCellDataFromEvent(event, includeSingleAxisMatch = false) {
    var _a4, _b;
    const me = this, { target } = event, targetIsRow = target.classList.contains("b-grid-row");
    let cellElement = target.closest(".b-grid-cell");
    if (!cellElement && includeSingleAxisMatch && !targetIsRow && !target.classList.contains("b-grid-subgrid")) {
      const { columns } = me, {
        top,
        left,
        right,
        bottom
      } = me.bodyContainer.getBoundingClientRect();
      let match, { x, y } = event;
      if (x >= left && x <= right) {
        y = match = Math.ceil(me[`${y < top ? "first" : "last"}FullyVisibleRow`].element.getBoundingClientRect().y);
      } else if (y >= top && y <= bottom) {
        x = match = Math.ceil(columns.visibleColumns[x < left ? 0 : columns.visibleColumns.length - 1].element.getBoundingClientRect().x);
      }
      if (match !== void 0) {
        cellElement = (_a4 = DomHelper.childFromPoint(target, event.offsetX, event.offsetY)) == null ? void 0 : _a4.closest(".b-grid-cell");
      }
    } else if (targetIsRow) {
      cellElement = (_b = DomHelper.childFromPoint(target, event.offsetX, event.offsetY - target.offsetHeight / 2)) == null ? void 0 : _b.closest(".b-grid-cell");
    }
    if (cellElement) {
      return me.getCellDataFromElement(cellElement);
    }
  }
  /**
   * This method finds the cell location of the passed element. It returns an object describing the cell.
   * @param {HTMLElement} cellElement A cell element or any element inside a cell.
   * @returns {Object} An object containing the following properties:
   * - `cellElement` - The cell element clicked on.
   * - `column` - The {@link Grid.column.Column column} clicked under.
   * - `columnId` - The `id` of the {@link Grid.column.Column column} clicked under.
   * - `record` - The {@link Core.data.Model record} clicked on.
   * - `id` - The `id` of the {@link Core.data.Model record} clicked on.
   * @internal
   * @category Events
   */
  getCellDataFromElement(cellElement) {
    const me = this;
    if (cellElement = cellElement.closest(".b-grid-cell")) {
      const cellData = DomDataStore.get(cellElement), { id, columnId } = cellData, record = me.store.getById(id), column = me.columns.getById(columnId);
      return record ? {
        cellElement,
        cellData,
        columnId,
        id,
        record,
        column,
        cellSelector: { id, columnId }
      } : null;
    }
  }
  /**
   * This method finds the header location of the passed event. It returns an object describing the header.
   * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.
   * @returns {Object} An object containing the following properties:
   * - `headerElement` - The header element clicked on.
   * - `column` - The {@link Grid.column.Column column} clicked under.
   * - `columnId` - The `id` of the {@link Grid.column.Column column} clicked under.
   * @internal
   * @category Events
   */
  getHeaderDataFromEvent(event) {
    const headerElement = event.target.closest(".b-grid-header");
    if (headerElement) {
      const headerData = ObjectHelper.assign({}, headerElement.dataset), { columnId } = headerData, column = this.columns.getById(columnId);
      return column ? {
        headerElement,
        headerData,
        columnId,
        column
      } : null;
    }
  }
  /**
   * Handles all dom events, routing them to correct functions (touchstart -> onElementTouchStart)
   * @param event
   * @private
   * @category Events
   */
  handleEvent(event) {
    if (!this.disabled && gridBodyElementEventHandlers[event.type]) {
      this[gridBodyElementEventHandlers[event.type]](event);
    }
  }
  //endregion
  //region Touch events
  /**
   * Touch start, chain this function in features to handle the event.
   * @param event
   * @category Touch events
   * @internal
   */
  onElementTouchStart(event) {
    const me = this;
    DomHelper.isTouchEvent = true;
    if (event.touches.length === 1) {
      me.longPressTimeout = me.setTimeout(() => {
        me.onElementLongPress(event);
        event.preventDefault();
        me.longPressPerformed = true;
      }, me.longPressTime);
    }
  }
  /**
   * Touch move, chain this function in features to handle the event.
   * @param event
   * @category Touch events
   * @internal
   */
  onElementTouchMove(event) {
    const me = this, {
      lastTouchTarget
    } = me, touch = event.changedTouches[0], {
      pageX,
      pageY
    } = touch, touchTarget = document.elementFromPoint(pageX, pageY);
    if (me.longPressTimeout) {
      me.clearTimeout(me.longPressTimeout);
      me.longPressTimeout = null;
    }
    if (touchTarget !== lastTouchTarget) {
      if (lastTouchTarget) {
        const mouseoutEvent = new MouseEvent("mouseout", ObjectHelper.copyProperties({
          relatedTarget: touchTarget,
          pointerType: "touch",
          bubbles: true
        }, touch, eventProps2));
        mouseoutEvent.preventDefault = () => event.preventDefault();
        lastTouchTarget == null ? void 0 : lastTouchTarget.dispatchEvent(mouseoutEvent);
      }
      if (touchTarget) {
        const mouseoverEvent = new MouseEvent("mouseover", ObjectHelper.copyProperties({
          relatedTarget: lastTouchTarget,
          pointerType: "touch",
          bubbles: true
        }, touch, eventProps2));
        mouseoverEvent.preventDefault = () => event.preventDefault();
        touchTarget == null ? void 0 : touchTarget.dispatchEvent(mouseoverEvent);
      }
    }
    me.lastTouchTarget = touchTarget;
  }
  /**
   * Touch end, chain this function in features to handle the event.
   * @param event
   * @category Touch events
   * @internal
   */
  onElementTouchEnd(event) {
    const me = this;
    if (me.longPressPerformed) {
      if (event.cancelable) {
        event.preventDefault();
      }
      me.longPressPerformed = false;
    }
    if (me.longPressTimeout) {
      me.clearTimeout(me.longPressTimeout);
      me.longPressTimeout = null;
    }
  }
  onElementLongPress(event) {
  }
  //endregion
  //region Mouse events
  // Trigger events in same style when clicking, dblclicking and for contextmenu
  triggerCellMouseEvent(name, event, cellData = this.getCellDataFromEvent(event), target = "cell") {
    var _a4;
    const me = this;
    if (cellData) {
      const column = me.columns.getById(cellData.columnId), eventData = {
        grid: me,
        record: cellData.record,
        column,
        cellSelector: cellData.cellSelector,
        cellElement: cellData.cellElement,
        target: event.target,
        event
      };
      me.trigger(target + StringHelper.capitalize(name), eventData);
      if (target === "cell" && name === "click") {
        (_a4 = column.onCellClick) == null ? void 0 : _a4.call(column, eventData);
      }
    }
  }
  /**
   * Mouse down, chain this function in features to handle the event.
   * @param event
   * @category Mouse events
   * @internal
   */
  onElementMouseDown(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    me.skipFocusSelection = true;
    if (me.isScrollbarOrRowBorderOrSplitterClick(event)) {
      event.preventDefault();
    } else {
      me.triggerCellMouseEvent("mousedown", event, cellData);
      if (cellData && !event.defaultPrevented) {
        me.onFocusGesture(event);
      }
    }
  }
  isScrollbarOrRowBorderOrSplitterClick({ target, x, y }) {
    if (target.closest(".b-grid-splitter") || target.matches(".b-grid-row, .b-virtual-width")) {
      return true;
    }
    if (target.matches(".b-vertical-overflow")) {
      const rect = target.getBoundingClientRect();
      return x > rect.right - DomHelper.scrollBarWidth;
    } else if (target.matches(".b-horizontal-overflow")) {
      const rect = target.getBoundingClientRect();
      return y > rect.bottom - DomHelper.scrollBarWidth - 1;
    }
  }
  /**
   * Mouse move, chain this function in features to handle the event.
   * @param event
   * @category Mouse events
   * @internal
   */
  onElementMouseMove(event) {
    this.mouseMoveEvent = event;
  }
  /**
   * Mouse up, chain this function in features to handle the event.
   * @param event
   * @category Mouse events
   * @internal
   */
  onElementMouseUp(event) {
  }
  onElementPointerDown(event) {
  }
  /**
   * Pointer up, chain this function in features to handle the event.
   * @param event
   * @category Mouse events
   * @internal
   */
  onElementPointerUp(event) {
  }
  /**
   * Called before {@link #function-onElementClick}.
   * Fires 'beforeElementClick' event which can return false to cancel further onElementClick actions.
   * @param event
   * @fires beforeElementClick
   * @category Mouse events
   * @internal
   */
  onHandleElementClick(event) {
    if (this.trigger("beforeElementClick", { event }) !== false) {
      this.onElementClick(event);
    }
  }
  /**
   * Click, select cell on click and also fire 'cellClick' event.
   * Chain this function in features to handle the dom event.
   * @param event
   * @fires cellClick
   * @category Mouse events
   * @internal
   */
  onElementClick(event) {
    var _a4;
    const me = this, cellData = me.getCellDataFromEvent(event);
    if (cellData) {
      return me.triggerCellMouseEvent("click", event, cellData);
    } else {
      const header = (_a4 = event.target) == null ? void 0 : _a4.closest(".b-grid-header"), column = header && me.columns.getById(header.dataset.columnId);
      if (column) {
        return me.trigger("headerClick", {
          domEvent: event,
          column
        });
      }
    }
  }
  onFocusGesture(event) {
    var _a4;
    const me = this, { navigationEvent } = me, { target } = event, isContextMenu = event.button === 2, isTreeExpander = !isContextMenu && target.matches(".b-icon-tree-expand, .b-icon-tree-collapse"), isUnfocusedRightClick = !document.hasFocus() && BrowserHelper.isMac && isContextMenu;
    if (isTreeExpander || isUnfocusedRightClick) {
      event.preventDefault();
    } else {
      me.navigationEvent = event;
      const location = new Location(target);
      if (isContextMenu || ((_a4 = me.focusedCell) == null ? void 0 : _a4.equals(location))) {
        const focusOptions = { scroll: false };
        if (globalThis.TouchEvent && event instanceof MouseEvent && navigationEvent instanceof TouchEvent && target === navigationEvent.target) {
          focusOptions.doSelect = false;
        }
        me.focusCell(location, focusOptions);
      }
    }
  }
  /**
   * Double click, fires 'cellDblClick' event.
   * Chain this function in features to handle the dom event.
   * @param {Event} event
   * @fires cellDblClick
   * @fires columnResize
   * @category Mouse events
   * @internal
   */
  onElementDblClick(event) {
    const { target } = event;
    this.triggerCellMouseEvent("dblClick", event);
    if (target.classList.contains("b-grid-header-resize-handle")) {
      const header = target.closest(".b-grid-header"), column = this.columns.getById(header.dataset.columnId);
      if (column.resizeToFitContent()) {
        this.trigger("columnResize", { column, domEvent: event });
      }
    }
  }
  shouldHover(event) {
    return (typeof event.buttons !== "number" || event.buttons === 0) && event.pointerType !== "touch";
  }
  /**
   * Mouse over, adds 'hover' class to elements.
   * @param event
   * @fires mouseOver
   * @category Mouse events
   * @internal
   */
  onElementMouseOver(event) {
    var _a4;
    if (!this.scrolling) {
      const me = this, { hoveredCell } = me, shouldHover = this.shouldHover(event);
      let cellElement = event.target.closest(".b-grid-cell");
      me._lastMouseOverOutEvent = event;
      if (!cellElement && event.target.classList.contains("b-grid-row")) {
        cellElement = (_a4 = DomHelper.childFromPoint(event.target, event.offsetX, event.offsetY - 2)) == null ? void 0 : _a4.closest(".b-grid-cell");
      }
      if (cellElement) {
        if (shouldHover) {
          me.hoveredCell = cellElement;
        }
        if (hoveredCell !== me.hoveredCell) {
          me.triggerCellMouseEvent("mouseOver", event);
        }
      }
      me.trigger("mouseOver", { event });
    }
  }
  /**
   * Mouse out, removes 'hover' class from elements.
   * @param event
   * @fires mouseOut
   * @category Mouse events
   * @internal
   */
  onElementMouseOut(event) {
    var _a4;
    const me = this, {
      target,
      relatedTarget
    } = event, shouldHover = (typeof event.buttons !== "number" || event.buttons === 0) && event.pointerType !== "touch";
    me._lastMouseOverOutEvent = event;
    if (shouldHover && relatedTarget && target.matches(".b-grid-cell") && !target.contains(relatedTarget)) {
      if (!relatedTarget.matches(".b-grid-row")) {
        me.hoveredCell = relatedTarget.closest(".b-grid-cell");
      }
    } else if (!(relatedTarget == null ? void 0 : relatedTarget.matches(".b-grid-row,.b-grid-cell")) && !((_a4 = me.hoveredCell) == null ? void 0 : _a4.contains(relatedTarget))) {
      me.hoveredCell = null;
    }
    if (!me.scrolling) {
      if ((relatedTarget == null ? void 0 : relatedTarget.closest(".b-grid-cell")) !== (target == null ? void 0 : target.closest(".b-grid-cell"))) {
        if (target == null ? void 0 : target.closest(".b-grid-cell")) {
          me.triggerCellMouseEvent("mouseOut", event);
        }
      }
      me.trigger("mouseOut", { event });
    }
  }
  // The may be chained in features
  updateHoveredCell(cellElement, was) {
    var _a4, _b, _c;
    const me = this, { selectionMode } = me, rowNumberColumnId = selectionMode.rowNumber && ((_a4 = me.columns.find((c) => c.type == "rownumber")) == null ? void 0 : _a4.id), checkboxSelectionColumnId = selectionMode.checkbox && ((_b = me.checkboxSelectionColumn) == null ? void 0 : _b.id);
    let prevRow, row;
    if (was) {
      toggleHover(was, false);
      const prevSelector = DomDataStore.get(was);
      prevRow = prevSelector.row;
      if (prevRow && !prevRow.isDestroyed) {
        setCellHover(rowNumberColumnId, prevRow, false);
        setCellHover(checkboxSelectionColumnId, prevRow, false);
      }
      if (prevSelector == null ? void 0 : prevSelector.columnId) {
        toggleHover((_c = me.columns.getById(prevSelector.columnId)) == null ? void 0 : _c.element, false);
      }
    }
    if (me._hoveredRow && !me._hoveredRow.isDestroyed) {
      me._hoveredRow.removeCls("b-hover");
    }
    me._hoveredRow = null;
    if (cellElement && !me.scrolling) {
      const selector = DomDataStore.get(cellElement);
      row = selector.row;
      if (row) {
        if (selectionMode.cell && selector.columnId !== rowNumberColumnId && selector.columnId !== checkboxSelectionColumnId) {
          const column = me.columns.getById(selector.columnId);
          toggleHover(cellElement);
          setCellHover(checkboxSelectionColumnId, row);
          setCellHover(rowNumberColumnId, row);
          if ((column == null ? void 0 : column.element) && column.headerHoverable !== false) {
            toggleHover(column.element);
          }
        } else {
          me._hoveredRow = row;
          row.addCls("b-hover");
        }
      } else {
        me.hoveredCell = null;
      }
    }
    if (row !== prevRow) {
      const { _lastMouseOverOutEvent } = me;
      if (prevRow && !prevRow.isDestroyed) {
        me.trigger("rowMouseLeave", { event: _lastMouseOverOutEvent, record: prevRow.cellContext.record, cellElement: was });
      }
      if (row) {
        const cellData = me.getCellDataFromEvent(_lastMouseOverOutEvent);
        me.triggerCellMouseEvent("mouseEnter", _lastMouseOverOutEvent, cellData, "row");
      }
    }
  }
  //endregion
  //region Keyboard events
  // Hooks on to keyMaps keydown-listener to be able to run before
  keyMapOnKeyDown(event) {
    const { target } = event;
    if (this.element.contains(target)) {
      this.onElementKeyDown(event);
      if (textKeys[event.key] && DomHelper.isEditable(target) && !target.getAttribute("readOnly") && this.matchKeyMapEntry(event) && target.matches(textInputs)) {
        if (!event.key.startsWith("Arrow") && !event.key === "Backspace") {
          event.preventDefault();
        }
        event.handled = true;
        event.stopPropagation();
        return false;
      } else {
        super.keyMapOnKeyDown(event);
      }
    }
  }
  /**
   * To catch all keydowns. For more specific keydown actions, use keyMap.
   * @param event
   * @category Keyboard events
   * @internal
   */
  onElementKeyDown(event) {
    var _a4, _b;
    if (event.handled || !this.element.contains(event.target)) {
      return;
    }
    const me = this, focusedCell = me.focusedCell;
    if ((focusedCell == null ? void 0 : focusedCell.isCell) && !focusedCell.isActionable) {
      const data = event.target.closest(".b-grid-cell") ? me.getCellDataFromEvent(event) : me.getCellDataFromElement(focusedCell.cell);
      (_b = data == null ? void 0 : (_a4 = data.column).onCellKeyDown) == null ? void 0 : _b.call(_a4, { ...data, event });
    }
  }
  undoRedoKeyPress(event) {
    var _a4;
    const { stm } = this.store;
    if (stm && this.enableUndoRedoKeys && !((_a4 = this.features.cellEdit) == null ? void 0 : _a4.isEditing)) {
      stm.onUndoKeyPress(event);
      return true;
    }
    return false;
  }
  // Trigger column.onCellClick when space bar is pressed
  clickCellByKey(event) {
    const me = this, focusedCell = me.focusedCell, cellElement = focusedCell == null ? void 0 : focusedCell.cell, column = me.columns.getById(cellElement.dataset.columnId);
    if ((focusedCell == null ? void 0 : focusedCell.isCell) && !focusedCell.isActionable) {
      if (column.onCellClick) {
        column.onCellClick({
          grid: me,
          column,
          record: me.store.getById(focusedCell.id),
          cellElement,
          target: event.target,
          event
        });
        return true;
      }
    }
    return false;
  }
  /**
   * Key press, chain this function in features to handle the dom event.
   * @param event
   * @category Keyboard events
   * @internal
   */
  onElementKeyPress(event) {
  }
  /**
   * Key up, chain this function in features to handle the dom event.
   * @param event
   * @category Keyboard events
   * @internal
   */
  onElementKeyUp(event) {
  }
  //endregion
  //region Other events
  /**
   * Context menu, chain this function in features to handle the dom event.
   * In most cases, include ContextMenu feature instead.
   * @param event
   * @category Other events
   * @internal
   */
  onElementContextMenu(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    if (cellData) {
      me.triggerCellMouseEvent("contextMenu", event, cellData);
      if (DomHelper.isTouchEvent) {
        me.onFocusGesture(event);
      }
    }
  }
  onGridBodyMouseEnterOrLeave(event) {
    const cellData = event.target.classList.contains("b-grid-cell") && this.getCellDataFromEvent(event);
    if (cellData) {
      this.triggerCellMouseEvent(event.type, event, cellData);
    }
  }
  /**
   * Overrides empty base function in View, called when view is resized.
   * @fires resize
   * @param element
   * @param width
   * @param height
   * @param oldWidth
   * @param oldHeight
   * @category Other events
   * @internal
   */
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const me = this;
    if (me._devicePixelRatio && me._devicePixelRatio !== globalThis.devicePixelRatio) {
      DomHelper.resetScrollBarWidth();
    }
    me._devicePixelRatio = globalThis.devicePixelRatio;
    me._bodyRectangle = Rectangle.client(me.bodyContainer);
    super.onInternalResize(...arguments);
    if (height !== oldHeight) {
      me._bodyHeight = me.bodyContainer.offsetHeight;
      if (me.isPainted) {
        me.rowManager.initWithHeight(me._bodyHeight);
      }
    }
    me.refreshVirtualScrollbars();
    if (width !== oldWidth) {
      me.setTimeout(() => {
        if (!me.isDestroyed) {
          me.updateResponsive(width, oldWidth);
        }
      }, 0);
    }
  }
  //endregion
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement this.
  get widgetClass() {
  }
};

// lib/Grid/view/mixin/GridFeatures.js
var validConfigTypes = {
  string: 1,
  object: 1,
  function: 1
  // used by CellTooltip
};
var GridFeatures_default = (Target) => class GridFeatures extends (Target || Base) {
  static get $name() {
    return "GridFeatures";
  }
  //region Init
  /**
   * Specify which features to use on the grid. Most features accepts a boolean, some also accepts a config object.
   * Please note that if you are not using the bundles you might need to import the features you want to use.
   *
   * ```javascript
   * const grid = new Grid({
   *     features : {
   *         stripe : true,   // Enable stripe feature
   *         sort   : 'name', // Configure sort feature
   *         group  : false   // Disable group feature
   *     }
   * }
   * ```
   *
   * @config {Object} features
   * @category Common
   */
  /**
   * Map of the features available on the grid. Use it to access them on your grid object
   *
   * ```javascript
   * grid.features.group.expandAll();
   * ```
   *
   * @readonly
   * @member {Object} features
   * @category Common
   */
  set features(features) {
    const me = this, defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);
    features = me._features = ObjectHelper.assign({}, features);
    if (defaultFeatures) {
      Object.keys(defaultFeatures).forEach((feature) => {
        if (!(feature in features)) {
          features[feature] = true;
        }
      });
    }
    const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);
    for (const featureName of Object.keys(features)) {
      const config = features[featureName];
      if (config) {
        const throwIfError = !globalThis.__bryntum_code_editor_changed;
        if (StringHelper.uncapitalize(featureName) !== featureName) {
          const errorMessage = `Invalid feature name '${featureName}', must start with a lowercase letter`;
          if (throwIfError) {
            throw new Error(errorMessage);
          }
          console.error(errorMessage);
          me._errorDuringConfiguration = errorMessage;
        }
        const featureClass = registeredInstanceFeatures[featureName];
        if (!featureClass) {
          const errorMessage = `Feature '${featureName}' not available, make sure you have imported it`;
          if (throwIfError) {
            throw new Error(errorMessage);
          }
          console.error(errorMessage);
          me._errorDuringConfiguration = errorMessage;
          return;
        }
        Reflect.defineProperty(features, featureName, me.createFeatureInitializer(
          features,
          featureName,
          featureClass,
          config
        ));
      }
    }
  }
  get features() {
    return this._features;
  }
  createFeatureInitializer(features, featureName, featureClass, config) {
    const constructorArgs = [this], construct = featureClass.prototype.construct;
    if (config === true) {
      config = {};
    }
    if (validConfigTypes[typeof config]) {
      constructorArgs[1] = config;
    }
    return {
      configurable: true,
      get() {
        delete features[featureName];
        featureClass.prototype.construct = function(...args) {
          features[featureName] = this;
          construct.apply(this, args);
          featureClass.prototype.construct = construct;
        };
        return new featureClass(...constructorArgs);
      }
    };
  }
  //endregion
  //region Other stuff
  /**
   * Check if a feature is included
   * @param {String} name Feature name, as registered with `GridFeatureManager.registerFeature()`
   * @returns {Boolean}
   * @category Misc
   */
  hasFeature(name) {
    const { features } = this;
    if (features) {
      const featureProp = Object.getOwnPropertyDescriptor(this.features, name);
      if (featureProp) {
        return Boolean(featureProp.value || featureProp.get);
      }
    }
    return false;
  }
  hasActiveFeature(name) {
    var _a4, _b;
    return Boolean(((_a4 = this.features) == null ? void 0 : _a4[name]) && !((_b = this.features) == null ? void 0 : _b[name].disabled));
  }
  //endregion
  //region Extract config
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs for the features
  getConfigValue(name, options) {
    var _a4, _b;
    if (name === "features") {
      const result = {};
      for (const feature in this.features) {
        const featureConfig = (_b = (_a4 = this.features[feature]) == null ? void 0 : _a4.getCurrentConfig) == null ? void 0 : _b.call(_a4, options);
        if (featureConfig) {
          if (ObjectHelper.isEmpty(featureConfig)) {
            if (!GridFeatureManager.isDefaultFeatureForInstance(this.features[feature].constructor, this)) {
              result[feature] = true;
            }
          } else {
            result[feature] = featureConfig;
          }
        } else {
          result[feature] = false;
        }
      }
      return result;
    }
    return super.getConfigValue(name, options);
  }
  //endregion
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement this.
  get widgetClass() {
  }
};

// lib/Grid/view/mixin/GridNavigation.js
var defaultFocusOptions = Object.freeze({});
var containedFocusable = function(e) {
  if (!this.focusableFinderCell.contains(e)) {
    return DomHelper.NodeFilter.FILTER_REJECT;
  }
  if (DomHelper.isFocusable(e) && !e.disabled) {
    return DomHelper.NodeFilter.FILTER_ACCEPT;
  }
  return DomHelper.NodeFilter.FILTER_SKIP;
};
var GridNavigation_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static get $name() {
      return "GridNavigation";
    }
    onStoreRecordIdChange(event) {
      var _a5;
      (_a5 = super.onStoreRecordIdChange) == null ? void 0 : _a5.call(this, event);
      const { focusedCell } = this, { oldValue, value } = event;
      if (focusedCell && focusedCell.id === oldValue) {
        focusedCell._id = value;
      }
    }
    /**
     * Called by the RowManager when the row which contains the focus location is derendered.
     *
     * This keeps focus in a consistent place.
     * @protected
     */
    onFocusedRowDerender() {
      const me = this, { focusedCell } = me;
      if ((focusedCell == null ? void 0 : focusedCell.id) != null && focusedCell.cell) {
        const isActive = focusedCell.cell.contains(DomHelper.getActiveElement(me));
        if (me.hideHeaders) {
          if (isActive) {
            me.revertFocus();
          }
        } else {
          const headerContext = me.normalizeCellContext({
            rowIndex: -1,
            columnIndex: isActive ? focusedCell.columnIndex : 0
          });
          if (isActive) {
            me.focusCell(headerContext);
          } else {
            headerContext.cell.tabIndex = 0;
          }
        }
        focusedCell.cell.tabIndex = -1;
      }
    }
    navigateFirstCell() {
      this.focusCell(Location.FIRST_CELL);
    }
    navigateFirstColumn() {
      this.focusCell(Location.FIRST_COLUMN);
    }
    navigateLastCell() {
      this.focusCell(Location.LAST_CELL);
    }
    navigateLastColumn() {
      this.focusCell(Location.LAST_COLUMN);
    }
    navigatePrevPage() {
      this.focusCell(Location.PREV_PAGE);
    }
    navigateNextPage() {
      this.focusCell(Location.NEXT_PAGE);
    }
    activateHeader(keyEvent) {
      var _a5;
      if (keyEvent.target.classList.contains("b-grid-header") && this.focusedCell.isColumnHeader) {
        const { column } = this.focusedCell;
        (_a5 = column.onKeyDown) == null ? void 0 : _a5.call(column, keyEvent);
        this.getHeaderElement(column.id).click();
      }
      return false;
    }
    onEscape(keyEvent) {
      var _a5, _b;
      const me = this, { focusedCell } = me;
      if (!keyEvent.target.closest(".b-dragging") && (focusedCell == null ? void 0 : focusedCell.isActionable)) {
        keyEvent.stopImmediatePropagation();
        me._focusedCell = null;
        me.focusCell({
          rowIndex: focusedCell.rowIndex,
          column: focusedCell.column
        }, {
          disableActionable: true
        });
      } else if (me.isNested && me.owner && !((_b = (_a5 = me.owner).catchFocus) == null ? void 0 : _b.call(_a5, { source: me }))) {
        me.revertFocus(true);
      }
    }
    onTab(keyEvent) {
      const { target } = keyEvent, {
        focusedCell,
        bodyElement
      } = this, {
        isActionable,
        actionTargets = []
      } = focusedCell, isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly;
      if (isEditable && target === actionTargets[actionTargets.length - 1]) {
        keyEvent.preventDefault();
        this.navigateRight(keyEvent);
      } else if (!isActionable || target === actionTargets[actionTargets.length - 1]) {
        bodyElement.style.display = "none";
        this.requestAnimationFrame(() => bodyElement.style.display = "");
        return false;
      }
    }
    onShiftTab(keyEvent) {
      const me = this, { target } = keyEvent, {
        focusedCell,
        bodyElement
      } = me, {
        cell,
        isActionable,
        actionTargets
      } = focusedCell, isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly, onFirstCell = focusedCell.columnIndex === 0 && focusedCell.rowIndex === (me.hideHeaders ? 0 : -1);
      if (!onFirstCell && isEditable && target === actionTargets[0]) {
        keyEvent.preventDefault();
        me.navigateLeft(keyEvent);
      } else if (!isActionable || target === actionTargets[0]) {
        const f = !onFirstCell && !me.hideHeaders && me.focusCell({
          rowIndex: -1,
          column: 0
        }, {
          disableActionable: true
        });
        if (f) {
          f.cell.tabIndex = -1;
          cell.tabIndex = 0;
          me._focusedCell = focusedCell;
        } else {
          bodyElement.style.display = "none";
          me.requestAnimationFrame(() => bodyElement.style.display = "");
        }
        return false;
      }
    }
    onSpace(keyEvent) {
      if (!this.focusedCell.isActionable) {
        keyEvent.preventDefault();
      }
      return false;
    }
    //region Cell
    /**
     * Triggered when a user navigates to a grid cell
     * @event navigate
     * @param {Grid.view.Grid} grid The grid instance
     * @param {Grid.util.Location} last The previously focused location
     * @param {Grid.util.Location} location The new focused location
     * @param {Event} [event] The UI event which caused navigation.
     */
    /**
     * Grid Location which encapsulates the currently focused cell.
     * Set to focus a cell or use {@link #function-focusCell}.
     * @property {Grid.util.Location}
     */
    get focusedCell() {
      return this._focusedCell;
    }
    /**
     * This property is `true` if an element _within_ a cell is focused.
     * @property {Boolean}
     * @readonly
     */
    get isActionableLocation() {
      var _a5;
      return (_a5 = this._focusedCell) == null ? void 0 : _a5.isActionable;
    }
    set focusedCell(cellSelector) {
      this.focusCell(cellSelector);
    }
    get focusedRecord() {
      var _a5;
      return (_a5 = this._focusedCell) == null ? void 0 : _a5.record;
    }
    /**
     * CSS selector for currently focused cell. Format is "[data-index=index] [data-column-id=columnId]".
     * @property {String}
     * @readonly
     */
    get cellCSSSelector() {
      const cell = this._focusedCell;
      return cell ? `[data-index=${cell.rowIndex}] [data-column-id=${cell.columnId}]` : "";
    }
    afterHide() {
      super.afterHide(...arguments);
      this.lastFocusedCell = null;
    }
    /**
     * Checks whether a cell is focused.
     * @param {LocationConfig|Grid.util.Location|String|Number} cellSelector Cell selector { id: x, columnId: xx } or row id
     * @returns {Boolean} true if cell or row is focused, otherwise false
     */
    isFocused(cellSelector) {
      var _a5;
      return Boolean((_a5 = this._focusedCell) == null ? void 0 : _a5.equals(this.normalizeCellContext(cellSelector)));
    }
    get focusElement() {
      var _a5;
      if (!this.isDestroying) {
        let focusCell;
        if (this.store.count && this._focusedCell) {
          focusCell = this._focusedCell.target;
        } else {
          focusCell = this.normalizeCellContext({
            rowIndex: -1,
            columnIndex: ((_a5 = this._focusedCell) == null ? void 0 : _a5.columnIndex) || 0
          }).target;
        }
        const superFocusEl = super.focusElement;
        if (superFocusEl && (!focusCell || focusCell.compareDocumentPosition(superFocusEl) === Node.DOCUMENT_POSITION_PRECEDING)) {
          return superFocusEl;
        }
        return focusCell;
      }
    }
    onInternalPaint({ firstPaint }) {
      var _a5;
      const me = this;
      (_a5 = super.onInternalPaint) == null ? void 0 : _a5.call(this, ...arguments);
      const defaultFocus = this.normalizeCellContext({
        rowIndex: me.hideHeaders ? 0 : -1,
        column: me.hideHeaders ? 0 : me.columns.find((col) => !col.hidden && col.isFocusable)
      });
      if (defaultFocus.cell) {
        defaultFocus._isDefaultFocus = true;
        me._focusedCell = defaultFocus;
        const { target } = defaultFocus;
        if (target === defaultFocus.cell) {
          defaultFocus.cell.tabIndex = 0;
        }
      }
    }
    /**
     * This function handles focus moving into, or within the grid.
     * @param {Event} focusEvent
     * @private
     */
    onGridBodyFocusIn(focusEvent) {
      var _a5, _b, _c;
      const me = this, { bodyElement } = me, lastFocusedCell = me.focusedCell, lastTarget = (lastFocusedCell == null ? void 0 : lastFocusedCell.initialTarget) || (lastFocusedCell == null ? void 0 : lastFocusedCell.target), {
        target,
        relatedTarget
      } = focusEvent, targetCell = target.closest(me.focusableSelector), targetRow = target.closest(".b-grid-row");
      if (targetCell && (!GlobalEvents_default.currentMouseDown || GlobalEvents_default.isMouseDown(0) || GlobalEvents_default.isMouseDown(2))) {
        const cellSelector = new Location(target), { cell } = cellSelector, lastCell = lastFocusedCell == null ? void 0 : lastFocusedCell.cell, actionTargets = cellSelector.actionTargets = me.findFocusables(targetCell), doSelect = (!me._fromFocusCell || me.selectOnFocus) && (target === cell || me._selectActionCell) && !(target == null ? void 0 : target._isRevertingFocus);
        if (targetRow && cellSelector.rowIndex === -1) {
          cell.focus({ preventScroll: true });
          return;
        }
        if (target.matches(me.focusableSelector)) {
          if (me.disableActionable) {
            cellSelector._target = cell;
          } else if (actionTargets.length) {
            me._selectActionCell = ((_a5 = GlobalEvents_default.currentMouseDown) == null ? void 0 : _a5.target) === target;
            actionTargets[0].focus();
            delete me._selectActionCell;
            return;
          }
        } else {
          if ((lastFocusedCell == null ? void 0 : lastFocusedCell.target) && relatedTarget && (!GlobalEvents_default.isMouseDown() || !bodyElement.contains((_b = GlobalEvents_default.currentMouseDown) == null ? void 0 : _b.target)) && !bodyElement.contains(relatedTarget) && !cellSelector.equals(lastFocusedCell)) {
            lastTarget.focus();
            return;
          }
          cellSelector._target = target;
        }
        if (lastCell) {
          lastCell.classList.remove("b-focused");
          lastCell.tabIndex = -1;
        }
        if (cell) {
          cell.classList.add("b-focused");
          cellSelector.column.onCellFocus(cellSelector);
          if (cell === target) {
            cell.tabIndex = 0;
          }
          if (cell.contains(focusEvent.relatedTarget)) {
            if (lastTarget === target) {
              return;
            }
          }
        }
        me._focusedCell = cellSelector;
        (_c = me.onCellNavigate) == null ? void 0 : _c.call(me, me, lastFocusedCell, cellSelector, doSelect);
        me.trigger("navigate", { lastFocusedCell, focusedCell: cellSelector, event: focusEvent });
      } else if (!target.closest(".b-rowexpander-body")) {
        lastTarget == null ? void 0 : lastTarget.focus({ preventScroll: true });
      }
    }
    findFocusables(cell) {
      const { focusableFinder } = this, result = [];
      focusableFinder.currentNode = this.focusableFinderCell = cell;
      for (let focusable = focusableFinder.nextNode(); focusable; focusable = focusableFinder.nextNode()) {
        result.push(focusable);
      }
      return result;
    }
    get focusableFinder() {
      const me = this;
      if (!me._focusableFinder) {
        me._focusableFinder = me.setupTreeWalker(me.bodyElement, DomHelper.NodeFilter.SHOW_ELEMENT, {
          acceptNode: containedFocusable.bind(me)
        });
      }
      return me._focusableFinder;
    }
    /**
     * Sets the passed record as the current focused record for keyboard navigation and selection purposes.
     * This API is used by Combo to activate items in its picker.
     * @param {Core.data.Model|Number|String} activeItem The record, or record index, or record id to highlight as the active ("focused") item.
     * @internal
     */
    restoreActiveItem(item = this._focusedCell) {
      if (this.rowManager.count) {
        if (!isNaN(item)) {
          item = this.store.getAt(item);
        } else if (!item.isModel) {
          item = this.store.getById(item);
        }
        return this.focusCell(item);
      }
    }
    /**
     * Navigates to a cell and/or its row (depending on selectionMode)
     * @param {LocationConfig|Grid.util.Location} cellSelector Cell location descriptor
     * @param {Object} options Modifier options for how to deal with focusing the cell. These
     * are used as the {@link Core.helper.util.Scroller#function-scrollTo} options.
     * @param {BryntumScrollOptions|Boolean} [options.scroll=true] Pass `false` to not scroll the cell into view, or a
     * scroll options object to affect the scroll.
     * @returns {Grid.util.Location} A Location object representing the focused location.
     * @fires navigate
     */
    focusCell(cellSelector, options = defaultFocusOptions) {
      var _a5, _b, _c, _d;
      const me = this, { _focusedCell } = me, {
        scroll,
        disableActionable
      } = options, isDown = cellSelector === Location.DOWN, isUp = cellSelector === Location.UP, isLeftRightKey = cellSelector === Location.PREV_CELL || cellSelector === Location.NEXT_CELL;
      if ((cellSelector == null ? void 0 : cellSelector.rowIndex) === -1 && me.hideHeaders) {
        me.revertFocus();
        return;
      }
      cellSelector = typeof cellSelector === "number" && (_focusedCell == null ? void 0 : _focusedCell.isLocation) ? _focusedCell.move(cellSelector) : me.normalizeCellContext(cellSelector);
      const doSelect = "doSelect" in options ? options.doSelect : !cellSelector.isActionable || cellSelector.initialTarget === cellSelector.cell;
      if (cellSelector.equals(_focusedCell)) {
        if (me.isNested && (isDown || isUp)) {
          if (!((_b = (_a5 = me.owner) == null ? void 0 : _a5.catchFocus) == null ? void 0 : _b.call(_a5, { source: me, navigationDirection: isDown ? "down" : "up" }))) {
            me.revertFocus(true);
          }
        } else {
          (_c = me.onCellNavigate) == null ? void 0 : _c.call(me, me, _focusedCell, cellSelector, doSelect);
        }
        return _focusedCell;
      }
      const subGrid = me.getSubGridFromColumn(cellSelector.columnId), { cell } = cellSelector, testCell = cell || me.getCell({
        rowIndex: me.rowManager.topIndex,
        columnId: cellSelector.columnId
      }), subGridRect = Rectangle.from(subGrid.element), bodyRect = Rectangle.from(me.bodyElement), cellRect = Rectangle.from(testCell).moveTo(null, subGridRect.y);
      if (scroll !== false) {
        if (cellSelector.rowIndex === -1) {
          if (isLeftRightKey) {
            me.scrollColumnIntoView(cellSelector.column);
          }
        } else {
          options = Object.assign({}, options, scroll);
          if (cellRect.width > subGridRect.width || cellRect.height > bodyRect.height) {
            options.x = options.y = false;
          } else {
            options.column = cellSelector.columnId;
          }
          me.scrollRowIntoView(cellSelector.id, options);
        }
      }
      if (me._hoveredRow || me.hoveredCell) {
        me.hoveredCell = null;
      }
      me.disableActionable = disableActionable;
      me.selectOnFocus = doSelect;
      me._fromFocusCell = true;
      (_d = cellSelector[disableActionable ? "cell" : "target"]) == null ? void 0 : _d.focus({ preventScroll: true });
      me.disableActionable = me.selectOnFocus = false;
      delete me._fromFocusCell;
      return cellSelector;
    }
    blurCell(cellSelector) {
      const me = this, cell = me.getCell(cellSelector);
      if (cell) {
        cell.classList.remove("b-focused");
      }
    }
    clearFocus(fullClear) {
      const me = this;
      if (me._focusedCell) {
        me.lastFocusedCell = fullClear ? null : me._focusedCell;
        me.blurCell(me._focusedCell);
        me._focusedCell = null;
      }
    }
    // For override-ability
    catchFocus() {
    }
    /**
     * Selects the cell before or after currently focused cell.
     * @private
     * @param next Specify true to select the next cell, false to select the previous
     * @returns {Object} Used cell selector
     */
    internalNextPrevCell(next = true) {
      const me = this, cellSelector = me._focusedCell;
      if (cellSelector) {
        return me.focusCell({
          id: cellSelector.id,
          columnId: me.columns.getAdjacentVisibleLeafColumn(cellSelector.column, next, true).id
        });
      }
      return null;
    }
    /**
     * Select the cell after the currently focused one.
     * @param {Event} [event] [DEPRECATED] unused param
     * @returns {Grid.util.Location} Cell selector
     */
    navigateRight() {
      var _a5;
      if ((_a5 = arguments[0]) == null ? void 0 : _a5.fromKeyMap) {
        return this.focusCell(this.rtl ? Location.PREV_CELL : Location.NEXT_CELL);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevCell(!this.rtl);
    }
    /**
     * Select the cell before the currently focused one.
     * @param {Event} [event] [DEPRECATED] unused param
     * @returns {Grid.util.Location} Cell selector
     */
    navigateLeft() {
      var _a5;
      if ((_a5 = arguments[0]) == null ? void 0 : _a5.fromKeyMap) {
        return this.focusCell(this.rtl ? Location.NEXT_CELL : Location.PREV_CELL);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevCell(Boolean(this.rtl));
    }
    //endregion
    //region Row
    /**
     * Selects the next or previous record in relation to the current selection. Scrolls into view if outside.
     * @private
     * @param next Next record (true) or previous (false)
     * @param {Boolean} [skipSpecialRows=true] True to not return specialRows like headers
     * @param {Boolean} [moveToHeader=true] True to allow focus to move to a header
     * @returns {Grid.util.Location|Boolean} Selection context for the focused row (& cell) or false if no selection was made
     */
    internalNextPrevRow(next, skipSpecialRows = true, moveToHeader = true) {
      const me = this, cell = me._focusedCell;
      if (!cell)
        return false;
      const record = me.store[`get${next ? "Next" : "Prev"}`](cell.id, false, skipSpecialRows);
      if (record) {
        return me.focusCell({
          id: record.id,
          columnId: cell.columnId,
          scroll: {
            x: false
          }
        });
      } else if (!next && moveToHeader && !cell.isColumnHeader) {
        this.clearFocus();
        this.getHeaderElement(cell.columnId).focus();
      }
      return false;
    }
    /**
     * Navigates to the cell below the currently focused cell
     * @param {Event} [event] [DEPRECATED] unused param
     * @returns {Grid.util.Location} Selector for focused row (& cell)
     */
    navigateDown() {
      var _a5;
      if ((_a5 = arguments[0]) == null ? void 0 : _a5.fromKeyMap) {
        return this.focusCell(Location.DOWN);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevRow(true, false);
    }
    /**
     * Navigates to the cell above the currently focused cell
     * @param {Event} [event] [DEPRECATED] unused param
     * @returns {Grid.util.Location} Selector for focused row (& cell)
     */
    navigateUp() {
      var _a5;
      if ((_a5 = arguments[0]) == null ? void 0 : _a5.fromKeyMap) {
        return this.focusCell(Location.UP);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevRow(false, false);
    }
    //endregion
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {
    }
  }, __publicField(_a4, "configurable", {
    focusable: false,
    focusableSelector: ".b-grid-cell,.b-grid-header.b-depth-0",
    // Set to true to revert focus on Esc or on ArrowUp/ArrowDown above/below first/last row
    isNested: false,
    // Documented on Grid
    keyMap: {
      ArrowUp: { handler: "navigateUp", weight: 10 },
      ArrowRight: { handler: "navigateRight", weight: 10 },
      ArrowDown: { handler: "navigateDown", weight: 10 },
      ArrowLeft: { handler: "navigateLeft", weight: 10 },
      "Ctrl+Home": "navigateFirstCell",
      Home: "navigateFirstColumn",
      "Ctrl+End": "navigateLastCell",
      End: "navigateLastColumn",
      PageUp: "navigatePrevPage",
      PageDown: "navigateNextPage",
      Enter: "activateHeader",
      // Private
      Escape: { handler: "onEscape", weight: 10 },
      "Shift+Tab": { handler: "onShiftTab", preventDefault: false, weight: 200 },
      Tab: { handler: "onTab", preventDefault: false, weight: 200 },
      " ": { handler: "onSpace", preventDefault: false }
    }
  }), _a4;
};

// lib/Grid/view/mixin/GridResponsive.js
var GridResponsive_default = (Target) => class GridResponsive extends (Target || Base) {
  static get $name() {
    return "GridResponsive";
  }
  static get defaultConfig() {
    return {
      /**
       * "Break points" for which responsive config to use for columns and css.
       * @config {Object<String,Number|String>}
       * @category Misc
       * @default { small : 400, medium : 600, large : '*' }
       */
      responsiveLevels: Object.freeze({
        small: 400,
        medium: 600,
        large: "*"
      })
    };
  }
  /**
   * Find closes bigger level, aka level we want to use.
   * @private
   * @category Misc
   */
  getClosestBiggerLevel(width) {
    const me = this, levels = Object.keys(ObjectHelper.assign({}, me.responsiveLevels));
    let useLevel = null, minDelta = 99995, biggestLevel = null;
    levels.forEach((level) => {
      let levelSize = me.responsiveLevels[level];
      if (!["number", "string"].includes(typeof levelSize)) {
        levelSize = levelSize.levelWidth;
      }
      if (levelSize === "*") {
        biggestLevel = level;
      } else if (width < levelSize) {
        const delta = levelSize - width;
        if (delta < minDelta) {
          minDelta = delta;
          useLevel = level;
        }
      }
    });
    return useLevel || biggestLevel;
  }
  /**
   * Get currently used responsive level (as string)
   * @property {String}
   * @readonly
   * @category Misc
   */
  get responsiveLevel() {
    return this.getClosestBiggerLevel(this.width);
  }
  /**
   * Check if resize lead to a new responsive level and take appropriate actions
   * @private
   * @fires responsive
   * @param width
   * @param oldWidth
   * @category Misc
   */
  updateResponsive(width, oldWidth) {
    const me = this, oldLevel = me.getClosestBiggerLevel(oldWidth), level = me.getClosestBiggerLevel(width);
    if (oldWidth === 0 || oldLevel !== level) {
      const levelConfig = me.responsiveLevels[level];
      if (!["number", "string"].includes(typeof levelConfig)) {
        me.applyState(levelConfig);
      }
      me.columns.forEach((column) => {
        const levels = column.responsiveLevels;
        if (levels) {
          if (levels[level]) {
            column.applyState(levels[level]);
          } else if (levels["*"]) {
            column.applyState(levels["*"]);
          }
        }
      });
      me.element.classList.remove("b-responsive-" + oldLevel);
      me.element.classList.add("b-responsive-" + level);
      me.trigger("responsive", { level, width, oldLevel, oldWidth });
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement this.
  get widgetClass() {
  }
};

// lib/Grid/view/mixin/GridSelection.js
var validIdTypes = {
  string: 1,
  number: 1
};
var isDataLoadAction = {
  dataset: 1,
  batch: 1
};
var GridSelection_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    static get $name() {
      return "GridSelection";
    }
    construct(config) {
      this._selectedCells = [];
      this._selectedRows = [];
      super.construct(config);
      if (config == null ? void 0 : config.selectedRecords) {
        this.selectedRecords = config.selectedRecords;
      }
    }
    //region Init
    getDefaultGridSelection(clas) {
      if (clas.$name === "GridSelection") {
        return clas.configurable.selectionMode;
      } else if (clas.superclass) {
        return this.getDefaultGridSelection(clas.superclass);
      }
    }
    changeSelectionMode(mode) {
      const me = this;
      if (me.selectionMode) {
        ObjectHelper.assign(me.selectionMode, mode);
        return me.selectionMode;
      }
      me.$defaultGridSelection = me.getDefaultGridSelection(me.constructor);
      return new Proxy(mode, {
        set(obj, prop, value) {
          const old = ObjectHelper.assign({}, obj);
          obj[prop] = value;
          me.updateSelectionMode(obj, old);
          return true;
        }
      });
    }
    /**
     * The selectionMode configuration has been changed.
     * @event selectionModeChange
     * @param {Object} selectionMode The new {@link #config-selectionMode}
     */
    // Will be called if selectionMode config object changes or if one of its properties changes
    updateSelectionMode(mode, oldMode = this.$defaultGridSelection) {
      var _a5, _b;
      const me = this, {
        columns,
        checkboxSelectionColumn
      } = me, changed = {}, { rowReorder } = me.features;
      for (const property in mode) {
        if (mode[property] != oldMode[property]) {
          changed[property] = mode[property];
        }
      }
      if (mode.rowCheckboxSelection && !mode.checkboxOnly) {
        mode.checkboxOnly = true;
        delete mode.rowCheckboxSelection;
      }
      if (changed.column) {
        mode.cell = true;
        mode.multiSelect = true;
      }
      if (changed.cell) {
        mode.checkboxOnly = false;
      }
      if (changed.cell === false) {
        mode.column = false;
      }
      if (changed.checkboxOnly) {
        if (!mode.checkbox) {
          mode.checkbox = true;
        }
        mode.cell = false;
      }
      if (changed.checkbox === false) {
        changed.checkboxOnly = false;
        changed.showCheckAll = false;
      }
      if (changed.showCheckAll) {
        mode.checkbox = mode.checkbox || true;
        mode.multiSelect = true;
      }
      if (changed.includeChildren || changed.includeParents) {
        mode.multiSelect = true;
      }
      if (changed.multiSelect === false) {
        mode.column = mode.showCheckAll = mode.dragSelect = mode.includeChildren = mode.includeParents = false;
      }
      if (changed.dragSelect) {
        if ((rowReorder == null ? void 0 : rowReorder.enabled) && rowReorder.gripOnly !== true) {
          rowReorder.showGrip = rowReorder.gripOnly = true;
        }
        mode.multiSelect = true;
        me._selectionListenersDetachers = {};
      }
      if (changed.dragSelect === false && me._selectionListenersDetachers) {
        (_b = (_a5 = me._selectionListenersDetachers).selectiondrag) == null ? void 0 : _b.call(_a5);
        delete me._selectionListenersDetachers.selectiondrag;
      }
      if (oldMode && (changed.cell !== void 0 || changed.deselectFilteredOutRecords !== void 0 || changed.multiSelect !== void 0)) {
        me.deselectAll();
      }
      if (changed.rowNumber) {
        if (!columns.findRecord("type", "rownumber")) {
          columns.insert(0, {
            ...typeof mode.rowNumber == "object" ? mode.rowNumber : {},
            type: "rownumber"
          });
          me._selectionAddedRowNumberColumn = true;
        }
      } else if (changed.rowNumber === false && me._selectionAddedRowNumberColumn) {
        columns.remove(columns.findRecord("type", "rownumber"));
        delete me._selectionAddedRowNumberColumn;
      }
      if (mode.checkbox !== (oldMode == null ? void 0 : oldMode.checkbox) || mode.checkbox && mode.showCheckAll !== (oldMode == null ? void 0 : oldMode.showCheckAll)) {
        if (me.isConfiguring) {
          me.shouldInitCheckboxSelection = true;
        } else {
          if (oldMode) {
            me.deselectAll();
          }
          me.initCheckboxSelection();
        }
      }
      if (oldMode && mode.checkbox && oldMode.checkbox && mode.checkboxIndex !== oldMode.checkboxIndex && checkboxSelectionColumn) {
        checkboxSelectionColumn.parent.insertChild(checkboxSelectionColumn, columns.getAt(me.checkboxSelectionColumnInsertIndex));
      }
      me.trigger("selectionModeChange", ObjectHelper.clone(mode));
      me.afterSelectionModeChange(mode);
    }
    afterConfigure() {
      const me = this;
      if (me.shouldInitCheckboxSelection) {
        me.shouldInitCheckboxSelection = false;
        me.initCheckboxSelection();
      }
      me.scrollManager.ion({
        scroll: ({ event, deltaY }) => {
          if (deltaY !== 0) {
            me.onSelectionDrag(event);
          }
        }
      });
      super.afterConfigure();
    }
    initCheckboxSelection() {
      var _a5, _b;
      const me = this, {
        selectionMode,
        columns,
        checkboxSelectionColumn
      } = me, { checkbox } = selectionMode;
      if (checkboxSelectionColumn) {
        me.checkboxSelectionColumn = null;
        columns.remove(checkboxSelectionColumn);
        checkboxSelectionColumn.destroy();
      }
      if (checkbox) {
        const checkColumnClass = ColumnStore.getColumnClass("check"), config = checkbox === true ? null : checkbox;
        if (!checkColumnClass) {
          throw new Error("CheckColumn must be imported for checkbox selection mode to work");
        }
        const col = me.checkboxSelectionColumn = new checkColumnClass(ObjectHelper.assign({
          id: `${me.id}-selection-column`,
          width: "4em",
          minWidth: "4em",
          // Needed because 4em is below Column's default minWidth
          field: null,
          sortable: false,
          filterable: false,
          groupable: false,
          hideable: false,
          cellCls: "b-checkbox-selection",
          // Always put the checkcolumn in the first region
          region: (_b = (_a5 = me.items) == null ? void 0 : _a5[0]) == null ? void 0 : _b.region,
          showCheckAll: selectionMode.showCheckAll,
          draggable: false,
          resizable: false,
          widgets: [{
            type: "checkbox",
            valueProperty: "checked",
            ariaLabel: "L{Checkbox.toggleRowSelect}"
          }]
        }, config), columns, { isSelectionColumn: true });
        col.meta.depth = 0;
        col._grid = me;
        const checkboxRenderer = col.renderer;
        col.setData("renderer", (renderData) => {
          renderData.value = me.isSelected(renderData.record);
          checkboxRenderer.call(col, renderData);
        });
        col.ion({
          toggle: "onCheckChange",
          toggleAll: "onCheckAllChange",
          thisObj: me
        });
        columns.insert(me.checkboxSelectionColumnInsertIndex, col);
      }
    }
    // Used internally to get the index where to insert checkboxselectioncolumn
    // Default : Insert the checkbox after any rownumber column. If not there, -1 means in at 0.
    // If provided, insert at provided index
    get checkboxSelectionColumnInsertIndex() {
      const { columns } = this;
      let { checkboxIndex } = this.selectionMode;
      if (!checkboxIndex) {
        checkboxIndex = columns.indexOf(columns.findRecord("type", "rownumber")) + 1;
      } else if (typeof checkboxIndex === "string") {
        checkboxIndex = columns.indexOf(columns.getById(checkboxIndex));
      }
      return checkboxIndex;
    }
    afterColumnsChange({ type, action, changes, columns, column }) {
      var _a5;
      const { _selectedCells } = this;
      if (_selectedCells == null ? void 0 : _selectedCells.length) {
        if (!columns && column) {
          columns = [column];
        }
        if (type === "move" || (changes == null ? void 0 : changes.hidden) || (changes == null ? void 0 : changes.region) || action === "add" || action === "remove") {
          let selectedCells = _selectedCells.map((c) => ({ id: c.id, columnId: c._column.id }));
          if ((action === "remove" || ((_a5 = changes == null ? void 0 : changes.hidden) == null ? void 0 : _a5.value)) && (columns == null ? void 0 : columns.length)) {
            selectedCells = selectedCells.filter((cell) => !columns.some((column2) => cell.columnId === column2.id));
          }
          this.deselectAll(false, true);
          this.selectCells({ cells: selectedCells, scrollIntoView: false });
        }
      }
    }
    //endregion
    // region Events docs & Hooks
    /**
     * The selection has been changed.
     * @event selectionChange
     * @param {'select'|'deselect'} action `'select'`/`'deselect'`
     * @param {'row'|'cell'} mode `'row'`/`'cell'`
     * @param {Grid.view.Grid} source
     * @param {Core.data.Model[]} deselected The records deselected in this operation.
     * @param {Core.data.Model[]} selected The records selected in this operation.
     * @param {Core.data.Model[]} selection The records in the new selection.
     * @param {Grid.util.Location[]} deselectedCells The cells deselected in this operation.
     * @param {Grid.util.Location[]} selectedCells The cells selected in this operation.
     * @param {Grid.util.Location[]} cellSelection The cells in the new selection.
     */
    /**
     * Fires before the selection changes. Returning `false` from a listener prevents the change
     * @event beforeSelectionChange
     * @preventable
     * @param {String} action `'select'`/`'deselect'`
     * @param {'row'|'cell'} mode `'row'`/`'cell'`
     * @param {Grid.view.Grid} source
     * @param {Core.data.Model[]} deselected The records to be deselected in this operation.
     * @param {Core.data.Model[]} selected The records to be selected in this operation.
     * @param {Core.data.Model[]} selection The records in the current selection, before applying `selected` and
     * `deselected`
     * @param {Grid.util.Location[]} deselectedCells The cells to be deselected in this operation.
     * @param {Grid.util.Location[]} selectedCells The cells to be selected in this operation.
     * @param {Grid.util.Location[]} cellSelection  The cells in the current selection, before applying `selectedCells`
     * and `deselectedCells`
     */
    afterSelectionChange() {
    }
    afterSelectionModeChange() {
    }
    // endregion
    // region selectedRecordCollection
    changeSelectedRecordCollection(collection) {
      if (collection == null ? void 0 : collection.isCollection) {
        if (!collection.owner) {
          collection.owner = this;
        }
        return collection;
      }
      return Collection.new(collection, { owner: this });
    }
    updateSelectedRecordCollection(collection) {
      collection.ion({
        change: "onSelectedRecordCollectionChange",
        thisObj: this
      });
    }
    onSelectedRecordCollectionChange({ added = [], removed }) {
      if (this.selectedRecordCollection._fromSelection !== this) {
        added = added.filter((row) => this.isSelectable(row));
        this.performSelection({
          selectedCells: [],
          deselectedCells: [],
          selectedRecords: added,
          deselectedRecords: removed
        });
      }
    }
    changeSelectedRecordCollectionSilent(fn) {
      this.selectedRecordCollection._fromSelection = this;
      const result = fn(this.selectedRecordCollection);
      delete this.selectedRecordCollection._fromSelection;
      return result;
    }
    // endregion
    // region Store
    bindStore(store) {
      var _a5;
      this.detachListeners("selectionStoreFilter");
      store.ion({
        name: "selectionStoreFilter",
        filter: "onStoreFilter",
        thisObj: this
      });
      (_a5 = super.bindStore) == null ? void 0 : _a5.call(this, store);
    }
    unbindStore(oldStore) {
      this.detachListeners("selectionStoreFilter");
      super.unbindStore(oldStore);
    }
    onStoreFilter({ source }) {
      const me = this, deselect = me.selectedRows.filter((record) => !source.includes(record)), selectionChange = me.prepareSelection(me.selectionMode.deselectFilteredOutRecords ? deselect : []);
      if (me.isCellSelectionMode) {
        const { deselectedCells } = me.prepareSelection(me._selectedCells.filter((cell) => !source.records.includes(cell.record)));
        if (deselectedCells == null ? void 0 : deselectedCells.length) {
          selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);
        }
      }
      if (selectionChange.deselectedCells.length || selectionChange.deselectedRecords.length) {
        me.performSelection(selectionChange, false);
        me.updateCheckboxHeader();
      }
    }
    /**
     * Triggered from Grid view when the id of a record has changed.
     * Update the collection indices.
     * @private
     * @category Selection
     */
    onStoreRecordIdChange({ record, oldValue }) {
      var _a5;
      (_a5 = super.onStoreRecordIdChange) == null ? void 0 : _a5.call(this, ...arguments);
      const item = this.selectedRecordCollection.get(oldValue);
      if (item === record) {
        this.selectedRecordCollection.rebuildIndices();
      }
    }
    /**
     * Triggered from Grid view when records get removed from the store.
     * Deselects all records which have been removed.
     * @private
     * @category Selection
     */
    onStoreRemove(event) {
      var _a5;
      (_a5 = super.onStoreRemove) == null ? void 0 : _a5.call(this, event);
      if (!event.isCollapse) {
        const me = this, deselectedRecords = event.records.filter((rec) => me.isSelected(rec)), selectionChange = me.prepareSelection(deselectedRecords);
        if (me.isCellSelectionMode) {
          const { deselectedCells } = me.prepareSelection(me.getSelectedCellsForRecords(event.records));
          if (deselectedCells == null ? void 0 : deselectedCells.length) {
            selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);
          }
        }
        if (deselectedRecords.length || selectionChange.deselectedCells.length) {
          me.performSelection(selectionChange);
        }
      }
    }
    /**
     * Triggered from Grid view when the store changes. This might happen
     * if store events are batched and then resumed.
     * Deselects all records which have been removed.
     * @private
     * @category Selection
     */
    onStoreDataChange({ action, source: store }) {
      var _a5;
      const me = this, { selectionMode } = me;
      let selectionChange;
      (_a5 = super.onStoreDataChange) == null ? void 0 : _a5.call(this, ...arguments);
      if (action === "pageLoad") {
        if (!selectionMode.preserveSelectionOnPageChange) {
          selectionChange = me.prepareSelection(null, null, true);
        }
        me.updateCheckboxHeader();
      } else if (isDataLoadAction[action]) {
        const deselect = [];
        if (selectionMode.preserveSelectionOnDatasetChange === false) {
          selectionChange = me.prepareSelection(null, null, true);
        } else {
          deselect.push(...me.changeSelectedRecordCollectionSilent((c) => c.match(store.storage)));
          for (const selectedCell of me._selectedCells) {
            if (!store.getById(selectedCell.id)) {
              deselect.push(selectedCell);
            }
          }
          selectionChange = me.prepareSelection(deselect);
        }
      }
      if (selectionChange && (selectionChange.deselectAll || selectionChange.deselectedCells.length || selectionChange.deselectedRecords.length || selectionChange.selectedCells.length || selectionChange.selectedRecords.length)) {
        me.performSelection(selectionChange, false);
        me.updateCheckboxHeader();
      }
    }
    /**
     * Triggered from Grid view when all records get removed from the store.
     * Deselects all records.
     * @private
     * @category Selection
     */
    onStoreRemoveAll() {
      var _a5;
      (_a5 = super.onStoreRemoveAll) == null ? void 0 : _a5.call(this);
      this.performSelection(this.prepareSelection(null, null, true), false);
    }
    //endregion
    // region Checkbox selection
    onCheckChange({ checked, record, checkbox }) {
      const me = this, { multiSelect } = me.selectionMode, deselectAll = !multiSelect && checked, deselect = !deselectAll && !checked ? [record] : null, select = checked ? [record] : null;
      me._isCheckboxSelecting = true;
      if (checked && !GlobalEvents_default.shiftKeyDown) {
        me._lastSelectionChecked = record;
      }
      if (checked && multiSelect && me._lastSelectionChecked && GlobalEvents_default.shiftKeyDown) {
        me.performSelection(me.internalSelectRange(me._lastSelectionChecked, record, true));
      } else if (me.performSelection(me.prepareSelection(deselect, select, deselectAll, true)) === false) {
        checkbox.checked = !checkbox.checked;
      }
      me._isCheckboxSelecting = false;
    }
    // Update header checkbox
    updateCheckboxHeader() {
      const { selectionMode, checkboxSelectionColumn, store } = this;
      if (!this._isCheckAllSelecting && selectionMode.checkbox && selectionMode.showCheckAll && (checkboxSelectionColumn == null ? void 0 : checkboxSelectionColumn.headerCheckbox)) {
        const allSelected = store.count && !store.some((record) => this.isSelectable(record) && !this.isSelected(record));
        if (checkboxSelectionColumn.headerCheckbox.checked !== allSelected) {
          checkboxSelectionColumn.suspendEvents();
          checkboxSelectionColumn.headerCheckbox.checked = allSelected;
          checkboxSelectionColumn.resumeEvents();
        }
      }
    }
    onCheckAllChange({ checked }) {
      const me = this;
      me._isCheckboxSelecting = me._isCheckAllSelecting = true;
      me[checked ? "selectAll" : "deselectAll"](me.store.isPaged && me.selectionMode.preserveSelectionOnPageChange);
      me._isCheckboxSelecting = me._isCheckAllSelecting = false;
    }
    //endregion
    // region Selection drag
    // Hook for SalesForce-code to overwrite
    get selectionDragMouseEventListenerElement() {
      return globalThis;
    }
    // Creates new selection range on mouseover. Listener is initiated on mousedown
    onSelectionDrag(event) {
      var _a5;
      const me = this, isScroll = event.type === "scroll", { _selectionStartCell, lastPointerMoveEvent } = me;
      if (isScroll && !me._isSelectionDragging) {
        return;
      }
      if (!GlobalEvents_default.isMouseDown()) {
        me.onSelectionEnd();
      }
      if (!_selectionStartCell) {
        return;
      }
      const { items: items2, _lastSelectionDragRegion } = me;
      let cellData, region, cellSelector;
      if (isScroll && lastPointerMoveEvent) {
        const el = document.elementFromPoint(lastPointerMoveEvent.clientX, lastPointerMoveEvent.clientY), cellEl = el == null ? void 0 : el.closest(".b-grid-cell");
        if (cellEl) {
          region = me._lastSelectionDragRegion;
          cellSelector = me.normalizeCellContext({
            columnId: cellEl.dataset.columnId,
            record: me.store.getById(cellEl.parentElement.dataset.id)
          });
        }
      } else {
        cellData = me.getCellDataFromEvent(event, true);
        region = cellData == null ? void 0 : cellData.column.region;
        cellSelector = (cellData == null ? void 0 : cellData.cellSelector) && me.normalizeCellContext(cellData.cellSelector);
        if (cellData) {
          me.lastPointerMoveEvent = event;
        }
      }
      if (cellSelector && !cellSelector.equals(me._lastSelectionDragCell, true)) {
        if (!me._isSelectionDragging) {
          me.enableScrollingCloseToEdges(items2);
        }
        if (me._clearSelectionOnSelectionDrag && !_selectionStartCell.equals(cellSelector, true)) {
          me.deselectAll();
          delete me._clearSelectionOnSelectionDrag;
        }
        if (_lastSelectionDragRegion && region !== _lastSelectionDragRegion) {
          const leavingSubGrid = me.subGrids[_lastSelectionDragRegion], enteringSubGrid = me.subGrids[region], leavingScrollable = leavingSubGrid.scrollable, enteringScrollable = enteringSubGrid.scrollable, goingForward = items2.indexOf(leavingSubGrid) - items2.indexOf(enteringSubGrid) < 0;
          enteringScrollable.x = goingForward ? 0 : enteringScrollable.maxX;
          if (goingForward ? leavingScrollable.x < leavingScrollable.maxX - 1 : leavingScrollable.x > 1) {
            return;
          }
          const activeHorizontalScroll = (_a5 = me.scrollManager._activeScroll) == null ? void 0 : _a5.horizontal;
          if (activeHorizontalScroll && activeHorizontalScroll.element !== enteringScrollable.element) {
            activeHorizontalScroll.stopScroll(true);
          }
        }
        me._lastSelectionDragRegion = region;
        me._lastSelectionDragCell = cellSelector;
        me._isSelectionDragging = true;
        const selectionChange = me._lastSelectionDragChange = me.internalSelectRange(
          _selectionStartCell,
          cellSelector,
          me.isRowNumberSelecting(cellSelector) || me.isRowNumberSelecting(_selectionStartCell)
        );
        selectionChange.deselectedCells = selectionChange.deselectedCells.filter((cell) => !me.isCellSelected(cell));
        selectionChange.deselectedRecords = selectionChange.deselectedRecords.filter((record) => !me.isSelected(record));
        me.hoveredCell = null;
        me.refreshGridSelectionUI(selectionChange);
        me.trigger("dragSelecting", selectionChange);
      }
    }
    // Tells onSelectionDrag that it's not dragging any longer
    onSelectionEnd() {
      var _a5, _b;
      const me = this, lastChange = me._lastSelectionDragChange;
      if (me._isSelectionDragging && !me._selectionStartCell.equals(me._lastSelectionDragCell, true) && lastChange) {
        me.performSelection(lastChange, false);
      }
      me.disableScrollingCloseToEdges(me.items);
      me._isSelectionDragging = false;
      me._lastSelectionDragChange = me._lastSelectionDragCell = me._lastSelectionDragRegion = null;
      (_b = (_a5 = me._selectionListenersDetachers).selectiondrag) == null ? void 0 : _b.call(_a5);
      delete me._selectionListenersDetachers.selectiondrag;
    }
    // endregion
    // region Column selection
    onHandleElementClick(event) {
      const me = this;
      if (me.selectionMode.rowNumber && event.target.closest(".b-rownumber-header")) {
        event.handled = true;
        if (me.store.count && me.store.some((record) => !me.isSelected(record))) {
          me.selectAll();
        } else {
          me.deselectAll();
        }
      } else if (me.selectionMode.column && event.target.closest(".b-grid-header")) {
        event.handled = true;
        me.selectColumn(event, event.ctrlKey);
      }
      super.onHandleElementClick(event);
    }
    selectColumn(event, addToSelection = false) {
      const me = this, { store } = me, { columnId } = me.getHeaderDataFromEvent(event);
      me._shiftSelectRange = null;
      if (!event.shiftKey) {
        me._shiftSelectColumn = columnId;
      }
      const fromColumnId = event.shiftKey && me._shiftSelectColumn || columnId, selectionChange = me.internalSelectRange(
        me.normalizeCellContext({ id: store.first.id, columnId: fromColumnId }),
        me.normalizeCellContext({ id: store.last.id, columnId })
      );
      if (addToSelection && !selectionChange.selectedCells.some((sc) => !me.isCellSelected(sc))) {
        selectionChange.deselectedCells = selectionChange.selectedCells;
        selectionChange.selectedCells = [];
      }
      if (!addToSelection) {
        selectionChange.deselectedCells = me._selectedCells;
      }
      me.cleanSelectionChange(selectionChange);
      me.performSelection(selectionChange);
    }
    // endregion
    // region Public row/record selection
    /**
     * Checks whether a row is selected. Will not check if any of a row's cells are selected.
     * @param {LocationConfig|Grid.util.Location|String|Number|Core.data.Model} cellSelectorOrId Cell selector { id: x, column: xx } or row
     * id, or record
     * @returns {Boolean} true if row is selected, otherwise false
     * @category Selection
     */
    isSelected(cellSelectorOrId) {
      if (cellSelectorOrId == null ? void 0 : cellSelectorOrId.id) {
        cellSelectorOrId = cellSelectorOrId.id;
      }
      if (validIdTypes[typeof cellSelectorOrId]) {
        return this.selectedRows.some((rec) => rec.id === cellSelectorOrId);
      }
      return false;
    }
    /**
     * Checks whether a cell is selected.
     * @param {LocationConfig|Grid.util.Location} cellSelector Cell selector { id: x, column: xx }
     * @param {Boolean} includeRow to also check if row is selected
     * @returns {Boolean} true if cell is selected, otherwise false
     * @category Selection
     */
    isCellSelected(cellSelector, includeRow) {
      cellSelector = this.normalizeCellContext(cellSelector);
      return this.isCellSelectionMode && this._selectedCells.some((cell) => cellSelector.equals(cell, true)) || includeRow && this.isSelected(cellSelector);
    }
    /**
     * Checks whether a cell or row can be selected.
     * @param {Core.data.Model|LocationConfig|Grid.util.Location|String|Number} recordCellOrId Record or cell or record id
     * @returns {Boolean} true if cell or row can be selected, otherwise false
     * @category Selection
     */
    isSelectable(recordCellOrId) {
      return this.normalizeCellContext({ id: recordCellOrId.id || recordCellOrId }).isSelectable;
    }
    /**
     * The last selected record. Set to select a row or use Grid#selectRow. Set to null to
     * deselect all
     * @property {Core.data.Model}
     * @category Selection
     */
    get selectedRecord() {
      return this.selectedRecords[this.selectedRecords.length - 1] || null;
    }
    set selectedRecord(record) {
      this.selectRow({ record });
    }
    /**
     * Selected records.
     *
     * If {@link #config-selectionMode deselectFilteredOutRecords} is `false` (default) this will include selected
     * records which has been filtered out.
     *
     * If {@link #config-selectionMode preserveSelectionOnPageChange} is `true` (defaults to `false`) this will include
     * selected records on all pages.
     *
     * If {@link #config-selectionMode selectRecordOnCell} is `true` (default) this will include any record which has at
     * least one cell selected.
     *
     * Can be set as array of ids:
     *
     * ```javascript
     * grid.selectedRecords = [1, 2, 4, 6]
     * ```
     *
     * @property {Core.data.Model[]}
     * @accepts {Core.data.Model[]|Number[]}
     * @category Selection
     */
    get selectedRecords() {
      return this.selectedRecordCollection.values;
    }
    set selectedRecords(selectedRecords) {
      this.selectRows(selectedRecords);
    }
    /**
     * Selected records. Records selected via cell selection is excluded.
     *
     * If {@link #config-selectionMode deselectFilteredOutRecords} is `false` (default) this will include selected
     * records which has been filtered out.
     *
     * If {@link #config-selectionMode preserveSelectionOnPageChange} is `true` (defaults to `false`) this will include
     * selected records on all pages.
     *
     * if {@link #config-selectionMode selectRecordOnCell} is `false` this will return same records as
     * {@link #property-selectedRecords}.
     *
     * Can be set as array of ids:
     *
     * ```javascript
     * grid.selectedRecords = [1, 2, 4, 6]
     * ```
     *
     * @property {Core.data.Model[]}
     * @accepts {Core.data.Model[]|Number[]}
     * @category Selection
     */
    get selectedRows() {
      return [...this._selectedRows];
    }
    set selectedRows(selectedRows) {
      this.selectRows(selectedRows);
    }
    /**
     * Removes and adds records to/from the selection at the same time. Analogous to the `Array` `splice` method.
     *
     * Note that if records that are specified for removal are also in the `toAdd` array, then those records are *not*
     * removed and then appended. They remain in the same position relative to all remaining records.
     *
     * @param {Number} index Index at which to remove a block of records. Only valid if the second, `toRemove` argument
     * is a number.
     * @param {Core.data.Model[]|Number} toRemove Either the number of records to remove starting at the passed `index`,
     * or an array of records to remove (If an array is passed, the `index` is ignored).
     * @param  {Core.data.Model[]|Core.data.Model} toAdd A record, or an array of records to add.
     * @category Selection
     */
    spliceSelectedRecords(index, toRemove, toAdd) {
      const me = this;
      if (typeof toRemove == "number") {
        const select = [...me.selectedRecords];
        select.splice(index, toRemove, ...ArrayHelper.asArray(toAdd));
        me.performSelection(me.prepareSelection(null, select, true, true));
      } else {
        me.performSelection(me.prepareSelection(toRemove, toAdd, false, true));
      }
    }
    /**
     * Select one row
     * @param {Object|Core.data.Model|String|Number} options A record or id to select or a config object describing the
     * selection
     * @param {Core.data.Model|String|Number} options.record Record or record id, specifying null will deselect all
     * @param {Grid.column.Column} [options.column] The column to scroll into view if `scrollIntoView` is not specified as
     * `false`. Defaults to the grid's first column.
     * @param {Boolean|BryntumScrollOptions} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view
     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces
     * @fires selectionChange
     * @category Selection
     */
    selectRow(options) {
      if (typeof options === "number" || options.isModel || !("record" in options)) {
        options = {
          records: [options]
        };
      }
      ObjectHelper.assignIf(options, {
        scrollIntoView: true
      });
      this.selectRows(options);
    }
    /**
     * Select one or more rows
     * @param {Object|Core.data.Model[]|String[]|Number[]} options An array of records or ids for a record or a
     * config object describing the selection
     * @param {Core.data.Model[]|String[]|Number[]} options.records An array of records or ids for a record
     * @param {Grid.column.Column} options.column The column to scroll into view if `scrollIntoView` is not specified as
     * `false`. Defaults to the grid's first column.
     * @param {Boolean|BryntumScrollOptions} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view
     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces
     * @category Selection
     */
    selectRows(options) {
      if (!options || Array.isArray(options) || options.isModel || typeof options === "number" || !("records" in options) && !("record" in options)) {
        options = {
          records: ArrayHelper.asArray(options) || []
        };
      }
      const me = this, { store } = me, toSelect = [], {
        records = options.record ? [options.record] : [],
        // Got a record instead of records
        column = me.columns.visibleColumns[0],
        // Default
        scrollIntoView,
        addToSelection = arguments[1]
        // Backwards compatibility
      } = options;
      for (let record of records) {
        record = store.getById(record);
        if (record) {
          toSelect.push(record);
        }
      }
      if (!addToSelection) {
        me._shiftSelectRange = null;
      }
      me.performSelection(me.prepareSelection(null, toSelect, !addToSelection, true));
      if (toSelect.length && scrollIntoView) {
        return me.scrollRowIntoView(toSelect[0].id, {
          ...scrollIntoView,
          column
        });
      }
    }
    /**
     * This selects all rows. If store is filtered, this will merge the selection of all visible rows with any selection
     * made prior to filtering.
     * @privateparam {Boolean} [silent] Pass `true` not to fire any event upon selection change
     * @category Selection
     */
    selectAll(silent = false) {
      const { store } = this, records = (store.isGrouped ? store.getAllDataRecords() : store.records).filter((r) => !r.isSpecialRow);
      this.performSelection(this.prepareSelection(null, records, false, true), true, silent);
    }
    /**
     * Deselects all selected rows and cells. If store is filtered, this will unselect all visible rows only. Any
     * selections made prior to filtering remains.
     * @param {Boolean} [removeCurrentRecordsOnly] Pass `false` to clear all selected records, and `true` to only
     * clear selected records in the current set of records
     * @param {Boolean} [silent] Pass `true` not to fire any event upon selection change
     * @category Selection
     */
    deselectAll(removeCurrentRecordsOnly = false, silent = false) {
      const { store } = this, records = removeCurrentRecordsOnly ? (store.isGrouped ? store.getAllDataRecords() : store.records).filter((r) => !r.isSpecialRow) : null;
      this.performSelection(this.prepareSelection(records, null, !removeCurrentRecordsOnly), true, silent);
    }
    /**
     * Deselect one row
     * @param {Core.data.Model|String|Number} recordOrId Record or an id for a record
     * @category Selection
     */
    deselectRow(record) {
      this.deselectRows(record);
    }
    /**
     * Deselect one or more rows
     * @param {Core.data.Model|String|Number|Core.data.Model[]|String[]|Number[]} recordOrIds An array of records or ids
     * for a record
     * @category Selection
     */
    deselectRows(recordsOrIds) {
      const { store } = this, records = ArrayHelper.asArray(recordsOrIds).map((recordOrId) => store.getById(recordOrId)).filter((rec) => rec);
      this.performSelection(this.prepareSelection(records));
    }
    /**
     * Selects rows corresponding to a range of records (from fromId to toId)
     * @param {String|Number} fromId
     * @param {String|Number} toId
     * @category Selection
     */
    selectRange(fromId, toId, addToSelection = false) {
      const me = this, { store } = me, selection = me.internalSelectRange(store.getById(fromId), store.getById(toId), true);
      me._shiftSelectRange = null;
      me.performSelection(selection);
    }
    // endregion
    // region Public cell selection
    /**
     * In cell selection mode, this will get the cell selector for the (last) selected cell. Set to an available cell
     * selector to select only that cell. Or use {@link #function-selectCell()} instead.
     * @property {Grid.util.Location}
     * @accepts {Grid.util.Location|LocationConfig}
     * @category Selection
     */
    get selectedCell() {
      return this._selectedCells[this._selectedCells.length - 1];
    }
    set selectedCell(cellSelector) {
      this.selectCells([cellSelector]);
    }
    /**
     * In cell selection mode, this will get the cell selectors for all selected cells. Set to an array of available
     * cell selectors. Or use {@link #function-selectCells()} instead.
     * @property {Grid.util.Location[]}
     * @accepts {Grid.util.Location[]|LocationConfig[]}
     * @category Selection
     */
    get selectedCells() {
      return [...this._selectedCells];
    }
    set selectedCells(cellSelectors) {
      this.selectCells(cellSelectors);
    }
    /**
     * CSS selector for the currently selected cell. Format is "[data-index=index] [data-column-id=column]".
     * @type {String}
     * @category Selection
     * @readonly
     */
    get selectedCellCSSSelector() {
      const cell = this.selectedCell, row = cell && this.getRowById(cell.id);
      if (!cell || !row)
        return "";
      return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;
    }
    /**
     * If in cell selection mode, this selects one cell. If not, this selects the cell's record.
     * @param {LocationConfig|Grid.util.Location|Object} options A cell selector ({ id: rowId, columnId: 'columnId' }) or a config object
     * @param {LocationConfig|Grid.util.Location} options.cell  A cell selector ({ id: rowId, columnId: 'columnId' })
     * @param {Boolean|BryntumScrollOptions} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view
     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces
     * @param {Boolean} [options.silent] Specify `true` to not trigger any events when selecting the cell
     * @returns {Grid.util.Location} Cell selector
     * @fires selectionChange
     * @category Selection
     */
    selectCell(options) {
      var _a5;
      if ("id" in options) {
        options = {
          cell: options
        };
        options = Object.assign({
          scrollIntoView: arguments[1],
          addToSelection: arguments[2],
          silent: arguments[3]
        }, options);
      }
      return (_a5 = this.selectCells(options)) == null ? void 0 : _a5[0];
    }
    /**
     * If in cell selection mode, this selects a number of cells. If not, this selects corresponding records.
     * @param {Object|LocationConfig[]|Grid.util.Location[]} options An array of cell selectors ({ id: rowId, columnId: 'columnId' }) or a config
     * object
     * @param {LocationConfig[]|Grid.util.Location[]} options.cells An array of cell selectors { id: rowId, columnId: 'columnId' }
     * @param {Boolean|BryntumScrollOptions} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view
     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces
     * @param {Boolean} [options.silent] Specify `true` to not trigger any events when selecting the cell
     * @returns {Grid.util.Location[]} Cell selectors
     * @fires selectionChange
     * @category Selection
     */
    selectCells(options) {
      if (Array.isArray(options)) {
        options = {
          cells: options
        };
      }
      const me = this, {
        cells = options.cell ? [options.cell] : [],
        // Got a cell instead of cells
        scrollIntoView = true,
        addToSelection = false,
        silent = false
      } = options, selectionChange = me.prepareSelection(null, cells, !addToSelection);
      if (!addToSelection) {
        me._shiftSelectRange = null;
      }
      me.performSelection(selectionChange, true, silent);
      if (scrollIntoView) {
        me.scrollRowIntoView(cells[0].id, {
          ...scrollIntoView,
          column: cells[0].columnId
        });
      }
      return me.isCellSelectionMode ? selectionChange.selectedCells : selectionChange.selectedRecords;
    }
    /**
     * If in cell selection mode, this deselects one cell. If not, this deselects the cell's record.
     * @param {LocationConfig|Grid.util.Location} cellSelector
     * @returns {Grid.util.Location} Normalized cell selector
     * @category Selection
     */
    deselectCell(cellSelector) {
      var _a5;
      return (_a5 = this.deselectCells([cellSelector])) == null ? void 0 : _a5[0];
    }
    /**
     * If in cell selection mode, this deselects a number of cells. If not, this deselects corresponding records.
     * @param {LocationConfig[]|Grid.util.Location[]} cellSelectors
     * @returns {Grid.util.Location[]} Normalized cell selectors
     * @category Selection
     */
    deselectCells(cellSelectors) {
      const selectionChange = this.prepareSelection(cellSelectors);
      this.performSelection(selectionChange);
      return this.isCellSelectionMode ? selectionChange.deselectedCells : selectionChange.deselectedRecords;
    }
    // Used by keymap to toggle selection of currently focused cell.
    toggleSelection(keyEvent) {
      const me = this, {
        _focusedCell,
        selectionMode
      } = me, isRowNumber = me.isRowNumberSelecting(_focusedCell), isSelected = me.isCellSelected(_focusedCell, true);
      if (selectionMode.selectOnKeyboardNavigation === true || _focusedCell.isActionable) {
        return false;
      }
      me.performSelection(
        me.prepareSelection(
          isSelected ? _focusedCell : null,
          isSelected ? null : _focusedCell,
          !selectionMode.multiSelect,
          isRowNumber
        )
      );
      keyEvent.preventDefault();
    }
    /**
     * Selects a range of cells, from a cell selector (Location) to another
     * @param {Grid.util.Location|LocationConfig} from
     * @param {Grid.util.Location|LocationConfig} to
     * @category Selection
     */
    selectCellRange(from, to) {
      this.performSelection(this.internalSelectRange(from, to));
    }
    // endregion
    // region Private convenience functions & properties
    getSelection() {
      if (this.isRowSelectionMode) {
        return this.selectedRecords;
      } else {
        return this.selectedCells;
      }
    }
    // Makes sure the same record or cell isn't deselected and selected at the same time. Selection will take precedence
    cleanSelectionChange(selectionChange) {
      var _a5, _b;
      const {
        deselectedRecords,
        deselectedCells,
        selectedCells,
        deselectedCellRecords
      } = selectionChange, selectedRecordIds = (_a5 = selectionChange.selectedRecords) == null ? void 0 : _a5.map((r) => r.id), selectedCellRecordIds = (_b = selectionChange.selectedCellRecords) == null ? void 0 : _b.map((r) => r.id);
      if ((deselectedRecords == null ? void 0 : deselectedRecords.length) && (selectedRecordIds == null ? void 0 : selectedRecordIds.length)) {
        selectionChange.deselectedRecords = deselectedRecords.filter((dr) => !selectedRecordIds.includes(dr.id));
      }
      if ((deselectedCells == null ? void 0 : deselectedCells.length) && (selectedCells == null ? void 0 : selectedCells.length)) {
        selectionChange.deselectedCells = deselectedCells.filter((dc) => !selectedCells.some((sc) => dc.equals(sc, true)));
      }
      if (deselectedCellRecords.length && (selectedCellRecordIds.length || (selectedRecordIds == null ? void 0 : selectedRecordIds.length))) {
        selectionChange.deselectedCellRecords = deselectedCellRecords.filter((dcr) => {
          return !selectedCellRecordIds.includes(dcr.id) && !selectedRecordIds.includes(dcr.id);
        });
      }
      return selectionChange;
    }
    getSelectedCellsForRecords(records) {
      return this._selectedCells.filter((cell) => cell.id && records.some((record) => record.id === cell.id));
    }
    delayUntilMouseUp(fn) {
      const detacher2 = EventHelper.on({
        element: this.selectionDragMouseEventListenerElement,
        blur: (ev) => fn(ev, detacher2),
        mouseup: (ev) => fn(ev, detacher2),
        thisObj: this,
        once: true
      });
    }
    get isRowSelectionMode() {
      return !this.isCellSelectionMode;
    }
    get isCellSelectionMode() {
      return this.selectionMode.cell === true;
    }
    // Checks if rowNumber is activated and that all arguments (cellselectors) is of type rownumber
    isRowNumberSelecting(...selectors) {
      return this.selectionMode.rowNumber && !selectors.some((cs) => cs.column.type !== "rownumber");
    }
    selectionShouldIncludeChildren(record) {
      var _a5;
      const { includeChildren, multiSelect } = this.selectionMode;
      return (includeChildren === "always" || includeChildren === true && this._isCheckboxSelecting) && multiSelect && !record.isLeaf && ((_a5 = record.allChildren) == null ? void 0 : _a5.length);
    }
    // endregion
    //region Navigation
    // Used by keyMap to extend selection range
    extendSelectionLeft() {
      this.extendSelection("Left");
    }
    // Used by keyMap to extend selection range
    extendSelectionRight() {
      this.extendSelection("Right");
    }
    // Used by keyMap to extend selection range
    extendSelectionUp() {
      this.extendSelection("Up");
    }
    // Used by keyMap to extend selection range
    extendSelectionDown() {
      this.extendSelection("Down");
    }
    // Used by keyMap to extend selection range
    extendSelection(dir) {
      this._isKeyboardRangeSelecting = true;
      this["navigate" + dir]();
      this._isKeyboardRangeSelecting = false;
    }
    // Called from GridNavigation on mouse or keyboard events
    // Single entry point for all default user selection actions
    onCellNavigate(me, fromCellSelector, toCellSelector, doSelect) {
      var _a5, _b;
      const {
        selectionMode,
        _selectionListenersDetachers
      } = me, { multiSelect, deselectOnClick, dragSelect } = selectionMode, { ctrlKeyDown, shiftKeyDown } = GlobalEvents_default, isMouseLeft = GlobalEvents_default.isMouseDown(), isMouseRight = GlobalEvents_default.isMouseDown(2), currentEvent = GlobalEvents_default.currentMouseDown || GlobalEvents_default.currentKeyDown;
      toCellSelector = me.normalizeCellContext(toCellSelector);
      if (me.selectionDisabled || !doSelect || // Do not affect selection if navigating into header row.
      toCellSelector.rowIndex === -1 || ((_a5 = toCellSelector.record) == null ? void 0 : _a5.isGroupHeader) || // Don't allow keyboard selection if keyboardNavigation is deactivated
      (currentEvent == null ? void 0 : currentEvent.fromKeyMap) && !selectionMode.selectOnKeyboardNavigation || // CheckColumn events are handled by the CheckColumn itself.
      me.columns.getById(toCellSelector.columnId) === me.checkboxSelectionColumn || selectionMode.checkboxOnly || // Don't select if event was handled elsewhere
      (currentEvent == null ? void 0 : currentEvent.handled) === true) {
        return;
      }
      if (!shiftKeyDown) {
        me._isAddingToSelection = ctrlKeyDown && multiSelect;
        me._selectionStartCell = toCellSelector;
      }
      if (multiSelect && dragSelect && isMouseLeft && !_selectionListenersDetachers.selectiondrag && !me.preventDragSelect) {
        _selectionListenersDetachers.selectiondrag = EventHelper.on({
          name: "selectiondrag",
          element: me.selectionDragMouseEventListenerElement,
          blur: "onSelectionEnd",
          mouseup: {
            handler: "onSelectionEnd",
            element: globalThis
          },
          mousemove: "onSelectionDrag",
          thisObj: me
        });
      }
      me.preventDragSelect = false;
      const startCell = me._selectionStartCell, adding = me._isAddingToSelection;
      if ((shiftKeyDown && isMouseLeft || me._isKeyboardRangeSelecting) && startCell && multiSelect) {
        me.performSelection(
          me.internalSelectRange(
            startCell,
            toCellSelector,
            me.isRowNumberSelecting(startCell, toCellSelector)
          )
        );
      } else {
        let delay = false, continueSelecting = true, deselect;
        if (me.isCellSelected(toCellSelector, true)) {
          if (isMouseRight) {
            return;
          }
          if (adding || deselectOnClick) {
            deselect = deselectOnClick ? null : [toCellSelector];
            continueSelecting = false;
          } else if (me.selectedRecords.length + (me.isCellSelectionMode ? me._selectedCells.length : 0) <= 1) {
            return;
          }
          delay = deselectOnClick || multiSelect;
        }
        if (!deselect && !adding) {
          deselect = null;
          if (dragSelect && delay && _selectionListenersDetachers.selectiondrag) {
            me._clearSelectionOnSelectionDrag = true;
          }
        }
        const finishSelection = (mouseUpEvent, detacher2) => {
          var _a6;
          detacher2 == null ? void 0 : detacher2();
          if (((_a6 = mouseUpEvent == null ? void 0 : mouseUpEvent.target) == null ? void 0 : _a6.nodeType) === Node.ELEMENT_NODE) {
            const mouseUpSelector = new Location(mouseUpEvent.target);
            if ((mouseUpSelector == null ? void 0 : mouseUpSelector.grid) && !mouseUpSelector.equals(toCellSelector, true)) {
              return;
            }
          }
          if (!shiftKeyDown) {
            me._shiftSelectRange = null;
          }
          me.performSelection(
            me.prepareSelection(
              deselect,
              continueSelecting && [toCellSelector],
              deselect === null,
              continueSelecting && me.isRowNumberSelecting(toCellSelector)
            )
          );
        };
        if ((_b = me.features.rowReorder) == null ? void 0 : _b.isDragging) {
          return;
        }
        if (delay) {
          me.delayUntilMouseUp(finishSelection);
        } else {
          finishSelection();
        }
      }
    }
    // endregion
    // region Internal selection & deselection functions
    /**
     * Used internally to prepare a number of cells or records for selection/deselection depending on if cell
     * selectionMode is activated. This function will not select/deselect anything by itself
     * (that's done in performSelection).
     * @param {LocationConfig[]|Core.data.Model[]} cellSelectorsToDeselect Array of cell selectors or records.
     * @param {LocationConfig[]|Core.data.Model[]} cellSelectorsToSelect Array of cell selectors or records.
     * @param {Boolean} deselectAll Set to `true` to clear all selected records and cells.
     * @param {Boolean} forceRecordSelection Set to `true` to force record selection even if cell selection is active.
     * @returns {Object} selectionChange object to use for UI update
     * @private
     * @category Selection
     */
    prepareSelection(cellSelectorsToDeselect, cellSelectorsToSelect, deselectAll = false, forceRecordSelection = false) {
      const me = this, isDragging = me._isSelectionDragging, {
        includeParents,
        selectRecordOnCell
      } = me.selectionMode, selectedCells = [], deselectedCells = deselectAll ? me._selectedCells : [], selectedRecords = [], deselectedRecords = deselectAll ? me._selectedRows : [], deselectedRecordIndex = ArrayHelper.keyBy(deselectedRecords, "id", () => 1), deselectedCellRecords = deselectAll ? me.selectedRecords.filter((r) => !deselectedRecordIndex[r.id]) : [];
      let selectedCellRecords = [];
      if (!deselectAll && cellSelectorsToDeselect) {
        for (const selector of ArrayHelper.asArray(cellSelectorsToDeselect)) {
          const cellSelector = me.normalizeCellContext(selector), record = (cellSelector == null ? void 0 : cellSelector.record) || (selector.isModel ? selector : me.store.getById(cellSelector.id));
          if (cellSelector.isSpecialRow) {
            continue;
          }
          deselectedCells.push(cellSelector);
          if (record && !deselectedRecordIndex[record.id]) {
            if (isDragging || me.isSelected(record)) {
              deselectedRecords.push(record);
              deselectedRecordIndex[record.id] = 1;
            } else if (selectRecordOnCell && me.selectedRecordCollection.get(record.id) && !deselectedCellRecords.some((dr) => dr.id === record.id)) {
              deselectedCellRecords.push(record);
            }
            if (me.selectionShouldIncludeChildren(record)) {
              for (const child of record.allChildren) {
                if (!deselectedRecordIndex[child.id] && (isDragging || me.isSelected(child))) {
                  deselectedRecords.push(child);
                  deselectedRecordIndex[record.id] = 1;
                }
              }
            }
          }
        }
      }
      if (cellSelectorsToSelect) {
        const selectedRecordIndex = {};
        for (const selector of ArrayHelper.asArray(cellSelectorsToSelect)) {
          const cellSelector = me.normalizeCellContext(selector), record = (cellSelector == null ? void 0 : cellSelector.record) || (selector.isModel ? selector : me.store.getById(cellSelector.id));
          if (!record || cellSelector.isSpecialRow) {
            continue;
          }
          if (me.isCellSelectionMode && !forceRecordSelection) {
            selectedCells.push(cellSelector);
          }
          if ((me.isRowSelectionMode || forceRecordSelection) && !selectedRecordIndex[record.id]) {
            selectedRecords.push(record);
            selectedRecordIndex[record.id] = 1;
            if (me.selectionShouldIncludeChildren(record)) {
              for (const child of record.allChildren) {
                if (!selectedRecordIndex[child.id]) {
                  selectedRecords.push(child);
                  selectedRecordIndex[child.id] = 1;
                }
              }
            }
          }
        }
        if (selectRecordOnCell && selectedCells.length) {
          selectedCellRecords = ArrayHelper.unique(selectedCells.map((c) => c.record)).filter((r) => !selectedRecordIndex[r.id]);
        }
      }
      if (includeParents && (deselectedRecords.length || selectedRecords.length)) {
        const allChanges = [...deselectedRecords, ...selectedRecords], lowestLevelParents = ArrayHelper.unique(
          allChanges.filter((rec) => rec.parent && !rec.allChildren.some((child) => allChanges.includes(child))).map((rec) => rec.parent)
        );
        lowestLevelParents.forEach((parent) => me.toggleParentSelection(parent, selectedRecords, deselectedRecords));
      }
      return me.cleanSelectionChange({
        selectedCells,
        selectedRecords,
        deselectedCells,
        deselectedRecords,
        deselectAll,
        action: (selectedRecords == null ? void 0 : selectedRecords.length) || (selectedCells == null ? void 0 : selectedCells.length) ? "select" : "deselect",
        selectedCellRecords,
        deselectedCellRecords
      });
    }
    toggleParentSelection(parent, toSelect, toDeselect) {
      if (!parent || parent.isRoot) {
        return;
      }
      const isSelected = this.isSelected(parent), inToSelect = toSelect.includes(parent), inToDeselect = toDeselect.includes(parent), childIsSelected = (child) => this.isSelected(child) && !toDeselect.includes(child) || toSelect.includes(child);
      if (this.selectionMode.includeParents === "some") {
        if (parent.allChildren.some(childIsSelected)) {
          if ((!isSelected || inToDeselect) && !inToSelect) {
            toSelect.push(parent);
          }
        } else if (isSelected && !inToDeselect) {
          toDeselect.push(parent);
        }
      } else {
        if (isSelected) {
          if (!inToDeselect && !inToSelect && parent.allChildren.some((child) => toDeselect.includes(child))) {
            toDeselect.push(parent);
          }
        } else if (!inToSelect) {
          if (parent.allChildren.every(childIsSelected)) {
            toSelect.push(parent);
          }
        }
      }
      if (parent.parent) {
        this.toggleParentSelection(parent.parent, toSelect, toDeselect);
      }
    }
    /**
     * Used internally to select a range of cells or records depending on selectionMode. Used in both shift-selection
     * and for drag selection. Will remember current selection range and replace it with new one when it changes. But a
     * range which is completed (drag select mouse up or a new shift range starting point has been set) will remain.
     * This function will not update UI (that's done in refreshGridSelectionUI).
     * @param {LocationConfig} fromSelector
     * @param {LocationConfig} toSelector
     * @returns {Object} selectionChange object to use for UI update
     * @private
     * @category Selection
     */
    internalSelectRange(fromSelector, toSelector, forceRecordSelection = false) {
      const me = this, selectRecords = me.isRowSelectionMode || forceRecordSelection, selectionChange = me.prepareSelection(
        me._shiftSelectRange,
        me.getRange(fromSelector, toSelector, selectRecords),
        false,
        forceRecordSelection
      );
      me._shiftSelectRange = selectionChange[`selected${selectRecords ? "Records" : "Cells"}`];
      return selectionChange;
    }
    /**
     * Used internally to get a range of cell selectors from a start selector to an end selector.
     * @private
     */
    getRange(fromSelector, toSelector, selectRecords = false) {
      const me = this, { store } = me, fromCell = me.normalizeCellContext(fromSelector), toCell = me.normalizeCellContext(toSelector), startRowIndex = Math.min(fromCell.rowIndex, toCell.rowIndex), endRowIndex = Math.max(fromCell.rowIndex, toCell.rowIndex), toSelect = [], startColIndex = Math.min(fromCell.columnIndex, toCell.columnIndex), endColIndex = Math.max(fromCell.columnIndex, toCell.columnIndex);
      if (startRowIndex === -1 || endRowIndex === -1) {
        throw new Error("Record not found in selectRange");
      }
      if (selectRecords) {
        const range = store.getRange(startRowIndex, endRowIndex + 1, false);
        if (toCell.rowIndex < fromCell.rowIndex) {
          range.reverse();
        }
        toSelect.push(...range);
      } else {
        for (let rIx = startRowIndex; rIx <= endRowIndex; rIx++) {
          for (let cIx = startColIndex; cIx <= endColIndex; cIx++) {
            toSelect.push({ rowIndex: rIx, columnIndex: cIx });
          }
        }
      }
      return toSelect.map((s) => me.normalizeCellContext(s));
    }
    // endregion
    // region Update UI & trigger events
    performSelection(selectionChange, updateUI = true, silent = false) {
      const me = this, {
        selectedRecords = [],
        selectedCells = [],
        selectedCellRecords = [],
        deselectedRecords = [],
        deselectedCells = [],
        deselectedCellRecords = [],
        action
      } = selectionChange, allSelectedRecords = [...selectedRecords, ...selectedCellRecords], allDeselectedRecords = [...deselectedRecords, ...deselectedCellRecords], rowMode = me.isRowSelectionMode;
      if (me.trigger("beforeSelectionChange", {
        mode: rowMode ? "row" : "cell",
        action,
        selected: allSelectedRecords,
        deselected: allDeselectedRecords,
        selection: me.selectedRecords,
        selectedCells,
        deselectedCells,
        cellSelection: me.selectedCells
      }) === false) {
        return false;
      }
      if (me._selectedCells === deselectedCells) {
        me._selectedCells = [];
      } else {
        const keepCells = [];
        for (const selectedCell of me._selectedCells) {
          if (!deselectedCells.some((cellSelector) => selectedCell.equals(cellSelector, true))) {
            keepCells.push(selectedCell);
          }
        }
        me._selectedCells = keepCells;
      }
      selectionChange.deselectedRecords = [...deselectedRecords];
      if (deselectedRecords === me._selectedRows) {
        me.changeSelectedRecordCollectionSilent((c) => c.clear());
        me._selectedRows.length = 0;
      } else {
        const keepRecords = [], keepInCollection = [], allDeselectedRecordsIndex = ArrayHelper.keyBy(allDeselectedRecords, "id", () => 1);
        for (const selectedRecord of me.selectedRecords) {
          if (!allDeselectedRecordsIndex[selectedRecord.id]) {
            if (me.isSelected(selectedRecord)) {
              keepRecords.push(selectedRecord);
            } else {
              keepInCollection.push(selectedRecord);
            }
          }
        }
        me.changeSelectedRecordCollectionSilent((c) => c.values = [...keepRecords, ...keepInCollection]);
        me._selectedRows = keepRecords;
      }
      if (selectedCells.length) {
        for (const selectedCell of selectedCells) {
          if (!me._selectedCells.some((cellSelector) => cellSelector.equals(selectedCell, true))) {
            me._selectedCells.push(selectedCell);
          }
        }
      }
      if (selectedRecords.length) {
        me.changeSelectedRecordCollectionSilent((c) => c.add(...selectedRecords));
        me._selectedRows.push(...selectedRecords.filter((r) => !me._selectedRows.some((sr) => sr.id === r.id)));
      }
      if (selectedCellRecords.length) {
        me.changeSelectedRecordCollectionSilent((c) => c.add(...selectedCellRecords));
      }
      if (updateUI) {
        me.refreshGridSelectionUI(selectionChange);
      }
      me.afterSelectionChange(selectionChange);
      if (!silent) {
        me.triggerSelectionChangeEvent(selectionChange);
      }
    }
    // Makes sure the DOM is up-to-date with current selection.
    refreshGridSelectionUI({ selectedRecords, selectedCells, deselectedRecords, deselectedCells }) {
      const me = this, { checkboxSelectionColumn } = me;
      checkboxSelectionColumn == null ? void 0 : checkboxSelectionColumn.suspendEvents();
      me.updateGridSelectionRecords(selectedRecords, true);
      me.updateGridSelectionRecords(deselectedRecords, false);
      me.updateCheckboxHeader();
      checkboxSelectionColumn == null ? void 0 : checkboxSelectionColumn.resumeEvents();
      if (me.isCellSelectionMode) {
        me.updateGridSelectionCells(selectedCells, true);
        if (me.selectionMode.column) {
          me.updateGridSelectionColumns(selectedCells);
        }
      }
      me.updateGridSelectionCells(deselectedCells, false);
    }
    // Loops through records and updates Grid rows
    updateGridSelectionRecords(records, selected) {
      const { checkboxSelectionColumn } = this;
      if (records == null ? void 0 : records.length) {
        for (let i = 0; i < records.length; i++) {
          const row = this.getRowFor(records[i]);
          if (row) {
            row.toggleCls("b-selected", selected);
            row.setAttribute("aria-selected", selected);
            if (checkboxSelectionColumn && !checkboxSelectionColumn.hidden && !records[i].isSpecialRow) {
              row.getCell(checkboxSelectionColumn.id).widget.checked = selected;
            }
          }
        }
      }
    }
    // Loops through cell selectors and updates Grid cell's
    updateGridSelectionCells(cells, selected) {
      if (cells == null ? void 0 : cells.length) {
        for (let i = 0; i < cells.length; i++) {
          const cell = this.getCell(cells[i]);
          if (cell) {
            cell.setAttribute("aria-selected", selected);
            cell.classList.toggle("b-selected", selected);
          }
        }
      }
    }
    // Loops through columns to toggle their selected state
    updateGridSelectionColumns(selectedCells) {
      var _a5;
      const { count } = this.store;
      for (const column of this.columns.visibleColumns) {
        (_a5 = column.element) == null ? void 0 : _a5.classList.toggle(
          "b-selected",
          (selectedCells == null ? void 0 : selectedCells.filter((s) => s.columnId === column.id).length) === count
        );
      }
    }
    triggerSelectionChangeEvent(selectionChange) {
      const {
        selectedRecords = [],
        selectedCells = [],
        selectedCellRecords = [],
        deselectedRecords = [],
        deselectedCells = [],
        deselectedCellRecords = []
      } = selectionChange, allSelectedRecords = [...selectedRecords, ...selectedCellRecords], allDeselectedRecords = [...deselectedRecords, ...deselectedCellRecords], rowMode = this.isRowSelectionMode;
      this.trigger("selectionChange", {
        mode: rowMode ? "row" : "cell",
        action: selectionChange.action,
        selected: allSelectedRecords,
        deselected: allDeselectedRecords,
        selection: this.selectedRecords,
        selectedCells,
        deselectedCells,
        cellSelection: this.selectedCells
      });
    }
    //endregion
    doDestroy() {
      var _a5;
      ((_a5 = this.selectedRecordCollection) == null ? void 0 : _a5.owner) === this && this.selectedRecordCollection.destroy();
      this._selectedCells.length = 0;
      this._selectedRows.length = 0;
      for (const detacher2 in this._selectionListenersDetachers) {
        this._selectionListenersDetachers[detacher2]();
      }
      super.doDestroy();
    }
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {
    }
  }, __publicField(_a4, "configurable", {
    /**
     * Selection configuration settings, change these properties to control how selection works and what can be
     * selected.
     *
     * When *configuring* (creating an instance), set this to an object containing only those properties you want to
     * *change*.
     *
     * ```javascript
     * new Grid({
     *     selectionMode : {
     *        // Enables cell selection
     *        cell       : true,
     *        // Enabled cell and record selection by dragging
     *        dragSelect : true,
     *        // Enables selection of a column's cells by clicking the column header
     *        column     : true,
     *        // Shows a row number column which, when clicked, selected the row/record
     *        rowNumber  : true
     *     }
     * });
     * ````
     *
     * After the configuring is done, these properties will be monitored for changes, making it possible to alter
     * the selection configuration at any time.
     *
     * ````javascript
     * // Adds a selection checkbox column and makes that the only way to select
     * grid.selectionMode.checkboxOnly = true;
     *
     * // Deactivates the auto selection of rows and cells when keyboard navigating
     * grid.selectionMode.selectOnKeyboardNavigation = false;
     * ````
     *
     * @prp {GridSelectionMode} selectionMode
     * @includetypedef
     * @default
     * @category Selection
     */
    selectionMode: {
      cell: false,
      multiSelect: true,
      checkboxOnly: false,
      checkbox: false,
      checkboxPosition: null,
      showCheckAll: false,
      deselectFilteredOutRecords: false,
      includeChildren: false,
      includeParents: false,
      preserveSelectionOnPageChange: false,
      preserveSelectionOnDatasetChange: true,
      deselectOnClick: false,
      dragSelect: false,
      selectOnKeyboardNavigation: true,
      column: false,
      rowNumber: false,
      selectRecordOnCell: true
    },
    keyMap: {
      "Shift+ArrowUp": "extendSelectionUp",
      "Shift+ArrowDown": "extendSelectionDown",
      "Shift+ArrowLeft": "extendSelectionLeft",
      "Shift+ArrowRight": "extendSelectionRight",
      " ": { handler: "toggleSelection", weight: 10 }
    },
    selectedRecordCollection: {},
    selectionDisabled: false
  }), _a4;
};

// lib/Grid/view/mixin/GridState.js
var suspendStoreEvents = (subGrid) => subGrid.columns.suspendEvents();
var resumeStoreEvents = (subGrid) => subGrid.columns.resumeEvents();
var fillSubGridColumns = (subGrid) => {
  subGrid.columns.clearCaches();
  subGrid.columns.fillFromMaster();
};
var compareStateSortIndex = (a, b) => a.stateSortIndex - b.stateSortIndex;
var GridState_default = (Target) => {
  var _a4;
  return _a4 = class extends (Target || Base) {
    /**
     * Gets or sets grid's state. Check out {@link Grid.view.mixin.GridState} mixin for details.
     * @member {Object} state
     * @property {Object[]} state.columns
     * @property {Number} state.rowHeight
     * @property {Object} state.scroll
     * @property {Number} state.scroll.scrollLeft
     * @property {Number} state.scroll.scrollTop
     * @property {Array} state.selectedRecords
     * @property {String} state.style
     * @property {String} state.selectedCell
     * @property {Object} state.store
     * @property {Sorter[]} state.store.sorters
     * @property {Grouper[]} state.store.groupers
     * @property {CollectionFilterConfig[]} state.store.filters
     * @property {String[]} state.store.collapsedGroups
     * @property {Object} state.subGrids
     * @category State
     */
    updateStore(store, was) {
      var _a5;
      (_a5 = super.updateStore) == null ? void 0 : _a5.call(this, store, was);
      this.detachListeners("stateStoreListeners");
      store == null ? void 0 : store.ion({
        name: "stateStoreListeners",
        filter: "triggerUpdate",
        group: "triggerUpdate",
        sort: "triggerUpdate",
        thisObj: this
      });
    }
    updateColumns(columns, was) {
      var _a5;
      (_a5 = super.updateColumns) == null ? void 0 : _a5.call(this, columns, was);
      this.detachListeners("stateColumnListeners");
      columns.ion({
        name: "stateColumnListeners",
        change: "triggerUpdate",
        sort: "triggerUpdate",
        thisObj: this
      });
    }
    updateRowManager(manager, was) {
      var _a5;
      (_a5 = super.updateRowManager) == null ? void 0 : _a5.call(this, manager, was);
      this.detachListeners("stateRowManagerListeners");
      manager.ion({
        name: "stateRowManagerListeners",
        rowHeight: "triggerUpdate",
        thisObj: this
      });
    }
    triggerUpdate() {
      this.trigger("stateChange");
    }
    finalizeInit() {
      super.finalizeInit();
      this.ion({
        selectionChange: "triggerUpdate",
        toggleGroup: ({ allRecords }) => !allRecords && this.triggerUpdate(),
        thisObj: this
      });
    }
    /**
     * Get grid's current state for serialization. State includes rowHeight, headerHeight, selectedCell,
     * selectedRecordId, column states and store state etc.
     * @returns {Object} State object to be serialized
     * @private
     */
    getState() {
      const me = this, style = me.element.style.cssText, state = {
        rowHeight: me.rowHeight
      };
      if (style) {
        state.style = style;
      }
      if (me.selectedCell) {
        const { id, columnId } = me.selectedCell;
        state.selectedCell = { id, columnId };
      }
      if (!me.disableGridColumnIdWarning && me.columns.find((c) => c.meta.generatedId === c.id)) {
        console.warn("Column(s) without id detected. When saving and restoring state, columns without a configured id can be restored incorrectly.");
      }
      state.selectedRecords = me.selectedRecords.map((entry) => entry.id);
      state.columns = me.columns.allRecords.map((column) => column.getState());
      state.store = me.store.state;
      state.scroll = me.storeScroll();
      state.subGrids = {};
      me.eachSubGrid((subGrid) => {
        var _a5;
        const config = state.subGrids[subGrid.region] = state.subGrids[subGrid.region] || {};
        if (subGrid.isPainted) {
          if (subGrid.flex == null) {
            config.width = subGrid.width;
          }
        } else {
          if (subGrid.config.width != null) {
            config.width = subGrid.config.width;
          } else {
            config.flex = subGrid.config.flex;
          }
        }
        config.collapsed = (_a5 = subGrid.collapsed) != null ? _a5 : false;
        if (config.collapsed) {
          config._beforeCollapseState = subGrid._beforeCollapseState;
        }
      });
      return state;
    }
    /**
     * Apply previously stored state.
     * @param {Object} state
     * @private
     */
    applyState(state) {
      const me = this, { columns } = me;
      me.suspendRefresh();
      if ("columns" in state) {
        let columnsChanged = false, needSort = false;
        columns.suspendEvents();
        me.eachSubGrid(suspendStoreEvents);
        state.columns.forEach((columnState, index) => {
          const column = columns.lookupStateColumn(columnState);
          if (column) {
            const columnGeneration = column.generation;
            if ("region" in columnState && !(columnState.region in me.subGrids)) {
              delete columnState.region;
              delete columnState.locked;
            }
            column.applyState(columnState);
            columnsChanged = columnsChanged || column.generation !== columnGeneration;
            column.stateSortIndex = index;
            if (column.allIndex !== index) {
              needSort = columnsChanged = true;
            }
          }
        });
        state.columns.forEach((columnState) => {
          if ("parentId" in columnState) {
            const parentStateConfig = state.columns.find((cfg) => cfg.id === columnState.parentId), parentColumn = parentStateConfig && columns.lookupStateColumn(parentStateConfig), childCol = columns.lookupStateColumn(columnState);
            if (parentColumn && childCol && childCol.parent !== parentColumn) {
              parentColumn.insertChild(childCol);
            }
          }
        });
        if (columnsChanged) {
          me.eachSubGrid(fillSubGridColumns);
        }
        if (needSort) {
          me.eachSubGrid((subGrid) => {
            subGrid.columns.records.sort(compareStateSortIndex);
            subGrid.columns.allRecords.sort(compareStateSortIndex);
          });
          columns.sort({
            fn: compareStateSortIndex,
            // always sort ascending
            ascending: true
          });
        }
        if (me.isPainted && columnsChanged) {
          me.renderContents();
        }
        columns.resumeEvents();
        me.eachSubGrid(resumeStoreEvents);
      }
      if ("subGrids" in state) {
        me.eachSubGrid((subGrid) => {
          if (subGrid.region in state.subGrids) {
            const subGridState = state.subGrids[subGrid.region];
            if ("width" in subGridState) {
              subGrid.width = subGridState.width;
            } else if ("flex" in subGridState) {
              subGrid.flex = subGridState.flex;
            }
            if ("collapsed" in subGridState) {
              subGrid.collapsed = subGridState.collapsed;
              subGrid._beforeCollapseState = subGridState._beforeCollapseState;
            }
          }
          subGrid.clearWidthCache();
        });
      }
      if ("rowHeight" in state) {
        me.rowHeight = state.rowHeight;
      }
      if ("style" in state) {
        me.style = state.style;
      }
      if ("selectedCell" in state) {
        me.selectedCell = state.selectedCell;
      }
      if ("store" in state) {
        me.store.state = state.store;
      }
      if ("selectedRecords" in state) {
        me.selectedRecords = state.selectedRecords;
      }
      me.resumeRefresh(true);
      me.whenVisible(() => me.applyScrollState(state));
    }
    applyScrollState(state) {
      const me = this;
      me.eachSubGrid((s) => s.refreshFakeScroll());
      if ("scroll" in state) {
        me.restoreScroll(state.scroll);
        if (state.scroll.scrollTop) {
          me.element.querySelectorAll(".b-resize-monitored").forEach((element) => {
            const widget = WidgetHelper.fromElement(element);
            if (widget) {
              widget.onElementResize(element);
            }
          });
        }
      }
    }
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {
    }
  }, __publicField(_a4, "$name", "GridState"), __publicField(_a4, "configurable", {
    statefulEvents: [
      "subGridCollapse",
      "subGridExpand",
      "horizontalScrollEnd",
      "stateChange",
      "selectionChange",
      "collapseAllGroups",
      "expandAllGroups"
    ]
  }), _a4;
};

// lib/Grid/util/SubGridScroller.js
var immediatePromise6 = Promise.resolve();
var defaultScrollOptions2 = {
  block: "nearest"
};
var SubGridScroller = class extends Scroller {
  // The Grid's main Y scroller keeps a list of the X scrollers
  updateYScroller(yScroller) {
    yScroller == null ? void 0 : yScroller.addScroller(this);
  }
  scrollIntoView(element, options = defaultScrollOptions2) {
    const me = this, { xDelta, yDelta } = me.getDeltaTo(element, options);
    let result = xDelta || yDelta ? me.scrollBy(xDelta, yDelta, options) : immediatePromise6;
    if (options.highlight || options.focus) {
      const scrollPromise2 = result;
      result = result.then(() => {
        var _a4, _b;
        if (scrollPromise2.cancelled) {
          return;
        }
        element = element instanceof Rectangle ? element : (_b = (_a4 = options.elementAfterScroll) == null ? void 0 : _a4.call(options)) != null ? _b : element;
        if (options.highlight) {
          if (element instanceof Rectangle) {
            element.translate(-xDelta, -yDelta).highlight();
          } else {
            DomHelper.highlight(element);
          }
        }
        if (options.focus) {
          element.focus({ preventScroll: true });
        }
      });
      result.cancel = () => {
        var _a4;
        return (_a4 = scrollPromise2.cancel) == null ? void 0 : _a4.call(scrollPromise2);
      };
    }
    return result;
  }
  scrollBy(xDelta, yDelta, options) {
    const yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options), xPromise = xDelta && super.scrollBy(xDelta, 0, options), result = Promise.all([xPromise, yPromise]);
    result.cancel = () => {
      var _a4, _b;
      (_a4 = xPromise == null ? void 0 : xPromise.cancel) == null ? void 0 : _a4.call(xPromise);
      (_b = yPromise == null ? void 0 : yPromise.cancel) == null ? void 0 : _b.call(yPromise);
      result.cancelled = true;
    };
    if ((xPromise == null ? void 0 : xPromise.cancel) && (yPromise == null ? void 0 : yPromise.cancel)) {
      options.force = true;
    }
    return result;
  }
  scrollTo(toX, toY, options) {
    const yPromise = toY != null && this.yScroller.scrollTo(null, toY, options), xPromise = toX != null && super.scrollTo(toX, null, options);
    if (!(options && options.animate)) {
      this.syncPartners();
    }
    const result = Promise.all([xPromise, yPromise]);
    result.cancel = () => {
      var _a4, _b;
      (_a4 = xPromise == null ? void 0 : xPromise.cancel) == null ? void 0 : _a4.call(xPromise);
      (_b = yPromise == null ? void 0 : yPromise.cancel) == null ? void 0 : _b.call(yPromise);
      result.cancelled = true;
    };
    if ((xPromise == null ? void 0 : xPromise.cancel) && (yPromise == null ? void 0 : yPromise.cancel)) {
      options.force = true;
    }
    return result;
  }
  get viewport() {
    const elementBounds = Rectangle.from(this.element), viewport = elementBounds.intersect(Rectangle.from(this.yScroller.element));
    return viewport || new Rectangle(elementBounds.x, elementBounds.y, elementBounds.width, 0);
  }
  set y(y) {
    if (this.yScroller) {
      this.yScroller.y = y;
    }
  }
  get y() {
    return this.yScroller ? this.yScroller.y : 0;
  }
  get maxY() {
    return this.yScroller ? this.yScroller.maxY : 0;
  }
  get scrollHeight() {
    return this.yScroller ? this.yScroller.scrollHeight : 0;
  }
  get clientHeight() {
    return this.yScroller ? this.yScroller.clientHeight : 0;
  }
  suspendEvents() {
    var _a4;
    super.suspendEvents();
    (_a4 = this.yScroller) == null ? void 0 : _a4.suspendEvents();
  }
  resumeEvents() {
    var _a4;
    super.resumeEvents();
    (_a4 = this.yScroller) == null ? void 0 : _a4.resumeEvents();
  }
};
// SubGrids do not drive the scrollWidth of their partners (Header and Footer)
// SubGrids scrollWidth is propagated from the Header by SubGrid.refreshFakeScroll.
__publicField(SubGridScroller, "configurable", {
  propagate: false,
  overflowX: "hidden-scroll",
  yScroller: null
});
SubGridScroller._$name = "SubGridScroller";

// lib/Grid/view/SubGrid.js
var sumWidths = (t, e) => t + e.getBoundingClientRect().width;
var SubGrid = class extends Widget {
  //endregion
  //region Init
  /**
   * SubGrid constructor
   * @param config
   * @private
   */
  construct(config) {
    super.construct(config);
    this.rowManager.ion({ addRows: "onAddRow", thisObj: this });
    if (VersionHelper.isTestEnv) {
      this.hideOverlayScroller.delay = 50;
    }
  }
  doDestroy() {
    var _a4;
    const me = this;
    me.header.destroy();
    me.footer.destroy();
    (_a4 = me.fakeScroller) == null ? void 0 : _a4.destroy();
    me.virtualScrollerElement.remove();
    me.splitterElements.forEach((element) => element.remove());
    super.doDestroy();
  }
  get barConfig() {
    const me = this, { width, flex } = me.element.style, config = {
      subGrid: me,
      parent: me,
      // Contained widgets need to know their parents
      maxWidth: me.maxWidth || void 0,
      minWidth: me.minWidth || void 0
    };
    if (flex) {
      config.flex = flex;
    } else if (width) {
      config.width = width;
    }
    return config;
  }
  changeHeader(header) {
    return new this.headerClass(ObjectHelper.assign({
      id: this.id + "-header"
    }, this.barConfig, header));
  }
  changeFooter(footer) {
    return new this.footerClass(ObjectHelper.assign({
      id: this.id + "-footer"
    }, this.barConfig, footer));
  }
  //endregion
  //region Splitters
  get splitterElements() {
    return [this.splitterElement, this.headerSplitter, this.scrollerSplitter, this.footerSplitter];
  }
  /**
   * Toggle (add/remove) class for splitters
   * @param {String} cls class name
   * @param {Boolean} [add] Set to `true` to add class, `false` to remove
   * @param {Boolean} [includePartners] Set to `true` to also process partners
   * @private
   */
  toggleSplitterCls(cls, add = true, includePartners = true) {
    this.splitterElements.forEach((el) => el == null ? void 0 : el.classList[add ? "add" : "remove"](cls));
    if (includePartners) {
      this.scrollable.eachPartner(({ scroller }) => {
        var _a4, _b;
        if (scroller.owner !== this) {
          (_b = (_a4 = scroller.owner).toggleSplitterCls) == null ? void 0 : _b.call(_a4, cls === "b-hover" ? "b-partner-splitter-hover" : "b-hover", add, false);
        }
      });
    }
  }
  hideSplitter() {
    this.splitterElements.forEach((el) => el.classList.add("b-hide-display"));
    this.$showingSplitter = false;
  }
  showSplitter() {
    this.splitterElements.forEach((el) => el.classList.remove("b-hide-display"));
    this.$showingSplitter = true;
  }
  //endregion
  //region Template
  changeElement(element, was) {
    const { region } = this;
    return super.changeElement({
      "aria-label": region,
      className: {
        "b-grid-subgrid": 1,
        [`b-grid-subgrid-${region}`]: region,
        "b-grid-subgrid-collapsed": this.collapsed
      },
      dataset: {
        region
      }
    }, was);
  }
  get rowElementConfig() {
    const { grid } = this;
    return {
      role: "row",
      className: grid.rowCls,
      children: this.columns.visibleColumns.map((column, columnIndex) => ({
        role: "gridcell",
        "aria-colindex": columnIndex + 1,
        tabIndex: grid.cellTabIndex,
        className: "b-grid-cell",
        dataset: {
          column: column.field || "",
          columnId: column.id
        }
      }))
    };
  }
  // Added to DOM in Grid `get bodyConfig`
  changeVirtualScrollerElement() {
    const references = DomHelper.createElement({
      role: "presentation",
      reference: "virtualScrollerElement",
      className: "b-virtual-scroller",
      tabIndex: -1,
      dataset: {
        region: this.region
      },
      children: [
        {
          reference: "virtualScrollerWidth",
          className: "b-virtual-width"
        }
      ]
    });
    this.virtualScrollerWidth = references.virtualScrollerWidth;
    return references.virtualScrollerElement;
  }
  changeSplitterElement() {
    const references = DomHelper.createElement({
      reference: "splitterElement",
      className: {
        "b-grid-splitter": 1,
        "b-grid-splitter-collapsed": this.collapsed,
        "b-hide-display": 1
        // GridSubGrids determines visibility
      },
      dataset: {
        region: this.region
      },
      children: [
        BrowserHelper.isTouchDevice ? { className: "b-splitter-touch-area" } : null,
        {
          className: "b-grid-splitter-inner b-grid-splitter-main",
          children: [
            {
              className: "b-grid-splitter-buttons",
              reference: "splitterButtons",
              children: [
                {
                  className: "b-grid-splitter-button-collapse",
                  children: [
                    BrowserHelper.isTouchDevice ? { className: "b-splitter-button-touch-area" } : null,
                    {
                      tag: "svg",
                      ns: "http://www.w3.org/2000/svg",
                      version: "1.1",
                      className: "b-grid-splitter-button-icon b-gridregion-collapse-arrow",
                      viewBox: "0 0 256 512",
                      children: [
                        {
                          tag: "path",
                          d: "M192 448c-8.188 0-16.38-3.125-22.62-9.375l-160-160c-12.5-12.5-12.5-32.75 0-45.25l160-160c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25L77.25 256l137.4 137.4c12.5 12.5 12.5 32.75 0 45.25C208.4 444.9 200.2 448 192 448z"
                        }
                      ]
                    }
                  ]
                },
                {
                  className: "b-grid-splitter-button-expand",
                  children: [
                    BrowserHelper.isTouchDevice ? { className: "b-splitter-button-touch-area" } : null,
                    {
                      tag: "svg",
                      ns: "http://www.w3.org/2000/svg",
                      version: "1.1",
                      className: "b-grid-splitter-button-icon b-gridregion-expand-arrow",
                      viewBox: "0 0 256 512",
                      children: [
                        {
                          tag: "path",
                          d: "M64 448c-8.188 0-16.38-3.125-22.62-9.375c-12.5-12.5-12.5-32.75 0-45.25L178.8 256L41.38 118.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0l160 160c12.5 12.5 12.5 32.75 0 45.25l-160 160C80.38 444.9 72.19 448 64 448z"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    });
    this.splitterButtons = references.splitterButtons;
    return references.splitterElement;
  }
  get splitterConfig() {
    return {
      className: this.splitterElement.className.trim(),
      children: [
        BrowserHelper.isTouchDevice ? { className: "b-splitter-touch-area" } : null,
        {
          className: "b-grid-splitter-inner"
        }
      ],
      dataset: {
        region: this.region
      }
    };
  }
  changeHeaderSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  changeScrollerSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  changeFooterSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  //endregion
  //region Render
  render(...args) {
    const me = this;
    super.render(...args);
    if (me.grid) {
      me.updateHasFlex();
      me.element.parentNode.insertBefore(me.splitterElement, me.element.nextElementSibling);
      me.splitterElements.forEach(
        (element) => EventHelper.on({
          element,
          mouseenter: "onSplitterMouseEnter",
          mouseleave: "onSplitterMouseLeave",
          thisObj: me
        })
      );
      me._collapsed && me.collapse();
    }
  }
  toggleHeaders(hide) {
    const me = this;
    if (hide) {
      me.headerSplitter.remove();
      me.header.element.remove();
      me.scrollable.removePartner(me.header.scrollable, "x");
    } else {
      const { grid } = me;
      if (!me.isConfiguring) {
        const index = grid.items.indexOf(me) * 2;
        DomHelper.insertAt(grid.headerContainer, me.headerSplitter, index);
        DomHelper.insertAt(grid.headerContainer, me.header.element, index);
        me.refreshHeader();
      }
      me.scrollable.addPartner(me.header.scrollable, "x");
    }
  }
  refreshHeader() {
    this.header.refreshContent();
  }
  refreshColumnHeader(column) {
    this.header.refreshColumn(column);
  }
  refreshFooter() {
    var _a4;
    (_a4 = this.footer) == null ? void 0 : _a4.refreshContent();
  }
  // Override to iterate header and footer.
  eachWidget(fn, deep = true) {
    const me = this, widgets = [me.header, me.footer];
    for (let i = 0; i < widgets.length; i++) {
      const widget = widgets[i];
      if (fn(widget) === false) {
        return;
      }
      if (deep && widget.eachWidget) {
        widget.eachWidget(fn, deep);
      }
    }
  }
  //endregion
  //region Size & resize
  /**
   * Sets cell widths. Cannot be done in template because of CSP
   * @private
   */
  fixCellWidths(rowElement) {
    const { visibleColumns } = this.columns;
    let cell = rowElement.firstElementChild, i = 0;
    while (cell) {
      const column = visibleColumns[i], { element } = column;
      if (column.minWidth) {
        cell.style.minWidth = DomHelper.setLength(column.minWidth);
      }
      if (column.maxWidth) {
        cell.style.maxWidth = DomHelper.setLength(column.maxWidth);
      }
      if (column.flex) {
        if (column.childLevel && element) {
          cell.style.flex = `0 0 ${element.getBoundingClientRect().width}px`;
          cell.style.width = "";
        } else {
          cell.style.flex = column.flex;
          cell.style.width = "";
        }
      } else if (column.width) {
        cell.style.width = DomHelper.setLength(column.width);
      } else {
        cell.style.flex = cell.style.width = cell.style.minWidth = "";
      }
      cell = cell.nextElementSibling;
      i++;
    }
  }
  get totalFixedWidth() {
    return this.columns.totalFixedWidth;
  }
  get headerScrollWidth() {
    return [...this.header.contentElement.children].reduce(sumWidths, 0) || this.columns.totalFixedWidth;
  }
  /**
   * Sets header width and scroller width (if needed, depending on if using flex). Might also change the subgrids
   * width, if it uses a width calculated from its columns.
   * @private
   */
  fixWidths() {
    const me = this, {
      element,
      header,
      footer
    } = me;
    if (!me.collapsed) {
      if (me.flex) {
        header.flex = me.flex;
        if (footer) {
          footer.flex = me.flex;
        }
        element.style.flex = me.flex;
      } else {
        if (me.hasCalculatedWidth && !me.columns.some((col) => !col.hidden && col.flex) && me.totalFixedWidth !== me.width) {
          me.width = me.totalFixedWidth;
          me.hasCalculatedWidth = true;
          return;
        }
        me.clearWidthCache();
        let totalWidth = me.width;
        if (!totalWidth && me.hasCalculatedWidth) {
          totalWidth = 0;
          for (const col of me.columns) {
            if (!col.flex && !col.hidden)
              totalWidth += col.width;
          }
        }
        element.style.width = `${totalWidth}px`;
        header.width = totalWidth;
        if (footer) {
          footer.width = totalWidth;
        }
      }
      me.handleHorizontalScroll(false);
    }
  }
  // Safari does not shrink cells the same way as chrome & ff does without having a width set on the row
  fixRowWidthsInSafariEdge() {
    if (BrowserHelper.isSafari) {
      const me = this, { region, header } = me, minWidth = header.calculateMinWidthForSafari();
      me.rowManager.forEach((row) => {
        const element = row.getElement(region);
        if (element) {
          element.style.width = `${minWidth}px`;
        }
      });
      header.headersElement.style.width = `${minWidth}px`;
    }
  }
  /**
   * Get/set SubGrid width, which also sets header and footer width (if available).
   * @property {Number}
   */
  set width(width) {
    var _a4, _b;
    const me = this;
    me.hasCalculatedWidth = false;
    super.width = width;
    me.header.width = width;
    me.footer.width = width;
    if (me.isPainted) {
      me.onElementResize();
    }
    if (!me.isExpanding && !me.isCollapsing && !me.isConfiguring) {
      (_b = (_a4 = me.grid).syncSplits) == null ? void 0 : _b.call(_a4, (other) => other.subGrids[me.region] && (other.subGrids[me.region].width = width));
    }
  }
  get width() {
    return super.width;
  }
  /**
   * Get/set SubGrid flex, which also sets header and footer flex (if available).
   * @property {Number|String}
   */
  set flex(flex) {
    var _a4, _b;
    const me = this;
    me.hasCalculatedWidth = false;
    me.header.flex = flex;
    me.footer.flex = flex;
    super.flex = flex;
    if (me.isPainted) {
      me.onElementResize();
    }
    if (!me.isExpanding && !me.isCollapsing && !me.isConfiguring) {
      (_b = (_a4 = me.grid).syncSplits) == null ? void 0 : _b.call(_a4, (other) => other.subGrids[me.region] && (other.subGrids[me.region].flex = flex));
    }
  }
  get flex() {
    return super.flex;
  }
  /**
   * Called when grid changes size. SubGrid determines if it has changed size and triggers scroll (for virtual
   * rendering in cells to work when resizing etc.)
   * @private
   */
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    var _a4;
    const me = this, { grid } = me;
    super.onInternalResize(...arguments);
    if (grid == null ? void 0 : grid.isPainted) {
      me.syncSplitterButtonPosition();
      if (newWidth !== oldWidth) {
        me.trigger("beforeInternalResize", me);
        (_a4 = grid.beforeSubGridInternalResize) == null ? void 0 : _a4.call(grid, me);
        grid.trigger("horizontalScroll", {
          grid,
          subGrid: me,
          scrollLeft: me.scrollable.scrollLeft,
          scrollX: me.scrollable.x
        });
        grid.trigger("horizontalScrollEnd", { subGrid: me });
        me.fakeScroller && me.refreshFakeScroll();
        grid.syncFlexedSubCols();
        me.fixRowWidthsInSafariEdge();
      }
      if (newHeight !== oldHeight) {
        grid.onHeightChange();
      }
      me.trigger("afterInternalResize", me);
    }
  }
  /**
   * Keeps the parallel splitters in the header, footer and fake scroller synced in terms
   * of being collapsed or not.
   * @private
   */
  syncParallelSplitters(collapsed) {
    const me = this, { grid } = me;
    if (me.splitterElement && me.$showingSplitter) {
      me.toggleSplitterCls("b-grid-splitter-collapsed", collapsed);
    } else {
      const prevGrid = grid.getSubGrid(grid.getPreviousRegion(me.region));
      if (prevGrid && prevGrid.splitterElement) {
        prevGrid.syncParallelSplitters(collapsed);
      }
    }
  }
  onSplitterMouseEnter() {
    const me = this, { nextSibling } = me;
    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.toggleSplitterCls("b-hover");
    }
    me.startSplitterButtonSyncing();
  }
  onSplitterMouseLeave() {
    const me = this, { nextSibling } = me;
    me.toggleSplitterCls("b-hover", false);
    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.stopSplitterButtonSyncing();
    }
  }
  startSplitterButtonSyncing() {
    const me = this;
    if (me.splitterElement) {
      me.syncSplitterButtonPosition();
      if (!me.splitterSyncScrollListener) {
        me.splitterSyncScrollListener = me.grid.scrollable.ion({
          scroll: "syncSplitterButtonPosition",
          thisObj: me
        });
      }
    }
  }
  stopSplitterButtonSyncing() {
    if (this.splitterSyncScrollListener) {
      this.splitterSyncScrollListener();
      this.splitterSyncScrollListener = null;
    }
  }
  syncSplitterButtonPosition() {
    const { grid } = this;
    this.splitterButtons.style.top = `${grid.scrollable.y + (grid.bodyHeight - (this.headerSplitter ? grid.headerHeight : 0)) / 2}px`;
  }
  /**
   * Get the "viewport" for the SubGrid as a Rectangle
   * @property {Core.helper.util.Rectangle}
   * @readonly
   */
  get viewRectangle() {
    const { scrollable } = this;
    return new Rectangle(scrollable.x, scrollable.y, this.width || 0, this.rowManager.viewHeight);
  }
  /**
   * Called when updating column widths to apply 'b-has-flex' which is used when fillLastColumn is configured.
   * @internal
   */
  updateHasFlex() {
    this.scrollable.element.classList.toggle("b-has-flex", this.columns.hasFlex);
  }
  updateResizable(resizable) {
    this.splitterElements.forEach((splitter) => DomHelper.toggleClasses(splitter, ["b-disabled"], !resizable));
  }
  /**
   * Resize all columns in the SubGrid to fit their width, according to their configured
   * {@link Grid.column.Column#config-fitMode}
   */
  resizeColumnsToFitContent() {
    this.grid.beginGridMeasuring();
    this.columns.visibleColumns.forEach((column) => {
      column.resizeToFitContent(null, null, true);
    });
    this.grid.endGridMeasuring();
  }
  //endregion
  //region Scroll
  get overflowingHorizontally() {
    return !this.collapsed && (this.hideHeaders ? this.scrollable.hasOverflow("x") : this.header.scrollable.hasOverflow("x"));
  }
  get overflowingVertically() {
    return false;
  }
  /**
   * Fixes widths of fake scrollers
   * @private
   */
  refreshFakeScroll() {
    const me = this, {
      element,
      virtualScrollerElement,
      virtualScrollerWidth,
      header,
      footer,
      scrollable
    } = me, totalFixedWidth = [...header.contentElement.children].reduce(sumWidths, 0);
    scrollable.scrollWidth = totalFixedWidth;
    element.style.setProperty("--total-column-width", `${me.headerScrollWidth}px`);
    virtualScrollerElement.style.width = element.style.width;
    virtualScrollerElement.style.flex = element.style.flex;
    virtualScrollerElement.style.minWidth = element.style.minWidth;
    virtualScrollerElement.style.maxWidth = element.style.maxWidth;
    header.scrollable.syncOverflowState();
    footer.scrollable.syncOverflowState();
    if (!me.collapsed) {
      if (me.overflowingHorizontally) {
        virtualScrollerWidth.style.width = `${scrollable.scrollWidth || 0}px`;
        me.grid.virtualScrollers.classList.remove("b-hide-display");
      } else {
        virtualScrollerWidth.style.width = 0;
      }
    }
  }
  /**
   * Init scroll syncing for header and footer (if available).
   * @private
   */
  initScroll() {
    const me = this, {
      scrollable,
      virtualScrollerElement,
      grid
    } = me;
    me.fakeScroller = new Scroller({
      element: virtualScrollerElement,
      overflowX: true,
      widget: me
      // To avoid more expensive style lookup for RTL
    });
    scrollable.ion({
      scroll: "onSubGridScroll",
      scrollend: "onSubGridScrollEnd",
      thisObj: me
    });
    if (!grid.hideHorizontalScrollbar) {
      scrollable.addPartner(me.fakeScroller, "x");
      me.refreshFakeScroll();
    }
    if (!grid.hideHeaders) {
      scrollable.addPartner(me.header.scrollable, "x");
    }
    if (!grid.hideFooters) {
      scrollable.addPartner(me.footer.scrollable, "x");
    }
  }
  onSubGridScrollEnd(event) {
    const me = this, { grid } = me;
    me.scrollingToCenter = event == null ? void 0 : event.scrollingToCenter;
    me.scrolling = false;
    me.handleHorizontalScroll(false);
    if (!DomHelper.scrollBarWidth) {
      grid.virtualScrollers.classList.remove("b-scrolling");
      me.hideOverlayScroller();
    }
    grid.trigger("horizontalScrollEnd", { subGrid: me });
  }
  onSubGridScroll(event) {
    const me = this;
    me.scrollingToCenter = event == null ? void 0 : event.scrollingToCenter;
    me.handleHorizontalScroll();
  }
  showOverlayScroller() {
    this.hideOverlayScroller.cancel();
    this.virtualScrollerElement.classList.add("b-show-virtual-scroller");
  }
  // Buffered 1500ms, hides virtual scrollers after scrolling has ended
  hideOverlayScroller() {
    this.virtualScrollerElement.classList.remove("b-show-virtual-scroller");
  }
  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }
  get scrolling() {
    return this._scrolling;
  }
  /**
   * Triggers the 'horizontalScroll' event + makes sure overlay scrollbar is reachable with pointer for a substantial
   * amount of time after scrolling starts
   * @internal
   */
  handleHorizontalScroll(addCls = true) {
    const subGrid = this, { grid } = subGrid;
    if (!subGrid.scrolling && addCls) {
      subGrid.scrolling = true;
      if (!DomHelper.scrollBarWidth) {
        grid.virtualScrollers.classList.add("b-scrolling");
        subGrid.showOverlayScroller();
      }
    }
    grid.trigger("horizontalScroll", {
      subGrid,
      grid,
      scrollLeft: subGrid.scrollable.scrollLeft,
      scrollX: subGrid.scrollable.x,
      scrollingToCenter: subGrid == null ? void 0 : subGrid.scrollingToCenter
    });
  }
  /**
   * Scrolls a column into view (if it is not already). Called by Grid#scrollColumnIntoView, use it instead to not
   * have to care about which SubGrid contains a column.
   * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been
   * scrolled into view.
   */
  scrollColumnIntoView(column, options) {
    const { columns, header } = this, scroller = header.scrollable;
    column = column instanceof Column ? column : columns.get(column) || columns.getById(column) || columns.getAt(column);
    if (column) {
      const columnHeaderElement = header.getHeader(column.id);
      if (columnHeaderElement) {
        return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);
      }
    }
  }
  //endregion
  //region Rows
  /**
   * Creates elements for the new rows when RowManager has determined that more rows are needed
   * @private
   */
  onAddRow({ source = this.grid.rowManager, rows, isExport }) {
    var _a4;
    const me = this, { region } = me, config = me.rowElementConfig, frag = document.createDocumentFragment(), insertRowsBefore = (_a4 = source.rows[rows[rows.length - 1].index + 1]) == null ? void 0 : _a4.elements[region];
    rows.forEach((row) => {
      const rowElement = DomHelper.createElement(config);
      DomHelper.syncClassList(rowElement, row.cls);
      frag.appendChild(rowElement);
      row.addElement(region, rowElement);
      me.fixCellWidths(rowElement);
    });
    if (!isExport) {
      me.fixRowWidthsInSafariEdge();
      me.element.insertBefore(frag, insertRowsBefore || me.insertRowsBefore);
    }
  }
  /**
   * Get all row elements for this SubGrid.
   * @property {HTMLElement[]}
   * @readonly
   */
  get rowElements() {
    return this.fromCache(".b-grid-row", true);
  }
  /**
   * Removes all row elements from the subgrids body and empties cache
   * @private
   */
  clearRows() {
    this.emptyCache();
    const all = this.element.querySelectorAll(".b-grid-row"), range = document.createRange();
    if (all.length) {
      range.setStartBefore(all[0]);
      range.setEndAfter(all[all.length - 1]);
      range.deleteContents();
    }
  }
  // only called when RowManager.rowScrollMode = 'dom', which is not intended to be used
  addNewRowElement() {
    const rowElement = DomHelper.append(this.element, this.rowElementConfig);
    this.fixCellWidths(rowElement);
    return rowElement;
  }
  get store() {
    return this.grid.store;
  }
  get rowManager() {
    var _a4;
    return (_a4 = this.grid) == null ? void 0 : _a4.rowManager;
  }
  //endregion
  // region Expand/collapse
  /**
   * Get/set collapsed state
   * @property {Boolean}
   */
  get collapsed() {
    return this._collapsed;
  }
  set collapsed(collapsed) {
    if (this.isConfiguring) {
      this._collapsed = collapsed;
    } else {
      if (collapsed) {
        this.collapse();
      } else {
        this.expand();
      }
    }
  }
  /**
   * Collapses subgrid. If collapsing subgrid is the only one expanded, next subgrid to the right (or previous) will
   * be expanded.
   *
   * ```javascript
   * let locked = grid.getSubGrid('locked');
   * locked.collapse().then(() => {
   *     console.log(locked.collapsed); // Logs 'True'
   * });
   *
   * let normal = grid.getSubGrid('normal');
   * normal.collapse().then(() => {
   *     console.log(locked.collapsed); // Logs 'False'
   *     console.log(normal.collapsed); // Logs 'True'
   * });
   * ```
   *
   * @param {Boolean} animate - Whether to animate the collapse.
   * @privateparam {Boolean} isRecursiveCall - Flag to set to true in case of partnered grids, to avoid infinite loop
   * @returns {Promise} A Promise which resolves when this SubGrid is fully collapsed.
   */
  async collapse(animate, isRecursiveCall = false) {
    const me = this, { grid } = me, { partners } = grid;
    animate = animate && Object.keys(grid.subGrids).length <= 2;
    if (grid.rendered && me._collapsed === true) {
      return;
    }
    if (grid.partners && !isRecursiveCall) {
      grid.isSyncingFromPartner = true;
      partners.forEach((partner) => partner.isSyncingFromPartner = true);
      await Promise.all([
        me.collapse(animate, true),
        ...partners.map((partner) => {
          var _a4;
          return (_a4 = partner.subGrids[me.region]) == null ? void 0 : _a4.collapse(animate, true);
        })
      ]);
      partners.forEach((partner) => partner.isSyncingFromPartner = false);
      grid.isSyncingFromPartner = false;
      return;
    }
    if (animate) {
      grid.element.classList.add("b-subgrid-width-transition");
      await grid.runWithTransition(() => me._collapseInternal(true), true);
      if (me.isDestroyed) {
        return;
      }
      grid.element.classList.remove("b-subgrid-width-transition");
    } else {
      me._collapseInternal(false);
    }
    grid.trigger("subGridCollapse", { subGrid: me });
    grid.afterToggleSubGrid({ subGrid: me, collapsed: true });
    me.isCollapsing = false;
    grid.trigger("afterInternalResize");
  }
  async _collapseInternal(animate = false) {
    var _a4, _b;
    const me = this, {
      grid,
      element
    } = me, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitterOwner = me.splitterElement ? me : me.previousSibling;
    let { _beforeCollapseState } = me, expandedRegions = 0;
    me.isCollapsing = true;
    grid.eachSubGrid((subGrid) => {
      subGrid !== me && !subGrid._collapsed && ++expandedRegions;
    });
    (_a4 = grid.syncSplits) == null ? void 0 : _a4.call(grid, (other) => {
      var _a5;
      return (_a5 = other.subGrids[me.region]) == null ? void 0 : _a5.collapse(animate);
    });
    if (expandedRegions === 0) {
      if (!nextRegion) {
        return;
      }
      await nextRegion.expand();
    }
    let widthChanged = false;
    if (!_beforeCollapseState) {
      _beforeCollapseState = me._beforeCollapseState = {};
      if (me.width) {
        widthChanged = true;
      }
      _beforeCollapseState.width = me.width;
      _beforeCollapseState.elementWidth = element.style.width;
      if (element.style.flex !== "") {
        _beforeCollapseState.flex = element.style.flex;
        me.header.element.style.flex = element.style.flex = "";
      }
      if (nextRegion.element.style.flex === "") {
        _beforeCollapseState.nextRegionWidth = nextRegion.width;
        nextRegion.width = "";
        nextRegion.flex = `1 1 ${_beforeCollapseState.nextRegionWidth}px`;
      }
      element.classList.add("b-grid-subgrid-collapsed");
      me.virtualScrollerElement.classList.add("b-collapsed");
      me.header.element.classList.add("b-collapsed");
      me.footer.element.classList.add("b-collapsed");
      me._collapsed = true;
      me.width = "";
      if (!widthChanged) {
        me.syncParallelSplitters(true);
      }
    }
    if (!me.isDestroyed) {
      if (widthChanged) {
        grid.refreshVirtualScrollbars();
        me.syncParallelSplitters(true);
        (_b = splitterOwner.startSplitterButtonSyncing) == null ? void 0 : _b.call(splitterOwner);
      }
    }
  }
  /**
   * Expands subgrid.
   *
   * ```javascript
   * grid.getSubGrid('locked').expand().then(() => console.log('locked grid expanded'));
   * ```
   * @param {Boolean} animate - Whether to animate the expand.
   * @privateparam {Boolean} isRecursiveCall - Flag to set to true in case of partnered grids, to avoid infinite loop
   * @returns {Promise} A Promise which resolves when this SubGrid is fully expanded.
   */
  async expand(animate, isRecursiveCall = false) {
    const me = this, { grid } = me, { partners } = grid;
    animate = animate && Object.keys(grid.subGrids).length <= 2;
    if (grid.rendered && me._collapsed !== true) {
      return;
    }
    if (partners && !isRecursiveCall) {
      grid.isSyncingFromPartner = true;
      partners.forEach((partner) => partner.isSyncingFromPartner = true);
      await Promise.all([
        me.expand(animate, true),
        ...partners.map((partner) => {
          var _a4;
          return (_a4 = partner.subGrids[me.region]) == null ? void 0 : _a4.expand(animate, true);
        })
      ]);
      partners.forEach((partner) => partner.isSyncingFromPartner = false);
      grid.isSyncingFromPartner = false;
      return;
    }
    if (animate) {
      grid.element.classList.add("b-subgrid-width-transition");
      await grid.runWithTransition(() => me._expandInternal(true), true);
      if (me.isDestroyed) {
        return;
      }
      grid.element.classList.remove("b-subgrid-width-transition");
    } else {
      me._expandInternal(false);
    }
    grid.trigger("subGridExpand", { subGrid: me });
    grid.afterToggleSubGrid({ subGrid: me, collapsed: false });
    me.isExpanding = false;
    grid.trigger("afterInternalResize");
  }
  async _expandInternal(animate = false) {
    var _a4;
    const me = this, {
      grid,
      _beforeCollapseState
    } = me, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitterOwner = me.splitterElement ? me : me.previousSibling;
    me.isExpanding = true;
    (_a4 = grid.syncSplits) == null ? void 0 : _a4.call(grid, (other) => {
      var _a5;
      return (_a5 = other.subGrids[me.region]) == null ? void 0 : _a5.expand(animate);
    });
    if (_beforeCollapseState != null) {
      let widthChanged = false;
      if (me.width !== _beforeCollapseState.elementWidth) {
        widthChanged = true;
      }
      if (_beforeCollapseState.nextRegionWidth) {
        nextRegion.width = _beforeCollapseState.nextRegionWidth;
        nextRegion.flex = null;
      }
      me.element.classList.remove("b-grid-subgrid-collapsed");
      me._collapsed = false;
      me.virtualScrollerElement.classList.remove("b-collapsed");
      me.header.element.classList.remove("b-collapsed");
      me.footer.element.classList.remove("b-collapsed");
      if (_beforeCollapseState.flex) {
        me.width = _beforeCollapseState.width;
        me.header.flex = me.flex = _beforeCollapseState.flex;
        me.footer.flex = _beforeCollapseState.flex;
        me._width = null;
      } else {
        me.width = _beforeCollapseState.elementWidth;
      }
      me.element.classList.remove("b-grid-subgrid-collapsed");
      me._collapsed = false;
      if (widthChanged) {
        splitterOwner.stopSplitterButtonSyncing();
        me.syncParallelSplitters(false);
      }
      delete me._beforeCollapseState;
    }
  }
  hide() {
    var _a4, _b;
    (_a4 = this.header) == null ? void 0 : _a4.hide();
    (_b = this.footer) == null ? void 0 : _b.hide();
    this.hideSplitter();
    return super.hide();
  }
  show() {
    var _a4, _b;
    const me = this;
    (_a4 = me.header) == null ? void 0 : _a4.show();
    (_b = me.footer) == null ? void 0 : _b.show();
    if (me.region !== me.grid.regions[me.grid.regions.length - 1]) {
      me.showSplitter();
    }
    return super.show();
  }
  //endregion
};
//region Config
__publicField(SubGrid, "$name", "SubGrid");
// Factoryable type name
__publicField(SubGrid, "type", "subgrid");
/**
 * Region (name) for this SubGrid
 * @config {String} region
 */
/**
 * Column store, a store containing the columns for this SubGrid
 * @config {Grid.data.ColumnStore} columns
 */
__publicField(SubGrid, "defaultConfig", {
  insertRowsBefore: null,
  appendTo: null,
  monitorResize: true,
  headerClass: null,
  footerClass: null,
  /**
   * The subgrid "weight" determines its position among its SubGrid siblings.
   * Higher weights go further right.
   * @config {Number}
   * @category Layout
   */
  weight: null,
  /**
   * Set `true` to start subgrid collapsed. To operate collapsed state on subgrid use
   * {@link #function-collapse}/{@link #function-expand} methods.
   * @config {Boolean}
   * @default false
   */
  collapsed: null,
  scrollable: {
    // Each SubGrid only handles scrolling in the X axis.
    // The owning Grid handles the Y axis.
    overflowX: "hidden-scroll"
  },
  scrollerClass: SubGridScroller,
  // Will be set to true by GridSubGrids if it calculates the subgrids width based on its columns.
  // Used to determine if hiding a column should affect subgrids width
  hasCalculatedWidth: null,
  /**
   * Set `true` to disable moving columns into or out of this SubGrid.
   * @config {Boolean}
   * @default false
   * @private
   */
  sealedColumns: null
});
__publicField(SubGrid, "configurable", {
  element: true,
  header: {},
  footer: {},
  virtualScrollerElement: true,
  splitterElement: true,
  headerSplitter: true,
  scrollerSplitter: true,
  footerSplitter: true,
  /**
   * Set to `false` to prevent this subgrid being resized with the {@link Grid.feature.RegionResize} feature
   * @config {Boolean}
   * @default true
   */
  resizable: null,
  role: "presentation"
});
__publicField(SubGrid, "delayable", {
  // This uses a shorter delay for tests, see construct()
  hideOverlayScroller: 1e3
});
SubGrid.initClass();
SubGrid._$name = "SubGrid";

// lib/Grid/view/mixin/GridSubGrids.js
var GridSubGrids_default = (Target) => class GridSubGrids extends (Target || Base) {
  static get $name() {
    return "GridSubGrids";
  }
  static get properties() {
    return {
      /**
       * An object containing the {@link Grid.view.SubGrid} region instances, indexed by subGrid id ('locked', normal'...)
       * @member {Object<String,Grid.view.SubGrid>} subGrids
       * @readonly
       * @category Common
       */
      subGrids: {}
    };
  }
  //region Init
  changeSubGridConfigs(configs) {
    const me = this, usedRegions = /* @__PURE__ */ new Set();
    for (const column of me.columns) {
      const { region } = column;
      if (region) {
        if (!configs[region]) {
          configs[region] = {};
        }
        usedRegions.add(region);
      }
    }
    if (configs.normal && ObjectHelper.isEmpty(configs.normal)) {
      configs.normal = { flex: 1 };
    }
    for (const region of usedRegions) {
      me.createSubGrid(region, configs[region]);
    }
    me.items = me.subGrids;
    return configs;
  }
  createSubGrid(region, config = null) {
    const me = this, subGridColumns = me.columns.makeChained((column) => column.region === region, ["region"]), subGridConfig = ObjectHelper.assign({
      type: "subgrid",
      id: `${me.id}-${region}Subgrid`,
      parent: me,
      grid: me,
      region,
      headerClass: me.headerClass,
      footerClass: me.footerClass,
      columns: subGridColumns,
      // Sort by region unless weight is explicitly defined
      weight: region,
      // SubGridScrollers know about the main grid's scroller so that if asked to
      // scroll vertically they know how to do it.
      scrollable: {
        yScroller: me.scrollable
      }
    }, config || me.subGridConfigs[region]);
    let hasCalculatedWidth = false;
    if (!subGridConfig.flex && !subGridConfig.width) {
      subGridConfig.width = subGridColumns.totalFixedWidth;
      hasCalculatedWidth = true;
    }
    const subGrid = me.subGrids[region] = SubGrid.create(subGridConfig);
    subGrid.element.style.setProperty("--total-column-width", subGridColumns.totalFixedWidth);
    subGrid.hasCalculatedWidth = hasCalculatedWidth;
    if (region === me.regions[0]) {
      subGrid.isFirstRegion = true;
    }
    return subGrid;
  }
  // A SubGrid is added to Grid, add its header etc. too
  onChildAdd(subGrid) {
    if (subGrid.isSubGrid) {
      const me = this, {
        items: items2,
        headerContainer,
        virtualScrollers,
        footerContainer
      } = me, index = items2.indexOf(subGrid) * 2;
      if (!me.hideHeaders || me.columns.some((c) => c.flex)) {
        DomHelper.insertAt(headerContainer, subGrid.headerSplitter, index);
        DomHelper.insertAt(headerContainer, subGrid.header.element, index);
      }
      DomHelper.insertAt(virtualScrollers, subGrid.scrollerSplitter, index);
      DomHelper.insertAt(virtualScrollers, subGrid.virtualScrollerElement, index);
      DomHelper.insertAt(footerContainer, subGrid.footerSplitter, index);
      DomHelper.insertAt(footerContainer, subGrid.footer.element, index);
      items2.forEach((subGrid2, i) => {
        if (i < items2.length - 1) {
          subGrid2.showSplitter();
        }
      });
      if (index === 0 && me.emptyTextEl) {
        subGrid.element.appendChild(me.emptyTextEl);
      }
    }
    return super.onChildAdd(subGrid);
  }
  // A SubGrid is remove from grid, remove its header etc. too
  onChildRemove(subGrid) {
    super.onChildRemove(subGrid);
    if (subGrid.isSubGrid) {
      const { items: items2 } = this;
      delete this.subGrids[subGrid.region];
      ArrayHelper.remove(this.regions, subGrid.region);
      subGrid.destroy();
      if (items2.length) {
        items2[items2.length - 1].hideSplitter();
      }
    }
  }
  doDestroy() {
    this.eachSubGrid((subGrid) => subGrid.destroy());
    super.doDestroy();
  }
  //endregion
  //region Iteration & calling
  /**
   * Iterate over all subGrids, calling the supplied function for each.
   * @param {Function} fn Function to call for each instance
   * @param {Object} thisObj `this` reference to call the function in, defaults to the subGrid itself
   * @category SubGrid
   * @internal
   */
  eachSubGrid(fn, thisObj = null) {
    this.items.forEach((subGrid, i) => {
      subGrid.isSubGrid && fn.call(thisObj || subGrid, subGrid, i++);
    });
  }
  /**
   * Call a function by name for all subGrids (that have the function).
   * @param {String} fnName Name of function to call, uses the subGrid itself as `this` reference
   * @param params Parameters to call the function with
   * @returns {*} Return value from first SubGrid is returned
   * @category SubGrid
   * @internal
   */
  callEachSubGrid(fnName, ...params) {
    let returnValue = null;
    this.items.forEach((subGrid, i) => {
      if (subGrid.isSubGrid && subGrid[fnName]) {
        const partialReturnValue = subGrid[fnName](...params);
        if (i === 0)
          returnValue = partialReturnValue;
      }
    });
    return returnValue;
  }
  //endregion
  //region Getters
  get regions() {
    return this.items.map((item) => item.region);
  }
  /**
   * This method should return names of the two last regions in the grid as they are visible in the UI. In case
   * `regions` property cannot be trusted, use different approach. Used by SubGrid and RegionResize to figure out
   * which region should collapse or expand.
   * @returns {String[]}
   * @private
   * @category SubGrid
   */
  getLastRegions() {
    const result = this.regions.slice(-2);
    return result.length === 2 ? result : [result[0], result[0]];
  }
  /**
   * This method should return right neighbour for passed region, or left neighbour in case last visible region is passed.
   * This method is used to decide which subgrid should take space of the collapsed one.
   * @param {String} region
   * @returns {String}
   * @private
   * @category SubGrid
   */
  getNextRegion(region) {
    const regions = this.regions;
    return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];
  }
  getPreviousRegion(region) {
    return this.regions[this.regions.indexOf(region) - 1];
  }
  /**
   * Returns the subGrid for the specified region.
   * @param {String} region Region, eg. locked or normal (per default)
   * @returns {Grid.view.SubGrid} A subGrid
   * @category SubGrid
   */
  getSubGrid(region) {
    return this.subGrids[region];
  }
  /**
   * Get the SubGrid that contains specified column
   * @param {String|Grid.column.Column} column Column "name" or column object
   * @returns {Grid.view.SubGrid}
   * @category SubGrid
   */
  getSubGridFromColumn(column) {
    column = column instanceof Column ? column : this.columns.getById(column) || this.columns.get(column);
    return this.getSubGrid(column.region);
  }
  //endregion
  /**
   * Returns splitter element for subgrid
   * @param {Grid.view.SubGrid|String} subGrid
   * @returns {HTMLElement}
   * @private
   * @category SubGrid
   */
  resolveSplitter(subGrid) {
    const regions = this.getLastRegions();
    let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;
    if (regions[1] === region) {
      region = regions[0];
    }
    return this.subGrids[region].splitterElement;
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement this.
  get widgetClass() {
  }
};

// lib/Grid/localization/En.js
var emptyString2 = new String();
var locale3 = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  ColumnPicker: {
    column: "Column",
    columnsMenu: "Columns",
    hideColumn: "Hide column",
    hideColumnShort: "Hide",
    newColumns: "New columns"
  },
  Filter: {
    applyFilter: "Apply filter",
    filter: "Filter",
    editFilter: "Edit filter",
    on: "On",
    before: "Before",
    after: "After",
    equals: "Equals",
    lessThan: "Less than",
    moreThan: "More than",
    removeFilter: "Remove filter",
    disableFilter: "Disable filter"
  },
  FilterBar: {
    enableFilterBar: "Show filter bar",
    disableFilterBar: "Hide filter bar"
  },
  Group: {
    group: "Group",
    groupAscending: "Group ascending",
    groupDescending: "Group descending",
    groupAscendingShort: "Ascending",
    groupDescendingShort: "Descending",
    stopGrouping: "Stop grouping",
    stopGroupingShort: "Stop"
  },
  HeaderMenu: {
    moveBefore: (text) => `Move before "${text}"`,
    moveAfter: (text) => `Move after "${text}"`,
    collapseColumn: "Collapse column",
    expandColumn: "Expand column"
  },
  ColumnRename: {
    rename: "Rename"
  },
  MergeCells: {
    mergeCells: "Merge cells",
    menuTooltip: "Merge cells with same value when sorted by this column"
  },
  Search: {
    searchForValue: "Search for value"
  },
  Sort: {
    sort: "Sort",
    sortAscending: "Sort ascending",
    sortDescending: "Sort descending",
    multiSort: "Multi sort",
    removeSorter: "Remove sorter",
    addSortAscending: "Add ascending sorter",
    addSortDescending: "Add descending sorter",
    toggleSortAscending: "Change to ascending",
    toggleSortDescending: "Change to descending",
    sortAscendingShort: "Ascending",
    sortDescendingShort: "Descending",
    removeSorterShort: "Remove",
    addSortAscendingShort: "+ Ascending",
    addSortDescendingShort: "+ Descending"
  },
  Split: {
    split: "Split",
    unsplit: "Unsplit",
    horizontally: "Horizontally",
    vertically: "Vertically",
    both: "Both"
  },
  Column: {
    columnLabel: (column) => `${column.text ? `${column.text} column. ` : ""}SPACE for context menu${column.sortable ? ", ENTER to sort" : ""}`,
    cellLabel: emptyString2
  },
  Checkbox: {
    toggleRowSelect: "Toggle row selection",
    toggleSelection: "Toggle selection of entire dataset"
  },
  RatingColumn: {
    cellLabel: (column) => {
      var _a4;
      return `${column.text ? column.text : ""} ${((_a4 = column.location) == null ? void 0 : _a4.record) ? `rating : ${column.location.record.get(column.field) || 0}` : ""}`;
    }
  },
  GridBase: {
    loadFailedMessage: "Data loading failed!",
    syncFailedMessage: "Data synchronization failed!",
    unspecifiedFailure: "Unspecified failure",
    networkFailure: "Network error",
    parseFailure: "Failed to parse server response",
    serverResponse: "Server response:",
    noRows: "No records to display",
    moveColumnLeft: "Move to left section",
    moveColumnRight: "Move to right section",
    moveColumnTo: (region) => `Move column to ${region}`
  },
  CellMenu: {
    removeRow: "Delete"
  },
  RowCopyPaste: {
    copyRecord: "Copy",
    cutRecord: "Cut",
    pasteRecord: "Paste",
    rows: "rows",
    row: "row"
  },
  CellCopyPaste: {
    copy: "Copy",
    cut: "Cut",
    paste: "Paste"
  },
  PdfExport: {
    "Waiting for response from server": "Waiting for response from server...",
    "Export failed": "Export failed",
    "Server error": "Server error",
    "Generating pages": "Generating pages...",
    "Click to abort": "Cancel"
  },
  ExportDialog: {
    width: "40em",
    labelWidth: "12em",
    exportSettings: "Export settings",
    export: "Export",
    printSettings: "Print settings",
    print: "Print",
    exporterType: "Control pagination",
    cancel: "Cancel",
    fileFormat: "File format",
    rows: "Rows",
    alignRows: "Align rows",
    columns: "Columns",
    paperFormat: "Paper format",
    orientation: "Orientation",
    repeatHeader: "Repeat header"
  },
  ExportRowsCombo: {
    all: "All rows",
    visible: "Visible rows"
  },
  ExportOrientationCombo: {
    portrait: "Portrait",
    landscape: "Landscape"
  },
  SinglePageExporter: {
    singlepage: "Single page"
  },
  MultiPageExporter: {
    multipage: "Multiple pages",
    exportingPage: ({ currentPage, totalPages }) => `Exporting page ${currentPage}/${totalPages}`
  },
  MultiPageVerticalExporter: {
    multipagevertical: "Multiple pages (vertical)",
    exportingPage: ({ currentPage, totalPages }) => `Exporting page ${currentPage}/${totalPages}`
  },
  RowExpander: {
    loading: "Loading",
    expand: "Expand",
    collapse: "Collapse"
  },
  TreeGroup: {
    group: "Group by",
    stopGrouping: "Stop grouping",
    stopGroupingThisColumn: "Ungroup column"
  }
};
var En_default2 = LocaleHelper.publishLocale(locale3);

// lib/Grid/view/GridBase.js
var resolvedPromise = new Promise((resolve) => resolve());
var storeListenerName2 = "GridBase:store";
var defaultScrollOptions3 = {
  block: "nearest",
  inline: "nearest"
};
var datasetReplaceActions = {
  dataset: 1,
  pageLoad: 1,
  filter: 1
};
var emptyArray12 = Object.freeze([]);
var ascending = (l, r) => l - r;
var GridBase = class extends Panel.mixin(
  Pluggable_default,
  State_default,
  GridElementEvents_default,
  GridFeatures_default,
  GridNavigation_default,
  GridResponsive_default,
  GridSelection_default,
  GridState_default,
  GridSubGrids_default,
  LoadMaskable_default
) {
  constructor() {
    super(...arguments);
    //endregion
    __publicField(this, "_animationSuspendedCounter", 0);
  }
  //region Config
  static get $name() {
    return "GridBase";
  }
  // Factoryable type name
  static get type() {
    return "gridbase";
  }
  static get delayable() {
    return {
      onGridVerticalScroll: {
        type: "raf"
      },
      // These use a shorter delay for tests, see finishConfigure()
      bufferedAfterColumnsResized: 250,
      bufferedElementResize: 250
    };
  }
  static get configurable() {
    return {
      //region Hidden configs
      /**
       * @hideconfigs autoUpdateRecord, defaults, hideWhenEmpty, itemCls, items, layout, layoutStyle, lazyItems,
       * namedItems, record, textContent, defaultAction, html, htmlCls, tag, textAlign, trapFocus, content,
       * defaultBindProperty, defaultFocus, align, anchor, centered, constrainTo, draggable, floating,
       * hideAnimation, positioned, scrollAction, showAnimation, x, y, localeClass, localizableProperties,
       * showTooltipWhenDisabled, tooltip, strictRecordMapping, maximizeOnMobile
       */
      /**
       * @hideproperties html, isSettingValues, isValid, items, record, values, content, layoutStyle, firstItem,
       * lastItem, anchorSize, x, y, layout, strictRecordMapping, visibleChildCount, maximizeOnMobile
       */
      /**
       * @hidefunctions attachTooltip, add, getWidgetById, insert, processWidgetConfig, remove, removeAll, getAt,
       * alignTo, setXY, showBy, showByPoint, toFront
       */
      //endregion
      /**
       * Set to `true` to make the grid read-only, by disabling any UIs for modifying data.
       *
       * __Note that checks MUST always also be applied at the server side.__
       * @prp {Boolean} readOnly
       * @default false
       * @category Misc
       */
      /**
       * Automatically set grids height to fit all rows (no scrolling in the grid). In general you should avoid
       * using `autoHeight: true`, since it will bypass Grids virtual rendering and render all rows at once, which
       * in a larger grid is really bad for performance.
       * @config {Boolean}
       * @default false
       * @category Layout
       */
      autoHeight: null,
      disableAutoHeightWarning: null,
      /**
       * Configure this as `true` to allow elements within cells to be styled as `position: sticky`.
       *
       * Columns which contain sticky content will need to be configured with
       *
       * ```javascript
       *    cellCls : 'b-sticky-cell',
       * ```
       *
       * Or a custom renderer can add the class to the passed cell element.
       *
       * It is up to the application author how to style the cell content. It is recommended that
       * a custom renderer create content with CSS class names which the application author
       * will use to apply the `position`, and matching `margin-top` and `top` styles to keep the
       * content stuck at the grid's top.
       *
       * Note that not all browsers support this CSS feature. A cross browser alternative
       * is to use the {link Grid.feature.StickyCells StickyCells} Feature.
       * @config {Boolean}
       * @category Misc
       */
      enableSticky: null,
      /**
       * Set to true to allow text selection in the grid cells. Note, this cannot be used simultaneously with the
       * `RowReorder` feature.
       * @config {Boolean}
       * @default false
       * @category Selection
       */
      enableTextSelection: null,
      /**
       * Set to `true` to stretch the last column in a grid with all fixed width columns
       * to fill extra available space if the grid's width is wider than the sum of all
       * configured column widths.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      fillLastColumn: true,
      /**
       * See {@link Grid.view.Grid#keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>} keyMap
       * @category Common
       */
      positionMode: "translate",
      // translate, translate3d, position
      /**
       * Configure as `true` to have the grid show a red "changed" tag in cells who's
       * field value has changed and not yet been committed.
       *
       * Set `showDirty.duringEdit` to `true` to show the red tag while editing a cell
       * ```javascript
       * showDirty : {
       *     duringEdit : true
       * }
       * ```
       *
       * @config {Boolean|Object}
       * @property {Boolean} showDirty.duringEdit Set to `true` to show the red tag while editing a cell
       * @default false
       * @category Misc
       */
      showDirty: null,
      /**
       * An object containing sub grid configuration objects keyed by a `region` property.
       * By default, grid has a 'locked' region (if configured with locked columns) and a 'normal' region.
       * The 'normal' region defaults to use `flex: 1`.
       *
       * This config can be used to reconfigure the "built-in" sub grids or to define your own.
       *
       * Redefining the default regions:
       *
       * {@frameworktabs}
       * {@js}
       * ```javascript
       * new Grid({
       *   subGridConfigs : {
       *     locked : { flex : 1 },
       *     normal : { width : 100 }
       *   }
       * });
       * ```
       * {@endjs}
       * {@react}
       * ```jsx
       * const App = props => {
       *     const subGridConfigs = {
       *         locked : { flex : 1 },
       *         normal : { width : 100 }
       *     };
       *
       *     return <bryntum-grid subGridConfigs={subGridConfigs} />
       * }
       * ```
       * {@endreact}
       * {@vue}
       * ```html
       * <bryntum-grid :sub-grid-configs="subGridConfigs" />
       * ```
       * ```javascript
       * export default {
       *     setup() {
       *         return {
       *             subGridConfigs : [
       *                 locked : { flex : 1 },
       *                 normal : { width : 100 }
       *             ]
       *         };
       *     }
       * }
       * ```
       * {@endvue}
       * {@angular}
       * ```html
       * <bryntum-grid [subGridConfigs]="subGridConfigs"></bryntum-grid>
       * ```
       * ```typescript
       * export class AppComponent {
       *      subGridConfigs = [
       *          locked : { flex : 1 },
       *          normal : { width : 100 }
       *      ]
       *  }
       * ```
       * {@endangular}
       * {@endframeworktabs}
       *
       * Defining your own multi region grid:
       *
       * ```javascript
       * new Grid({
       *   subGridConfigs : {
       *     left   : { width : 100 },
       *     middle : { flex : 1 },
       *     right  : { width  : 100 }
       *   },
       *
       *   columns : [
       *     { field : 'manufacturer', text: 'Manufacturer', region : 'left' },
       *     { field : 'model', text: 'Model', region : 'middle' },
       *     { field : 'year', text: 'Year', region : 'middle' },
       *     { field : 'sales', text: 'Sales', region : 'right' }
       *   ]
       * });
       * ```
       * @config {Object<String,SubGridConfig>}
       * @category Misc
       */
      subGridConfigs: {
        normal: { flex: 1 }
      },
      /**
       * Store that holds records to display in the grid, or a store config object. If the configuration contains
       * a `readUrl`, an `AjaxStore` will be created.
       *
       * Note that a store will be created during initialization if none is specified.
       *
       * Supplying a store config object at initialization time:
       *
       * ```javascript
       * const grid = new Grid({
       *     store : {
       *         fields : ['name', 'powers'],
       *         data   : [
       *             { id : 1, name : 'Aquaman', powers : 'Decent swimmer' },
       *             { id : 2, name : 'Flash', powers : 'Pretty fast' },
       *         ]
       *     }
       * });
       * ```
       *
       * Accessing the store at runtime:
       *
       * ```javascript
       * grid.store.sort('powers');
       * ```
       *
       * @prp {Core.data.Store}
       * @accepts {Core.data.Store|StoreConfig}
       * @typings {Core.data.Store|StoreConfig|Core.data.AjaxStore|AjaxStoreConfig}
       * @category Common
       */
      store: {
        value: {},
        $config: "nullify"
      },
      rowManager: {
        value: {},
        $config: ["nullify", "lazy"]
      },
      /**
       * Configuration values for the {@link Core.util.ScrollManager} class on initialization. Returns the
       * {@link Core.util.ScrollManager} at runtime.
       *
       * @prp {Core.util.ScrollManager}
       * @accepts {ScrollManagerConfig|Core.util.ScrollManager}
       * @readonly
       * @category Scrolling
       */
      scrollManager: {
        value: {},
        $config: ["nullify", "lazy"]
      },
      /**
       * Accepts column definitions for the grid during initialization. They will be used to create
       * {@link Grid/column/Column} instances that are added to a {@link Grid/data/ColumnStore}.
       *
       * At runtime it returns the {@link Grid/data/ColumnStore}.
       *
       * Initialization using column config objects:
       *
       * ```javascript
       * new Grid({
       *   columns : [
       *     { text : 'Alias', field : 'alias' },
       *     { text : 'Superpower', field : 'power' }
       *   ]
       * });
       * ```
       *
       * Also accepts a store config object:
       *
       * ```javascript
       * new Grid({
       *   columns : {
       *     data : [
       *       { text : 'Alias', field : 'alias' },
       *       { text : 'Superpower', field : 'power' }
       *     ],
       *     listeners : {
       *       update() {
       *         // Some update happened
       *       }
       *     }
       *   }
       * });
       * ```
       *
       * Access the {@link Grid/data/ColumnStore} at runtime to manipulate columns:
       *
       * ```javascript
       * grid.columns.add({ field : 'column', text : 'New column' });
       * ```
       *
       * Replacing the columns fully at runtime:
       *
       * ```javascript
       * grid.columns = [{ field : 'column', text : 'New column' }];
       * ```
       * @prp {Grid.data.ColumnStore}
       * @accepts {Grid.data.ColumnStore|GridColumnConfig[]|ColumnStoreConfig}
       * @category Common
       */
      columns: {
        value: [],
        $config: "nullify"
      },
      /**
       * Grid's `min-height`. Defaults to `10em` to be sure that the Grid always has a height wherever it is
       * inserted.
       *
       * Can be either a String or a Number (which will have 'px' appended).
       *
       * Note that _reading_ the value will return the numeric value in pixels.
       *
       * @config {String|Number}
       * @category Layout
       */
      minHeight: "10em",
      /**
       * Set to `true` to hide the column header elements
       * @prp {Boolean}
       * @default false
       * @category Misc
       */
      hideHeaders: null,
      /**
       * Set to `true` to hide the footer elements
       * @prp {Boolean}
       * @default
       * @category Misc
       */
      hideFooters: true,
      /**
       * Set to `true` to hide the Grid's horizontal scrollbar(s)
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      hideHorizontalScrollbar: null,
      contentElMutationObserver: false,
      trapFocus: false,
      ariaElement: "bodyElement",
      cellTabIndex: -1,
      rowCls: {
        value: "b-grid-row",
        $config: {
          merge: this.mergeCls
        }
      },
      cellCls: {
        value: "b-grid-cell",
        $config: {
          merge: this.mergeCls
        }
      },
      /**
       * Text or HTML, or a {@link DomConfig} block to display when there is no data to display in the grid
       * @prp {String|DomConfig}
       * @default
       * @category Common
       */
      emptyText: "L{noRows}",
      sortFeatureStore: "store",
      /**
       * Row height in pixels. This allows the default height for rows to be controlled. Note that it may be
       * overriden by specifying a {@link Grid/data/GridRowModel#field-rowHeight} on a per record basis, or from
       * a column {@link Grid/column/Column#config-renderer}.
       *
       * When initially configured as `null`, an empty row will be measured and its height will be used as default
       * row height, enabling it to be controlled using CSS
       *
       * @prp {Number}
       * @category Common
       */
      rowHeight: null,
      /**
       * Preserve the grid's vertical scroll position when changesets are applied, as in the case of remote
       * changes, or when stores are configured with {@link Core.data.Store#config-syncDataOnLoad}.
       *
       * @prp {PreserveScrollOptions|Boolean}
       * @default
       * @category Common
       */
      preserveScroll: false,
      /**
       * When the {@link Grid.feature.Tree} feature is in use and the Store is a tree store, this
       * config may be set to `true` to visually animate branch node expand and collapse operations.
       * {@note}This is not supported in Scheduler and Gantt{/@note}
       * @prp {Boolean}
       * @default false
       */
      animateTreeNodeToggle: VersionHelper.checkVersion("core", "6.0", ">="),
      /**
       * Set to `false` to not show column lines. End result might be overruled by/differ between themes.
       *
       * @prp {Boolean}
       * @default
       * @category Misc
       */
      columnLines: true,
      /**
       * Set to `false` to not show row lines. End result might be overruled by/differ between themes.
       *
       * @prp {Boolean}
       * @default
       * @category Misc
       */
      rowLines: true,
      /**
       * Use fixed row height. Setting this to `true` will configure the underlying RowManager to use fixed row
       * height, which sacrifices the ability to use rows with variable height to gain a fraction better
       * performance.
       *
       * Using this setting also ignores the {@link Grid.view.GridBase#config-getRowHeight} function, and thus any
       * row height set in data. Only Grids configured {@link Grid.view.GridBase#config-rowHeight} is used.
       *
       * @config {Boolean}
       * @category Layout
       */
      fixedRowHeight: null
    };
  }
  // Default settings, applied in grids constructor.
  static get defaultConfig() {
    return {
      /**
       * A function called for each row to determine its height. It is passed a {@link Core.data.Model record} and
       * expected to return the desired height of that records row. If the function returns a falsy value, Grids
       * configured {@link Grid.view.GridBase#config-rowHeight} is used.
       *
       * The default implementation of this function returns the row height from the records
       * {@link Grid.data.GridRowModel#field-rowHeight rowHeight field}.
       *
       * Override this function to take control over how row heights are determined:
       *
       * ```javascript
       * new Grid({
       *    getRowHeight(record) {
       *        if (record.low) {
       *            return 20;
       *        }
       *        else if (record.high) {
       *            return 60;
       *        }
       *
       *        // Will use grids configured rowHeight
       *        return null;
       *    }
       * });
       * ```
       *
       * NOTE: Height set in a Column renderer takes precedence over the height returned by this function.
       *
       * @config {Function} getRowHeight
       * @param {Core.data.Model} getRowHeight.record Record to determine row height for
       * @returns {Number} Desired row height
       * @category Layout
       */
      // used if no rowHeight specified and none found in CSS. not public since our themes have row height
      // specified and this is more of an internal failsafe
      defaultRowHeight: 45,
      /**
       * Refresh entire row when a record changes (`true`) or, if possible, only the cells affected (`false`).
       *
       * When this is set to `false`, then if a column uses a renderer, cells in that column will still
       * be updated because it is impossible to know whether the cells value will be affected.
       *
       * If a standard, provided Column class is used with no custom renderer, its cells will only be updated
       * if the column's {@link Grid.column.Column#config-field} is changed.
       * @config {Boolean}
       * @default
       * @category Misc
       */
      fullRowRefresh: true,
      /**
       * Specify `true` to preserve vertical scroll position after store actions that trigger a `refresh` event,
       * such as loading new data and filtering.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      preserveScrollOnDatasetChange: null,
      /**
       * True to preserve focused cell after loading new data
       * @config {Boolean}
       * @default
       * @category Misc
       */
      preserveFocusOnDatasetChange: true,
      /**
       * Convenient shortcut to set data in grids store both during initialization and at runtime. Can also be
       * used to retrieve data at runtime, although we do recommend interacting with Grids store instead using
       * the {@link #property-store} property.
       *
       * Setting initial data during initialization:
       *
       * ```javascript
       * const grid = new Grid({
       *     data : [
       *       { id : 1, name : 'Batman' },
       *       { id : 2, name : 'Robin' },
       *       ...
       *     ]
       * });
       * ```
       *
       * Setting data at runtime:
       *
       * ```javascript
       * grid.data = [
       *     { id : 3, name : 'Joker' },
       *     ...
       * ];
       * ```
       *
       * Getting data at runtime:
       *
       * ```javascript
       * const records = store.data;
       * ```
       *
       * Note that a Store will be created during initialization if none is specified.
       *
       * @prp {Core.data.Model[]}
       * @accepts {Object[]|Core.data.Model[]}
       * @category Common
       */
      data: null,
      /**
       * Region to which columns are added when they have none specified
       * @config {String}
       * @default
       * @category Misc
       */
      defaultRegion: "normal",
      /**
       * true to destroy the store when the grid is destroyed
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      destroyStore: null,
      /**
       * Grids change the `maskDefaults` to cover only their `body` element.
       * @config {MaskConfig}
       * @category Misc
       */
      maskDefaults: {
        cover: "body",
        target: "element"
      },
      /**
       * Set to `false` to only measure cell contents when double-clicking the edge between column headers.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      resizeToFitIncludesHeader: true,
      /**
       * Set to `false` to prevent remove row animation and remove the delay related to that.
       * @config {Boolean}
       * @default
       * @category Misc
       */
      animateRemovingRows: true,
      /**
       * Set to `true` to not get a warning when using another base class than GridRowModel for your grid data. If
       * you do, and would like to use the full feature set of the grid then include the fields from GridRowModel
       * in your model definition.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      disableGridRowModelWarning: null,
      /**
       * Set to `true` to not get a warning when calling {@link #function-getState} when there is a column
       * configured without an `id`. But the recommended action is to always configure columns with an `id` when
       * using states.
       * @config {Boolean}
       * @default false
       * @category State
       */
      disableGridColumnIdWarning: null,
      headerClass: Header,
      footerClass: Footer,
      testPerformance: false,
      rowScrollMode: "move",
      // move, dom, all
      /**
       * Grid monitors window resize by default.
       * @config {Boolean}
       * @default true
       * @category Misc
       */
      monitorResize: true,
      /**
       * An object containing Feature configuration objects (or `true` if no configuration is required)
       * keyed by the Feature class name in all lowercase.
       * @config {Object}
       * @category Common
       */
      features: true,
      /**
       * Configures whether the grid is scrollable in the `Y` axis. This is used to configure a {@link Core.helper.util.Scroller}.
       * See the {@link #config-scrollerClass} config option.
       * @config {Boolean|ScrollerConfig|Core.helper.util.Scroller}
       * @category Scrolling
       */
      scrollable: {
        // Just Y for now until we implement a special grid.view.Scroller subclass
        // Which handles the X scrolling of subgrids.
        overflowY: true
      },
      /**
       * The class to instantiate to use as the {@link #config-scrollable}. Defaults to {@link Core.helper.util.Scroller}.
       * @config {Core.helper.util.Scroller}
       * @typings {typeof Scroller}
       * @category Scrolling
       */
      scrollerClass: GridScroller,
      refreshSuspended: 0,
      /**
       * Animation transition duration in milliseconds.
       * @prp {Number}
       * @default
       * @category Misc
       */
      transitionDuration: 500,
      /**
       * Event which is used to show context menus.
       * Available options are: 'contextmenu', 'click', 'dblclick'.
       * @config {'contextmenu'|'click'|'dblclick'}
       * @category Misc
       * @default
       */
      contextMenuTriggerEvent: "contextmenu",
      localizableProperties: ["emptyText"],
      asyncEventSuffix: "",
      fixElementHeightsBuffer: 350,
      testConfig: {
        transitionDuration: 50,
        fixElementHeightsBuffer: 50
      }
    };
  }
  static get properties() {
    return {
      _selectedRecords: [],
      _verticalScrollHeight: 0,
      virtualScrollHeight: 0,
      _scrollTop: null
    };
  }
  // Keep this commented out to have easy access to the syntax next time we need to use it
  // static get deprecatedEvents() {
  //     return {
  //         cellContextMenuBeforeShow : {
  //             product            : 'Grid',
  //             invalidAsOfVersion : '5.0.0',
  //             message            : '`cellContextMenuBeforeShow` event is deprecated, in favor of `cellMenuBeforeShow` event. Please see https://bryntum.com/products/grid/docs/guide/Grid/upgrades/4.0.0 for more information.'
  //         }
  //     };
  // }
  //endregion
  //region Init-destroy
  finishConfigure(config) {
    const me = this, { initScroll } = me;
    me.initScroll = () => !me.scrollInitialized && initScroll.call(me);
    if (VersionHelper.isTestEnv) {
      me.bufferedAfterColumnsResized.delay = 50;
      me.bufferedElementResize.delay = 50;
    }
    super.finishConfigure(config);
    LocaleManager_default.ion({
      locale: "onBeforeLocaleChange",
      prio: 1,
      thisObj: me
    });
    LocaleManager_default.ion({
      locale: "onLocaleChange",
      prio: -1,
      thisObj: me
    });
    GlobalEvents_default.ion({
      theme: "onThemeChange",
      thisObj: me
    });
    me.ion({
      subGridExpand: "internalOnSubGridExpand",
      prio: -1,
      thisObj: me
    });
    me.bufferedFixElementHeights = me.buffer("fixElementHeights", me.fixElementHeightsBuffer, me);
    me.setGridClassList(me.element.classList);
    me.verticalScroller.classList.remove("b-content-element", "b-auto-container");
    me.bodyWrapElement.classList.remove("b-auto-container-panel");
  }
  internalOnSubGridExpand() {
    this.renderContents();
  }
  onBeforeLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = true;
  }
  onLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = false;
    if (this.isPainted) {
      this.renderContents();
    }
  }
  finalizeInit() {
    super.finalizeInit();
    if (this.store.isLoading) {
      this.onStoreBeforeRequest();
    }
  }
  changeScrollManager(scrollManager, oldScrollManager) {
    oldScrollManager == null ? void 0 : oldScrollManager.destroy();
    if (scrollManager) {
      return ScrollManager.new({
        element: this.element,
        owner: this
      }, scrollManager);
    } else {
      return null;
    }
  }
  /**
   * Cleanup
   * @private
   */
  doDestroy() {
    var _a4, _b;
    const me = this;
    me.detachListeners(storeListenerName2);
    (_a4 = me.scrollManager) == null ? void 0 : _a4.destroy();
    for (const feature of Object.values(me.features)) {
      (_b = feature.destroy) == null ? void 0 : _b.call(feature);
    }
    me._focusedCell = null;
    me.columns.destroy();
    super.doDestroy();
  }
  /**
   * Adds extra classes to the Grid element after it's been configured.
   * Also iterates through features, thus ensuring they have been initialized.
   * @private
   */
  setGridClassList(classList) {
    const me = this;
    Object.values(me.features).forEach((feature) => {
      if (feature.disabled || feature === false) {
        return;
      }
      let featureClass;
      if (Object.prototype.hasOwnProperty.call(feature.constructor, "featureClass")) {
        featureClass = feature.constructor.featureClass;
      } else {
        featureClass = `b-${feature instanceof Base ? feature.$$name : feature.constructor.name}`;
      }
      if (featureClass) {
        classList.add(featureClass.toLowerCase());
      }
    });
  }
  //endregion
  // region Feature events
  // For documentation & typings purposes
  /**
   * Fires after a sub grid is collapsed.
   * @event subGridCollapse
   * @param {Grid.view.Grid} source The firing Grid instance
   * @param {Grid.view.SubGrid} subGrid The sub grid instance
   */
  /**
   * Fires after a sub grid is expanded.
   * @event subGridExpand
   * @param {Grid.view.Grid} source The firing Grid instance
   * @param {Grid.view.SubGrid} subGrid The sub grid instance
   */
  /**
   * Fires before a row is rendered.
   * @event beforeRenderRow
   * @param {Grid.view.Grid} source The firing Grid instance.
   * @param {Grid.row.Row} row The row about to be rendered.
   * @param {Core.data.Model} record The record for the row.
   * @param {Number} recordIndex The zero-based index of the record.
   */
  /**
   * Fires after a row is rendered.
   * @event renderRow
   * @param {Grid.view.Grid} source The firing Grid instance.
   * @param {Grid.row.Row} row The row that has been rendered.
   * @param {Core.data.Model} record The record for the row.
   * @param {Number} recordIndex The zero-based index of the record.
   */
  //endregion
  //region Grid template & elements
  compose() {
    const { autoHeight, enableSticky, enableTextSelection, fillLastColumn, positionMode, showDirty } = this;
    return {
      class: {
        [`b-grid-${positionMode}`]: 1,
        "b-enable-sticky": enableSticky,
        "b-grid-notextselection": !enableTextSelection,
        "b-autoheight": autoHeight,
        "b-fill-last-column": fillLastColumn,
        "b-show-dirty": showDirty,
        "b-show-dirty-during-edit": showDirty == null ? void 0 : showDirty.duringEdit
      }
    };
  }
  async recomposeInternal() {
    var _a4;
    let scrollState;
    const { isConstructing } = this;
    if (!isConstructing) {
      scrollState = this.storeScroll();
    }
    await super.recomposeInternal();
    if (!isConstructing) {
      const oldValues = [...Object.keys(scrollState.scrollLeft).map((k) => scrollState.scrollLeft[k]), scrollState.scrollTop];
      if (Math.max(...oldValues)) {
        const newState = this.storeScroll();
        if (!Math.max([...Object.keys(newState.scrollLeft).map((k) => newState.scrollLeft[k]), newState.scrollTop])) {
          (_a4 = this.restoreScroll) == null ? void 0 : _a4.call(this, scrollState);
        }
      }
    }
  }
  get cellCls() {
    const { _cellCls } = this;
    return _cellCls.value || _cellCls;
  }
  get bodyConfig() {
    const { autoHeight, hideFooters, hideHeaders } = this;
    return {
      reference: "bodyElement",
      className: {
        "b-autoheight": autoHeight,
        "b-grid-panel-body": 1
      },
      // Only include aria-labelled-by if we have a header
      [this.hasHeader ? "ariaLabelledBy" : ""]: `${this.id}-panel-title`,
      children: {
        headerContainer: {
          tag: "header",
          role: "row",
          "aria-rowindex": 1,
          className: {
            "b-grid-header-container": 1,
            "b-hidden": hideHeaders
          }
        },
        bodyContainer: {
          className: "b-grid-body-container",
          tabIndex: -1,
          // Explicitly needs this because it's in theory focusable
          // and DomSync won't add a default role
          role: "presentation",
          children: {
            verticalScroller: {
              className: "b-grid-vertical-scroller"
            }
          }
        },
        virtualScrollers: {
          className: "b-virtual-scrollers b-hide-display",
          style: BrowserHelper.isFirefox && DomHelper.scrollBarWidth ? {
            height: `${DomHelper.scrollBarWidth}px`
          } : void 0
        },
        footerContainer: {
          tag: "footer",
          className: {
            "b-grid-footer-container": 1,
            "b-hidden": hideFooters
          }
        }
      }
    };
  }
  get contentElement() {
    return this.verticalScroller;
  }
  get overflowElement() {
    return this.bodyContainer;
  }
  updateHideHeaders(hide) {
    var _a4;
    hide = Boolean(hide);
    (_a4 = this.headerContainer) == null ? void 0 : _a4.classList.toggle("b-hidden", hide);
    this.eachSubGrid((subGrid) => subGrid.toggleHeaders(hide));
  }
  updateHideFooters(hide) {
    var _a4;
    hide = Boolean(hide);
    (_a4 = this.footerContainer) == null ? void 0 : _a4.classList.toggle("b-hidden", hide);
    this.eachSubGrid((subGrid) => {
      subGrid.scrollable[hide ? "removePartner" : "addPartner"](subGrid.footer.scrollable, "x");
    });
  }
  updateHideHorizontalScrollbar(hide) {
    hide = Boolean(hide);
    this.eachSubGrid((subGrid) => {
      subGrid.virtualScrollerElement.classList.toggle("b-hide-display", hide);
      subGrid.scrollable[hide ? "removePartner" : "addPartner"](subGrid.fakeScroller, "x");
      if (!hide) {
        subGrid.refreshFakeScroll();
      }
    });
  }
  //endregion
  //region Columns
  changeColumns(columns, currentStore) {
    const me = this;
    if (!columns && currentStore) {
      if (me.isDestroying) {
        currentStore.owner === me && currentStore.destroy();
      } else {
        currentStore.removeAll();
      }
      return currentStore;
    }
    if (columns.isStore) {
      (currentStore == null ? void 0 : currentStore.owner) === me && currentStore.destroy();
      columns.grid = me;
      return columns;
    }
    if (Array.isArray(columns)) {
      if (currentStore) {
        const columnsBefore = currentStore.allRecords.slice();
        currentStore.data = columns;
        for (const oldColumn of columnsBefore) {
          if (!currentStore.includes(oldColumn)) {
            oldColumn.destroy();
          }
        }
        return currentStore;
      }
      columns = { data: columns };
    }
    if (currentStore) {
      throw new Error("Replacing ColumnStore is not supported");
    }
    return ColumnStore.new({
      grid: me,
      owner: me
    }, columns);
  }
  updateColumns(columns, was) {
    var _a4, _b;
    const me = this;
    (_a4 = super.updateColumns) == null ? void 0 : _a4.call(this, columns, was);
    columns.ion({
      refresh: me.onColumnsChanged,
      sort: me.onColumnsChanged,
      change: me.onColumnsChanged,
      move: me.onColumnsChanged,
      thisObj: me
    });
    columns.ion(columnResizeEvent(me.onColumnsResized, me));
    if (BrowserHelper.isTouchDevice) {
      me.touch = true;
      columns.forEach((column) => {
        const { touchConfig } = column;
        if (touchConfig) {
          column.applyState(touchConfig);
        }
      });
    }
    (_b = me.bodyElement) == null ? void 0 : _b.setAttribute("aria-colcount", columns.visibleColumns.length);
  }
  onColumnsChanged({ type, action, changes, record: column, records: changedColumns, isMove }) {
    var _a4;
    const me = this, {
      columns,
      checkboxSelectionColumn
    } = me, isSingleFieldChange = changes && Object.keys(changes).length === 1;
    isMove = isMove === true ? true : isMove && Object.values(isMove).some((field) => field);
    if (isMove || type === "refresh" && action !== "batch" && action !== "sort" || // Ignore the update of parentIndex following a column move (we redraw on the insert)
    action === "update" && isSingleFieldChange && "parentIndex" in changes || // Ignore sort caused by sync, will refresh on the batch instead
    action === "sort" && columns.isSyncingDataOnLoad) {
      return;
    }
    const addingColumnToNonExistingSubGrid = action === "add" && changedColumns.some((col) => col.region && !me.subGrids[col.region]);
    if (me.isConfiguring || !addingColumnToNonExistingSubGrid && (!me.isPainted || isMove && action === "remove")) {
      return;
    }
    if (action === "add") {
      for (const column2 of changedColumns) {
        const { region } = column2;
        if (!me.subGrids[region]) {
          me.add(me.createSubGrid(region, (_a4 = me.subGridConfigs) == null ? void 0 : _a4[region]));
        }
      }
    } else if (action === "update") {
      if (("width" in changes || "minWidth" in changes || "maxWidth" in changes || "flex" in changes) && !("region" in changes)) {
        const { region } = column;
        columns.visibleColumns.forEach((col) => {
          if (col.region === region && col.repaintOnResize) {
            me.refreshColumn(col);
          }
        });
        me.afterColumnsChange({ type, action, changes, column });
        return;
      }
      if ("text" in changes && isSingleFieldChange) {
        column.subGrid.refreshHeader();
        return;
      }
      if ("hidden" in changes) {
        const subGrid = me.getSubGridFromColumn(column.id);
        subGrid.header.fixHeaderWidths();
        subGrid.footer.fixFooterWidths();
        subGrid.updateHasFlex();
      }
    } else if (action === "remove") {
      changedColumns.forEach((c) => {
        var _a5;
        return (_a5 = c.freeColumnWidgets) == null ? void 0 : _a5.call(c);
      });
    }
    if (action === "dataset" || action === "batch" || action === "update" && "region" in changes) {
      const regions = columns.getDistinctValues("region", true), { toRemove, toAdd } = ArrayHelper.delta(regions, me.regions, true);
      me.remove(toRemove.map((region) => me.getSubGrid(region)));
      me.add(toAdd.map((region) => me.createSubGrid(region, me.subGridConfigs[region])));
    }
    if (checkboxSelectionColumn && !columns.includes(checkboxSelectionColumn)) {
      const insertIndex = columns.indexOf(columns.findRecord("type", "rownumber")) + 1;
      columns.insert(insertIndex, checkboxSelectionColumn, true);
    }
    if (!me._suspendRenderContentsOnColumnsChanged) {
      me.renderContents();
    }
    me.syncFlexedSubCols();
    me.bodyElement.setAttribute("aria-colcount", columns.visibleColumns.length);
    me.afterColumnsChange({ type, action, changes, column, columns: changedColumns });
  }
  onColumnsResized({ changes, record: column }) {
    var _a4;
    const me = this;
    if (me.isConfiguring) {
      return;
    }
    const domWidth = DomHelper.setLength(column.width), domMinWidth = DomHelper.setLength(column.minWidth), domMaxWidth = DomHelper.setLength(column.maxWidth), subGrid = me.getSubGridFromColumn(column.id);
    subGrid.header.fixHeaderWidths();
    subGrid.footer.fixFooterWidths();
    subGrid.updateHasFlex();
    if (!(column.flex && column.childLevel)) {
      if (!me.cellEls || column !== me.lastColumnResized) {
        me.cellEls = DomHelper.children(
          me.element,
          `.b-grid-cell[data-column-id="${column.id}"]`
        );
        me.lastColumnResized = column;
      }
      for (const cell of me.cellEls) {
        if ("width" in changes) {
          cell.style.width = domWidth;
        }
        if ("minWidth" in changes) {
          cell.style.minWidth = domMinWidth;
        }
        if ("maxWidth" in changes) {
          cell.style.maxWidth = domMaxWidth;
        }
        if ("flex" in changes) {
          cell.style.flex = (_a4 = column.flex) != null ? _a4 : null;
        }
      }
    }
    if (!me.resizingColumns) {
      me.afterColumnsResized(column);
    }
    me.syncFlexedSubCols();
  }
  afterColumnsResized(column) {
    const me = this;
    me.eachSubGrid((subGrid) => {
      if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {
        subGrid.fixWidths();
        subGrid.fixRowWidthsInSafariEdge();
      }
    });
    me.lastColumnResized = me.cellEls = null;
    me.bufferedAfterColumnsResized(column);
    me.onHeightChange();
  }
  syncFlexedSubCols() {
    const flexedSubCols = this.columns.query((c) => c.flex && c.childLevel && c.element);
    if (flexedSubCols) {
      for (const column of flexedSubCols) {
        const width = column.element.getBoundingClientRect().width, cellEls = DomHelper.children(
          this.element,
          `.b-grid-cell[data-column-id="${column.id}"]`
        );
        for (const cell of cellEls) {
          cell.style.flex = `0 0 ${width}px`;
        }
      }
    }
  }
  bufferedAfterColumnsResized(column) {
    if (this.columns.usesAutoHeight) {
      this.refreshRows();
    }
    this.refreshVirtualScrollbars();
    this.eachSubGrid((subGrid) => {
      if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {
        subGrid.refreshFakeScroll();
      }
    });
  }
  bufferedElementResize() {
    this.refreshRows();
  }
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    if (DomHelper.scrollBarWidth && newWidth < oldWidth) {
      this.eachSubGrid((subGrid) => {
        if (subGrid.flex) {
          subGrid.onElementResize(subGrid.element);
        }
      });
    }
    super.onInternalResize(...arguments);
    if (this.isPainted && newWidth !== oldWidth && this.columns.usesFlexAutoHeight) {
      this.bufferedElementResize();
    }
  }
  //endregion
  //region Rows
  /**
   * Get the topmost visible grid row
   * @member {Grid.row.Row} firstVisibleRow
   * @readonly
   * @category Rows
   */
  /**
   * Get the last visible grid row
   * @member {Grid.row.Row} lastVisibleRow
   * @readonly
   * @category Rows
   */
  /**
   * Get the Row that is currently displayed at top.
   * @member {Grid.row.Row} topRow
   * @readonly
   * @category Rows
   * @private
   */
  /**
   * Get the Row currently displayed furthest down.
   * @member {Grid.row.Row} bottomRow
   * @readonly
   * @category Rows
   * @private
   */
  /**
   * Get Row for specified record id.
   * @function getRowById
   * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   * @private
   */
  /**
   * Returns top and bottom for rendered row or estimated coordinates for unrendered.
   * @function getRecordCoords
   * @param {Core.data.Model|String|Number} recordOrId Record or record id
   * @returns {Object} Record bounds with format { top, height, bottom }
   * @category Calculations
   * @private
   */
  /**
   * Get the Row at specified index. "Wraps" index if larger than available rows.
   * @function getRow
   * @param {Number} index
   * @returns {Grid.row.Row}
   * @category Rows
   * @private
   */
  /**
   * Get a Row for either a record, a record id or an HTMLElement
   * @function getRowFor
   * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement
   * @returns {Grid.row.Row} Found Row or `null` if record not rendered
   * @category Rows
   */
  /**
   * Get a Row from an HTMLElement
   * @function getRowFromElement
   * @param {HTMLElement} element
   * @returns {Grid.row.Row} Found Row or `null` if record not rendered
   * @category Rows
   * @private
   */
  changeRowManager(rowManager, oldRowManager) {
    const me = this;
    if (!me._isRowMeasured) {
      me.measureRowHeight();
    }
    oldRowManager == null ? void 0 : oldRowManager.destroy();
    if (rowManager) {
      const result = RowManager.new({
        grid: me,
        rowHeight: me.rowHeight,
        rowScrollMode: me.rowScrollMode || "move",
        autoHeight: me.autoHeight,
        fixedRowHeight: me.fixedRowHeight,
        internalListeners: {
          changeTotalHeight: "onRowManagerChangeTotalHeight",
          requestScrollChange: "onRowManagerRequestScrollChange",
          thisObj: me
        }
      }, rowManager);
      me.relayEvents(result, ["beforeRenderRow", "renderRow", "removeRows"]);
      me._rowManager = null;
      return result;
    }
  }
  // Manual relay needed for Split feature to catch the config change
  updateRowHeight(rowHeight) {
    if (!this.isConfiguring && this.rowManager) {
      this.rowManager.rowHeight = rowHeight;
    }
  }
  updateFixedRowHeight(fixedRowHeight) {
    var _a4, _b;
    if (fixedRowHeight && ((_b = (_a4 = this.columns || this.peekConfig("columns")) == null ? void 0 : _a4.some) == null ? void 0 : _b.call(_a4, (col) => col.autoHeight))) {
      console.warn("One or more columns have `autoHeight` set, which is incompatible with `fixedRowHeight`.");
    }
  }
  get rowHeight() {
    var _a4, _b;
    return (_b = (_a4 = this._rowManager) == null ? void 0 : _a4.rowHeight) != null ? _b : this._rowHeight;
  }
  // Default implementation, documented in `defaultConfig`
  getRowHeight(record) {
    return record.rowHeight;
  }
  // Hook for features that need to alter the row height
  processRowHeight(record, height) {
  }
  //endregion
  //region Store
  getAsyncEventSuffixForStore(store) {
    return this.asyncEventSuffix;
  }
  /**
   * Hooks up data store listeners
   * @private
   * @category Store
   */
  bindStore(store) {
    const suffix = this.getAsyncEventSuffixForStore(store);
    store.ion({
      name: storeListenerName2,
      [`refresh${suffix}`]: "onStoreDataChange",
      [`add${suffix}`]: "onStoreAdd",
      [`remove${suffix}`]: "onStoreRemove",
      [`replace${suffix}`]: "onStoreReplace",
      [`removeAll${suffix}`]: "onStoreRemoveAll",
      [`move${suffix}`]: store.tree ? null : "onFlatStoreMove",
      change: "relayStoreDataChange",
      idChange: "onStoreRecordIdChange",
      update: "onStoreUpdateRecord",
      beforeRequest: "onStoreBeforeRequest",
      afterRequest: "onStoreAfterRequest",
      exception: "onStoreException",
      commit: "onStoreCommit",
      clearChanges: "onStoreRecordClearChanges",
      startApplyChangeset: "internalOnStoreStartApplyChangeset",
      endApplyChangeset: "internalOnStoreEndApplyChangeset",
      thisObj: this
    });
    super.bindStore(store);
  }
  unbindStore(oldStore) {
    this.detachListeners(storeListenerName2);
    if (this.destroyStore) {
      oldStore.destroy();
    }
  }
  changeStore(store) {
    var _a4;
    if (store == null) {
      return null;
    }
    if (typeof store === "string") {
      store = Store.getStore(store);
    }
    if (!store.isStore) {
      store = ObjectHelper.assign({
        data: this.data,
        tree: Boolean((_a4 = this.initialConfig.features) == null ? void 0 : _a4.tree)
      }, store);
      if (!store.data) {
        delete store.data;
      }
      if (!store.modelClass) {
        store.modelClass = GridRowModel;
      }
      store = new (store.readUrl ? AjaxStore : Store)(store);
    }
    return store;
  }
  updateStore(store, was) {
    var _a4, _b;
    const me = this;
    (_a4 = super.updateStore) == null ? void 0 : _a4.call(this, store, was);
    if (was) {
      me.unbindStore(was);
    }
    if (store) {
      if (was) {
        me.deselectAll();
      }
      me.bindStore(store);
    }
    me.trigger("bindStore", { store, oldStore: was });
    if (!me.isDestroying && me.isPainted && !me.refreshSuspended) {
      (_b = me._rowManager) == null ? void 0 : _b.reinitialize();
    }
  }
  /**
   * Rerenders a cell if a record is updated in the store
   * @private
   * @category Store
   */
  onStoreUpdateRecord({ source: store, record, changes }) {
    const me = this;
    if (me.refreshSuspended) {
      return;
    }
    if (me.forceFullRefresh) {
      me.rowManager.refresh();
      me.forceFullRefresh = false;
    } else {
      let row;
      if (record.isFieldModified("id")) {
        row = me.getRowFor(record.meta.modified.id);
      }
      row = row || me.getRowFor(record);
      if (!row) {
        return;
      }
      if (me.fullRowRefresh || record.isSpecialRow) {
        const index = store.indexOf(record);
        if (index !== -1) {
          row.render(index, record);
        }
      } else {
        me.columns.visibleColumns.forEach((column) => {
          const field = column.field, isSafe = column.constructor.simpleRenderer && !Object.prototype.hasOwnProperty.call(column.data, "renderer");
          if (!isSafe || changes[field]) {
            const cellElement = row.getCell(field);
            if (cellElement) {
              row.renderCell(cellElement);
            }
          }
        });
      }
    }
  }
  refreshFromRowOnStoreAdd(row, context) {
    const me = this, { rowManager } = me;
    rowManager.renderFromRow(row);
    rowManager.trigger("changeTotalHeight", { totalHeight: rowManager.totalHeight });
    if (me.store.count === 1) {
      me.callEachSubGrid("refreshFakeScroll");
    }
  }
  onMaskAutoClose(mask) {
    super.onMaskAutoClose(mask);
    this.toggleEmptyText();
  }
  /**
   * Refreshes rows when data is added to the store
   * @private
   * @category Store
   */
  onStoreAdd({
    source: store,
    records,
    index,
    oldIndex,
    isChild,
    oldParent,
    parent,
    isMove,
    isExpand,
    isExpandAll
  }) {
    const me = this, { rowManager } = me;
    if (!me.isPainted || isExpandAll || me.refreshSuspended) {
      return;
    }
    if (isExpand && me.animateTreeNodeToggle) {
      return rowManager.insert(rowManager.getRowFor(parent).index + 1, records.length);
    }
    const hasExpandedOldParent = isMove && records.some((record) => {
      if (isMove[record.id]) {
        const oldParent2 = store.getById(record.meta.modified.parentId);
        return (oldParent2 == null ? void 0 : oldParent2.isExpanded(store)) && (oldParent2 == null ? void 0 : oldParent2.ancestorsExpanded(store));
      }
    });
    if (isChild && !records[0].ancestorsExpanded(store) && !hasExpandedOldParent) {
      if (!parent.isLeaf) {
        const parentRow = rowManager.getRowById(parent);
        if (parentRow) {
          rowManager.renderRows([parentRow]);
        }
      }
      return;
    }
    rowManager.calculateRowCount(false, true, true);
    if (store.isFiltered) {
      index = store.indexOf(records[0]);
    }
    const {
      topIndex,
      rows,
      rowCount
    } = rowManager, bottomIndex = rowManager.topIndex + rowManager.rowCount - 1, dataStart = index, dataEnd = index + records.length - 1, atEnd = bottomIndex >= store.count - records.length - 1;
    if (oldParent || oldIndex > -1 || isChild && isMove && Object.values(isMove).some((v) => v)) {
      rowManager.refresh();
    } else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);
    } else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    } else {
      if (atEnd && index > bottomIndex) {
        rowManager.fillBelow(me._scrollTop || 0);
      }
      rowManager.estimateTotalHeight(true);
    }
  }
  /**
   * Responds to exceptions signalled by the store
   * @private
   * @category Store
   */
  onStoreException({ action, type, response, exceptionType, error }) {
    var _a4;
    const me = this;
    let message;
    switch (type) {
      case "server":
        message = response.message || me.L("L{unspecifiedFailure}");
        break;
      case "exception":
        message = exceptionType === "network" ? me.L("L{networkFailure}") : (error == null ? void 0 : error.message) || ((_a4 = response == null ? void 0 : response.parsedJson) == null ? void 0 : _a4.message) || me.L("L{parseFailure}");
        break;
    }
    me.applyMaskError(
      `<div class="b-grid-load-failure">
                <div class="b-grid-load-fail">${me.L(action === "read" ? "L{loadFailedMessage}" : "L{syncFailedMessage}")}</div>
                ${(response == null ? void 0 : response.url) ? `<div class="b-grid-load-fail">${response.url}</div>` : ""}
                <div class="b-grid-load-fail">${me.L("L{serverResponse}")}</div>
                <div class="b-grid-load-fail">${message}</div>
            </div>`
    );
  }
  /**
   * Refreshes rows when data is changed in the store
   * @private
   * @category Store
   */
  onStoreDataChange({ action, changes, source: store, syncInfo }) {
    var _a4;
    (_a4 = super.onStoreDataChange) == null ? void 0 : _a4.call(this, ...arguments);
    const me = this;
    if (me.refreshSuspended || !me.rowManager) {
      return;
    }
    if (action === "dataset") {
      me.rowManager.clearKnownHeights();
      if (store.isTree && store.isFiltered) {
        return;
      }
    }
    const isGroupFieldChange = store.isGrouped && changes && store.groupers.some((grp) => grp.rootFieldName in changes);
    if (me.isPainted && !isGroupFieldChange) {
      me.renderRows(Boolean(!(action in datasetReplaceActions) || me.preserveScrollOnDatasetChange));
    }
    me.toggleEmptyText();
  }
  /**
   * The hook is called when the id of a record has changed.
   * @private
   * @category Store
   */
  onStoreRecordIdChange() {
    var _a4;
    (_a4 = super.onStoreRecordIdChange) == null ? void 0 : _a4.call(this, ...arguments);
  }
  /**
   * Shows a load mask while the connected store is loading
   * @private
   * @category Store
   */
  onStoreBeforeRequest() {
    this.applyLoadMask();
  }
  /**
   * Hides load mask after a load request ends either in success or failure
   * @private
   * @category Store
   */
  onStoreAfterRequest(event) {
    if (this.loadMask && !event.exception) {
      this.masked = null;
      this.toggleEmptyText();
    }
  }
  needsFullRefreshOnStoreRemove({ isCollapse }) {
    var _a4, _b;
    const { store } = this;
    return ((_b = (_a4 = this.features) == null ? void 0 : _a4.group) == null ? void 0 : _b.enabled) && store.isGrouped || // Need to redraw parents when children are removed since they might be converted to leaves
    store.tree && !isCollapse && store.modelClass.convertEmptyParentToLeaf;
  }
  /**
   * Animates removal of record.
   * @private
   * @category Store
   */
  onStoreRemove({ source: store, records, isCollapse, isChild, isMove, isCollapseAll }) {
    var _a4;
    if (!this.isPainted || isMove || isCollapseAll) {
      return;
    }
    (_a4 = super.onStoreRemove) == null ? void 0 : _a4.call(this, ...arguments);
    const me = this, { rowManager } = me;
    rowManager.invalidateKnownHeight(records);
    if (me.refreshSuspended) {
      return;
    }
    if (me.animateRemovingRows && !isCollapse && !isChild) {
      const rowsToRemove = records.reduce((result, record) => {
        const row = rowManager.getRowById(record.id);
        row && result.push(row);
        return result;
      }, []);
      if (rowsToRemove.length) {
        const topRow = rowsToRemove[0];
        me.isAnimating = true;
        EventHelper.onTransitionEnd({
          element: topRow._elementsArray[0],
          property: "left",
          // Detach listener after timeout even if event wasn't fired
          duration: me.transitionDuration + 50,
          thisObj: me,
          handler: () => {
            me.isAnimating = false;
            rowsToRemove.forEach((row) => !row.isDestroyed && row.removeCls("b-removing"));
            rowManager.refresh();
            me.trigger("rowRemove");
            me.afterRemove(arguments[0]);
          }
        });
        rowsToRemove.forEach((row) => row.addCls("b-removing"));
      }
    } else if (isCollapse && me.animateTreeNodeToggle) {
      const indicesToRemove = records.flatMap((record) => {
        const row = rowManager.getRowFor(record);
        return row ? row.index : emptyArray12;
      }).sort(ascending), { length } = indicesToRemove;
      if (length && indicesToRemove[length - 1] === indicesToRemove[0] + length - 1) {
        return rowManager.insert(indicesToRemove[0], -indicesToRemove.length);
      }
    } else if (me.needsFullRefreshOnStoreRemove(...arguments)) {
      rowManager.refresh();
      me.afterRemove(arguments[0]);
    } else {
      const { rows } = rowManager, topRowIndex = records.reduce((result, record) => {
        const row = rowManager.getRowById(record.id);
        if (row) {
          result = Math.min(result, rows.indexOf(row));
        }
        return result;
      }, rows.length);
      if (rows[topRowIndex]) {
        !me.refreshSuspended && rowManager.renderFromRow(rows[topRowIndex]);
      } else {
        rowManager.trigger("changeTotalHeight", { totalHeight: rowManager.totalHeight });
      }
      me.trigger("rowRemove", { isCollapse });
      me.afterRemove(arguments[0]);
    }
  }
  onFlatStoreMove({ from, to }) {
    const { rowManager, store } = this, {
      topIndex,
      rowCount
    } = rowManager, [dataStart, dataEnd] = [from, to].sort((a, b) => a - b), visibleStart = store.indexOf(store.getAt(dataStart, true)), visibleEnd = store.indexOf(store.getAt(dataEnd, true));
    if (visibleStart >= topIndex && visibleStart < topIndex + rowCount) {
      rowManager.renderFromRow(rowManager.rows[visibleStart - topIndex]);
    } else if (visibleEnd >= topIndex && visibleEnd < topIndex + rowCount) {
      rowManager.refresh();
    }
  }
  onStoreReplace({ records, all }) {
    const { rowManager } = this;
    if (all) {
      rowManager.clearKnownHeights();
      rowManager.refresh();
    } else {
      const rows = records.reduce((rows2, [, record]) => {
        const row = this.getRowFor(record);
        if (row) {
          rows2.push(row);
        }
        return rows2;
      }, []);
      rowManager.invalidateKnownHeight(records);
      rowManager.renderRows(rows);
    }
  }
  relayStoreDataChange(event) {
    var _a4;
    (_a4 = this.ariaElement) == null ? void 0 : _a4.setAttribute("aria-rowcount", this.store.count + 1);
    if (!this.project) {
      return this.trigger("dataChange", { ...event, store: event.source, source: this });
    }
  }
  /**
   * Rerenders grid when all records have been removed
   * @private
   * @category Store
   */
  onStoreRemoveAll() {
    var _a4;
    (_a4 = super.onStoreRemoveAll) == null ? void 0 : _a4.call(this, ...arguments);
    if (this.isPainted) {
      this.rowManager.clearKnownHeights();
      this.renderRows(false);
      this.toggleEmptyText();
    }
  }
  // Refresh dirty cells on commit
  onStoreCommit({ changes }) {
    if (this.showDirty && changes.modified.length) {
      const rows = [];
      changes.modified.forEach((record) => {
        const row = this.rowManager.getRowFor(record);
        row && rows.push(row);
      });
      this.rowManager.renderRows(rows);
    }
  }
  // Refresh dirty cells after a call to Model#clearChanges
  onStoreRecordClearChanges({ record }) {
    const row = this.rowManager.getRowFor(record);
    if (row) {
      this.rowManager.renderRows([row]);
    }
  }
  internalOnStoreStartApplyChangeset() {
    this.suspendRefresh();
    if (this.constructor.bindStoreChangeset) {
      this.captureScrollTargetRow();
    }
  }
  internalOnStoreEndApplyChangeset() {
    this.resumeRefresh(true);
    if (this.constructor.bindStoreChangeset) {
      this.restoreScrollTargetRow();
    }
  }
  /**
   * Remember scroll position when store is about to apply a changeset
   * @private
   */
  captureScrollTargetRow() {
    const me = this;
    if (me.preserveScroll) {
      const { firstFullyVisibleRow: firstRow, lastVisibleRow: lastRow } = me.rowManager;
      if (firstRow) {
        me.lastVisibleRowIds = [firstRow.id];
        for (let index = firstRow.dataIndex + 1; index <= lastRow.dataIndex; index++) {
          me.lastVisibleRowIds.push(me.rowManager.getRow(index).id);
        }
        me.lastTopRowOffset = me.scrollable.getDeltaTo(
          firstRow.element,
          { block: "start", x: false, constrainToScrollable: false }
        );
      }
    }
  }
  /**
   * Restore scroll position. Go to the topmost row formerly in the view that is still present in the dataset.
   * @private
   */
  restoreScrollTargetRow() {
    const me = this;
    let didOverscroll = false;
    if (me.preserveScroll) {
      if (me.lastVisibleRowIds) {
        me.rowManager.refresh();
        if (me.scrollable.scrollHeight >= me.lastOverscrollHeight && me.scrollable.y === me.lastOverscrollY) {
          me.rowManager.fillBelow(me.scrollable.y);
        } else {
          me.lastOverscrollHeight = null;
          me.lastOverscrollY = null;
        }
        const targetId = me.lastVisibleRowIds.find((rowId) => me.store.getById(rowId));
        if (targetId != void 0 && targetId !== me.rowManager.firstFullyVisibleRow.id) {
          if (me.preserveScroll.overscroll) {
            const scrollNeeded = me.scrollable.getDeltaTo(
              me.getRecordCoords(targetId),
              {
                block: "start",
                x: false,
                constrainToScrollable: false,
                edgeOffset: me.lastTopRowOffset.yDelta
              }
            ).yDelta;
            if (scrollNeeded > me.scrollable.maxY - me.scrollable.y) {
              me.scrollable.scrollHeight += scrollNeeded;
              didOverscroll = true;
            }
          }
          me.scrollRowIntoView(targetId, {
            block: "start",
            edgeOffset: me.lastTopRowOffset.yDelta,
            x: false
          });
        }
      }
      me.lastVisibleRowIds = void 0;
      me.lastTopRowOffset = void 0;
      if (didOverscroll) {
        me.lastOverscrollHeight = me.scrollable.scrollHeight;
        me.lastOverscrollY = me.scrollable.y;
      }
    }
  }
  // Documented with config
  get data() {
    if (this._store) {
      return this._store.records;
    } else {
      return this._data;
    }
  }
  set data(data) {
    if (this._store) {
      this._store.data = data;
    } else {
      this._data = data;
    }
  }
  //endregion
  //region Context menu items
  /**
   * Populates the header context menu. Chained in features to add menu items.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateHeaderMenu({ column, items: items2 }) {
    const me = this, { subGrids, regions } = me, { parent } = column;
    let first = true;
    Object.entries(subGrids).forEach(([region, subGrid]) => {
      if (subGrid.sealedColumns) {
        return;
      }
      if (column.draggable && region !== column.region && (!parent && subGrids[column.region].columns.count > 1 || parent && parent.children.length > 1)) {
        const preceding = subGrid.element.compareDocumentPosition(subGrids[column.region].element) === document.DOCUMENT_POSITION_PRECEDING, moveRight = me.rtl ? !preceding : preceding, text = regions.length > 2 ? me.L("L{moveColumnTo}", me.optionalL(region)) : me.L(moveRight ? "L{moveColumnRight}" : "L{moveColumnLeft}");
        items2[`${region}Region`] = {
          targetSubGrid: region,
          text,
          icon: "b-fw-icon b-icon-column-move-" + (moveRight ? "right" : "left"),
          separator: first,
          disabled: !column.allowDrag,
          onItem: ({ item }) => {
            const lastRegionIndex = me.columns.indexOf(subGrids[item.targetSubGrid].columns.last);
            column.traverse((col) => col.region = region);
            me.columns.insert(lastRegionIndex + 1, column);
            me.scrollColumnIntoView(column);
          }
        };
        first = false;
      }
    });
  }
  /**
   * Populates the cell context menu. Chained in features to add menu items.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Core.data.Model} options.record Record for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateCellMenu({ record, items: items2 }) {
  }
  getColumnDragToolbarItems(column, items2) {
    return items2;
  }
  //endregion
  //region Getters
  normalizeCellContext(cellContext) {
    const grid = this, { columns } = grid;
    if (cellContext.isLocation) {
      return cellContext;
    }
    if (cellContext.isModel) {
      return new Location({
        grid,
        id: cellContext.id,
        columnId: columns.visibleColumns[0].id
      });
    }
    return new Location(ObjectHelper.assign({ grid }, cellContext));
  }
  /**
   * Returns a cell if rendered or null if not found.
   * @param {LocationConfig} cellContext A cell location descriptor
   * @returns {HTMLElement|null}
   * @category Getters
   */
  getCell(cellContext) {
    const { store, columns } = this, { visibleColumns } = this.columns, rowIndex = !isNaN(cellContext.row) ? cellContext.row : !isNaN(cellContext.rowIndex) ? cellContext.rowIndex : store.indexOf(cellContext.record || cellContext.id), columnIndex = !isNaN(cellContext.column) ? cellContext.column : !isNaN(cellContext.columnIndex) ? cellContext.columnIndex : visibleColumns.indexOf(cellContext.column || columns.getById(cellContext.columnId) || columns.get(cellContext.field) || visibleColumns[0]);
    return rowIndex > -1 && rowIndex < store.count && columnIndex > -1 && columnIndex < visibleColumns.length && this.normalizeCellContext(cellContext).cell || null;
  }
  /**
   * Returns the header element for the column
   * @param {String|Number|Grid.column.Column} columnId or Column instance
   * @returns {HTMLElement} Header element
   * @category Getters
   */
  getHeaderElement(columnId) {
    if (columnId.isModel) {
      columnId = columnId.id;
    }
    return this.fromCache(`.b-grid-header[data-column-id="${columnId}"]`);
  }
  getHeaderElementByField(field) {
    const column = this.columns.get(field);
    return column ? this.getHeaderElement(column) : null;
  }
  /**
   * Body height
   * @member {Number}
   * @readonly
   * @category Layout
   */
  get bodyHeight() {
    return this._bodyHeight;
  }
  /**
   * Header height
   * @member {Number}
   * @readonly
   * @category Layout
   */
  get headerHeight() {
    const me = this;
    if (me.isPainted && !me._headerHeight) {
      me._headerHeight = me.headerContainer.offsetHeight;
    }
    return me._headerHeight;
  }
  /**
   * Footer height
   * @member {Number}
   * @readonly
   * @category Layout
   */
  get footerHeight() {
    const me = this;
    if (me.isPainted && !me._footerHeight) {
      me._footerHeight = me.footerContainer.offsetHeight;
    }
    return me._footerHeight;
  }
  get isTreeGrouped() {
    var _a4;
    return Boolean((_a4 = this.features.treeGroup) == null ? void 0 : _a4.isGrouped);
  }
  /**
   * Searches up from the specified element for a grid row and returns the record associated with that row.
   * @param {HTMLElement} element Element somewhere within a row or the row container element
   * @returns {Core.data.Model} Record for the row
   * @category Getters
   */
  getRecordFromElement(element) {
    const el = element.closest(".b-grid-row");
    if (!el)
      return null;
    return this.store.getAt(el.dataset.index);
  }
  /**
   * Searches up from specified element for a grid cell or an header and returns the column which the cell belongs to
   * @param {HTMLElement} element Element somewhere in a cell
   * @returns {Grid.column.Column} Column to which the cell belongs
   * @category Getters
   */
  getColumnFromElement(element) {
    const cell = element.closest(".b-grid-cell, .b-grid-header");
    if (!cell)
      return null;
    if (cell.matches(".b-grid-header")) {
      return this.columns.getById(cell.dataset.columnId);
    }
    const cellData = DomDataStore.get(cell);
    return this.columns.getById(cellData.columnId);
  }
  // Only added for type checking, since it seems common to get it wrong in react/angular
  updateAutoHeight(autoHeight) {
    ObjectHelper.assertBoolean(autoHeight, "autoHeight");
  }
  updateColumnLines(columnLines) {
    ObjectHelper.assertBoolean(columnLines, "columnLines");
    DomHelper.toggleClasses(this.element, "b-no-column-lines", !columnLines);
  }
  updateRowLines(rowLines) {
    DomHelper.toggleClasses(this.element, "b-no-row-lines", !rowLines);
  }
  get keyMapElement() {
    return this.bodyElement;
  }
  //endregion
  //region Fix width & height
  /**
   * Sets widths and heights for headers, rows and other parts of the grid as needed
   * @private
   * @category Width & height
   */
  fixSizes() {
    this.callEachSubGrid("fixWidths");
    const colHeaders = this.headerContainer.querySelectorAll(".b-grid-header.b-depth-0");
    for (let i = 0, { length } = colHeaders; i < length; i++) {
      colHeaders[i].setAttribute("aria-colindex", i + 1);
    }
  }
  onRowManagerChangeTotalHeight({ totalHeight, immediate }) {
    return this.refreshTotalHeight(totalHeight, immediate);
  }
  /**
   * Makes height of vertical scroller match estimated total height of grid. Called when scrolling vertically and
   * when showing/hiding rows.
   * @param {Number} [height] Total height supplied by RowManager
   * @param {Boolean} [immediate] Flag indicating if buffered element sizing should be bypassed
   * @private
   * @category Width & height
   */
  refreshTotalHeight(height = this.rowManager.totalHeight, immediate = false) {
    const me = this;
    if (me.renderingRows || !me.isVisible) {
      return false;
    }
    const scroller = me.scrollable, delta = Math.abs(me.virtualScrollHeight - height), clientHeight = me._bodyRectangle.height, newMaxY = height - clientHeight;
    if (delta) {
      const isCritical = newMaxY - me._scrollTop < clientHeight * 2 || // Or if we have scrolled pass visual height
      me._verticalScrollHeight && me._verticalScrollHeight - clientHeight < me._scrollTop;
      scroller.scrollHeight = me.virtualScrollHeight = height;
      if (me.isPainted && (me.scrolling && !isCritical || delta < 100) && !immediate) {
        me.bufferedFixElementHeights();
      } else {
        me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();
        me.bufferedFixElementHeights.cancel();
        me.fixElementHeights();
      }
    }
  }
  fixElementHeights() {
    const me = this, height = me.virtualScrollHeight, heightInPx = `${height}px`;
    me._verticalScrollHeight = height;
    me.verticalScroller.style.height = heightInPx;
    me.virtualScrollHeightDirty = false;
    if (me.autoHeight) {
      me.bodyContainer.style.height = heightInPx;
      me._bodyHeight = height;
      me.refreshBodyRectangle();
    }
    me.refreshVirtualScrollbars();
  }
  refreshBodyRectangle() {
    return this._bodyRectangle = Rectangle.client(this.bodyContainer);
  }
  //endregion
  //region Scroll & virtual rendering
  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }
  get scrolling() {
    return this._scrolling;
  }
  /**
   * Activates automatic scrolling of a subGrid when mouse is moved closed to the edges. Useful when dragging DOM
   * nodes from outside this grid and dropping on the grid.
   * @param {Grid.view.SubGrid|String|Grid.view.SubGrid[]|String[]} subGrid A subGrid instance or its region name or
   * an array of either
   * @category Scrolling
   */
  enableScrollingCloseToEdges(subGrids) {
    this.scrollManager.startMonitoring({
      scrollables: [
        {
          element: this.scrollable.element,
          direction: "vertical"
        },
        ...ArrayHelper.asArray(subGrids || []).map((subGrid) => ({ element: (typeof subGrid === "string" ? this.subGrids[subGrid] : subGrid).scrollable.element }))
      ],
      direction: "horizontal"
    });
  }
  /**
   * Deactivates automatic scrolling of a subGrid when mouse is moved closed to the edges
   * @param {Grid.view.SubGrid|String|Grid.view.SubGrid[]|String[]} subGrid A subGrid instance or its region name or
   * an array of either
   * @category Scrolling
   */
  disableScrollingCloseToEdges(subGrids) {
    this.scrollManager.stopMonitoring([
      this.scrollable.element,
      ...ArrayHelper.asArray(subGrids || []).map((subGrid) => (typeof subGrid === "string" ? this.subGrids[subGrid] : subGrid).element)
    ]);
  }
  /**
   * Responds to request from RowManager to adjust scroll position. Happens when jumping to a scroll position with
   * variable row height.
   * @param {Number} bottomMostRowY
   * @private
   * @category Scrolling
   */
  onRowManagerRequestScrollChange({ bottom }) {
    this.scrollable.y = bottom - this.bodyHeight;
  }
  /**
   * Scroll syncing for normal headers & grid + triggers virtual rendering for vertical scroll
   * @private
   * @fires scroll
   * @category Scrolling
   */
  initScroll() {
    const me = this, { scrollable } = me;
    if (!me.scrollInitialized) {
      me.scrollInitialized = true;
      scrollable.contentElement = me.contentElement;
      scrollable.ion({
        scroll: "onGridVerticalScroll",
        scrollend: "onGridVerticalScrollEnd",
        thisObj: me
      });
      me.callEachSubGrid("initScroll");
      if (BrowserHelper.isMobileSafari) {
        scrollable.element.style.transform = "translate3d(0, 0, 0)";
      }
    }
  }
  onGridVerticalScroll({ source: scrollable }) {
    const me = this, { y: scrollTop } = scrollable;
    if (scrollTop !== me._scrollTop) {
      me._scrollTop = scrollTop;
      if (!me.scrolling) {
        me.scrolling = true;
        me.eachSubGrid((s) => s.suspendResizeMonitor = true);
      }
      me.rowManager.updateRenderedRows(scrollTop);
      me.afterScroll({ scrollTop });
      me.trigger("scroll", { scrollTop });
    }
  }
  onGridVerticalScrollEnd() {
    this.scrolling = false;
    this.eachSubGrid((s) => s.suspendResizeMonitor = false);
  }
  /**
   * Scrolls a row into view. If row isn't rendered it tries to calculate position. Accepts the {@link BryntumScrollOptions}
   * `column` property
   * @param {Core.data.Model|String|Number} recordOrId Record or record id
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which resolves when the specified row has been scrolled into view.
   * @category Scrolling
   */
  async scrollRowIntoView(recordOrId, options = defaultScrollOptions3) {
    var _a4;
    const me = this, blockPosition = options.block || "nearest", { rowManager } = me, record = me.store.getById(recordOrId);
    if (record) {
      let scrollPromise2;
      if (me.store.indexOf(record) === -1) {
        return resolvedPromise;
      }
      let scroller = me.scrollable, recordRect = me.getRecordCoords(record);
      const scrollerRect = Rectangle.from(scroller.element);
      if (recordRect.virtual) {
        const virtualBlock = recordRect.block, innerOptions = blockPosition !== "nearest" ? options : {
          block: virtualBlock
        };
        scrollPromise2 = scroller.scrollIntoView(recordRect, {
          block: "center"
        });
        rowManager.scrollTargetRecordId = record;
        rowManager.updateRenderedRows(scroller.y, true);
        recordRect = me.getRecordCoords(record);
        rowManager.lastScrollTop = scroller.y;
        if (recordRect.virtual) {
          return resolvedPromise;
        }
        if (options.animate) {
          scroller.suspendEvents();
          if (blockPosition === "end" || blockPosition === "nearest" && virtualBlock === "end") {
            scroller.y -= scrollerRect.bottom - recordRect.bottom;
          } else if (blockPosition === "start" || blockPosition === "nearest" && virtualBlock === "start") {
            scroller.y += recordRect.y - scrollerRect.y;
          }
          rowManager.updateRenderedRows(scroller.y, false, true);
          if (virtualBlock === "end") {
            scroller.y -= rowManager.appendRowBuffer * rowManager.rowHeight - 1;
          } else {
            scroller.y += rowManager.prependRowBuffer * rowManager.rowHeight - 1;
          }
          scroller.resumeEvents();
          await scroller.scrollIntoView(me.getRecordCoords(record), Object.assign({}, options, innerOptions));
        } else {
          if (!options.recursive) {
            await scrollPromise2;
          }
          await ((_a4 = me.scrollRowIntoView) == null ? void 0 : _a4.call(me, record, Object.assign({ recursive: true }, options, innerOptions)));
        }
      } else {
        let { column } = options;
        if (column) {
          if (!column.isModel) {
            column = me.columns.getById(column) || me.columns.get(column);
          }
          if (column) {
            scroller = me.getSubGridFromColumn(column).scrollable;
            const cellRect = Rectangle.from(rowManager.getRowFor(record).getCell(column.id));
            recordRect.x = cellRect.x;
            recordRect.width = cellRect.width;
          }
        } else {
          options = ObjectHelper.assign({}, options, { x: false });
        }
        await scroller.scrollIntoView(recordRect, options);
      }
    }
  }
  /**
   * Scrolls a column into view (if it is not already)
   * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been
   * scrolled into view.
   * @category Scrolling
   */
  scrollColumnIntoView(column, options) {
    column = column instanceof Column ? column : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);
    return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);
  }
  /**
   * Scrolls a cell into view (if it is not already)
   * @param {LocationConfig|Grid.util.Location} cellContext Cell selector { id: recordId, column: 'columnName' }
   * @returns {Promise} A promise which resolves when the specified cell has been scrolled into view.
   * @category Scrolling
   */
  scrollCellIntoView(cellContext, options) {
    const location = this.normalizeCellContext(cellContext);
    return this.scrollRowIntoView(location.id, {
      column: location.columnId,
      ...typeof options === "boolean" ? { animate: options } : options
    });
  }
  /**
   * Scroll all the way down
   * @returns {Promise} A promise which resolves when the bottom is reached.
   * @category Scrolling
   */
  scrollToBottom(options) {
    return this.scrollRowIntoView(this.store.last, options);
  }
  /**
   * Scroll all the way up
   * @returns {Promise} A promise which resolves when the top is reached.
   * @category Scrolling
   */
  scrollToTop(options) {
    return this.scrollable.scrollBy(0, -this.scrollable.y, options);
  }
  /**
   * Stores the scroll state. Returns an objects with a `scrollTop` number value for the entire grid and a `scrollLeft`
   * object containing a left position scroll value per sub grid.
   * @returns {Object}
   * @category Scrolling
   */
  storeScroll() {
    const state = this.storedScrollState = {
      scrollTop: this.scrollable.y,
      scrollLeft: {}
    };
    this.eachSubGrid((subGrid) => {
      state.scrollLeft[subGrid.region] = subGrid.scrollable.x;
    });
    return state;
  }
  /**
   * Restore scroll state. If state is not specified, restores the last stored state.
   * @param {Object} [state] Scroll state, optional
   * @category Scrolling
   */
  restoreScroll(state = this.storedScrollState) {
    const me = this;
    me.eachSubGrid((subGrid) => {
      var _a4;
      const x = state.scrollLeft[subGrid.region];
      if (x != null) {
        subGrid.scrollable.updateX(x);
        subGrid.header.scrollable.updateX(x);
        subGrid.footer.scrollable.updateX(x);
        (_a4 = subGrid.fakeScroller) == null ? void 0 : _a4.updateX(x);
      }
    });
    me.scrollable.updateY(state.scrollTop);
  }
  //endregion
  //region Theme & measuring
  beginGridMeasuring() {
    const me = this;
    if (!me.$measureCellElements) {
      me.$measureCellElements = DomHelper.createElement({
        // For row height measuring, features are not yet there. Work around that for the stripe feature,
        // which removes borders
        className: "b-grid-subgrid " + (!me._isRowMeasured && me.hasFeature("stripe") ? "b-stripe" : ""),
        reference: "subGridElement",
        style: {
          position: "absolute",
          top: "-10000px",
          left: "-100000px",
          visibility: "hidden",
          contain: "strict"
        },
        children: [
          {
            className: "b-grid-row",
            reference: "rowElement",
            children: [
              {
                className: "b-grid-cell",
                reference: "cellElement",
                style: {
                  width: "auto",
                  contain: BrowserHelper.isFirefox ? "layout paint" : "layout style paint"
                }
              }
            ]
          }
        ]
      });
    }
    me.getConfig("element");
    me.verticalScroller.appendChild(me.$measureCellElements.subGridElement);
    if (!me.rendered) {
      const targetEl = me.appendTo || me.insertBefore || document.body, rootElement = DomHelper.getRootElement(typeof targetEl === "string" ? document.getElementById(targetEl) : targetEl) || document.body;
      if (!me.adopt || !rootElement.contains(me.element)) {
        rootElement.appendChild(me.element);
        me.$removeAfterMeasuring = true;
      }
    }
    return me.$measureCellElements;
  }
  endGridMeasuring() {
    if (this.$removeAfterMeasuring) {
      this.element.remove();
      this.$removeAfterMeasuring = false;
    }
    this.$measureCellElements.subGridElement.remove();
  }
  /**
   * Creates a fake subgrid with one row and measures its height. Result is used as rowHeight.
   * @private
   */
  measureRowHeight() {
    const me = this, { rowElement } = me.beginGridMeasuring(), styles = DomHelper.getStyleValue(rowElement, ["height", "border-top-width", "border-bottom-width"]), styleHeight = parseInt(styles.height), multiplier = BrowserHelper.isFirefox ? globalThis.devicePixelRatio / Math.max(Math.trunc(globalThis.devicePixelRatio), 1) : 1, borderTop = styles["border-top-width"] ? Math.round(multiplier * parseFloat(styles["border-top-width"])) : 0, borderBottom = styles["border-bottom-width"] ? Math.round(multiplier * parseFloat(styles["border-bottom-width"])) : 0;
    if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {
      me.rowHeight = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;
      me._rowHeightFromStyle = me.rowHeight;
    }
    me._rowBorderHeight = borderTop + borderBottom;
    me._isRowMeasured = true;
    me.endGridMeasuring();
  }
  /**
   * Handler for global theme change event (triggered by shared.js). Remeasures row height.
   * @private
   */
  onThemeChange({ theme }) {
    this.whenVisible("measureRowHeight");
    this.trigger("theme", { theme });
  }
  //endregion
  //region Rendering of rows
  /**
   * Triggers a render of records to all row elements. Call after changing order, grouping etc. to reflect changes
   * visually. Preserves scroll.
   * @category Rendering
   */
  refreshRows(returnToTop = false) {
    if (this.refreshSuspended) {
      return;
    }
    const { element, rowManager } = this;
    element.classList.add("b-notransition");
    if (returnToTop) {
      rowManager.returnToTop();
    } else {
      rowManager.refresh(true);
    }
    element.classList.remove("b-notransition");
  }
  /**
   * Triggers a render of all the cells in a column.
   * @param {Grid.column.Column} column
   * @category Rendering
   */
  refreshColumn(column) {
    if (column.isVisible) {
      if (column.isLeaf) {
        this.rowManager.forEach((row) => row.renderCell(row.getCell(column.id)));
      } else {
        column.children.forEach((child) => this.refreshColumn(child));
      }
    }
  }
  //endregion
  //region Render the grid
  /**
   * Recalculates virtual scrollbars widths and scrollWidth
   * @private
   */
  refreshVirtualScrollbars() {
    const me = this, {
      headerContainer,
      footerContainer,
      virtualScrollers,
      scrollable,
      hasVerticalOverflow
    } = me, { classList } = virtualScrollers, hadHorizontalOverflow = !classList.contains("b-hide-display"), hasHorizontalOverflow = Object.values(me.subGrids).some((subGrid) => subGrid.overflowingHorizontally), horizontalOverflowChanged = hasHorizontalOverflow !== hadHorizontalOverflow;
    if (horizontalOverflowChanged) {
      virtualScrollers.classList.toggle("b-hide-display", !hasHorizontalOverflow);
    }
    if (DomHelper.scrollBarWidth) {
      const needsPadding = hasVerticalOverflow || scrollable.overflowY === "scroll";
      headerContainer.classList.toggle("b-show-yscroll-padding", needsPadding);
      footerContainer.classList.toggle("b-show-yscroll-padding", needsPadding);
      virtualScrollers.classList.toggle("b-show-yscroll-padding", needsPadding);
      if (horizontalOverflowChanged) {
        if (hasHorizontalOverflow) {
          me.callEachSubGrid("refreshFakeScroll");
        }
        me.onHeightChange();
      }
    }
  }
  get hasVerticalOverflow() {
    return this.scrollable.hasOverflow("y");
  }
  /**
   * Returns content height calculated from row manager
   * @private
   */
  get contentHeight() {
    const rowManager = this.rowManager;
    return Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);
  }
  onContentChange() {
    const me = this, rowManager = me.rowManager;
    if (me.isVisible) {
      rowManager.estimateTotalHeight();
      me.paintListener = null;
      me.refreshTotalHeight(me.contentHeight);
      me.callEachSubGrid("refreshFakeScroll");
      me.onHeightChange();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "onContentChange",
        once: true,
        thisObj: me
      });
    }
  }
  triggerPaint() {
    if (!this.isPainted) {
      this.refreshBodyRectangle();
    }
    super.triggerPaint();
  }
  onHeightChange() {
    const me = this;
    me.refreshBodyRectangle();
    me._bodyHeight = me.autoHeight ? me.contentHeight : me.bodyContainer.offsetHeight;
  }
  /**
   * Suspends UI refreshes after updates to the underlying data.
   *
   * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to
   * actually resume UI refresh.
   *
   * @category Rendering
   */
  suspendRefresh() {
    this.refreshSuspended++;
  }
  /**
   * Resumes UI refreshes after updates to the underlying data.
   *
   * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to
   * actually resume UI refresh.
   *
   * Specify `false` as the first param to not refresh if this call unblocked the refresh suspension.
   *
   * @param {Boolean} [trigger=true] `true` to trigger a refresh, if this resume unblocks suspension
   * @category Rendering
   */
  resumeRefresh(trigger = true) {
    if (this.refreshSuspended && !--this.refreshSuspended) {
      if (trigger) {
        this.refreshRows();
      }
      this.trigger("resumeRefresh", { trigger });
    }
  }
  /**
   * Rerenders all grid rows, completely replacing all row elements with new ones
   * @category Rendering
   */
  renderRows(keepScroll = true) {
    const me = this, scrollState = keepScroll && me.storeScroll();
    if (me.refreshSuspended) {
      return;
    }
    me.trigger("beforeRenderRows");
    me.renderingRows = true;
    me.element.classList.add("b-grid-refreshing");
    if (!keepScroll) {
      me.scrollable.y = me._scrollTop = 0;
    }
    me.rowManager.reinitialize(!keepScroll);
    me.trigger("renderRows");
    me.renderingRows = false;
    me.onContentChange();
    if (keepScroll) {
      me.restoreScroll(scrollState);
    }
    if (me.autoHeight && me.store.count > 200 && !me.autoHeightWarning && !me.disableAutoHeightWarning) {
      console.warn("Warning: 'autoHeight' is enabled for a large number of rows (200+). While 'autoHeight' provides flexibility, it should be used cautiously as it disables virtualization, leading to significant performance degradation with large datasets. Consider alternatives to maintain optimal performance.");
      me.autoHeightWarning = true;
    }
    me.element.classList.remove("b-grid-refreshing");
  }
  /**
   * Rerenders the grids rows, headers and footers, completely replacing all row elements with new ones
   * @category Rendering
   */
  renderContents() {
    const me = this, { element, headerContainer, footerContainer, rowManager } = me;
    me.emptyCache();
    if (me.isPainted) {
      me._headerHeight = null;
      me.callEachSubGrid("refreshHeader");
      me.callEachSubGrid("refreshFooter");
      me.renderHeader(headerContainer, element);
      me.renderFooter(footerContainer, element);
      me.fixSizes();
      const refreshContext = rowManager.removeAllRows();
      rowManager.calculateRowCount(false, true, true);
      if (rowManager.rowCount) {
        rowManager.setPosition(refreshContext);
        me.renderRows();
      }
    }
  }
  /**
   * Rerenders all grid headers
   * @category Rendering
   */
  refreshHeaders() {
    this.callEachSubGrid("refreshHeader");
  }
  /**
   * Rerender a single grid header
   * @param {Grid.column.Column} column The column to refresh
   * @category Rendering
   */
  refreshHeader(column) {
    column.subGrid.refreshHeader();
  }
  onPaintOverride() {
  }
  // Render rows etc. on first paint, to make sure Grids element has been laid out
  onInternalPaint({ firstPaint }) {
    var _a4;
    const me = this;
    me.ariaElement.setAttribute("aria-rowcount", me.store.count + 1);
    (_a4 = super.onInternalPaint) == null ? void 0 : _a4.call(this, ...arguments);
    if (me.onPaintOverride() || !firstPaint) {
      return;
    }
    const {
      rowManager,
      store,
      element,
      headerContainer,
      bodyContainer,
      footerContainer
    } = me, scrollPad = DomHelper.scrollBarPadElement;
    let columnsChanged, maxDepth = 0;
    me.role = (store == null ? void 0 : store.isTree) ? "treegrid" : "grid";
    me.columns.ion({
      change: () => columnsChanged = true,
      once: true
    });
    me.updateResponsive(me.width, 0);
    if (columnsChanged) {
      me.callEachSubGrid("refreshHeader", headerContainer);
      me.callEachSubGrid("refreshFooter", footerContainer);
    }
    me.renderHeader(headerContainer, element);
    me.renderFooter(footerContainer, element);
    DomHelper.append(headerContainer, scrollPad);
    DomHelper.append(footerContainer, scrollPad);
    DomHelper.append(me.virtualScrollers, scrollPad);
    me.refreshBodyRectangle();
    const bodyOffsetHeight = me.bodyContainer.offsetHeight;
    if (me.autoHeight) {
      me._bodyHeight = rowManager.initWithHeight(element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight, true);
      bodyContainer.style.height = me.bodyHeight + "px";
    } else {
      me._bodyHeight = bodyOffsetHeight;
      rowManager.initWithHeight(me._bodyHeight, true);
    }
    me.eachSubGrid((subGrid) => {
      if (subGrid.header.maxDepth > maxDepth) {
        maxDepth = subGrid.header.maxDepth;
      }
    });
    headerContainer.dataset.maxDepth = maxDepth;
    me.fixSizes();
    if (store.count || !store.isLoading) {
      me.renderRows();
    }
    if (me.columns.usesAutoHeight) {
      const { fonts } = document;
      if ((fonts == null ? void 0 : fonts.status) !== "loaded") {
        fonts.ready.then(() => !me.isDestroyed && me.refreshRows());
      }
    }
    me.initScroll();
    me.initInternalEvents();
  }
  render() {
    var _a4;
    const me = this;
    me.requireSize = Boolean(me.owner);
    super.render(...arguments);
    me.setupFocusListeners();
    if (!me.autoHeight) {
      if (me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {
        console.warn("Grid element not sized correctly, please check your CSS styles and review how you size the widget");
      }
      if (!me.splitFrom && !((_a4 = me.features.split) == null ? void 0 : _a4.owner) && // Don't warn for splits
      !("minHeight" in me.initialConfig) && !("height" in me.initialConfig) && parseInt(globalThis.getComputedStyle(me.element).minHeight) === me.height) {
        console.warn(
          `The ${me.$$name} is sized by its predefined minHeight, likely this is not intended. Please check your CSS and review how you size the widget, or assign a fixed height in the config. For more information, see the "Basics/Sizing the component" guide in docs.`
        );
      }
    }
  }
  //endregion
  //region Hooks
  /**
   * Called after headers have been rendered to the headerContainer.
   * This does not do anything, it's just for Features to hook in to.
   * @param {HTMLElement} headerContainer DOM element which contains the headers.
   * @param {HTMLElement} element Grid element
   * @private
   * @category Rendering
   */
  renderHeader(headerContainer, element) {
  }
  /**
   * Called after footers have been rendered to the footerContainer.
   * This does not do anything, it's just for Features to hook in to.
   * @param {HTMLElement} footerContainer DOM element which contains the footers.
   * @param {HTMLElement} element Grid element
   * @private
   * @category Rendering
   */
  renderFooter(footerContainer, element) {
  }
  // Hook for features to affect cell rendering before renderers are run
  beforeRenderCell() {
  }
  // Hooks for features to react to a row being rendered
  beforeRenderRow() {
  }
  afterRenderRow() {
  }
  // Hook for features to react to scroll
  afterScroll() {
  }
  // Hook that can be overridden to prepare custom editors, can be used by framework wrappers
  processCellEditor(editorConfig) {
  }
  // Hook for features to react to column changes
  afterColumnsChange() {
    super.afterColumnsChange(...arguments);
  }
  // Hook for features to react to record removal (which might be transitioned)
  afterRemove(removeEvent) {
  }
  // Hook for features to react to groups being collapsed/expanded
  afterToggleGroup() {
  }
  // Hook for features to react to subgrid being collapsed
  afterToggleSubGrid() {
  }
  // Hook into Base, to trigger another hook for features to hook into :)
  // If features hook directly into this, it will be called both for Grid's changes + feature's changes,
  // since they also extend Base.
  onConfigChange(info) {
    super.onConfigChange(info);
    if (!this.isConfiguring) {
      this.afterConfigChange(info);
    }
  }
  afterConfigChange(info) {
  }
  afterAddListener(eventName, listener) {
  }
  afterRemoveListener(eventName, listener) {
  }
  //endregion
  //region Masking and Appearance
  syncMaskCover(mask = this.masked) {
    if (mask) {
      const bodyRect = mask.cover === "body" && this.rectangleOf("bodyContainer"), scrollerRect = bodyRect && this.rectangleOf("virtualScrollers"), { style } = mask.element;
      style.marginTop = bodyRect ? `${bodyRect.y}px` : "";
      style.height = bodyRect ? `${bodyRect.height + ((scrollerRect == null ? void 0 : scrollerRect.height) || 0)}px` : "";
    }
  }
  /**
   * Show a load mask with a spinner and the specified message. When using an AjaxStore masking and unmasking is
   * handled automatically, but if you are loading data in other ways you can call this function manually when your
   * load starts.
   * ```
   * myLoadFunction() {
   *   // Show mask before initiating loading
   *   grid.maskBody('Loading data');
   *   // Your custom loading code
   *   load.then(() => {
   *      // Hide the mask when loading is finished
   *      grid.unmaskBody();
   *   });
   * }
   * ```
   * @param {String|MaskConfig} loadMask The message to show in the load mask (next to the spinner) or a config object
   * for a {@link Core.widget.Mask}.
   * @returns {Core.widget.Mask}
   * @category Misc
   */
  maskBody(loadMask) {
    let ret;
    if (this.bodyContainer) {
      this.masked = Mask.mergeConfigs(this.loadMaskDefaults, loadMask);
      ret = this.masked;
    }
    return ret;
  }
  /**
   * Hide the load mask.
   * @category Misc
   */
  unmaskBody() {
    this.masked = null;
  }
  updateEmptyText(emptyText) {
    var _a4, _b;
    (_a4 = this.emptyTextEl) == null ? void 0 : _a4.remove();
    const isDomHelper = typeof emptyText === "object";
    if (isDomHelper) {
      emptyText = ArrayHelper.asArray(emptyText);
    }
    this.emptyTextEl = DomHelper.createElement({
      parent: (_b = this.firstItem) == null ? void 0 : _b.element,
      className: "b-empty-text",
      [isDomHelper ? "children" : (emptyText == null ? void 0 : emptyText.includes("<")) ? "html" : "text"]: emptyText
    });
  }
  toggleEmptyText() {
    const { bodyContainer, store } = this;
    bodyContainer == null ? void 0 : bodyContainer.classList.toggle("b-grid-empty", !(store.count > 0 || store.isLoading || store.isCommitting));
  }
  // Notify columns when our read-only state is toggled
  updateReadOnly(readOnly, old) {
    var _a4;
    super.updateReadOnly(readOnly, old);
    if (!this.isConfiguring) {
      for (const column of this.columns.bottomColumns) {
        (_a4 = column.updateReadOnly) == null ? void 0 : _a4.call(column, readOnly);
      }
    }
  }
  //endregion
  //region Extract config
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs for the grid, with special handling for inline data
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), { store } = this, data = store.getInlineData(options), storeState = store.getCurrentConfig(options) || result.store;
    if (data.length) {
      result.data = data;
    }
    if (storeState && store.originalModelClass === GridRowModel) {
      delete storeState.modelClass;
    }
    if (!ObjectHelper.isEmpty(storeState)) {
      result.store = storeState;
    }
    if (result.store) {
      delete result.store.data;
    }
    return result;
  }
  /**
   * Suspends CSS transitions after a row / event has been updated
   *
   * Multiple calls to `suspendAnimations` stack up, and will require an equal number of `resumeAnimations` calls to
   * actually resume animations.
   * @category Misc
   */
  suspendAnimations() {
    this._animationSuspendedCounter++;
  }
  /**
   * Resumes CSS transitions after a row / event has been updated
   * @category Misc
   */
  resumeAnimations() {
    this._animationSuspendedCounter--;
  }
  /**
   * Runs a function with transitions enabled (row height, event size etc.). Useful if you want to alter the UI
   * state with a transition.
   *
   * @param {Function} fn The function to run
   * @privateparam {Boolean} shouldAnimate boolean if it is false, animation won't run, otherwise animation runs
   * @returns {Promise} A promise which resolves when the transition duration has expired
   * @category Misc
   */
  async runWithTransition(fn, shouldAnimate) {
    const me = this;
    if (!shouldAnimate || !me.isVisible || me._animationSuspendedCounter !== 0 || me.enableEventAnimations === false) {
      return fn();
    }
    me.isAnimating = true;
    await me.executeAndAwaitAnimations(me.element, fn);
    me.isAnimating = false;
    if (!me.isDestroyed && !me.isAnimating) {
      me.trigger("transitionEnd");
    }
  }
};
__publicField(GridBase, "bindStoreChangeset", true);
GridBase.initClass();
VersionHelper.setVersion("grid", "5.6.11");
GridBase._$name = "GridBase";

// lib/Grid/view/Grid.js
var Grid = class extends GridBase {
  static get $name() {
    return "Grid";
  }
  // Factoryable type name
  static get type() {
    return "grid";
  }
};
Grid.initClass();
Grid._$name = "Grid";

// lib/Grid/view/TreeGrid.js
var TreeGrid = class extends Grid {
  static get $name() {
    return "TreeGrid";
  }
  // Factoryable type name
  static get type() {
    return "treegrid";
  }
  static get configurable() {
    return {
      /**
       * The store instance or config object that holds the records to be displayed by this TreeGrid. If assigning
       * a store instance, it must be configured with `tree: true`.
       *
       * A store will be created if none is specified.
       * @config {Core.data.Store|StoreConfig} store
       * @category Common
       */
      store: {
        tree: true
      }
    };
  }
  //region Plugged in functions / inherited configs
  /**
   * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
   *
   * @function toggleCollapse
   * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @param {Boolean} [skipRefresh] Set to true to not refresh rows (if calling in batch)
   * @async
   * @category Feature shortcuts
   */
  /**
   * Collapse a single node.
   *
   * @function collapse
   * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
   * @async
   * @category Feature shortcuts
   */
  /**
   * Expand a single node.
   *
   * @function expand
   * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to expand
   * @async
   * @category Feature shortcuts
   */
  /**
   * Expands parent nodes to make this node "visible".
   *
   * @function expandTo
   * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node
   * @async
   * @category Feature shortcuts
   */
  //endregion
  /* disconnect doc comment */
  //region Store
  updateStore(store, was) {
    if (store && !store.tree) {
      throw new Error("TreeGrid requires a Store configured with tree : true");
    }
    super.updateStore(store, was);
  }
  //endregion
};
TreeGrid.initClass();
TreeGrid._$name = "TreeGrid";

// lib/Grid/widget/GroupBar.js
var GroupBar = class extends ChipView {
  construct() {
    super.construct(...arguments);
    const treeGrid = this.treeGrid = this.up("gridbase", true);
    if (!treeGrid) {
      throw new Error("GroupBar must be used inside a Grid component");
    }
    treeGrid.ion({
      paint: this.onTreePaint,
      once: true,
      thisObj: this
    });
  }
  onTreePaint() {
    const me = this, { treeGrid } = me, { treeGroup, columnReorder } = treeGrid.features;
    if (!treeGroup) {
      throw new Error("GroupBar widget requires the TreeGroup feature to be present");
    }
    columnReorder.usingGroupBarWidget = true;
    me.store = new Store({
      fields: ["cls", "ascending"],
      internalListeners: {
        add: me.onStoreChanged,
        remove: me.onStoreChanged,
        thisObj: me
      }
    });
    treeGrid.ion({
      treeGroupChange: me.onTreeGroupChanged,
      beforeColumnDropFinalize: me.onBeforeColumnDropFinalize,
      columnDrag: me.onColumnDrag,
      columnDragStart: me.onColumnDragStart,
      columnDrop: me.onColumnDrop,
      thisObj: me
    });
    me.onTreeGroupChanged({ levels: treeGroup.levels });
  }
  onStoreChanged({ records }) {
    var _a4;
    const me = this, { treeGrid } = me;
    if (!me.treeGrid.isConstructing && ((_a4 = records == null ? void 0 : records[0]) == null ? void 0 : _a4.cls) !== "b-drop-target") {
      me.ignoreGroupChange = true;
      treeGrid.features.treeGroup.levels = me.store.map(({ field }) => field);
      me.ignoreGroupChange = false;
    }
  }
  onTreeGroupChanged({ levels }) {
    if (!this.ignoreGroupChange) {
      if (levels.some((level) => level instanceof Function && !level.fieldName)) {
        throw new Error("GroupBar only supports column grouping");
      }
      this.store.data = (levels || []).map((level) => {
        level = level.fieldName || level;
        return this.treeGrid.columns.get(level);
      });
    }
  }
  onColumnDragStart() {
    this.store.add({ id: "placeholder", cls: "b-drop-target" });
  }
  onColumnDrag({ context, column, event }) {
    const overGroupBar = event.target.closest(".b-groupbar");
    if (overGroupBar) {
      context.valid = true;
    }
  }
  onBeforeColumnDropFinalize({ column, event }) {
    const droppedOnGroupBar = event.target.closest(".b-groupbar");
    if (droppedOnGroupBar) {
      if (!column.isTreeColumn) {
        this.store.getById("placeholder").remove();
        this.store.add(column);
      }
    }
  }
  onColumnDrop() {
    var _a4;
    (_a4 = this.store.getById("placeholder")) == null ? void 0 : _a4.remove();
  }
};
__publicField(GroupBar, "type", "groupbar");
__publicField(GroupBar, "$name", "GroupBar");
__publicField(GroupBar, "configurable", {
  selectedCls: "not-used",
  itemTpl(record) {
    return StringHelper.encodeHtml(StringHelper.capitalize(record.getValue(this.displayField)));
  }
});
GroupBar.initClass();
GroupBar._$name = "GroupBar";

// lib/Grid/widget/TreeCombo.js
var TreeCombo = class extends Combo {
  changePicker(picker, oldPicker) {
    return super.changePicker({
      ...picker,
      selectedRecordCollection: this.valueCollection
    }, oldPicker);
  }
  updateMultiSelect(multiSelect) {
    super.updateMultiSelect(...arguments);
    this.picker.selectionMode.multiSelect = multiSelect;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(...arguments);
    this.picker.readOnly = readOnly;
  }
};
__publicField(TreeCombo, "$name", "TreeCombo");
__publicField(TreeCombo, "type", "treecombo");
__publicField(TreeCombo, "configurable", {
  multiSelect: true,
  picker: {
    type: "treegrid",
    minWidth: "35em",
    disableGridRowModelWarning: true,
    selectionMode: {
      row: true,
      rowCheckboxSelection: true
    }
  },
  chipView: {
    itemTpl(record) {
      return StringHelper.xss`${record.name}`;
    },
    scrollable: {
      overflowX: "hidden-scroll"
    }
  }
});
TreeCombo.initClass();
TreeCombo._$name = "TreeCombo";
export {
  ActionBase,
  ActionColumn,
  AddAction,
  AggregateColumn,
  AjaxHelper,
  AjaxStore,
  Animator,
  ArrayDataField,
  ArrayHelper,
  AsyncHelper,
  AvatarRendering,
  Badge_default as Badge,
  Bag,
  Bar,
  Base,
  BooleanCombo,
  BooleanDataField,
  Box,
  BrowserHelper,
  Button,
  ButtonGroup,
  CSSHelper,
  CalendarPanel,
  Card,
  CellCopyPaste,
  CellEdit,
  CellMenu,
  CellTooltip,
  CheckColumn,
  Checkbox,
  ChipView,
  ClickRepeater,
  Clipboardable_default as Clipboardable,
  CollapseTool,
  Collection,
  CollectionFilter,
  CollectionSorter,
  ColorColumn,
  ColorField,
  ColorPicker,
  Column,
  ColumnAutoWidth,
  ColumnDragToolbar,
  ColumnPicker,
  ColumnRename,
  ColumnReorder,
  ColumnResize,
  ColumnStore,
  Combo,
  Config,
  Container,
  ContextMenuBase,
  CopyPasteBase,
  DataField,
  DataGenerator,
  DateColumn,
  DateDataField,
  DateField,
  DateHelper,
  DatePicker,
  DateTimeField,
  DayTime,
  Delayable_default as Delayable,
  DemoBot,
  DisplayField,
  DomClassList,
  DomDataStore,
  DomHelper,
  DomSync,
  DragContext,
  DragHelper,
  DragProxy,
  DragTipProxy,
  Draggable_default as Draggable,
  Droppable_default as Droppable,
  Duration,
  DurationField,
  DurationUnitDataField,
  DynamicObject,
  Editor,
  EventHelper,
  Events_default as Events,
  ExcelExporter,
  ExportDialog,
  ExportOrientationCombo,
  ExportRowsCombo,
  Exporter,
  Factoryable_default as Factoryable,
  Featureable_default as Featureable,
  Fencible_default as Fencible,
  Field,
  FieldContainer,
  FieldFilterPicker,
  FieldFilterPickerGroup,
  FieldSet,
  FileDrop,
  FileField,
  FileFormat,
  FilePicker,
  FillHandle,
  Filter,
  FilterBar,
  FilterField,
  Finalizable_default as Finalizable,
  Fit,
  Footer,
  Formatter,
  Fullscreen,
  FunctionHelper,
  GlobalEvents_default as GlobalEvents,
  Grid,
  GridBase,
  GridElementEvents_default as GridElementEvents,
  GridFeatureManager,
  GridFeatures_default as GridFeatures,
  GridFieldFilterPicker,
  GridFieldFilterPickerGroup,
  GridResponsive_default as GridResponsive,
  GridRowModel,
  GridSelection_default as GridSelection,
  GridState_default as GridState,
  GridSubGrids_default as GridSubGrids,
  Group,
  GroupBar,
  GroupSummary,
  Header,
  HeaderMenu,
  Histogram,
  Hoverable_default as Hoverable,
  IdHelper,
  Identifiable_default as Identifiable,
  InsertAction,
  InsertChildAction,
  InstancePlugin,
  IntegerDataField,
  KeyMap_default as KeyMap,
  Label,
  Labelable_default as Labelable,
  Layout,
  List,
  LoadMaskable_default as LoadMaskable,
  LocaleHelper,
  LocaleManager_default as LocaleManager,
  Localizable_default as Localizable,
  Location,
  Mask,
  Menu,
  MenuItem,
  MergeCells,
  MessageDialog_default as MessageDialog,
  Minifiable_default as Minifiable,
  Model,
  ModelDataField,
  ModelLink_default as ModelLink,
  ModelStm_default as ModelStm,
  Month,
  MultiPageExporter,
  MultiPageVerticalExporter,
  Navigator,
  NumberColumn,
  NumberDataField,
  NumberField,
  NumberFormat,
  ObjectDataField,
  ObjectHelper,
  Objects,
  Orientation,
  Override,
  PagingToolbar,
  Panel,
  PanelCollapser,
  PanelCollapserOverlay,
  PaperFormat,
  Parser_default as Parser,
  PasswordField,
  PdfExport,
  PercentColumn,
  PickerField,
  Pluggable_default as Pluggable,
  Point,
  Popup,
  Print,
  PrintMixin_default as PrintMixin,
  Promissory,
  QuickFind,
  RTL_default as RTL,
  Radio,
  RadioGroup,
  RandomGenerator,
  RatingColumn,
  Rectangle,
  RegionResize,
  RemoveAction,
  RemoveAllAction,
  RemoveChildAction,
  Renderable,
  ResizeHelper,
  ResizeMonitor,
  Responsive_default as Responsive,
  Ripple,
  Rotatable_default as Rotatable,
  Row,
  RowCopyPaste,
  RowExpander,
  RowManager,
  RowNumberColumn,
  RowReorder,
  RowResize,
  RowsRange,
  Scale,
  ScrollManager,
  Scroller,
  Search,
  SinglePageExporter,
  SlideToggle,
  Slider,
  Sort,
  Split,
  Splitter,
  State_default as State,
  StateBase,
  StateProvider,
  StateStorage,
  StateTrackingManager,
  StickyCells,
  Store,
  StoreCRUD_default as StoreCRUD,
  StoreChained_default as StoreChained,
  StoreChanges_default as StoreChanges,
  StoreDataField,
  StoreFilter_default as StoreFilter,
  StoreGroup_default as StoreGroup,
  StoreProxy_default as StoreProxy,
  StoreRelation_default as StoreRelation,
  StoreSearch_default as StoreSearch,
  StoreSort_default as StoreSort,
  StoreState_default as StoreState,
  StoreStm_default as StoreStm,
  StoreSum_default as StoreSum,
  StoreSync_default as StoreSync,
  StoreTree_default as StoreTree,
  StringDataField,
  StringHelper,
  Stripe,
  Styleable_default as Styleable,
  SubGrid,
  Summary,
  Tab,
  TabBar,
  TabPanel,
  TableExporter,
  TemplateColumn,
  TemplateHelper,
  TextAreaField,
  TextAreaPickerField,
  TextField,
  TimeColumn,
  TimeField,
  TimePicker,
  TimeZoneHelper,
  Toast,
  Tool,
  Toolable_default as Toolable,
  Toolbar,
  Tooltip,
  Transaction,
  Tree,
  TreeColumn,
  TreeCombo,
  TreeGrid,
  TreeGroup,
  TreeNode_default as TreeNode,
  UndoRedoBase,
  UpdateAction,
  VBox,
  VersionHelper,
  WalkHelper,
  Wbs,
  WebSocketManager,
  Widget,
  WidgetColumn,
  WidgetHelper,
  XMLHelper,
  YearPicker,
  unitMagnitudes
};
//# sourceMappingURL=grid.module.js.map
